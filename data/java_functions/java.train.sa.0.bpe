 @ Nullable public static PsiElement [ ] getMethod@@ Parameter@@ References ( Method method , int parameterIndex ) { Parameter [ ] parameters = method . getParameters ( ) ; if ( parameters . length == 0 || parameterIndex >= parameters . length ) { return null ; } final String temp@@ VariableName = parameters [ parameterIndex ] . getName ( ) ; return PsiTreeUtil . collect@@ Elements ( method . getLast@@ Child ( ) , new PsiElement@@ Filter ( ) { @ Override public boolean is@@ Accepted ( PsiElement element ) { return element instanceof Variable && temp@@ VariableName . equals ( ( ( Variable ) element ) . getName ( ) ) ; } } ) ; }
 public static < T > T load ( String js , Class < T > valueType ) { try { return mapper . readValue ( js , valueType ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
 private static String getProject@@ Id ( ) { String projectId = System . getProperty ( PROJECT_@@ ENV_@@ NAME , System . getenv ( PROJECT_@@ ENV_@@ NAME ) ) ; if ( projectId == null ) { projectId = System . getProperty ( LEGACY_@@ PROJECT_@@ ENV_@@ NAME , System . getenv ( LEGACY_@@ PROJECT_@@ ENV_@@ NAME ) ) ; } Preconditions . checkArgument ( projectId != null , " A ▁ project ▁ ID ▁ is ▁ required . " ) ; return projectId ; }
 private static String remove@@ Noise ( String s ) { return s . replace ( " ▁ ▁ ▁ " , " ▁ " ) . replace ( " ▁ ▁ " , " ▁ " ) . replace ( " ▁ , ▁ " , " ▁ " ) . replace ( " ▁ ( ▁ ) " , " " ) . replace ( " & # x@@ 00@@ 0a@@ 0 ; " , " ▁ " ) . replace ( " " , " ▁ " ) . replace ( " [ ▁ – ▁ ] " , " ▁ " ) . replace ( " [ ▁ ] " , " " ) ; }
 public static long lowest@@ One@@ Bit ( long v ) { return v & - v ; }
 private static boolean contains@@ Variables ( String entry@@ Path ) { List < String > variable@@ sList = new ArrayList < String > ( ) ; StringUtil . get@@ Used@@ Variables ( entry@@ Path , variable@@ sList , true ) ; return ! variable@@ sList . isEmpty ( ) ; }
 public static Add@@ Msg@@ Location decode ( final ByteBuffer buf ) { if ( ! buf . has@@ Remaining ( ) ) { return null ; } final long offset = buf . getLong ( ) ; final int length = buf . getInt ( ) ; final int checksum = buf . getInt ( ) ; final int desc@@ Len = buf . getInt ( ) ; final byte [ ] desc@@ Bytes = new byte [ desc@@ Len ] ; buf . get ( desc@@ Bytes ) ; final String desc = Byte@@ Utils . getString ( desc@@ Bytes ) ; return new Add@@ Msg@@ Location ( offset , length , checksum , desc ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel ( SIG@@ MA sigma ) { if ( sigma . ordinal ( ) == SIG@@ MA . ZER@@ O@@ POINT@@ FIVE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Fi@@ ve ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ZER@@ O@@ POINT@@ SE@@ VEN@@ ONE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Se@@ ven@@ One ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ SQ@@ RT@@ 2 ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ POINT@@ FIVE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ Point@@ Fi@@ ve ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . TWO . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Two ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ POINT@@ FI@@ VE@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ Point@@ Fi@@ ve@@ SQ@@ RT@@ 2 ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . TW@@ O@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Two@@ SQ@@ RT@@ 2 ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . THREE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Three ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . FOUR . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Four ( ) ; } else { return null ; } }
 private static short next@@ Id ( ) { while ( id@@ Registr@@ ations . containsKey ( next@@ Available@@ Id ) ) { next@@ Available@@ Id -- ; } return next@@ Available@@ Id -- ; }
 public static Builder from ( K@@ ra@@ ken@@ User@@ Trade trade ) { Builder builder = new Builder ( ) . cost ( trade . get@@ Cost ( ) ) ; builder . orderId ( trade . getOrder@@ Id ( ) ) . fee@@ Amount ( trade . get@@ Fee@@ Amount ( ) ) . fee@@ Currency ( trade . get@@ Fee@@ Currency ( ) ) ; builder . type ( trade . getType ( ) ) . trad@@ able@@ Amount ( trade . get@@ Tr@@ ad@@ able@@ Amount ( ) ) . currency@@ Pair ( trade . get@@ Currency@@ Pair ( ) ) . price ( trade . get@@ Price ( ) ) . timestamp ( trade . getTimestamp ( ) ) . id ( trade . getId ( ) ) ; return builder ; }
 public static Long valueOf ( long v ) { return v >= 128 || v < - 128 ? new Long ( v ) : SMALL_@@ VALUES [ ( ( int ) v ) + 128 ] ; }
 public static boolean is@@ ED@@ T ( String name ) { return name . startsWith ( " AW@@ T - EventQueue " ) ; }
 @ Converter public static OR@@ F_@@ R@@ 04 to@@ Or@@ fR@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ F_@@ R@@ 04 . class , body ) ; }
 public static void main ( String [ ] args ) { System . out . println ( " ▁ " ) ; test_@@ dateTime ( ) ; System . out . println ( " ▁ " ) ; test_@@ date@@ Time_@@ tz ( ) ; System . out . println ( " ▁ " ) ; test_@@ local@@ Date ( ) ; System . out . println ( " ▁ " ) ; test_@@ local@@ D@@ ate_@@ tz ( ) ; System . out . println ( " ▁ " ) ; test_@@ local@@ DateTime ( ) ; System . out . println ( " ▁ " ) ; test_@@ local@@ D@@ ate_@@ shift_@@ java_@@ tz ( ) ; System . out . println ( " ▁ " ) ; test_@@ local@@ Time_@@ as_@@ integer ( ) ; System . out . println ( " ▁ " ) ; test_@@ local@@ Time_@@ as_string ( ) ; System . out . println ( " ▁ " ) ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return class_@@ NAME ; case 2 : return INTER@@ PRE@@ TER_@@ CONTEXT ; default : return null ; } }
 private static TypeAdapter make@@ Adapter ( Fixture fixture , String name ) throws RuntimeException { Matcher regex@@ Matcher = regex@@ Method@@ Pattern . matcher ( name ) ; if ( regex@@ Matcher . find ( ) ) { return make@@ Adapter@@ For@@ Regex@@ Method ( name , fixture , regex@@ Matcher ) ; } else { Matcher method@@ Matcher = method@@ Pattern . matcher ( name ) ; return method@@ Matcher . find ( ) ? make@@ Adapter@@ For@@ Method ( name , fixture , method@@ Matcher ) : make@@ Adapter@@ For@@ Field ( name , fixture ) ; } }
 private static boolean is@@ Method@@ Parameter ( @ NotNull Psi@@ Variable variable ) { if ( variable instanceof Psi@@ Parameter ) { final Psi@@ Parameter parameter = ( Psi@@ Parameter ) variable ; return ! ( parameter . get@@ Declaration@@ Scope ( ) instanceof Psi@@ Fore@@ ach@@ Statement ) ; } return false ; }
 @ Converter public static SR@@ M_S@@ 02 to@@ S@@ rm@@ S@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 02 . class , body ) ; }
 public static _Fields findByThrift@@ Id@@ OrThrow ( int fieldId ) { _Fields fields = findByThrift@@ Id ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
 public static int get@@ Store@@ Local@@ Env ( byte [ ] bytes ) { if ( bytes . length > 7 ) { return ( ( ( bytes [ 4 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) | ( ( bytes [ 5 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 8 ) ) | ( ( bytes [ 6 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 16 ) ) | ( ( bytes [ 7 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 24 ) ; } return 0 ; }
 public static File getPlugin@@ System@@ Dir ( String folder ) { return new File ( Path@@ Manager . getSystem@@ Path ( ) , " M@@ aven " + " / " + folder ) . getAbsolute@@ File ( ) ; }
 public static String get@@ Admin@@ RootPath ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ ROOT_@@ PATH , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result = properties . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ ROOT_@@ PATH , Web@@ Config@@ Default . WEB_@@ ADMIN_@@ ROOT_@@ PATH ) ; if ( ! StringUtils . has@@ Text ( result ) ) throw new RuntimeException ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ ROOT_@@ PATH + " ▁ can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } } ) ; return ( String ) cached@@ Config ; }
 public static Serializer@@ Registration read@@ Class ( ByteBuffer buffer ) { short class@@ ID = buffer . getShort ( ) ; if ( class@@ ID == - 1 ) return NULL_@@ CLASS ; return id@@ Registr@@ ations . get ( class@@ ID ) ; }
 public static void main ( String [ ] args ) { String X = " abc@@ da@@ f " ; String Y = " z@@ bc@@ df " ; System . out . println ( " Length ▁ of ▁ Lon@@ gest ▁ Common ▁ Sub@@ string ▁ is ▁ " + LC@@ Sub@@ Str@@ _@@ DP ( X . toCharArray ( ) , Y . toCharArray ( ) ) ) ; }
 static String reason ( Fixed@@ BitSet actual , Fixed@@ BitSet expected , Index@@ Searcher index@@ Searcher ) throws IOException { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " expected ▁ cardinality : " ) . append ( expected . cardinality ( ) ) . append ( ' \n ' ) ; Doc@@ Id@@ Set@@ Iterator iterator = expected . iterator ( ) ; for ( int doc = iterator . next@@ Doc ( ) ; doc != Doc@@ Id@@ Set@@ Iterator . NO_@@ MORE_@@ DOC@@ S ; doc = iterator . next@@ Doc ( ) ) { builder . append ( " Expected ▁ doc [ " ) . append ( doc ) . append ( " ] ▁ with ▁ id ▁ value ▁ " ) . append ( index@@ Searcher . doc ( doc ) . get ( Uid@@ FieldMapper . NAME ) ) . append ( ' \n ' ) ; } builder . append ( " actual ▁ cardinality : ▁ " ) . append ( actual . cardinality ( ) ) . append ( ' \n ' ) ; iterator = actual . iterator ( ) ; for ( int doc = iterator . next@@ Doc ( ) ; doc != Doc@@ Id@@ Set@@ Iterator . NO_@@ MORE_@@ DOC@@ S ; doc = iterator . next@@ Doc ( ) ) { builder . append ( " Actual ▁ doc [ " ) . append ( doc ) . append ( " ] ▁ with ▁ id ▁ value ▁ " ) . append ( index@@ Searcher . doc ( doc ) . get ( Uid@@ FieldMapper . NAME ) ) . append ( ' \n ' ) ; } return builder . toString ( ) ; }
 public static Long getLong ( String string ) { if ( string == null || string . length ( ) == 0 ) { return null ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return null ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return null ; } }
 public static void invokeLater ( Project p , Runnable r ) { invokeLater ( p , Modality@@ State . default@@ Modality@@ State ( ) , r ) ; }
 public static String substitu@@ te@@ Config@@ Parameters ( String string ) { return SUB@@ STIT@@ UT@@ OR . replace ( string ) ; }
 public static String getWeb@@ Url ( ) { try { String result = properties . get ( Web@@ Config@@ Key . WEB_@@ URL ) ; if ( ! StringUtils . has@@ Text ( result ) ) throw new RuntimeException ( Web@@ Config@@ Key . WEB_@@ URL + " can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " / " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } return result ; } catch ( Property@@ NotFoundException e ) { throw new RuntimeException ( e ) ; } }
 static PrintWriter new@@ Output ( ) throws IOException { if ( System . getProperty ( " J@@ UD@@ GE " ) != null ) { return new PrintWriter ( " ch@@ airs . out " ) ; } else { return new PrintWriter ( System . out ) ; } }
 public static long rotate@@ Left ( long v , int distance ) { return ( v << distance ) | ( v >@@ >> - distance ) ; }
 private static boolean consist@@ sOf@@ Same@@ Element@@ Number@@ Tuples ( @ NotNull Py@@ Union@@ Type union@@ Type , int elementCount ) { for ( Py@@ Type type : union@@ Type . get@@ Members ( ) ) { if ( type instanceof Py@@ TupleType ) { final Py@@ TupleType tuple@@ Type = ( Py@@ TupleType ) type ; if ( ! tuple@@ Type . is@@ Ho@@ mo@@ gene@@ ous ( ) && elementCount != tuple@@ Type . getElement@@ Count ( ) ) { return false ; } } else { return false ; } } return true ; }
 private static void validate@@ Sql@@ Server ( Sql@@ Server sql@@ Server ) { Assert . assertNotNull ( sql@@ Server ) ; Assert . assertEquals ( R@@ G_@@ NAME , sql@@ Server . resourceGroupName ( ) ) ; Assert . assertNotNull ( sql@@ Server . fully@@ Qualified@@ Domain@@ Name ( ) ) ; Assert . assertEquals ( Server@@ Version . ONE_@@ TWO_@@ FULL_@@ STOP_@@ ZERO , sql@@ Server . version ( ) ) ; Assert . assertEquals ( " userName " , sql@@ Server . administr@@ ator@@ Login ( ) ) ; }
 public static void set@@ Red@@ Left ( Context context , boolean red@@ Left ) { SharedPreferences prefs = PreferenceManager . getDefault@@ SharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( " red@@ Left " , red@@ Left ) ; editor . apply ( ) ; }
 @ Converter public static SR@@ M_S@@ 07 to@@ S@@ rm@@ S@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 07 . class , body ) ; }
 public static _Fields find@@ ByName ( String name ) { return byName . get ( name ) ; }
 public static boolean can@@ Complete@@ Normally ( @ NotNull Control@@ Flow flow , final int startOffset , final int endOffset ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { private final boolean [ ] can@@ Complete@@ Normally = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visit@@ Conditional@@ GoTo@@ Instruction ( Conditional@@ GoTo@@ Instruction instruction , int offset , int next@@ Offset ) { check@@ Instruction ( offset , next@@ Offset , false ) ; } @ Override public void visit@@ GoTo@@ Instruction ( GoTo@@ Instruction instruction , int offset , int next@@ Offset ) { check@@ Instruction ( offset , next@@ Offset , instruction . is@@ Return ) ; } private void check@@ Instruction ( int offset , int next@@ Offset , boolean is@@ Return ) { if ( offset > endOffset ) return ; if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean is@@ Normal = next@@ Offset <= endOffset && ! is@@ Return && ( next@@ Offset == endOffset || can@@ Complete@@ Normally [ next@@ Offset ] ) ; if ( is@@ Normal && next@@ Offset == endOffset ) { PsiElement element = flow . getElement ( offset ) ; if ( element instanceof Psi@@ Break@@ Statement ) { Psi@@ Statement ex@@ ited@@ Statement = ( ( Psi@@ Break@@ Statement ) element ) . find@@ Ex@@ ited@@ Statement ( ) ; if ( ex@@ ited@@ Statement == null || flow . getStartOffset ( ex@@ ited@@ Statement ) < startOffset ) { is@@ Normal = false ; } } else if ( element instanceof Psi@@ Continue@@ Statement ) { Psi@@ Statement continu@@ ed@@ Statement = ( ( Psi@@ Continue@@ Statement ) element ) . find@@ Contin@@ ued@@ Statement ( ) ; if ( continu@@ ed@@ Statement == null || flow . getStartOffset ( continu@@ ed@@ Statement ) < startOffset ) { is@@ Normal = false ; } } } can@@ Complete@@ Normally [ offset ] |= is@@ Normal ; } @ Override public void visit@@ Conditional@@ Throw@@ To@@ Instruction ( Conditional@@ Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; int throw@@ To@@ Offset = instruction . offset ; boolean is@@ Normal ; if ( throw@@ To@@ Offset == next@@ Offset ) { is@@ Normal = throw@@ To@@ Offset <= endOffset && ! is@@ Leaf ( next@@ Offset ) && can@@ Complete@@ Normally [ next@@ Offset ] ; } else { is@@ Normal = can@@ Complete@@ Normally [ next@@ Offset ] ; } can@@ Complete@@ Normally [ offset ] |= is@@ Normal ; } @ Override public void visit@@ Throw@@ To@@ Instruction ( Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( next@@ Offset <= endOffset ) { boolean is@@ Normal = ! is@@ Leaf ( next@@ Offset ) && can@@ Complete@@ Normally [ next@@ Offset ] ; can@@ Complete@@ Normally [ offset ] |= is@@ Normal ; } } @ Override public void visit@@ Call@@ Instruction ( Call@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( next@@ Offset > endOffset && next@@ Offset != offset + 1 ) { return ; } boolean is@@ Normal = can@@ Complete@@ Normally [ next@@ Offset ] ; can@@ Complete@@ Normally [ offset ] |= is@@ Normal ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { check@@ Instruction ( offset , next@@ Offset , false ) ; } @ Override @ NotNull public Boolean getResult ( ) { return can@@ Complete@@ Normally [ startOffset ] ; } } final My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , startOffset , endOffset ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static void display@@ High@@ Score@@ Position ( String player@@ Name , int high@@ Score@@ Position ) { System . out . println ( player@@ Name + " ▁ managed ▁ to ▁ get ▁ into ▁ position ▁ " + high@@ Score@@ Position + " ▁ on ▁ the ▁ high ▁ score ▁ table " ) ; }
 private static org . apache . log4j . Logger create@@ Log@@ 4j@@ Logger ( String log@@ Dir@@ Parent ) { synchronized ( water . util . Log . class ) { if ( _logger != null ) { return _logger ; } String log@@ 4j@@ Properties = System . getProperty ( " log4j . properties " ) ; if ( log@@ 4j@@ Properties != null ) { Property@@ Configurator . configure ( log@@ 4j@@ Properties ) ; } else { java . util . Properties p = new java . util . Properties ( ) ; setLog@@ 4j@@ Properties ( log@@ Dir@@ Parent , p ) ; Property@@ Configurator . configure ( p ) ; } _logger = LogManager . getLogger ( Log . class . getName ( ) ) ; } return _logger ; }
 public static void main ( String args [ ] ) { Logger . getLogger ( " " ) . setLevel ( Level . WARNING ) ; try { execute@@ No@@ Catch ( getProject@@ Id ( ) ) ; System . out . println ( " OK " ) ; } catch ( Exception e ) { System . err . println ( " Failed ▁ with ▁ exception : " ) ; e . printStackTrace ( System . err ) ; System . exit ( 1 ) ; } }
 private static Bounded@@ Sum@@ Summary get@@ Summary ( Bounded@@ Sum sum ) { byte [ ] non@@ Parsed@@ Summary = sum . get@@ Serializable@@ Summary ( ) ; try { return Bounded@@ Sum@@ Summary . parseFrom ( non@@ Parsed@@ Summary ) ; } catch ( InvalidProtocolBufferException p@@ be ) { throw new IllegalArgumentException ( p@@ be ) ; } }
 public static boolean is@@ Included ( String relative@@ Name , List < Pattern > includes , List < Pattern > excludes ) { boolean result = false ; for ( Pattern each : includes ) { if ( each . matcher ( relative@@ Name ) . matches ( ) ) { result = true ; break ; } } if ( ! result ) return false ; for ( Pattern each : excludes ) { if ( each . matcher ( relative@@ Name ) . matches ( ) ) return false ; } return true ; }
 public static S@@ la@@ Alert@@ Action createFrom@@ Json ( final Object obj ) throws Exception { return createFrom@@ Json ( ( HashMap < String , Object > ) obj ) ; }
 public static PrintStream unwrap ( PrintStream stream ) { return stream instanceof Wrapper ? ( ( Wrapper ) stream ) . parent : stream ; }
 @ Converter public static SR@@ R@@ _S@@ 06 to@@ S@@ rr@@ S@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 06 . class , body ) ; }
 public static String getGlobal@@ Obj@@ Measure ( String i@@ Obj@@ ID , String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getGlobal@@ Obj@@ Measure " ) ; } String measure = null ; System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : getGlobal@@ Obj@@ Measure " ) ; return measure ; }
 public static boolean verify@@ Permission ( int [ ] grant@@ Results ) { return grant@@ Results . length == 1 && grant@@ Results [ 0 ] == PackageManager . PERMISSION_@@ GRAN@@ TED ; }
 public static boolean is@@ Http@@ Socket@@ Read@@ Metric@@ Enabled ( ) { return http@@ Socket@@ Read@@ Metric@@ Enabled ; }
 public static boolean isEmpty ( Map m ) { return m == null || m . isEmpty ( ) ; }
 static SearchContext create@@ SearchContext ( String indexName , String parent@@ Type , String child@@ Type ) throws IOException { Index@@ Service index@@ Service = createIndex ( indexName ) ; Mapper@@ Service mapperService = index@@ Service . mapperService ( ) ; mapperService . merge ( child@@ Type , new Compressed@@ String ( Put@@ Mapping@@ Request . build@@ From@@ Simpli@@ fied@@ Def ( child@@ Type , " _ parent " , " type = " + parent@@ Type ) . string ( ) ) , true ) ; return create@@ SearchContext ( index@@ Service ) ; }
 @ Converter public static SI@@ U@@ _S@@ 13 to@@ Si@@ u@@ S@@ 13 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 13 . class , body ) ; }
 @ Converter public static BAR_@@ P@@ 06 to@@ Bar@@ P@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( BAR_@@ P@@ 06 . class , body ) ; }
 public static void invoke@@ And@@ Wait@@ Write@@ Action ( Project p , final Runnable r ) { invoke@@ AndWait ( p , new Runnable ( ) { public void run ( ) { ApplicationManager . getApplication ( ) . run@@ Write@@ Action ( r ) ; } } ) ; }
 @ Converter public static QR@@ Y_@@ PC@@ 9 to@@ Qry@@ PC@@ 9 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ PC@@ 9 . class , body ) ; }
 public static long add@@ Cap ( long a , long b ) { long u = a + b ; if ( u < 0L ) { u = Long . MAX_VALUE ; } return u ; }
 public static < E > Node@@ In@@ Graph < E > create ( E node ) { return new Node@@ In@@ Graph < > ( node , null ) ; }
 public static An@@ des@@ Event@@ Admin@@ Service@@ Stub get@@ An@@ des@@ Event@@ Admin@@ Service@@ Stub ( Servlet@@ Config config , HttpSession session , HttpServletRequest request ) throws AxisFault { String backend@@ Server@@ URL = Carbon@@ UIUtil . getServer@@ URL ( config . get@@ ServletContext ( ) , session ) ; backend@@ Server@@ URL = backend@@ Server@@ URL + AN@@ DES_@@ ADMIN_@@ EVENT_@@ SERVICE_@@ NAME ; Configuration@@ Context config@@ Context = ( Configuration@@ Context ) config . get@@ ServletContext ( ) . getAttribute ( Carbon@@ Constants . CONFIGURATION_@@ CONTEXT ) ; An@@ des@@ Event@@ Admin@@ Service@@ Stub stub = new An@@ des@@ Event@@ Admin@@ Service@@ Stub ( config@@ Context , backend@@ Server@@ URL ) ; String cookie = ( String ) session . getAttribute ( Server@@ Constants . AD@@ MIN@@ _SERVICE_@@ COOKIE ) ; if ( cookie != null ) { Options option = stub . _get@@ ServiceClient ( ) . getOptions ( ) ; option . set@@ Manage@@ Session ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTP@@ Constants . COOKIE_@@ STRING , cookie ) ; } return stub ; }
 public static void show@@ Error ( Activity activity , int message ) { Simple@@ Toast . error ( activity , activity . getResources ( ) . getString ( message ) ) ; }
 @ Converter public static DOC_@@ T@@ 12 to@@ Doc@@ T@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( DOC_@@ T@@ 12 . class , body ) ; }
 @ Converter public static QR@@ Y_@@ PC@@ K to@@ Qry@@ PC@@ K ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ PC@@ K . class , body ) ; }
 private static boolean [ ] to@@ Primitive@@ Boolean@@ Array ( Boolean [ ] values ) { boolean [ ] boo@@ leans = new boolean [ values . length ] ; range ( 0 , values . length ) . forEach ( i -> boo@@ leans [ i ] = values [ i ] ) ; return boo@@ leans ; }
 public static void update@@ Subscription@@ Category@@ Title@@ At ( final Context context , final String category , final String new@@ Title , final int position ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final String title = getSub@@ scription@@ Title@@ At ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; final boolean new@@ Category = ! values . get ( 0 ) . equals ( category ) ; if ( new@@ Category || ! new@@ Title . equals ( title ) ) { if ( new@@ Category ) { final List < String > new@@ Values = new ArrayList < > ( subscriptions . removeAll ( title ) ) ; new@@ Values . set ( 0 , category ) ; subscriptions . putAll ( new@@ Title , new@@ Values ) ; } else { subscriptions . putAll ( new@@ Title , subscriptions . removeAll ( title ) ) ; } save@@ Sub@@ scriptions ( context , subscriptions ) ; update@@ Current@@ Feed@@ Position ( context , new@@ Title ) ; } }
 @ Converter public static REF_@@ I@@ 14 to@@ Ref@@ I@@ 14 ( String body ) throws HL7@@ Exception { return to@@ Message ( REF_@@ I@@ 14 . class , body ) ; }
 @ Class@@ Rule public static final TestRule TEST_@@ DATA_@@ RULE = new TestData@@ Resource ( HI@@ BER@@ N@@ ATE_@@ RESOURCE ) { @ Override protected void load@@ TestData ( final Session session ) { Map < String , String > github@@ Config = new HashMap < > ( ) ; github@@ Config . put ( CLI@@ EN@@ T_ID_@@ KEY , " id " ) ; github@@ Config . put ( CLIENT_@@ SEC@@ RET_@@ KEY , " secret " ) ; context = Application@@ Builder . new@@ Application ( session ) . client ( Client@@ Type . Authorization@@ Grant ) . role ( " some _ role " ) . authenticator ( Github , github@@ Config ) . build ( ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 18 to@@ Ad@@ t@@ A@@ 18 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 18 . class , body ) ; }
 public static void test_@@ local@@ Date ( ) { System . out . println ( " Test ▁ LocalDate " ) ; LocalDate ld@@ 1 = LocalDate . now ( ) ; java . sql . Date d = to@@ SQL@@ Date ( ld@@ 1 ) ; LocalDate ld@@ 2 = to@@ LocalDate ( d ) ; System . out . println ( " LocalDate ▁ 1 ▁ = ▁ " + ld@@ 1 ) ; System . out . println ( " Date ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + d ) ; System . out . println ( " LocalDate ▁ 2 ▁ = ▁ " + ld@@ 2 ) ; if ( ! ld@@ 2 . equals ( ld@@ 1 ) ) { throw new IllegalStateException ( ) ; } }
 @ System@@ Api public static void prepare@@ And@@ Author@@ ize ( Context context ) { I@@ Connectivity@@ Manager cm = getService ( ) ; String packageName = context . getPackageName ( ) ; try { int userId = User@@ Handle . my@@ UserId ( ) ; if ( ! cm . prepare@@ V@@ pn ( packageName , null , userId ) ) { cm . prepare@@ V@@ pn ( null , packageName , userId ) ; } cm . set@@ Vpn@@ Package@@ Authorization ( packageName , userId , true ) ; } catch ( RemoteException e ) { } }
 @ Converter public static MF@@ K_@@ M@@ 04 to@@ M@@ fk@@ M@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ K_@@ M@@ 04 . class , body ) ; }
 public static boolean unsubscribe ( final Context context , final List < String > titles ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; if ( subscriptions . asMap ( ) . size ( ) < 2 ) { save@@ Sub@@ scriptions ( context , null ) ; put@@ Current@@ Feed@@ Position ( context , 0 ) ; put@@ Previous@@ Feed@@ Position ( context , 0 ) ; return false ; } final String current@@ Title = getCurrent@@ Feed@@ Title ( context ) ; for ( final String title : titles ) { subscriptions . removeAll ( title ) ; } if ( subscriptions . isEmpty ( ) ) { save@@ Sub@@ scriptions ( context , null ) ; put@@ Current@@ Feed@@ Position ( context , 0 ) ; put@@ Previous@@ Feed@@ Position ( context , 0 ) ; return false ; } save@@ Sub@@ scriptions ( context , subscriptions ) ; if ( subscriptions . containsKey ( current@@ Title ) ) { update@@ Current@@ Feed@@ Position ( context , current@@ Title ) ; return false ; } return true ; }
 public static boolean is@@ Variable@@ Defin@@ ite@@ ly@@ Not@@ Assigned ( @ NotNull Psi@@ Variable variable , @ NotNull Control@@ Flow flow ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { private final boolean [ ] maybe@@ Assigned = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visit@@ Write@@ Variable@@ Instruction ( Write@@ Variable@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean assigned = instruction . variable == variable || maybe@@ Assigned [ next@@ Offset ] ; maybe@@ Assigned [ offset ] |= assigned ; } @ Override public void visit@@ Throw@@ To@@ Instruction ( Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean assigned = ! is@@ Leaf ( next@@ Offset ) && maybe@@ Assigned [ next@@ Offset ] ; maybe@@ Assigned [ offset ] |= assigned ; } @ Override public void visit@@ Conditional@@ Throw@@ To@@ Instruction ( Conditional@@ Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; int throw@@ To@@ Offset = instruction . offset ; boolean assigned = throw@@ To@@ Offset == next@@ Offset ? ! is@@ Leaf ( next@@ Offset ) && maybe@@ Assigned [ next@@ Offset ] : maybe@@ Assigned [ next@@ Offset ] ; maybe@@ Assigned [ offset ] |= assigned ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean assigned = maybe@@ Assigned [ next@@ Offset ] ; maybe@@ Assigned [ offset ] |= assigned ; } @ Override @ NotNull public Boolean getResult ( ) { return ! maybe@@ Assigned [ 0 ] ; } } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static long getR@@ am@@ Cache@@ Clean@@ Freq ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ CA@@ H@@ CE_@@ RAM@@ CACHE_@@ POOL_@@ CLE@@ AN_@@ FREQ , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . getLong@@ Value ( Web@@ Config@@ Key . CORE_@@ CA@@ H@@ CE_@@ RAM@@ CACHE_@@ POOL_@@ CLE@@ AN_@@ FREQ , Web@@ Config@@ Default . CORE_@@ CA@@ H@@ CE_@@ RAM@@ CACHE_@@ POOL_@@ CLE@@ AN_@@ FREQ ) ; } } ) ; return ( long ) cached@@ Config ; }
 public static void execute@@ On@@ Pooled@@ Thread ( Runnable runnable ) { my@@ Async@@ Tasks . add ( ApplicationManager . getApplication ( ) . execute@@ On@@ Pooled@@ Thread ( runnable ) ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ Point@@ Fi@@ ve@@ SQ@@ RT@@ 2 ( ) { double a = 1. / 24@@ 500@@ 0l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 16@@ l * a ) , ( float ) ( 11@@ 8@@ l * a ) , ( float ) ( 528@@ l * a ) , ( float ) ( 15@@ 8@@ 1l * a ) , ( float ) ( 32@@ 64@@ l * a ) , ( float ) ( 44@@ 88@@ l * a ) , ( float ) ( 32@@ 64@@ l * a ) , ( float ) ( - 132@@ 6@@ l * a ) , ( float ) ( - 707@@ 2l * a ) , ( float ) ( - 97@@ 24@@ l * a ) , ( float ) ( - 707@@ 2l * a ) , ( float ) ( - 132@@ 6@@ l * a ) , ( float ) ( 32@@ 64@@ l * a ) , ( float ) ( 44@@ 88@@ l * a ) , ( float ) ( 32@@ 64@@ l * a ) , ( float ) ( 15@@ 8@@ 1l * a ) , ( float ) ( 528@@ l * a ) , ( float ) ( 11@@ 8@@ l * a ) , ( float ) ( 16@@ l * a ) , ( float ) ( 1l * a ) } ; }
 public static @ Nonnull Affinity@@ Group@@ Filter@@ Options getInstance ( boolean matches@@ Any ) { return new Affinity@@ Group@@ Filter@@ Options ( matches@@ Any ) ; }
 public static boolean need@@ Variable@@ Value@@ At ( @ NotNull Psi@@ Variable variable , @ NotNull Control@@ Flow flow , final int offset ) { Instruction@@ Client@@ Visitor < Boolean > visitor = new Instruction@@ Client@@ Visitor < Boolean > ( ) { final boolean [ ] needed@@ Below = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void proce@@ dure@@ Entered ( int startOffset , int endOffset ) { for ( int i = startOffset ; i < endOffset ; i ++ ) needed@@ Below [ i ] = false ; } @ Override public void visit@@ Read@@ Variable@@ Instruction ( Read@@ Variable@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean needed = needed@@ Below [ next@@ Offset ] ; if ( instruction . variable . equals ( variable ) ) { needed = true ; } needed@@ Below [ offset ] |= needed ; } @ Override public void visit@@ Write@@ Variable@@ Instruction ( Write@@ Variable@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean needed = needed@@ Below [ next@@ Offset ] ; if ( instruction . variable . equals ( variable ) ) { needed = false ; } needed@@ Below [ offset ] = needed ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean needed = needed@@ Below [ next@@ Offset ] ; needed@@ Below [ offset ] |= needed ; } @ Override public Boolean getResult ( ) { return needed@@ Below [ offset ] ; } } ; depth@@ First@@ Search ( flow , visitor , offset , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static int compare@@ Static ( final String s1 , final String s2 ) { int this@@ Marker = 0 ; int that@@ Marker = 0 ; final int s1@@ Length = s1 . length ( ) ; final int s2@@ Length = s2 . length ( ) ; while ( ( this@@ Marker < s1@@ Length ) && ( that@@ Marker < s2@@ Length ) ) { final String this@@ Chunk = get@@ Chunk ( s1 , s1@@ Length , this@@ Marker ) ; this@@ Marker += this@@ Chunk . length ( ) ; final String that@@ Chunk = get@@ Chunk ( s2 , s2@@ Length , that@@ Marker ) ; that@@ Marker += that@@ Chunk . length ( ) ; int result ; if ( is@@ Digit ( this@@ Chunk . charAt ( 0 ) ) && is@@ Digit ( that@@ Chunk . charAt ( 0 ) ) ) { final int this@@ Chunk@@ Length = this@@ Chunk . length ( ) ; result = this@@ Chunk@@ Length - that@@ Chunk . length ( ) ; if ( result == 0 ) { for ( int i = 0 ; i < this@@ Chunk@@ Length ; i ++ ) { result = this@@ Chunk . charAt ( i ) - that@@ Chunk . charAt ( i ) ; if ( result != 0 ) { return result ; } } } } else { result = this@@ Chunk . compareTo ( that@@ Chunk ) ; } if ( result != 0 ) { return result ; } } return s1@@ Length - s2@@ Length ; }
 public static Error@@ MessageFactory should@@ End@@ With ( Object actual , Object expected , Comparison@@ Strategy comparison@@ Strategy ) { return new Should@@ End@@ With ( actual , expected , comparison@@ Strategy ) ; }
 @ Nullable private static Boolean is@@ Union@@ Callable ( @ NotNull final Py@@ Union@@ Type type ) { for ( final Py@@ Type member : type . get@@ Members ( ) ) { final Boolean callable = is@@ Callable ( member ) ; if ( callable == null ) { return null ; } if ( callable ) { return true ; } } return false ; }
 private static boolean match@@ Container ( @ Nullable Py@@ Callable@@ Parameter container , @ NotNull List < Py@@ Expression > arguments , @ NotNull Map < Py@@ Generic@@ Type , Py@@ Type > substitutions , @ NotNull Type@@ Eval@@ Context context ) { if ( container == null ) { return true ; } final List < Py@@ Type > types = ContainerUtil . map ( arguments , context :: getType ) ; return match ( container . get@@ Argument@@ Type ( context ) , Py@@ Union@@ Type . union ( types ) , context , substitutions ) ; }
 public static ClientModel authoriz@@ e@@ Client ( String authorization@@ Header , Multi@@ valu@@ ed@@ Map < String , String > form@@ Data , Event@@ Builder event , Realm@@ Model realm ) { String client_id = null ; String client@@ Secret = null ; if ( authorization@@ Header != null ) { String [ ] username@@ Secret = Basic@@ Auth@@ Helper . parse@@ Header ( authorization@@ Header ) ; if ( username@@ Secret != null ) { client_id = username@@ Secret [ 0 ] ; client@@ Secret = username@@ Secret [ 1 ] ; } else { if ( ! form@@ Data . containsKey ( OAuth2@@ Constants . CLIENT_@@ ID ) ) { throw new Un@@ authoriz@@ edException ( " Bad ▁ Authorization ▁ header " , Response . status ( 401 ) . header ( HttpHeaders . WW@@ W_@@ AUTHENTIC@@ ATE , " Basic ▁ realm = \@@ " " + realm . getName ( ) + " \@@ " " ) . build ( ) ) ; } } } if ( client_id == null ) { client_id = form@@ Data . getFirst ( OAuth2@@ Constants . CLIENT_@@ ID ) ; client@@ Secret = form@@ Data . getFirst ( " client _ secret " ) ; } if ( client_id == null ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2@@ Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2@@ Constants . ERROR_@@ DESCRIPTION , " Missing ▁ client _ id ▁ parameter " ) ; throw new Bad@@ RequestException ( " Could ▁ not ▁ find ▁ client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_@@ JSON_@@ TYPE ) . build ( ) ) ; } event . client ( client_id ) ; ClientModel client = realm . getClient@@ By@@ ClientId ( client_id ) ; if ( client == null ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2@@ Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2@@ Constants . ERROR_@@ DESCRIPTION , " Could ▁ not ▁ find ▁ client " ) ; event . error ( Errors . CLIENT_@@ NOT_FOUND ) ; throw new Bad@@ RequestException ( " Could ▁ not ▁ find ▁ client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_@@ JSON_@@ TYPE ) . build ( ) ) ; } if ( ! client . isEnabled ( ) ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2@@ Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2@@ Constants . ERROR_@@ DESCRIPTION , " Client ▁ is ▁ not ▁ enabled " ) ; event . error ( Errors . CLIENT_@@ DISABLED ) ; throw new Bad@@ RequestException ( " Client ▁ is ▁ not ▁ enabled " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_@@ JSON_@@ TYPE ) . build ( ) ) ; } if ( ! client . is@@ Public@@ Client ( ) ) { if ( client@@ Secret == null || ! client . validate@@ Secret ( client@@ Secret ) ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2@@ Constants . ERROR , " un@@ authorized _ client " ) ; event . error ( Errors . INVALID_@@ CLIENT_@@ CREDENTI@@ ALS ) ; throw new Bad@@ RequestException ( " Un@@ authorized ▁ Client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_@@ JSON_@@ TYPE ) . build ( ) ) ; } } return client ; }
 public static void pause ( @ Nonnull Condition [ ] conditions , long timeout ) { check@@ NotNull@@ OrEmpty ( conditions ) ; Timeout@@ Watch watch = start@@ Watch@@ With@@ Timeout@@ Of ( timeout ) ; while ( ! are@@ Satisfied ( conditions ) ) { if ( watch . is@@ TimeOut ( ) ) { for ( Condition condition : conditions ) { condition . done ( ) ; } throw new Wait@@ Timed@@ Out@@ Error ( String . format ( " Timed ▁ out ▁ waiting ▁ for ▁ % s " , format ( conditions ) ) ) ; } pause ( SLE@@ EP_@@ INTERVAL ) ; } for ( Condition condition : conditions ) { condition . done ( ) ; } }
 public static Long getLong ( String string , Long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return defaultValue ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return defaultValue ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return defaultValue ; } }
 public static Authenticator get@@ Authenticator ( final Ldap@@ Authentication@@ Properties l ) { if ( l . getType ( ) == Ldap@@ Authentication@@ Properties . Authentication@@ Types . AD ) { LOGGER . debug ( " Creating ▁ active ▁ directory ▁ authenticator ▁ for ▁ { } " , l . getL@@ d@@ ap@@ Url ( ) ) ; return getActive@@ Directory@@ Authenticator ( l ) ; } if ( l . getType ( ) == Ldap@@ Authentication@@ Properties . Authentication@@ Types . DIRECT ) { LOGGER . debug ( " Creating ▁ direct - bind ▁ authenticator ▁ for ▁ { } " , l . getL@@ d@@ ap@@ Url ( ) ) ; return get@@ Direct@@ Bind@@ Authenticator ( l ) ; } if ( l . getType ( ) == Ldap@@ Authentication@@ Properties . Authentication@@ Types . SASL ) { LOGGER . debug ( " Creating ▁ SASL ▁ authenticator ▁ for ▁ { } " , l . getL@@ d@@ ap@@ Url ( ) ) ; return getS@@ asl@@ Authenticator ( l ) ; } if ( l . getType ( ) == Ldap@@ Authentication@@ Properties . Authentication@@ Types . AUTHENTIC@@ ATED ) { LOGGER . debug ( " Creating ▁ authenticated ▁ authenticator ▁ for ▁ { } " , l . getL@@ d@@ ap@@ Url ( ) ) ; return get@@ Authenticated@@ Or@@ An@@ on@@ Search@@ Authenticator ( l ) ; } LOGGER . debug ( " Creating ▁ anonymous ▁ authenticator ▁ for ▁ { } " , l . getL@@ d@@ ap@@ Url ( ) ) ; return get@@ Authenticated@@ Or@@ An@@ on@@ Search@@ Authenticator ( l ) ; }
 public static String byteArray@@ To@@ HexString ( byte [ ] raw ) { if ( raw == null ) return null ; final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; for ( final byte b : raw ) { hex . append ( HEX@@ ES [ ( b >> 4 ) & 0xF ] ) . append ( HEX@@ ES [ ( b ) & 0xF ] ) ; } return hex . toString ( ) ; }
 private static Authenticator getActive@@ Directory@@ Authenticator ( final Ldap@@ Authentication@@ Properties l ) { if ( Common@@ Helper . isBlank ( l . getD@@ n@@ Format ( ) ) ) { throw new IllegalArgumentException ( " Dn ▁ format ▁ cannot ▁ be ▁ empty / blank ▁ for ▁ active ▁ directory ▁ authentication " ) ; } final var resolver = new Format@@ Dn@@ Resolver ( l . getD@@ n@@ Format ( ) ) ; final var auth@@ n = new Authenticator ( resolver , getP@@ oo@@ led@@ Bind@@ Authentication@@ Handler ( l ) ) ; if ( l . is@@ Enhance@@ With@@ Entry@@ Resolver ( ) ) { auth@@ n . set@@ Entry@@ Resolver ( new@@ Search@@ Entry@@ Resolver ( l ) ) ; } return auth@@ n ; }
 static public void err ( String msg ) { err ( Sys . WATER , msg ) ; }
 private static boolean Validate@@ Parameters ( ) { Assembly@@ Usage . Print@@ Logo ( c@@ Param . getIs@@ Logo ( ) ) ; if ( tang@@ ible . Dot@@ Net@@ To@@ Java@@ StringHelper . isNullOrEmpty ( c@@ Param . getCache@@ Id ( ) ) ) { System . err . println ( " Error : ▁ Cache ▁ Name ▁ not ▁ specified " ) ; return false ; } if ( tang@@ ible . Dot@@ Net@@ To@@ Java@@ StringHelper . isNullOrEmpty ( c@@ Param . getServer ( ) ) ) { System . err . println ( " Error : ▁ Server ▁ not ▁ specified " ) ; return false ; } if ( ! IsValid@@ IP ( c@@ Param . getServer ( ) ) ) { System . err . println ( " Error : ▁ Invalid ▁ Server ▁ IP " ) ; return false ; } if ( tang@@ ible . Dot@@ Net@@ To@@ Java@@ StringHelper . isNullOrEmpty ( c@@ Param . getClient@@ Node ( ) ) ) { System . err . println ( " Error : ▁ Client ▁ Node ▁ not ▁ specified " ) ; return false ; } if ( ! IsValid@@ IP ( c@@ Param . getClient@@ Node ( ) ) ) { System . err . println ( " Error : ▁ Client@@ Node ( IP ) ▁ is ▁ invalid " ) ; return false ; } return true ; }
 public static List < Const@@ Label > of ( String ... texts ) { List < Const@@ Label > resultList = new ArrayList < Const@@ Label > ( ) ; for ( String text : texts ) { resultList . add ( new Const@@ Label ( text ) ) ; } return resultList ; }
 public static Network@@ ServiceType valueOf ( String typeName ) { Network@@ ServiceType type = types . get ( typeName ) ; if ( type == null ) { throw new IllegalArgumentException ( " Network@@ ServiceType ▁ type : ▁ " + typeName + " ▁ was ▁ not ▁ provided ▁ by ▁ any ▁ Network@@ ServiceProvider " ) ; } return type ; }
 @ Converter public static AD@@ T_@@ A@@ 25 to@@ Ad@@ t@@ A@@ 25 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 25 . class , body ) ; }
 private static String percent@@ Encode ( String s ) { if ( s == null ) { return " " ; } try { return URLEncoder . encode ( s , " UTF - 8" ) . replace ( " + " , " % 20" ) . replace ( " * " , " % 2A " ) . replace ( " % 7@@ E " , " ~ " ) ; } catch ( UnsupportedEncodingException ue@@ e ) { throw new RuntimeException ( ue@@ e . getMessage ( ) , ue@@ e ) ; } }
 @ Nullable public static Boolean is@@ Callable ( @ Nullable Py@@ Type type ) { if ( type == null ) { return null ; } if ( type instanceof Py@@ Union@@ Type ) { return is@@ Union@@ Callable ( ( Py@@ Union@@ Type ) type ) ; } if ( type instanceof Py@@ Callable@@ Type ) { return ( ( Py@@ Callable@@ Type ) type ) . is@@ Callable ( ) ; } if ( type instanceof Py@@ Struc@@ tur@@ alType && ( ( Py@@ Struc@@ tur@@ alType ) type ) . isIn@@ ferred@@ From@@ Usages ( ) ) { return true ; } return false ; }
 @ Converter public static R@@ DO_@@ O@@ 01 to@@ R@@ do@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ DO_@@ O@@ 01 . class , body ) ; }
 private static Process@@ Runtime@@ Factory@@ Service initialize@@ Provider ( ) { return Service@@ Registry . getInstance ( ) . get ( Process@@ Runtime@@ Factory@@ Service . class ) ; }
 private static void merge ( int offset , CopyOnWrite@@ List source , @ NotNull CopyOnWrite@@ List [ ] target ) { if ( source != null ) { CopyOnWrite@@ List existing = target [ offset ] ; target [ offset ] = existing == null ? source : existing . addAll ( source ) ; } }
 public static void set@@ Sensitive@@ Logging ( boolean sensitive@@ Logging ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putBoolean ( GLOB@@ AL@@ _SETT@@ ING_S@@ EN@@ SI@@ TIVE_@@ LOGGING , sensitive@@ Logging ) ; editor . commit ( ) ; }
 public static int get@@ I18n@@ Refresh@@ Freq ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ CACHE_@@ I18@@ N_@@ REFRESH_@@ FREQ , key -> { return properties . getInt@@ Value ( Web@@ Config@@ Key . CORE_@@ CACHE_@@ I18@@ N_@@ REFRESH_@@ FREQ , Web@@ Config@@ Default . CORE_@@ CACHE_@@ I18@@ N_@@ REFRESH_@@ FREQ ) ; } ) ; return ( int ) cached@@ Config ; }
 public static boolean remove ( Metric@@ Type type ) { return type == null ? false : registry . remove@@ Metric@@ Type ( type ) ; }
 public static void set@@ Fade@@ In@@ Duration ( int fade@@ In@@ Duration ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putInt ( GLOB@@ AL@@ _SETT@@ ING_@@ FA@@ DE_@@ IN_@@ DURATION , fade@@ In@@ Duration ) ; editor . commit ( ) ; }
 public static String replace ( String tpl , Object ... vals ) { if ( tpl != null ) { for ( int i = 1 ; i <= vals . length ; i ++ ) { tpl = tpl . replace ( " { ? " + i + " } " , String . valueOf ( vals [ i - 1 ] ) ) ; } } return tpl ; }
 public static ZonedDateTime to@@ DateTime ( java . sql . Timestamp ts , String time@@ Zone@@ ID ) { ZonedDateTime dt = ( ts == null ? null : ZonedDateTime . of@@ Instant ( ts . to@@ Instant ( ) , ZoneId . of ( time@@ Zone@@ ID ) ) ) ; return dt ; }
 @ Converter public static SI@@ U@@ _S@@ 18 to@@ Si@@ u@@ S@@ 18 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 18 . class , body ) ; }
 static boolean is@@ Cau@@ ght@@ Exception@@ Type ( @ NotNull PsiClassType throw@@ Type , @ NotNull PsiType catch@@ Type ) { return catch@@ Type . isAssignableFrom ( throw@@ Type ) || m@@ ight@@ Be@@ Assign@@ able@@ From@@ Subclass ( throw@@ Type , catch@@ Type ) ; }
 @ NotNull private static String get@@ Presentable@@ Text ( @ NotNull Vcs@@ Full@@ Commit@@ Details commit , boolean with@@ Message ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( commit . getId ( ) . to@@ Short@@ String ( ) ) . append ( " ▁ " ) ; sb . append ( commit . get@@ Author ( ) . getName ( ) ) ; long time = commit . get@@ Author@@ Time ( ) ; sb . append ( " ▁ on ▁ " ) . append ( DateFormat@@ Util . format@@ Date ( time ) ) . append ( " ▁ at ▁ " ) . append ( DateFormat@@ Util . format@@ Time ( time ) ) ; if ( ! Comparing . equal ( commit . get@@ Author ( ) , commit . get@@ Committer ( ) ) ) { sb . append ( " ▁ ( committed ▁ by ▁ " ) . append ( commit . get@@ Committer ( ) . getName ( ) ) . append ( " ) " ) ; } if ( with@@ Message ) { sb . append ( " ▁ " ) . append ( commit . get@@ Subject ( ) ) ; } return sb . toString ( ) ; }
 @ Converter public static AD@@ T_@@ A@@ 44 to@@ Ad@@ t@@ A@@ 44 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 44 . class , body ) ; }
 public static int bin@@ _to_@@ int ( byte [ ] bits ) { return bin@@ _to_@@ int ( bits , false ) ; }
 public static boolean check@@ Permission@@ Gran@@ ted ( @ NonNull Context context , @ NonNull String permission ) { return Context@@ Compat . check@@ Self@@ Permission ( context , permission ) == PackageManager . PERMISSION_@@ GRAN@@ TED ; }
 public static String copy ( Context context , int id , String path , boolean overwrite ) { log ( " Copy@@ Resource ▁ id : ▁ " , " " + id ) ; log ( " Copy@@ Resource ▁ path : ▁ " , path ) ; File tmp = null ; InputStream input = null ; FileOutputStream output = null ; boolean success = true ; File sd@@ card = Environment . getExternal@@ Storage@@ Directory ( ) ; if ( sd@@ card == null || ! Environment . getExternal@@ Storage@@ State ( ) . equals ( Environment . MEDIA_@@ MOUN@@ TED ) ) { return " SD ▁ card ▁ not ▁ found ▁ or ▁ not ▁ ready . " ; } path = sd@@ card . getAbsolutePath ( ) + " / " + path ; log ( " Copy@@ Resource ▁ full ▁ path : ▁ " , path ) ; File file = new File ( path ) ; if ( file . exists ( ) && ! overwrite ) { return " File ▁ already ▁ exists , ▁ not ▁ copied . . . " ; } File directory = new File ( file . getParent ( ) ) ; if ( ! directory . isDirectory ( ) ) { return " Directory ▁ does ▁ not ▁ exist . . . " ; } try { tmp = File . createTempFile ( prefix , null , directory ) ; log ( " Copy@@ Resource ▁ tmp ▁ path : ▁ " , tmp . toString ( ) ) ; input = context . getResources ( ) . open@@ Raw@@ Resource ( id ) ; output = new FileOutputStream ( tmp ) ; byte [ ] buffer = new byte [ 1024 ] ; int count = 0 ; while ( 0 < ( count = input . read ( buffer ) ) ) output . write ( buffer , 0 , count ) ; } catch ( Exception e1 ) { success = false ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( Exception e2 ) { success = false ; } try { if ( input != null ) input . close ( ) ; } catch ( Exception e2 ) { } } if ( success ) success = tmp . rename@@ To ( file ) ; if ( tmp != null && tmp . exists ( ) ) if ( ! tmp . delete ( ) ) log ( " Copy@@ Resource ▁ failed ▁ to ▁ delete : ▁ " , tmp . toString ( ) ) ; return success ? null : " Unknown ▁ error . . . " ; }
 public static < T extends Request@@ Metric@@ Collector > T getRequest@@ Metric@@ Collector ( ) { if ( mc == null ) { if ( isDefault@@ Metrics@@ Enabled ( ) ) enable@@ Default@@ Metrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? Request@@ Metric@@ Collector . NONE : mc . getRequest@@ Metric@@ Collector ( ) ) ; return t ; }
 @ Converter public static AD@@ T_@@ A@@ 13 to@@ Ad@@ t@@ A@@ 13 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 13 . class , body ) ; }
 public static Collection < Ph@@ p@@ Class > getClass@@ From@@ Ph@@ pType@@ Set@@ Array@@ Clean ( Project project , Set < String > types ) { Ph@@ pType ph@@ pType = new Ph@@ pType ( ) ; ph@@ pType . add ( types ) ; ArrayList < Ph@@ p@@ Class > php@@ Classes = new ArrayList < Ph@@ p@@ Class > ( ) ; for ( String typeName : Ph@@ p@@ Index . getInstance ( project ) . complete@@ Type ( project , ph@@ pType , new HashSet < String > ( ) ) . get@@ Types ( ) ) { if ( typeName . startsWith ( " \ \@@ " ) ) { if ( typeName . endsWith ( " [ ] " ) ) { typeName = typeName . substring ( 0 , typeName . length ( ) - 2 ) ; } Ph@@ p@@ Class php@@ Class = Ph@@ p@@ Elements@@ Util . getClass@@ Interface ( project , typeName ) ; if ( php@@ Class != null ) { php@@ Classes . add ( php@@ Class ) ; } } } return php@@ Classes ; }
 static public void err ( Sys t , String msg ) { Event e = Event . make ( t , Kind . ERR@@ R , null , msg ) ; write ( e , true , false ) ; }
 @ BeforeClass public static void setUp@@ BeforeClass ( ) throws Exception { client = Client . create ( ) ; }
 public static ContentValues status@@ To@@ ContentValues ( Status status ) { ContentValues cv = new ContentValues ( ) ; cv . put ( C_@@ ID , status . id ) ; cv . put ( C_@@ CRE@@ ATED_@@ AT , status . created@@ At . getTime ( ) ) ; cv . put ( C_@@ TEXT , status . text ) ; cv . put ( C_@@ USER , status . user . screen@@ Name ) ; return cv ; }
 public static boolean is@@ Machine@@ Metric@@ Exclu@@ ded ( ) { return machine@@ Metrics@@ Exclu@@ ded ; }
 @ Nullable public static PsiElement getContext@@ Element ( final Stack@@ Frame@@ Context context ) { return getContext@@ Element ( context , getSource@@ Position ( context ) ) ; }
 public static void verify@@ Manifest@@ Receiver ( Context context , Class < ? extends BroadcastReceiver > cls ) { try { context . getPackage@@ Manager ( ) . get@@ Receiver@@ Info ( new ComponentName ( context , cls ) , PackageManager . GET_@@ DISAB@@ LED_@@ COMPONE@@ N@@ TS ) ; } catch ( Exception ignored ) { report@@ Missing@@ Component ( context , cls ) ; } }
 static public void debug ( Sys t , Object ... objects ) { if ( flag ( t ) == false ) return ; Event e = Event . make ( t , Kind . DE@@ BG , null , objects ) ; write ( e , false , true ) ; }
 @ Converter public static BAR_@@ P@@ 01 to@@ Bar@@ P@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( BAR_@@ P@@ 01 . class , body ) ; }
 public static Matrix@@ 2D Extract@@ Commit@@ Sub@@ Matrix ( Gra@@ in gra@@ in , String _re@@ pository , int offset , int size ) { try { String sql ; Matrix@@ Descriptor descriptor = new Matrix@@ Descriptor ( InfoType . ARTI@@ FAC@@ T , InfoType . COMMIT ) ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date ▁ ASC ▁ " + " LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . Add@@ Col@@ Desc ( rs . getString ( " HashCode " ) ) ; } switch ( gra@@ in ) { case FILE : sql = " SELECT ▁ Distin@@ ct ( TF . New@@ Name ) ▁ FROM ▁ T@@ FILE ▁ TF ▁ " + " WHERE ▁ TF . Commit@@ Id ▁ IN ▁ " + " ( SELECT ▁ TC . id ▁ FROM ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' " + " ORDER ▁ BY ▁ TC . date ▁ ASC ▁ LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ) " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . Add@@ Row@@ Desc ( rs . getString ( " New@@ Name " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TC@@ L . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ Func@@ Name ▁ " + " FROM ▁ T@@ Function ▁ TF , ▁ T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . classi@@ d ▁ = ▁ TC@@ L . id ▁ AND ▁ TC@@ L . file@@ id ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ " + " AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " GROUP ▁ BY ▁ TC@@ L . name , ▁ TF . name ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . Add@@ Row@@ Desc ( rs . getString ( " ClassName " ) + " . " + rs . getString ( " Func@@ Name " ) ) ; rs . close ( ) ; break ; } Matrix@@ 2D mat = new Matrix@@ 2D ( descriptor ) ; switch ( gra@@ in ) { case FILE : sql = " SELECT ▁ TC . HashCode , ▁ TF . New@@ Name ▁ FROM ▁ T@@ FILE ▁ TF , ▁ T@@ COMMIT ▁ TC ▁ " + " WHERE ▁ TF . Commit@@ Id ▁ = ▁ TC . id ▁ AND ▁ TC . id ▁ IN ▁ " + " ( SELECT ▁ TC . id ▁ FROM ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' " + " ORDER ▁ BY ▁ TC . date ▁ ASC ▁ LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ) " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . Set@@ Element ( rs . getString ( " New@@ Name " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ TC . hashcode , ▁ TC@@ L . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ Func@@ Name ▁ from ▁ T@@ Function ▁ TF , ▁ " + " T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . classi@@ d ▁ = ▁ TC@@ L . id ▁ AND ▁ TC@@ L . file@@ id ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ AND ▁ " + " TC . Repo@@ Id ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TF@@ L . newname , ▁ TC@@ L . name , ▁ TF . name ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . Set@@ Element ( rs . getString ( " ClassName " ) + " . " + rs . getString ( " Func@@ Name " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; break ; } s@@ mt . close ( ) ; return mat ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
 public static int getMax@@ Result ( ResultSet resultSet ) throws SQLException { resultSet . next ( ) ; return resultSet . getInt ( 1 ) ; }
 @ NotNull private static List < Psi@@ Try@@ Statement > collect@@ Try@@ Statement@@ Stack ( @ Nullable PsiElement startElement , @ NotNull PsiElement enclosing@@ Code@@ Fragment ) { final List < Psi@@ Try@@ Statement > stack = new ArrayList < > ( ) ; for ( Psi@@ Try@@ Statement try@@ Statement = get@@ Enclosing@@ Try@@ Statement@@ H@@ av@@ ing@@ Catch@@ Or@@ Finally ( startElement , enclosing@@ Code@@ Fragment ) ; try@@ Statement != null ; try@@ Statement = get@@ Enclosing@@ Try@@ Statement@@ H@@ av@@ ing@@ Catch@@ Or@@ Finally ( try@@ Statement , enclosing@@ Code@@ Fragment ) ) { stack . add ( try@@ Statement ) ; } return stack ; }
 @ Nullable static public String getArray@@ KeyValue@@ Inside@@ Signature ( PsiElement psi@@ Element@@ Inside@@ Class , String call@@ To [ ] , String methodName , String keyName ) { Ph@@ p@@ Class php@@ Class = PsiTreeUtil . getParent@@ OfType ( psi@@ Element@@ Inside@@ Class , Ph@@ p@@ Class . class ) ; if ( php@@ Class == null ) { return null ; } String className = php@@ Class . get@@ Presentable@@ FQ@@ N ( ) ; if ( className == null ) { return null ; } for ( String s : call@@ To ) { String array@@ KeyValue@@ Inside@@ Signature = Ph@@ p@@ Elements@@ Util . getArray@@ KeyValue@@ Inside@@ Signature ( psi@@ Element@@ Inside@@ Class . getProject ( ) , " # M # C@@ \ \@@ " + className + " . " + s , methodName , keyName ) ; if ( array@@ KeyValue@@ Inside@@ Signature != null ) { return array@@ KeyValue@@ Inside@@ Signature ; } } return null ; }
 public static boolean is@@ Variable@@ Access ( @ NotNull Control@@ Flow flow , int offset , @ NotNull Psi@@ Variable variable ) { Instruction instruction = flow . get@@ Instructions ( ) . get ( offset ) ; return instruction instanceof Read@@ Variable@@ Instruction && ( ( Read@@ Variable@@ Instruction ) instruction ) . variable == variable || instruction instanceof Write@@ Variable@@ Instruction && ( ( Write@@ Variable@@ Instruction ) instruction ) . variable == variable ; }
 public static View@@ Action scrollTo@@ Position ( final int position ) { return new View@@ Action ( ) { @ SuppressWarnings ( " unchecked " ) @ Override public Matcher < View > get@@ Constraints ( ) { return isAssignableFrom ( RecyclerView . class ) ; } @ Override public void perform ( Ui@@ Controller ui@@ Controller , View view ) { ( ( RecyclerView ) view ) . scrollTo@@ Position ( position ) ; } @ Override public String getDescription ( ) { return " scroll ▁ to " ; } } ; }
 public static void create@@ Course@@ Status ( String i@@ Course@@ ID , String i@@ Lear@@ ner@@ ID ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " create@@ Course@@ Status " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ Course@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ Lear@@ ner@@ ID ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : create@@ Course@@ Status " ) ; }
 public static Builder builder ( BuildTarget build@@ Target , Project@@ Filesystem project@@ Filesystem , Tool@@ chain@@ Provider tool@@ chain@@ Provider , BuildRule@@ Params params , Action@@ Graph@@ Builder graph@@ Builder , Cell@@ Path@@ Resolver cell@@ Path@@ Resolver , Java@@ Buck@@ Config java@@ Buck@@ Config , Javac@@ Factory javac@@ Factory , Javac@@ Options javac@@ Options , Core@@ Arg args , Configured@@ Compiler@@ Factory compiler@@ Factory ) { return new Builder ( build@@ Target , project@@ Filesystem , tool@@ chain@@ Provider , params , graph@@ Builder , cell@@ Path@@ Resolver , java@@ Buck@@ Config , javac@@ Factory , javac@@ Options , args , compiler@@ Factory ) ; }
 private static org . apache . log4j . Logger getLog@@ 4j@@ Logger ( ) { return _logger ; }
 private static final String conv@@ Path ( String slash@@ Path ) { return " \@@ " " + slash@@ Path . replaceAll ( " \\ / " , " \\ \ \@@ " ) + " \@@ " " ; }
 public static String getCount ( ) { return Integer . toString ( sCount ) ; }
 @ Converter public static MD@@ M_@@ T@@ 01 to@@ M@@ dm@@ T@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 01 . class , body ) ; }
 private static Object create@@ Persistent@@ Service ( final String factory@@ Interface , final String serviceName , final Properties properties ) throws Standard@@ Exception { try { return AccessController . doPrivileged ( new Privileged@@ Exception@@ Action < Object > ( ) { public Object run ( ) throws Standard@@ Exception { return Monitor . create@@ Persistent@@ Service ( factory@@ Interface , serviceName , properties ) ; } } ) ; } catch ( Privileged@@ Action@@ Exception pa@@ e ) { throw Standard@@ Exception . plain@@ Wrap@@ Exception ( pa@@ e ) ; } }
 public static Method [ ] get@@ Imp@@ lemented@@ Methods ( @ NotNull Method method ) { ArrayList < Method > items = get@@ Imp@@ lemented@@ Methods ( method . getContain@@ ingClass ( ) , method , new ArrayList < Method > ( ) ) ; return items . toArray ( new Method [ items . size ( ) ] ) ; }
 public static boolean isEmpty ( Collection c ) { return c == null || c . isEmpty ( ) ; }
 public static void test_@@ local@@ Time_@@ as_string ( ) { System . out . println ( " Test ▁ LocalTime ▁ as ▁ String " ) ; LocalTime l@@ t1 = LocalTime . now ( ) ; String t = toString ( l@@ t1 ) ; LocalTime l@@ t2 = to@@ LocalTime ( t ) ; System . out . println ( " LocalTime ▁ 1 ▁ = ▁ " + l@@ t1 ) ; System . out . println ( " String ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + t ) ; System . out . println ( " LocalTime ▁ 2 ▁ = ▁ " + l@@ t2 ) ; if ( ! l@@ t2 . equals ( l@@ t1 ) ) { throw new IllegalStateException ( ) ; } }
 public static void createTest@@ Jar ( File file ) throws Exception { createTest@@ Jar ( file , false ) ; }
 @ Converter public static CR@@ M_@@ C@@ 02 to@@ C@@ rm@@ C@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 02 . class , body ) ; }
 static Event make ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object message ) { return make@@ 0 ( sys , kind , ouch , null , message ) ; }
 public static void clear@@ Global@@ Objs ( String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID , List < String > i@@ Obj@@ List ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " clear@@ Global@@ Objs " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED : ▁ AD@@ L@@ Seq@@ Utilities : clear@@ Global@@ Objs " ) ; }
 @ NotNull public static PsiElement find@@ Code@@ Fragment ( @ NotNull PsiElement element ) { PsiElement code@@ Fragment = element ; PsiElement parent = code@@ Fragment . getParent ( ) ; while ( parent != null ) { if ( parent instanceof Psi@@ Directory || parent instanceof PsiMethod || parent instanceof PsiField || parent instanceof Psi@@ Class@@ Initializer || parent instanceof Dummy@@ Holder || parent instanceof Psi@@ Lambda@@ Expression ) { break ; } code@@ Fragment = parent ; parent = parent . getParent ( ) ; } return code@@ Fragment ; }
 public static int end@@ Stat ( Flat@@ Buffer@@ Builder builder ) { int o = builder . endObject ( ) ; return o ; }
 public static List < Instruction > getAll@@ Instruction@@ s@@ But@@ One ( String to@@ Exclude ) { List < Instruction > ins = new ArrayList < Instruction > ( ) ; for ( Map . Entry < String , Instruction > entry : instruction@@ Map . entrySet ( ) ) { if ( ! entry . getKey ( ) . equals ( to@@ Exclude ) ) { ins . add ( entry . getValue ( ) ) ; } } return ins ; }
 private static double parse@@ Term ( Chars chars ) { double arg = parse@@ Arg ( chars ) ; while ( chars . hasNext ( ) ) { char c = chars . peek ( ) ; if ( c == ' × ' ) { chars . next ( ) ; arg *= parse@@ Arg ( chars ) ; } else if ( c == ' ÷ ' ) { chars . next ( ) ; arg /= parse@@ Arg ( chars ) ; } else { break ; } } return arg ; }
 public static byte [ ] decode@@ _bin ( byte [ ] data ) { if ( ( data . length & 7 ) != 0 ) throw new ValueError ( " Data ▁ length ▁ must ▁ be ▁ a ▁ multiple ▁ of ▁ 8" ) ; byte [ ] sb = new byte [ data . length / 8 ] ; for ( int i = 0 ; i < data . length ; i += 8 ) { byte ch = 0 ; for ( int j = 0 ; j < 8 ; j ++ ) { ch = ( byte ) ( ch << 1 ) ; ch |= data [ i + j ] ; } sb [ i / 8 ] = ch ; } return sb ; }
 public static void enable@@ Component ( Context context , String full@@ ClassName ) { try { enable@@ Component ( context , Class . forName ( full@@ ClassName ) ) ; } catch ( ClassNotFoundException ignored ) { } }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
 private static String getElement@@ Text ( Node i@@ Node , String i@@ Element ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getElement@@ Text " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ Element ) ; } StringBuilder value = new StringBuilder ( ) ; Node curNode = null ; NodeList children = null ; if ( i@@ Element != null && i@@ Node != null ) { children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ ▁ " + i ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ < " + curNode . getLocalName ( ) + " > " ) ; } if ( curNode . getLocalName ( ) . equals ( i@@ Element ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ < " + i@@ Element + " > " ) ; } break ; } } } if ( curNode != null ) { String comp = curNode . getLocalName ( ) ; if ( comp != null ) { if ( ! comp . equals ( i@@ Element ) ) { curNode = null ; } } else { curNode = null ; } } } else { curNode = i@@ Node ; } if ( curNode != null ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Look@@ ing ▁ at ▁ children " ) ; } children = curNode . getChildNodes ( ) ; if ( children != null ) { value = new StringBuilder ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { curNode = children . item ( i ) ; if ( ( curNode . getNodeType ( ) == Node . TEXT_@@ NODE ) || ( curNode . getNodeType ( ) == Node . CDATA@@ _SECTION_@@ NODE ) ) { value . append ( curNode . getNodeValue ( ) ) ; } } } } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + value ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getElement@@ Text " ) ; } return value . toString ( ) ; }
 public static < T > Metric < ? > gen@@ Def ( Metric@@ Type < T > metric@@ Type ) { Metric@@ Id < ? > id = new Metric@@ Id < > ( BaseTest . getRandom@@ Id ( ) , metric@@ Type , BaseTest . getRandom@@ Id ( ) ) ; return new Metric < > ( id , TAGS , DATA_@@ RE@@ TEN@@ TION ) ; }
 @ Converter public static AD@@ T_@@ A@@ 38 to@@ Ad@@ t@@ A@@ 38 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 38 . class , body ) ; }
 private static int [ ] getPost@@ Order ( TreeNode root ) { List < Integer > list = new ArrayList < > ( ) ; getPost@@ OrderBy@@ Recur@@ sion ( root , list ) ; return list . stream ( ) . mapTo@@ Int ( Integer :: intValue ) . toArray ( ) ; }
 public static Serializer@@ Registration register@@ Class ( Class cls ) { return register@@ Class ( cls , true ) ; }
 public static ZonedDateTime to@@ Date@@ Mid@@ night ( java . util . Date d , String time@@ Zone@@ ID ) { ZonedDateTime dm = ( d == null ? null : to@@ LocalDate ( d ) . at@@ StartOf@@ Day ( ZoneId . of ( time@@ Zone@@ ID ) ) ) ; return dm ; }
 public static void main ( String [ ] args ) { new Ex@@ ctr@@ actor ( ) ; new Analyzer ( ) ; }
 @ Converter public static SI@@ U@@ _S@@ 17 to@@ Si@@ u@@ S@@ 17 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 17 . class , body ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Se@@ ven@@ One ( ) { float a = 1.@@ f / 14@@ 1.@@ 8f ; return new float [ ] { a , 3 * a , - 8 * a , 3 * a , a } ; }
 public static String get@@ Saved@@ Password ( Context context ) { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " pass@@ Pref " , " " ) ; }
 public static Vector@@ 4b create ( boolean x1 , boolean x2 , boolean x3 , boolean x4 ) { return new Vector@@ 4b ( x1 , x2 , x3 , x4 ) ; }
 private static void getPost@@ OrderBy@@ Recur@@ sion ( TreeNode root , List < Integer > list ) { if ( root == null ) { return ; } getPost@@ OrderBy@@ Recur@@ sion ( root . left , list ) ; getPost@@ OrderBy@@ Recur@@ sion ( root . right , list ) ; list . add ( root . val ) ; }
 private static void write@@ Entry ( Jar@@ OutputStream jar@@ OutputStream , String name , int data ) throws IOException { jar@@ OutputStream . put@@ Next@@ Entry ( new Jar@@ Entry ( name ) ) ; jar@@ OutputStream . write ( new byte [ ] { ( byte ) data } ) ; jar@@ OutputStream . close@@ Entry ( ) ; }
 @ Converter public static R@@ AR_@@ R@@ AR to@@ R@@ ar@@ R@@ ar ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ AR_@@ R@@ AR . class , body ) ; }
 private static Seq@@ Condition@@ Set extract@@ Seq@@ Rule@@ Conditions ( Node i@@ Node ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " extract@@ Seq@@ Rule@@ Conditions " ) ; } String temp@@ Val = null ; Seq@@ Condition@@ Set cond@@ Set = new Seq@@ Condition@@ Set ( ) ; List < Seq@@ Condition > conditions = new ArrayList < Seq@@ Condition > ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " condition@@ Combination " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { cond@@ Set . m@@ Combination = temp@@ Val ; } } else { cond@@ Set . m@@ Combination = Seq@@ Condition@@ Set . COMBIN@@ ATION_@@ ALL ; } NodeList cond@@ Info = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < cond@@ Info . getLength ( ) ; i ++ ) { Node cur@@ Cond = cond@@ Info . item ( i ) ; if ( cur@@ Cond . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( cur@@ Cond . getLocalName ( ) . equals ( " rule@@ Condition " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < Condition > ▁ " + " element " ) ; } Seq@@ Condition cond = new Seq@@ Condition ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Cond , " condition " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { cond . m@@ Condition = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Cond , " referenced@@ Objective " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { cond . m@@ Obj@@ ID = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Cond , " measure@@ Threshold " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { cond . m@@ Threshold = ( new Double ( temp@@ Val ) ) . doubleValue ( ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Cond , " operator " ) ; if ( temp@@ Val != null ) { if ( temp@@ Val . equals ( " not " ) ) { cond . m@@ Not = true ; } else { cond . m@@ Not = false ; } } conditions . add ( cond ) ; } } } if ( conditions . size ( ) > 0 ) { cond@@ Set . m@@ Conditions = conditions ; } else { cond@@ Set = null ; } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " extract@@ Seq@@ Rule@@ Conditions " ) ; } return cond@@ Set ; }
 public static < T , U > List < Pair < T , U > > mapTo@@ List ( Map < T , U > map ) { return ContainerUtil . map@@ 2@@ List ( map . entrySet ( ) , new Function < Map . Entry < T , U > , Pair < T , U > > ( ) { public Pair < T , U > fun ( Map . Entry < T , U > tu@@ Entry ) { return Pair . create ( tu@@ Entry . getKey ( ) , tu@@ Entry . getValue ( ) ) ; } } ) ; }
 public static File get@@ Maven@@ Conf@@ File ( File maven@@ Home ) { return new File ( new File ( maven@@ Home , B@@ IN_@@ DIR ) , M@@ 2_@@ CONF_@@ FILE ) ; }
 private static void validate@@ List@@ Sql@@ Database ( List < Sql@@ Database > sql@@ Databases ) { boolean found = false ; for ( Sql@@ Database database : sql@@ Databases ) { if ( database . name ( ) . equals ( SQL_@@ DATABASE_@@ NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
 protected static Map < Integer , String > to@@ Item@@ TypeMap ( ResultSet resultSet ) throws SQLException { Map < Integer , String > result = new HashMap < Integer , String > ( ) ; while ( resultSet . next ( ) ) { result . put ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; } return result ; }
 public static void test@@ Complex@@ Keys ( ) throws SQLException { Class@@ CD loaded = new Class@@ CD ( ) ; loaded . set@@ C ( new Class@@ C ( 31 , 0 ) ) ; loaded . set@@ D ( new Class@@ D ( 44 , null ) ) ; loaded = broker . load@@ Entity ( loaded , false ) ; System . out . println ( loaded ) ; }
 @ NotNull public static List < Psi@@ Variable > get@@ SS@@ A@@ Variables ( @ NotNull Control@@ Flow flow , int from , int to , boolean report@@ Var@@ s@@ If@@ Non@@ Initializ@@ ing@@ Path@@ Exists ) { List < Instruction > instructions = flow . get@@ Instructions ( ) ; Collection < Psi@@ Variable > written@@ Variables = get@@ Written@@ Variables ( flow , from , to , false ) ; List < Psi@@ Variable > result = new ArrayList < > ( 1 ) ; variables : for ( Psi@@ Variable psi@@ Variable : written@@ Variables ) { final List < SS@@ A@@ Instruction@@ State > queue = new ArrayList < > ( ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( 0 , from ) ) ; Set < SS@@ A@@ Instruction@@ State > processed@@ States = new TH@@ ash@@ Set < > ( ) ; while ( ! queue . isEmpty ( ) ) { final SS@@ A@@ Instruction@@ State state = queue . remove ( 0 ) ; if ( state . getWrite@@ Count ( ) > 1 ) continue variables ; if ( ! processed@@ States . contains ( state ) ) { processed@@ States . add ( state ) ; int i = state . get@@ Instruction@@ Idx ( ) ; if ( i < to ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Return@@ Instruction ) { int [ ] offsets = ( ( Return@@ Instruction ) instruction ) . get@@ Possible@@ Return@@ Offsets ( ) ; for ( int offset : offsets ) { queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , Math . min ( offset , to ) ) ) ; } } else if ( instruction instanceof GoTo@@ Instruction ) { int next@@ Offset = ( ( GoTo@@ Instruction ) instruction ) . offset ; next@@ Offset = Math . min ( next@@ Offset , to ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , next@@ Offset ) ) ; } else if ( instruction instanceof Throw@@ To@@ Instruction ) { int next@@ Offset = ( ( Throw@@ To@@ Instruction ) instruction ) . offset ; next@@ Offset = Math . min ( next@@ Offset , to ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , next@@ Offset ) ) ; } else if ( instruction instanceof Conditional@@ GoTo@@ Instruction ) { int next@@ Offset = ( ( Conditional@@ GoTo@@ Instruction ) instruction ) . offset ; next@@ Offset = Math . min ( next@@ Offset , to ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , next@@ Offset ) ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , i + 1 ) ) ; } else if ( instruction instanceof Conditional@@ Throw@@ To@@ Instruction ) { int next@@ Offset = ( ( Conditional@@ Throw@@ To@@ Instruction ) instruction ) . offset ; next@@ Offset = Math . min ( next@@ Offset , to ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , next@@ Offset ) ) ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , i + 1 ) ) ; } else if ( instruction instanceof Write@@ Variable@@ Instruction ) { Write@@ Variable@@ Instruction write = ( Write@@ Variable@@ Instruction ) instruction ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) + ( write . variable == psi@@ Variable ? 1 : 0 ) , i + 1 ) ) ; } else if ( instruction instanceof Read@@ Variable@@ Instruction ) { Read@@ Variable@@ Instruction read = ( Read@@ Variable@@ Instruction ) instruction ; if ( read . variable == psi@@ Variable && state . getWrite@@ Count ( ) == 0 ) continue variables ; queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , i + 1 ) ) ; } else { queue . add ( new SS@@ A@@ Instruction@@ State ( state . getWrite@@ Count ( ) , i + 1 ) ) ; } } else if ( ! report@@ Var@@ s@@ If@@ Non@@ Initializ@@ ing@@ Path@@ Exists && state . getWrite@@ Count ( ) == 0 ) continue variables ; } } result . add ( psi@@ Variable ) ; } return result ; }
 protected static Ko@@ do@@ Under@@ FileSystem cre@@ at@@ Instance ( Al@@ lux@@ io@@ URI uri , Under@@ FileSystem@@ Configuration conf ) { String bucket@@ Name = Under@@ FileSystem@@ Utils . getBucket@@ Name ( uri ) ; Preconditions . checkArgument ( conf . isSet ( Property@@ Key . KO@@ DO_@@ ACCESS_@@ KEY ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Ko@@ do " , Property@@ Key . KO@@ DO_@@ ACCESS_@@ KEY ) ; Preconditions . checkArgument ( conf . isSet ( Property@@ Key . KO@@ DO@@ _SEC@@ RET_@@ KEY ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Ko@@ do " , Property@@ Key . KO@@ DO@@ _SEC@@ RET_@@ KEY ) ; Preconditions . checkArgument ( conf . isSet ( Property@@ Key . KO@@ DO_@@ DOWNLOAD_@@ HOST ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Ko@@ do " , Property@@ Key . KO@@ DO_@@ DOWNLOAD_@@ HOST ) ; Preconditions . checkArgument ( conf . isSet ( Property@@ Key . KO@@ DO_@@ ENDPOINT ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Ko@@ do " , Property@@ Key . KO@@ DO_@@ ENDPOINT ) ; String access@@ Key = conf . getString ( Property@@ Key . KO@@ DO_@@ ACCESS_@@ KEY ) ; String secret@@ Key = conf . getString ( Property@@ Key . KO@@ DO@@ _SEC@@ RET_@@ KEY ) ; String endPoint = conf . getString ( Property@@ Key . KO@@ DO_@@ ENDPOINT ) ; String sou@@ ce@@ Host = conf . getString ( Property@@ Key . KO@@ DO_@@ DOWNLOAD_@@ HOST ) ; Auth auth = Auth . create ( access@@ Key , secret@@ Key ) ; Configuration configuration = new Configuration ( ) ; Ok@@ HttpClient . Builder ok@@ Http@@ Builder = initialize@@ Ko@@ do@@ ClientConfig ( conf ) ; Ok@@ HttpClient ok@@ HttpClient = ok@@ Http@@ Builder . build ( ) ; Ko@@ do@@ Client ko@@ do@@ Client = new Ko@@ do@@ Client ( auth , bucket@@ Name , sou@@ ce@@ Host , endPoint , configuration , ok@@ HttpClient ) ; return new Ko@@ do@@ Under@@ FileSystem ( uri , ko@@ do@@ Client , conf ) ; }
 @ Converter public static AD@@ T_@@ A@@ 15 to@@ Ad@@ t@@ A@@ 15 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 15 . class , body ) ; }
 static < T > void call ( Callable < T > callable ) throws Exception { callable . call ( ) ; }
 public static Properties get@@ Env@@ Properties ( ) { Properties re@@ us@@ lt = new Properties ( ) ; for ( Map . Entry < String , String > each : System . getenv ( ) . entrySet ( ) ) { if ( is@@ Mag@@ ical@@ Property ( each . getKey ( ) ) ) continue ; re@@ us@@ lt . put ( each . getKey ( ) , each . getValue ( ) ) ; } return re@@ us@@ lt ; }
 static private Event make@@ 0 ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages , Object message ) { Event result = null ; try { result = new Event ( ) ; result . init ( sys , kind , ouch , messages , message , last@@ Good@@ Timer = new Timer ( ) ) ; } catch ( OutOf@@ MemoryError e ) { synchronized ( Event . class ) { if ( last@@ Event . print@@ Me ) { missed ++ ; return null ; } result = last@@ Event ; result . init ( sys , kind , ouch , messages , null , last@@ Good@@ Timer ) ; } } return result ; }
 public static An@@ des@@ Admin@@ Service@@ Stub get@@ An@@ des@@ Admin@@ Service@@ Stub ( Servlet@@ Config config , HttpSession session , HttpServletRequest request ) throws AxisFault { String backend@@ Server@@ URL = Carbon@@ UIUtil . getServer@@ URL ( config . get@@ ServletContext ( ) , session ) ; backend@@ Server@@ URL = backend@@ Server@@ URL + AN@@ DES_@@ AD@@ MIN@@ _SERVICE_@@ NAME ; Configuration@@ Context config@@ Context = ( Configuration@@ Context ) config . get@@ ServletContext ( ) . getAttribute ( Carbon@@ Constants . CONFIGURATION_@@ CONTEXT ) ; An@@ des@@ Admin@@ Service@@ Stub stub = new An@@ des@@ Admin@@ Service@@ Stub ( config@@ Context , backend@@ Server@@ URL ) ; String cookie = ( String ) session . getAttribute ( Server@@ Constants . AD@@ MIN@@ _SERVICE_@@ COOKIE ) ; if ( cookie != null ) { Options option = stub . _get@@ ServiceClient ( ) . getOptions ( ) ; option . set@@ Manage@@ Session ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTP@@ Constants . COOKIE_@@ STRING , cookie ) ; } return stub ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return class_@@ NAME ; default : return null ; } }
 static public void info ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , true , true ) ; }
 public static String format@@ Html@@ Image ( URL url ) { return " < img ▁ src = \@@ " " + url + " \@@ " > ▁ " ; }
 private static com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . Cache@@ Server@@ List Get@@ Se@@ vers@@ Priority@@ List ( ) throws UnknownHostException { java . util . HashMap < Integer , com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . dom . Cache@@ Server > server@@ s@@ Priority@@ List = new java . util . HashMap < Integer , com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . dom . Cache@@ Server > ( ) ; java . util . ArrayList < Address > hosts = config . getCache@@ Deployment ( ) . get@@ Servers ( ) . GetAll@@ Configured@@ Nodes ( ) ; int priority = 0 ; for ( Address addr : hosts ) { com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . dom . Cache@@ Server server = new com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . dom . Cache@@ Server ( ) ; server . set@@ ServerName ( addr . get@@ IpAddress ( ) . getHost@@ Address ( ) ) ; server . setPriority ( priority ) ; server@@ s@@ Priority@@ List . put ( priority , server ) ; priority ++ ; } com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . Cache@@ Server@@ List cs@@ List = new com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . management . client@@ configuration . Cache@@ Server@@ List ( ) ; cs@@ List . set@@ Server@@ sList ( server@@ s@@ Priority@@ List ) ; return cs@@ List ; }
 public static void show@@ With@@ Font@@ A@@ we@@ some@@ Image ( Activity activity , String message , String fat@@ Image@@ String , Notification@@ Type type ) { switch ( type ) { case SUCCESS : Simple@@ Toast . ok ( activity , message , fat@@ Image@@ String ) ; break ; case ERROR : Simple@@ Toast . error ( activity , message , fat@@ Image@@ String ) ; break ; case MU@@ TED : Simple@@ Toast . muted ( activity , message , fat@@ Image@@ String ) ; break ; case WARNING : Simple@@ Toast . warning ( activity , message , fat@@ Image@@ String ) ; break ; case INFO : Simple@@ Toast . info ( activity , message , fat@@ Image@@ String ) ; break ; } }
 public static int signum ( long v ) { return v < 0 ? - 1 : ( v == 0 ? 0 : 1 ) ; }
 public static Voice get@@ Voice@@ At@@ Lang ( String lang ) { Js@@ Array < Voice > vo@@ ices = Speech@@ Synthe@@ sis . get ( ) . get@@ Vo@@ ices ( ) ; for ( int i = 0 ; i < vo@@ ices . length ( ) ; i ++ ) { if ( vo@@ ices . get ( i ) . getL@@ ang ( ) . equals ( lang ) ) { return vo@@ ices . get ( i ) ; } } return null ; }
 @ Converter public static SP@@ Q_@@ Q@@ 01 to@@ Sp@@ q@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( SP@@ Q_@@ Q@@ 01 . class , body ) ; }
 @ Nullable public static Py@@ Type getTarget@@ TypeFrom@@ Tuple@@ Assignment ( @ NotNull Py@@ Target@@ Expression target , @ NotNull Py@@ Tuple@@ Expression parent@@ Tuple , @ NotNull Py@@ TupleType assigned@@ TupleType ) { final int count = assigned@@ TupleType . getElement@@ Count ( ) ; final Py@@ Expression [ ] elements = parent@@ Tuple . getElements ( ) ; if ( elements . length == count || assigned@@ TupleType . is@@ Ho@@ mo@@ gene@@ ous ( ) ) { final int index = ArrayUtil . indexOf ( elements , target ) ; if ( index >= 0 ) { return assigned@@ TupleType . getElementType ( index ) ; } for ( int i = 0 ; i < count ; i ++ ) { Py@@ Expression element = elements [ i ] ; while ( element instanceof Py@@ Parenthe@@ sized@@ Expression ) { element = ( ( Py@@ Parenthe@@ sized@@ Expression ) element ) . getContain@@ ed@@ Expression ( ) ; } if ( element instanceof Py@@ Tuple@@ Expression ) { final Py@@ Type elementType = assigned@@ TupleType . getElementType ( i ) ; if ( elementType instanceof Py@@ TupleType ) { final Py@@ Type result = getTarget@@ TypeFrom@@ Tuple@@ Assignment ( target , ( Py@@ Tuple@@ Expression ) element , ( Py@@ TupleType ) elementType ) ; if ( result != null ) { return result ; } } } } } return null ; }
 public static void internal@@ Force@@ Init ( ) { }
 public static int de@@ compress_@@ light ( int input ) { if ( input < 64 ) { return input ; } if ( input < 96 ) { return ( ( input - 64 ) * 2 ) + 64 ; } if ( input < 128 ) { return ( ( input - 96 ) * 4 ) + 128 ; } if ( input < 160 ) { return ( ( input - 128 ) * 8 ) + 256 ; } if ( input < 192 ) { return ( ( input - 160 ) * 16 ) + 512 ; } if ( input < 240 ) { return ( ( input - 192 ) * 64 ) + 1024 ; } if ( input < 255 ) { return ( ( input - 240 ) * 128 ) + 4096 ; } return 6000 ; }
 public static List < String > array@@ 2@@ List ( String ... values ) { List < String > list = new ArrayList < String > ( ) ; for ( String value : values ) { list . add ( value ) ; } return list ; }
 @ Converter public static ACK to@@ ACK ( String body ) throws HL7@@ Exception { return to@@ Message ( ACK . class , body ) ; }
 public static void test@@ Entity@@ Loading ( ) throws SQLException { Class@@ D d = new Class@@ D ( ) ; d . set@@ D1 ( 44 ) ; Class@@ C c = new Class@@ C ( ) ; c . set@@ C1 ( 32 ) ; Class@@ B b = new Class@@ B ( ) ; b . set@@ B1 ( 21 ) ; Class@@ A a = new Class@@ A ( ) ; a . set@@ A1 ( 11 ) ; a . set@@ A@@ 11 ( 111 ) ; Object [ ] loaded = new Object [ 4 ] ; loaded [ 0 ] = broker . load@@ Entity ( d , false ) ; loaded [ 1 ] = broker . load@@ Entity ( c , false ) ; loaded [ 2 ] = broker . load@@ Entity ( b , false ) ; loaded [ 3 ] = broker . load@@ Entity ( a , false ) ; System . out . println ( " " ) ; for ( Object o : loaded ) { System . out . println ( o ) ; } }
 public static int bit@@ Count ( long v ) { v -= ( v >@@ >> 1 ) & 0x5@@ 5555@@ 5555@@ 5555@@ 55@@ 5L ; v = ( v & 0x3@@ 33333333@@ 333333@@ 3L ) + ( ( v >@@ >> 2 ) & 0x3@@ 33333333@@ 333333@@ 3L ) ; int i = ( ( int ) ( v >@@ >> 32 ) ) + ( int ) v ; i = ( i & 0x0@@ F@@ 0F@@ 0F@@ 0F ) + ( ( i >@@ >> 4 ) & 0x0@@ F@@ 0F@@ 0F@@ 0F ) ; i += i >@@ >> 8 ; i += i >@@ >> 16 ; return i & 0x000000@@ 7@@ F ; }
 private static Method getMethod ( String name , Fixture fixture , Matcher matcher ) { Method method = null ; String methodName ; if ( Grace@@ ful@@ Nam@@ er . is@@ Grace@@ ful@@ Name ( name ) ) { methodName = Grace@@ ful@@ Nam@@ er . dis@@ gr@@ ace ( name ) . toLowerCase ( ) ; method = find@@ Method ( fixture , methodName ) ; } else { try { methodName = matcher . group ( 1 ) ; Class < ? > targetClass = getTarget@@ Class ( fixture ) ; method = targetClass . getMethod ( methodName , new Class [ 0 ] ) ; } catch ( NoSuchMethodException var@@ 6 ) { ; } } return method ; }
 @ Converter public static SI@@ U@@ _S@@ 14 to@@ Si@@ u@@ S@@ 14 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 14 . class , body ) ; }
 public static int get@@ Milli@@ Seconds@@ Between@@ Syn@@ cs ( Context context , final int defaultValue ) { try { String val = PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " sync@@ Freq@@ Pref " , " " ) ; int secs ; if ( val == null || val . length ( ) == 0 ) return defaultValue ; try { secs = Integer . parseInt ( val . split ( " ▁ " ) [ 0 ] ) * 60 * 1000 ; } catch ( NumberFormatException e ) { return defaultValue ; } return secs ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static AWS@@ CredentialsProvider get@@ Credential@@ Provider ( ) { StackTraceElement [ ] e = Thread . currentThread ( ) . getStackTrace ( ) ; for ( int i = 0 ; i < e . length ; i ++ ) { if ( e [ i ] . getClassName ( ) . equals ( DEFAULT_@@ METRIC_@@ COLLEC@@ TOR_@@ FACTORY ) ) { return credential@@ Provider ; } } SecurityException ex = new SecurityException ( ) ; LogFactory . getLog ( Aws@@ Sdk@@ Metrics . class ) . warn ( " Illegal ▁ attempt ▁ to ▁ access ▁ the ▁ credential ▁ provider " , ex ) ; throw ex ; }
 public static String [ ] getValues ( Map < String , String > map , String ... key@@ Arr ) { String [ ] obj@@ Arr = new String [ key@@ Arr . length ] ; if ( key@@ Arr . length > 0 && map != null && map . size ( ) > 0 ) { int i = 0 ; for ( String key : key@@ Arr ) { obj@@ Arr [ i ++ ] = map . get ( key ) ; } } return obj@@ Arr ; }
 @ Converter public static AD@@ T_@@ A@@ 05 to@@ Ad@@ t@@ A@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 05 . class , body ) ; }
 private static String log ( Locale l , boolean nl , String format , Object ... args ) { String msg = String . format ( l , format , args ) ; Event e = Event . make ( Sys . WATER , Kind . INFO , null , msg ) ; Log . write ( e , false , true ) ; return e . to@@ Short@@ String ( ) + NL ; }
 private static Graph@@ Hop@@ per@@ Server@@ Configuration create@@ Config ( ) { Graph@@ Hop@@ per@@ Server@@ Configuration config = new Graph@@ Hop@@ per@@ Server@@ TestConfiguration ( ) ; config . get@@ Graph@@ Hop@@ per@@ Configuration ( ) . put@@ Object ( " graph . flag _ encoders " , " car | turn _ costs = true " ) . put@@ Object ( " routing . ch . disabling _ allowed " , true ) . put@@ Object ( " prepare . min _ network _ size " , 0 ) . put@@ Object ( " data@@ reader . file " , " . . / core / files / mo@@ sco@@ w . os@@ m . gz " ) . put@@ Object ( " graph . encoded _ values " , " road _ class , surface , road _ environment , max _ speed " ) . put@@ Object ( " graph . location " , DIR ) . set@@ Profiles ( Arrays . asList ( new Profile ( " my _ car _ turn _ costs " ) . set@@ Vehicle ( " car " ) . set@@ Weight@@ ing ( " fa@@ stest " ) . set@@ Turn@@ Co@@ sts ( true ) , new Profile ( " my _ car _ no _ turn _ costs " ) . set@@ Vehicle ( " car " ) . set@@ Weight@@ ing ( " fa@@ stest " ) . set@@ Turn@@ Co@@ sts ( false ) ) ) . set@@ CH@@ Profiles ( Arrays . asList ( new CH@@ Profile ( " my _ car _ turn _ costs " ) , new CH@@ Profile ( " my _ car _ no _ turn _ costs " ) ) ) . set@@ LM@@ Profiles ( Arrays . asList ( new LM@@ Profile ( " my _ car _ no _ turn _ costs " ) , new LM@@ Profile ( " my _ car _ turn _ costs " ) . set@@ Prepar@@ ation@@ Profile ( " my _ car _ no _ turn _ costs " ) ) ) ; return config ; }
 public static void remove ( String name ) { instruction@@ Map . remove ( name ) ; }
 @ Converter public static P@@ GL_@@ PC@@ 6 to@@ P@@ gl@@ P@@ c6 ( String body ) throws HL7@@ Exception { return to@@ Message ( P@@ GL_@@ PC@@ 6 . class , body ) ; }
 public static void test@@ Server ( ) throws Exception { Rpc@@ Context context = new Rpc@@ Context ( ) ; Rpc@@ Server rpc@@ Server = new Rpc@@ Server ( context ) ; rpc@@ Server . add@@ Service ( new Hello@@ ServiceImpl ( ) ) ; rpc@@ Server . start ( ) ; }
 public static < T extends Metric@@ Collector > T get@@ Metric@@ Collector ( ) { if ( mc == null ) { if ( isDefault@@ Metrics@@ Enabled ( ) ) enable@@ Default@@ Metrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? Metric@@ Collector . NONE : mc ) ; return t ; }
 private static Field find@@ Field ( Fixture fixture , String simple@@ Name ) { List < Field > fields = getAll@@ Declared@@ Fields ( getTarget@@ Class ( fixture ) ) ; Field field = null ; Iterator var@@ 4 = fields . iterator ( ) ; while ( var@@ 4 . hasNext ( ) ) { Field possible@@ Field = ( Field ) var@@ 4 . next ( ) ; if ( simple@@ Name . equalsIgnoreCase ( possible@@ Field . getName ( ) ) ) { field = possible@@ Field ; break ; } } return field ; }
 @ NotNull public static List < Psi@@ Variable > get@@ Used@@ Variables ( @ NotNull Control@@ Flow flow , int start , int end ) { List < Psi@@ Variable > array = new ArrayList < > ( ) ; if ( start < 0 ) return array ; List < Instruction > instructions = flow . get@@ Instructions ( ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Read@@ Variable@@ Instruction ) { Psi@@ Variable variable = ( ( Read@@ Variable@@ Instruction ) instruction ) . variable ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } else if ( instruction instanceof Write@@ Variable@@ Instruction ) { Psi@@ Variable variable = ( ( Write@@ Variable@@ Instruction ) instruction ) . variable ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } } return array ; }
 @ NotNull public static DFA@@ Type create ( DFA@@ Type t1 , DFA@@ Type t2 , PsiManager manager ) { if ( t1 . equals ( t2 ) ) return t1 ; final PsiType primary = Types@@ Util . get@@ Least@@ Upper@@ Bound@@ Nullable ( t1 . primary , t2 . primary , manager ) ; final DFA@@ Type type = new DFA@@ Type ( primary ) ; final PsiType type1 = reduce ( t1 . mix@@ ins ) ; final PsiType type2 = reduce ( t2 . mix@@ ins ) ; if ( type1 != null && type2 != null ) { type . add@@ Mixin ( Generic@@ s@@ Util . get@@ Least@@ UpperBound ( type1 , type2 , manager ) , null ) ; } return type ; }
 public static void configure@@ DataStore ( Job job , Map < String , String > data@@ Store@@ Params ) { Object m = Java@@ Converters . map@@ As@@ Scal@@ a@@ Map@@ Converter ( data@@ Store@@ Params ) . as@@ Scal@@ a ( ) ; scala . collection . immutable . Map < String , String > scal@@ a@@ Params = ( ( scala . collection . mutable . Map < String , String > ) m ) . toMap ( Pre@@ def . < Tuple2 < String , String > > con@@ forms ( ) ) ; Geo@@ Me@@ sa@@ Output@@ Format@@ $ . MODULE@@ $ . configure@@ DataStore ( job , scal@@ a@@ Params ) ; }
 public static void show@@ Error ( Project project , String title , Throwable e ) { Maven@@ Log . LOG . warn ( title , e ) ; Notifications . Bus . notify ( new Notification ( MAV@@ EN_@@ NOTIFICATION_@@ GROUP , title , e . getMessage ( ) , Notification@@ Type . ERROR ) , project ) ; }
 public static JsonNode load ( String js ) { try { return mapper . read@@ Tree ( js ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
 public static byte [ ] random@@ Bytes ( int size ) { byte [ ] data = new byte [ size ] ; new Random ( ) . next@@ Bytes ( data ) ; return data ; }
 private static void validate@@ Alias@@ Filter ( XContentParser parser , Query@@ Shard@@ Context query@@ Shard@@ Context ) throws IOException { QueryBuilder parse@@ Inner@@ QueryBuilder = parse@@ Inner@@ QueryBuilder ( parser ) ; QueryBuilder queryBuilder = Rewrite@@ able . rewrite ( parse@@ Inner@@ QueryBuilder , query@@ Shard@@ Context , true ) ; queryBuilder . to@@ Filter ( query@@ Shard@@ Context ) ; }
 private static boolean are@@ Instruction@@ s@@ Reachable ( @ NotNull final Control@@ Flow flow , @ NotNull final int [ ] instruction@@ Offsets , final int startOffset ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { private boolean reachable ; @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { reachable |= ArrayUtil . indexOf ( instruction@@ Offsets , next@@ Offset ) >= 0 ; } @ Override @ NotNull public Boolean getResult ( ) { return reachable ; } } if ( startOffset != 0 && has@@ Calls ( flow ) ) { return are@@ Instruction@@ s@@ Reach@@ able@@ With@@ Calls ( flow , instruction@@ Offsets , startOffset ) ; } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , startOffset , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static Temporal@@ Query < Chronology > chron@@ ology ( ) { return Temporal@@ Queries . CHRON@@ O ; }
 private static Mapping@@ Jackson@@ 2@@ HttpMessage@@ Converter create@@ Json@@ Converter ( ) { final Mapping@@ Jackson@@ 2@@ HttpMessage@@ Converter converter = new Mapping@@ Jackson@@ 2@@ HttpMessage@@ Converter ( ) ; converter . set@@ ObjectMapper ( new ObjectMapper ( ) . find@@ And@@ Register@@ Modules ( ) . disable ( Deserializ@@ ation@@ Feature . FAIL_@@ ON_@@ UNKNOWN_@@ PROPERTIES ) ) ; return converter ; }
 public static < E > Set < E > as@@ Set ( E ... elements ) { if ( elements == null || elements . length == 0 ) { return Collections . emptySet ( ) ; } if ( elements . length == 1 ) { return Collections . singleton ( elements [ 0 ] ) ; } LinkedHashSet < E > set = new LinkedHashSet < E > ( elements . length * 4 / 3 + 1 ) ; Collections . addAll ( set , elements ) ; return set ; }
 private static void depth@@ First@@ Search ( @ NotNull Control@@ Flow flow , @ NotNull Instruction@@ Client@@ Visitor visitor , int startOffset , int endOffset ) { visitor . processed@@ Instructions = new boolean [ endOffset ] ; internal@@ Depth@@ First@@ Search ( flow . get@@ Instructions ( ) , visitor , startOffset , endOffset ) ; }
 public static String join@@ 2 ( String connector , String ... strs ) { StringBuffer s@@ Buffer = new StringBuffer ( ) ; for ( Object object : strs ) { s@@ Buffer . append ( object ) . append ( connector ) ; } if ( s@@ Buffer . length ( ) > 0 ) { s@@ Buffer . delete ( s@@ Buffer . length ( ) - connector . length ( ) , s@@ Buffer . length ( ) ) ; } return s@@ Buffer . toString ( ) ; }
 public static java . sql . Timestamp to@@ SQL@@ Timestamp ( ZonedDateTime dt ) { java . sql . Timestamp ts = ( dt == null ? null : new java . sql . Timestamp ( dt . to@@ Instant ( ) . to@@ Epoch@@ Mil@@ li ( ) ) ) ; return ts ; }
 @ Test@@ Only public static void await@@ Qu@@ i@@ esc@@ ence ( long timeout , @ NotNull TimeUnit unit ) { Con@@ currency@@ Util . await@@ Qu@@ i@@ esc@@ ence ( EXEC@@ UT@@ OR , timeout , unit ) ; }
 public static DB_@@ Inser@@ t_@@ Unified@@ Rep@@ P@@ ep@@ Iso@@ to@@ pe@@ Label@@ Lookup@@ DAO getInstance ( ) { return new DB_@@ Inser@@ t_@@ Unified@@ Rep@@ P@@ ep@@ Iso@@ to@@ pe@@ Label@@ Lookup@@ DAO ( ) ; }
 static public boolean is@@ Method@@ With@@ First@@ String ( PsiElement psiElement , String ... methodName ) { if ( ! Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . METHOD_@@ REFERENCE ) . with@@ Child ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . PARAMETER_@@ LIST ) . with@@ FirstChild ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . STRING ) ) ) . accepts ( psiElement ) ) { return false ; } String method@@ Ref@@ Name = ( ( Method@@ Reference ) psiElement ) . getName ( ) ; return null != method@@ Ref@@ Name && Arrays . asList ( methodName ) . contains ( method@@ Ref@@ Name ) ; }
 @ Converter public static R@@ Q@@ P_@@ I@@ 04 to@@ R@@ q@@ pI@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ P_@@ I@@ 04 . class , body ) ; }
 @ NotNull private static Optional < Boolean > match ( @ NotNull Py@@ ClassType expected , @ NotNull Py@@ ClassType actual , @ NotNull Match@@ Context context ) { if ( expected . equals ( actual ) ) { return Optional . of ( true ) ; } if ( expected instanceof Py@@ TupleType && actual instanceof Py@@ TupleType ) { return match ( ( Py@@ TupleType ) expected , ( Py@@ TupleType ) actual , context ) ; } final Py@@ Class superClass = expected . get@@ Py@@ Class ( ) ; final Py@@ Class sub@@ Class = actual . get@@ Py@@ Class ( ) ; final boolean match@@ Classes = match@@ Classes ( superClass , sub@@ Class , context . context ) ; if ( Py@@ Protocol@@ s@@ K@@ t . is@@ Protocol ( expected , context . context ) && ! match@@ Classes ) { if ( expected instanceof Py@@ Collection@@ Type && ! match@@ Generics ( ( Py@@ Collection@@ Type ) expected , actual , context ) ) { return Optional . of ( false ) ; } for ( k@@ ot@@ lin . Pair < Py@@ Typed@@ Element , List < R@@ ated@@ ResolveResult > > pair : inspec@@ t@@ Protocol@@ Subclass ( expected , actual , context . context ) ) { final List < R@@ ated@@ ResolveResult > subclass@@ Elements = pair . get@@ Second ( ) ; if ( ContainerUtil . isEmpty ( subclass@@ Elements ) ) { return Optional . of ( false ) ; } final Py@@ Type protocol@@ ElementType = context . context . getType ( pair . getFirst ( ) ) ; final boolean element@@ Result = Stream@@ Ex . of ( subclass@@ Elements ) . map ( ResolveResult :: getElement ) . select ( Py@@ Typed@@ Element . class ) . map ( context . context :: getType ) . any@@ Match ( subclass@@ ElementType -> match ( protocol@@ ElementType , subclass@@ ElementType , context ) . orElse ( true ) ) ; if ( ! element@@ Result ) { return Optional . of ( false ) ; } } final Py@@ Type original@@ Protocol@@ Generic@@ Type = Stream@@ Ex . of ( Extensions . get@@ Extensions ( Py@@ Type@@ Provider . EP_@@ NAME ) ) . map ( provider -> provider . getGeneric@@ Type ( superClass , context . context ) ) . find@@ First ( Objects :: non@@ Null ) . orElse ( null ) ; match ( expected , original@@ Protocol@@ Generic@@ Type , context ) ; return Optional . of ( true ) ; } if ( expected instanceof Py@@ Collection@@ Type ) { return Optional . of ( match ( ( Py@@ Collection@@ Type ) expected , actual , context ) ) ; } if ( match@@ Classes ) { if ( expected instanceof Py@@ Typ@@ ing@@ New@@ Type && ! expected . equals ( actual ) && superClass . equals ( sub@@ Class ) ) { return Optional . of ( actual . get@@ Ancestor@@ Types ( context . context ) . contains ( expected ) ) ; } return Optional . of ( true ) ; } if ( expected . equals ( actual ) ) { return Optional . of ( true ) ; } return Optional . empty ( ) ; }
 @ NotNull public static List < PsiReferenceExpression > getRead@@ Before@@ Write ( @ NotNull Control@@ Flow flow ) { return getRead@@ Before@@ Write ( flow , 0 ) ; }
 private static void Insert@@ Users ( ) throws SQLException { Map < String , User@@ Node > users = User@@ Node . getUser@@ s ( ) ; Statement s@@ mt = conn . createStatement ( ) ; for ( User@@ Node user : users . values ( ) ) { String sql = " SELECT ▁ * ▁ FROM ▁ T@@ USER ▁ WHERE ▁ name ▁ = ▁ ' " + user . getName ( ) + " ' ; " ; ResultSet rs = s@@ mt . executeQuery ( sql ) ; if ( ! rs . next ( ) ) { sql = " INSERT ▁ INTO ▁ T@@ USER ▁ ( Name ) ▁ VALUES ▁ ( ' " + user . getName ( ) + " ' ) ; " ; s@@ mt . executeUpdate ( sql ) ; } rs . close ( ) ; } s@@ mt . close ( ) ; }
 public static void print ( ) { }
 private static boolean is@@ Str@@ Unicode@@ Match ( @ NotNull Py@@ Class sub@@ Class , @ NotNull Py@@ Class superClass ) { return Py@@ Names . TYPE_@@ STR . equals ( sub@@ Class . getName ( ) ) && Py@@ Names . TYPE_@@ UNICODE . equals ( superClass . getName ( ) ) ; }
 private static List < Seq@@ Objective@@ Map > get@@ Objective@@ Maps ( Node i@@ Node ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " get@@ Objective@@ Maps " ) ; } String temp@@ Val = null ; List < Seq@@ Objective@@ Map > maps = new ArrayList < Seq@@ Objective@@ Map > ( ) ; NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " mapInfo " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < mapInfo > ▁ " + " element " ) ; } Seq@@ Objective@@ Map map = new Seq@@ Objective@@ Map ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " target@@ Objective@@ ID " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { map . m@@ Global@@ Obj@@ ID = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " read@@ S@@ atis@@ fied@@ Status " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { map . m@@ Read@@ Status = ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " read@@ Normalized@@ Measure " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { map . m@@ Read@@ Measure = ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " write@@ S@@ atis@@ fied@@ Status " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { map . m@@ Write@@ Status = ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " write@@ Normalized@@ Measure " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { map . m@@ Write@@ Measure = ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ; } } maps . add ( map ) ; } } } if ( maps . size ( ) == 0 ) { maps = null ; } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " get@@ Objective@@ Maps " ) ; } return maps ; }
 public static String getCurrent@@ Feed@@ Title ( final Context context ) { return getSub@@ scription@@ Title@@ At ( context , getCurrent@@ Feed@@ Position ( context ) ) ; }
 public static void visit@@ Namespace@@ Class@@ For@@ Completion ( PsiElement psiElement , int cursor@@ Offset , Class@@ For@@ Completion@@ Visitor visitor ) { int cursor@@ Offset@@ Clean = cursor@@ Offset - psiElement . getText@@ Offset ( ) ; if ( cursor@@ Offset@@ Clean < 1 ) { return ; } String content = psiElement . getText ( ) ; int length = content . length ( ) ; if ( ! ( length >= cursor@@ Offset@@ Clean ) ) { return ; } String before@@ Cursor = content . substring ( 0 , cursor@@ Offset@@ Clean ) ; boolean isValid ; String namespace = before@@ Cursor ; int last@@ Slash = before@@ Cursor . lastIndexOf ( " \ \@@ " ) ; if ( last@@ Slash <= 0 ) { isValid = Ph@@ p@@ Index@@ Util . has@@ Namespace ( psiElement . getProject ( ) , before@@ Cursor ) ; } else { isValid = true ; namespace = before@@ Cursor . substring ( 0 , last@@ Slash ) ; } if ( ! isValid ) { return ; } String prefix = " " ; if ( namespace . startsWith ( " \ \@@ " ) ) { prefix = " \ \@@ " ; } else { namespace = " \ \@@ " + namespace ; } for ( Ph@@ p@@ Class php@@ Class : Ph@@ p@@ Index@@ Util . get@@ Ph@@ p@@ Class@@ Inside@@ Namespace ( psiElement . getProject ( ) , namespace ) ) { String present@@ able@@ FQ@@ N = php@@ Class . get@@ Presentable@@ FQ@@ N ( ) ; if ( present@@ able@@ FQ@@ N != null && fr . ad@@ ri@@ en@@ bra@@ ult . idea . sym@@ f@@ ony@@ 2@@ plugin . util . StringUtils . start@@ With@@ Equal@@ Class@@ name ( present@@ able@@ FQ@@ N , before@@ Cursor ) ) { visitor . visit ( php@@ Class , present@@ able@@ FQ@@ N , prefix ) ; } } }
 static Tokenizer@@ Factory new@@ Factory ( String name , Supplier < Tokenizer > supplier ) { return new Tokenizer@@ Factory ( ) { @ Override public String name ( ) { return name ; } @ Override public Tokenizer create ( ) { return supplier . get ( ) ; } } ; }
 public static void main ( String [ ] args ) throws IOException { Ok@@ Http@@ Timeout@@ Example ok@@ Http@@ Timeout@@ Example = new Ok@@ Http@@ Timeout@@ Example ( ) ; ok@@ Http@@ Timeout@@ Example . run ( ) ; }
 public static void get@@ Written@@ Variables ( @ NotNull Control@@ Flow flow , int start , int end , final boolean ignore@@ Not@@ Reach@@ ing@@ Writes , @ NotNull Collection < ? super Psi@@ Variable > set ) { List < Instruction > instructions = flow . get@@ Instructions ( ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Write@@ Variable@@ Instruction && ( ! ignore@@ Not@@ Reach@@ ing@@ Writes || is@@ Instruction@@ Reachable ( flow , end , i ) ) ) { set . add ( ( ( Write@@ Variable@@ Instruction ) instruction ) . variable ) ; } } }
 public static ZonedDateTime to@@ Date@@ Mid@@ night ( java . util . Date d ) { ZonedDateTime dm = ( d == null ? null : to@@ LocalDate ( d ) . at@@ StartOf@@ Day ( par@@ is ) ) ; return dm ; }
 static String parse@@ Actual@@ Path ( Context context , String path ) throws IllegalStateException { String [ ] supported@@ Path = new String [ ] { DIR_@@ EXT_@@ ROOT , DIR_@@ EXT_@@ FILES , DIR_@@ INT_@@ FILES } ; for ( String s : supported@@ Path ) { String regex = " ^ " + s . replace ( " $ " , " \\ $ " ) . replace ( " { " , " \\ { " ) . replace ( " } " , " \\ } " ) ; Matcher matcher = Pattern . compile ( regex ) . matcher ( path ) ; if ( ! matcher . find ( ) ) { continue ; } String param = matcher . group ( ) ; String actual@@ Path = null ; switch ( param ) { case DIR_@@ EXT_@@ ROOT : File root = Environment . getExternal@@ Storage@@ Directory ( ) ; if ( ( ! Environment . MEDIA_@@ MOUN@@ TED . equals ( Environment . getExternal@@ Storage@@ State ( ) ) ) || root == null ) { throw new IllegalStateException ( " External ▁ storage ▁ is ▁ not ▁ available ! " ) ; } actual@@ Path = matcher . replace@@ First ( root . getAbsolutePath ( ) ) ; break ; case DIR_@@ EXT_@@ FILES : File file@@ sDir = context . getExternal@@ Files@@ Dir ( null ) ; if ( file@@ sDir == null ) { throw new IllegalStateException ( " External ▁ storage ▁ is ▁ not ▁ available ! " ) ; } actual@@ Path = matcher . replace@@ First ( file@@ sDir . getAbsolutePath ( ) ) ; break ; case DIR_@@ INT_@@ FILES : actual@@ Path = matcher . replace@@ First ( context . getFile@@ sDir ( ) . getAbsolutePath ( ) ) ; break ; } return actual@@ Path ; } return path ; }
 public static Serializer@@ Registration get@@ Serializer@@ Registration ( Class cls ) { return get@@ Serializer@@ Registration ( cls , strict@@ Registration ) ; }
 public static final Parcelable . Creator < Category > CRE@@ ATOR = new Parcelable . Creator < Category > ( ) { public Category createFrom@@ Parcel ( Parcel in ) { return new Category ( in ) ; } public Category [ ] newArray ( int size ) { return new Category [ size ] ; } }
 @ Converter public static SI@@ U@@ _S@@ 16 to@@ Si@@ u@@ S@@ 16 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 16 . class , body ) ; }
 @ NotNull static public Collection < String > getArray@@ Creation@@ Keys ( @ NotNull Array@@ Creation@@ Expression array@@ Creation@@ Expression ) { return getArray@@ Creation@@ KeyMap ( array@@ Creation@@ Expression ) . keySet ( ) ; }
 @ NotNull public static File resolve@@ User@@ Settings@@ File ( @ Nullable String overri@@ dden@@ User@@ Settings@@ File ) { if ( ! isEmpty@@ Or@@ Spaces ( overri@@ dden@@ User@@ Settings@@ File ) ) return new File ( overri@@ dden@@ User@@ Settings@@ File ) ; return new File ( resolve@@ M2@@ Dir ( ) , SETTINGS_@@ XML ) ; }
 @ Converter public static MD@@ M_@@ T@@ 02 to@@ M@@ dm@@ T@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 02 . class , body ) ; }
 public static Connection@@ Config new@@ Connection@@ Config ( final Abstract@@ Ldap@@ Properties l ) { final var cc = new Connection@@ Config ( ) ; final var urls = Arrays . stream ( l . getL@@ d@@ ap@@ Url ( ) . split ( " , " ) ) . collect ( Collectors . joining ( " ▁ " ) ) ; LOGGER . debug ( " Transform@@ ed ▁ LDAP ▁ urls ▁ from ▁ [ { } ] ▁ to ▁ [ { } ] " , l . getL@@ d@@ ap@@ Url ( ) , urls ) ; cc . set@@ Ldap@@ Url ( urls ) ; cc . setUse@@ Start@@ TLS ( l . isUse@@ Start@@ T@@ ls ( ) ) ; cc . set@@ Connect@@ Timeout ( new@@ Duration ( l . get@@ Connect@@ Timeout ( ) ) ) ; if ( l . get@@ Trust@@ Certificates ( ) != null ) { final var cfg = new X509@@ Credential@@ Config ( ) ; cfg . set@@ Trust@@ Certificates ( l . get@@ Trust@@ Certificates ( ) ) ; cc . set@@ Ssl@@ Config ( new Ssl@@ Config ( cfg ) ) ; } else if ( l . getKey@@ store ( ) != null ) { final var cfg = new KeyStore@@ Credential@@ Config ( ) ; cfg . set@@ KeyStore ( l . getKey@@ store ( ) ) ; cfg . setKey@@ Store@@ Password ( l . getKey@@ store@@ Password ( ) ) ; cfg . setKey@@ Store@@ Type ( l . getKey@@ store@@ Type ( ) ) ; cc . set@@ Ssl@@ Config ( new Ssl@@ Config ( cfg ) ) ; } else { cc . set@@ Ssl@@ Config ( new Ssl@@ Config ( ) ) ; } if ( l . getS@@ asl@@ Mechanis@@ m ( ) != null ) { final var bc = new Bind@@ Connection@@ Initializer ( ) ; final Sasl@@ Config sc ; switch ( l . getS@@ asl@@ Mechanis@@ m ( ) ) { case DIGE@@ ST_@@ MD5 : sc = Sasl@@ Config . builder ( ) . mechanism ( Mechanis@@ m . DIGE@@ ST_@@ MD5 ) . realm ( l . getS@@ asl@@ Realm ( ) ) . build ( ) ; break ; case CR@@ AM_@@ MD5 : sc = Sasl@@ Config . builder ( ) . mechanism ( Mechanis@@ m . CR@@ AM_@@ MD5 ) . build ( ) ; break ; case EXTERNAL : sc = Sasl@@ Config . builder ( ) . mechanism ( Mechanis@@ m . EXTERNAL ) . build ( ) ; break ; case GSS@@ API : sc = Sasl@@ Config . builder ( ) . mechanism ( Mechanis@@ m . GSS@@ API ) . realm ( l . getS@@ asl@@ Realm ( ) ) . build ( ) ; break ; default : throw new IllegalArgumentException ( " Unknown ▁ SASL ▁ mechanism ▁ " + l . getS@@ asl@@ Mechanis@@ m ( ) . name ( ) ) ; } sc . set@@ Authorization@@ Id ( l . getS@@ asl@@ Authorization@@ Id ( ) ) ; sc . set@@ Mut@@ ual@@ Authentication ( l . getS@@ asl@@ Mut@@ ual@@ Auth ( ) ) ; sc . set@@ Quality@@ Of@@ Protection ( l . getS@@ asl@@ Quality@@ Of@@ Protection ( ) ) ; sc . set@@ Security@@ Strength ( l . getS@@ asl@@ Security@@ Strength ( ) ) ; bc . set@@ Bind@@ Sasl@@ Config ( sc ) ; cc . set@@ Connection@@ Initializ@@ ers ( bc ) ; } else if ( Common@@ Helper . are@@ Equals ( l . get@@ Bind@@ Credential ( ) , " * " ) && Common@@ Helper . are@@ Equals ( l . get@@ Bind@@ Dn ( ) , " * " ) ) { cc . set@@ Connection@@ Initializ@@ ers ( new Fast@@ Bind@@ Connection@@ Initializer ( ) ) ; } else if ( Common@@ Helper . isNotBlank ( l . get@@ Bind@@ Dn ( ) ) && Common@@ Helper . isNotBlank ( l . get@@ Bind@@ Credential ( ) ) ) { cc . set@@ Connection@@ Initializ@@ ers ( new Bind@@ Connection@@ Initializer ( l . get@@ Bind@@ Dn ( ) , new Credential ( l . get@@ Bind@@ Credential ( ) ) ) ) ; } return cc ; }
 public static String get@@ Asset@@ sPath ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ ASSE@@ TS_@@ PATH , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . WEB_@@ ASSE@@ TS_@@ PATH , Web@@ Config@@ Default . WEB_@@ ASSE@@ TS_@@ PATH ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static boolean preview ( String text ) throws Vide@@ vox@@ Exception { String cmd = " echo ▁ \@@ " " + text + " \@@ " ▁ | ▁ fe@@ sti@@ val ▁ - - tt@@ s " ; logger . debug ( " command ▁ is : ▁ " + cmd ) ; Process@@ Builder builder = new Process@@ Builder ( " / bin / bash " , " - c " , cmd ) ; try { builder . start ( ) . waitFor ( ) ; } catch ( IOException | InterruptedException e ) { throw new Vide@@ vox@@ Exception ( " Text ▁ to ▁ speech ▁ preview ▁ is ▁ not ▁ working ▁ at ▁ the ▁ moment " ) ; } return true ; }
 public static String getTask@@ Prefix ( String task@@ Name ) { return task@@ Name + " - " ; }
 public static Segment@@ Prun@@ er getSegment@@ Prun@@ er ( String prun@@ er@@ ClassName , Configuration segment@@ Prun@@ er@@ Config ) { try { Class < ? extends Segment@@ Prun@@ er > cls = PR@@ U@@ NER_@@ MAP . get ( prun@@ er@@ ClassName . toLowerCase ( ) ) ; if ( cls != null ) { Segment@@ Prun@@ er segment@@ Prun@@ er = cls . newInstance ( ) ; segment@@ Prun@@ er . init ( segment@@ Prun@@ er@@ Config ) ; return segment@@ Prun@@ er ; } } catch ( Exception ex ) { throw new RuntimeException ( " Not ▁ support ▁ Segment@@ Prun@@ er ▁ type ▁ with ▁ - ▁ " + prun@@ er@@ ClassName , ex ) ; } throw new UnsupportedOperationException ( " No ▁ Segment@@ Prun@@ er ▁ type ▁ with ▁ - ▁ " + prun@@ er@@ ClassName ) ; }
 public static void show@@ Warning ( Activity activity , String message ) { Simple@@ Toast . warning ( activity , message ) ; }
 private static boolean match ( @ NotNull Py@@ Struc@@ tur@@ alType expected , @ NotNull Py@@ Type actual , @ NotNull Type@@ Eval@@ Context context ) { if ( actual instanceof Py@@ Struc@@ tur@@ alType ) { return match ( expected , ( Py@@ Struc@@ tur@@ alType ) actual ) ; } if ( actual instanceof Py@@ ClassType ) { return match ( expected , ( Py@@ ClassType ) actual , context ) ; } if ( actual instanceof Py@@ ModuleType ) { final Py@@ File module = ( ( Py@@ ModuleType ) actual ) . getModule ( ) ; if ( module . get@@ LanguageLevel ( ) . is@@ At@@ Least ( LanguageLevel . PYTHON@@ 37 ) && defin@@ es@@ Get@@ Attr ( module , context ) ) { return true ; } } final Py@@ Resolve@@ Context resolve@@ Context = Py@@ Resolve@@ Context . no@@ Imp@@ lic@@ its ( ) . with@@ Type@@ Eval@@ Context ( context ) ; return Stream@@ Ex . of ( expected . getAttribute@@ Names ( ) ) . none@@ Match ( attribute -> ContainerUtil . isEmpty ( actual . resolve@@ Member ( attribute , null , Access@@ Direction . READ , resolve@@ Context ) ) ) ; }
 public static void init ( Context context ) { if ( camera@@ Manager == null ) { camera@@ Manager = new Camera@@ Manager ( context ) ; } }
 public static Pooled@@ ConnectionFactory new@@ Pooled@@ ConnectionFactory ( final Abstract@@ Ldap@@ Properties l ) { final var cc = new@@ Connection@@ Config ( l ) ; final var cf = new Pooled@@ ConnectionFactory ( cc ) ; cf . setBlock@@ WaitTime ( new@@ Duration ( l . getBlock@@ WaitTime ( ) ) ) ; cf . setMin@@ PoolSize ( l . getMin@@ PoolSize ( ) ) ; cf . setMax@@ PoolSize ( l . getMax@@ PoolSize ( ) ) ; cf . set@@ Validate@@ On@@ Check@@ Out ( l . is@@ Validate@@ On@@ Check@@ out ( ) ) ; cf . set@@ Validate@@ Perio@@ di@@ cally ( l . is@@ Validate@@ Perio@@ di@@ cally ( ) ) ; final var strategy = new Idle@@ Prun@@ e@@ Strategy ( ) ; strategy . set@@ Idle@@ Time ( new@@ Duration ( l . get@@ Idle@@ Time ( ) ) ) ; strategy . set@@ Prun@@ e@@ Period ( new@@ Duration ( l . getP@@ run@@ e@@ Period ( ) ) ) ; cf . set@@ Prun@@ e@@ Strategy ( strategy ) ; cf . set@@ Fail@@ Fast@@ Initialize ( l . is@@ Fail@@ Fast ( ) ) ; final var validator = new Search@@ Connection@@ Validator ( ) ; validator . set@@ Validate@@ Period ( new@@ Duration ( l . get@@ Validate@@ Period ( ) ) ) ; cf . set@@ Validator ( validator ) ; if ( Common@@ Helper . isNotBlank ( l . get@@ Pool@@ P@@ assi@@ v@@ ator ( ) ) ) { final var pass = Abstract@@ Ldap@@ Properties . Ldap@@ Connection@@ Pool@@ P@@ assi@@ v@@ ator . valueOf ( l . get@@ Pool@@ P@@ assi@@ v@@ ator ( ) . toUpperCase ( ) ) ; switch ( pass ) { case CLOSE : cf . set@@ P@@ assi@@ v@@ ator ( conn -> { conn . close ( ) ; return true ; } ) ; break ; case BIND : LOGGER . debug ( " Creating ▁ a ▁ bind ▁ pas@@ si@@ v@@ ator ▁ instance ▁ for ▁ the ▁ connection ▁ pool " ) ; final var bind@@ Request = new Simple@@ Bind@@ Request ( l . get@@ Bind@@ Dn ( ) , new Credential ( l . get@@ Bind@@ Credential ( ) ) ) ; cf . set@@ P@@ assi@@ v@@ ator ( new Bind@@ Connection@@ P@@ assi@@ v@@ ator ( bind@@ Request ) ) ; break ; default : break ; } } LOGGER . debug ( " Initializing ▁ ldap ▁ connection ▁ pool ▁ for ▁ { } ▁ and ▁ bind@@ Dn ▁ { } " , l . getL@@ d@@ ap@@ Url ( ) , l . get@@ Bind@@ Dn ( ) ) ; cf . initialize ( ) ; return cf ; }
 public static final Mac getInstance ( String algorithm , Provider provider ) throws NoSuchAlgorithmException { Instance instance = J@@ ce@@ Security . getInstance ( " Mac " , Mac@@ Spi . class , algorithm , provider ) ; return new Mac ( ( Mac@@ Spi ) instance . impl , instance . provider , algorithm ) ; }
 @ Nullable public static File resolve@@ Global@@ Settings@@ File ( @ Nullable String overri@@ dden@@ Maven@@ Home ) { File directory = resolve@@ Maven@@ Home@@ Directory ( overri@@ dden@@ Maven@@ Home ) ; if ( directory == null ) return null ; return new File ( new File ( directory , CONF_@@ DIR ) , SETTINGS_@@ XML ) ; }
 public static boolean is@@ Per@@ Host@@ Metric@@ Enabled ( ) { if ( per@@ Host@@ Metrics@@ Included ) return true ; String host = host@@ Metric@@ Name ; host = host == null ? " " : host . trim ( ) ; return host . length ( ) > 0 ; }
 public static void main ( String args [ ] ) { Show@@ Len@@ s@@ Di@@ stor@@ tion < Image@@ UInt8 > app = new Show@@ Len@@ s@@ Di@@ stor@@ tion < Image@@ UInt8 > ( Image@@ UInt8 . class ) ; List < Path@@ Label > inputs = new ArrayList < Path@@ Label > ( ) ; inputs . add ( new Path@@ Label ( " shapes " , " . . / data / evaluation / shap@@ es@@ 01 . png " ) ) ; inputs . add ( new Path@@ Label ( " be@@ ach " , " . . / data / evaluation / scale / be@@ ach@@ 02 . jpg " ) ) ; inputs . add ( new Path@@ Label ( " sun@@ flow@@ ers " , " . . / data / evaluation / sun@@ flow@@ ers . png " ) ) ; app . setInput@@ List ( inputs ) ; while ( ! app . get@@ Has@@ Processed@@ Image ( ) ) { Thread . yield ( ) ; } Show@@ Images . show@@ Window ( app , " L@@ ens ▁ Di@@ stor@@ tion " ) ; }
 @ Nullable private static PsiElement getL@@ atest@@ Write@@ Var@@ Expression ( @ Nullable CopyOnWrite@@ List write@@ Vars , @ NotNull Psi@@ Variable variable ) { if ( write@@ Vars == null ) return null ; for ( final Variable@@ Info variable@@ Info : write@@ Vars . getList ( ) ) { if ( variable@@ Info . variable == variable ) { return variable@@ Info . expression ; } } return null ; }
 public static int size ( Map m ) { return m != null ? m . size ( ) : 0 ; }
 public static void add@@ Id ( Flat@@ Buffer@@ Builder builder , int id@@ Offset ) { builder . add@@ Offset ( 0 , id@@ Offset , 0 ) ; }
 @ Converter public static OR@@ N_@@ O@@ 02 to@@ Or@@ n@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ N_@@ O@@ 02 . class , body ) ; }
 public static Regions getRegion ( ) throws IllegalArgumentException { return Regions . from@@ Name ( region . getName ( ) ) ; }
 public static void show@@ Success ( Activity activity , String message ) { Simple@@ Toast . ok ( activity , message ) ; }
 public static void addSub@@ scriptions ( final Context context , final List out@@ lines ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; for ( final Object outline : out@@ lines ) { if ( outline instanceof Outline ) { final String text = ( ( Outline ) outline ) . getText ( ) ; final String xml@@ Url = ( ( Outline ) outline ) . get@@ Xml@@ Url ( ) ; final String category = context . getString ( R . string . unc@@ ateg@@ oriz@@ ed ) ; if ( ! TextUtils . isEmpty ( xml@@ Url ) && ! TextUtils . isEmpty ( text ) && ! subscriptions . containsKey ( text ) ) { subscriptions . putAll ( text . trim ( ) , Arrays . asList ( category , " " , xml@@ Url ) ) ; } } else { for ( final Outline sub@@ Outline : ( ( Outline@@ Group ) outline ) . getOut@@ lines ( ) ) { final String text = sub@@ Outline . getText ( ) ; final String xml@@ Url = sub@@ Outline . get@@ Xml@@ Url ( ) ; final String category = ( ( Outline@@ Group ) outline ) . getText ( ) ; if ( ! TextUtils . isEmpty ( xml@@ Url ) && ! TextUtils . isEmpty ( text ) && ! subscriptions . containsKey ( text ) ) { subscriptions . putAll ( text . trim ( ) , Arrays . asList ( category , " " , xml@@ Url ) ) ; } } } } final String current@@ Title = getCurrent@@ Feed@@ Title ( context ) ; save@@ Sub@@ scriptions ( context , subscriptions ) ; update@@ Current@@ Feed@@ Position ( context , current@@ Title ) ; }
 public static boolean unregister@@ Metric@@ Admin@@ MBean ( ) { Sdk@@ MBean@@ Registry registry = Sdk@@ MBean@@ Registry . Factory . get@@ MBean@@ Registry ( ) ; synchronized ( Aws@@ Sdk@@ Metrics . class ) { if ( registered@@ Admin@@ M@@ bean@@ Name == null ) return true ; boolean success = registry . unregister@@ MBean ( registered@@ Admin@@ M@@ bean@@ Name ) ; if ( success ) registered@@ Admin@@ M@@ bean@@ Name = null ; return success ; } }
 private static void validate@@ Sql@@ Elastic@@ Pool ( Sql@@ Elastic@@ Pool sql@@ Elastic@@ Pool ) { validate@@ Sql@@ Elastic@@ Pool ( sql@@ Elastic@@ Pool , SQL_@@ E@@ LAST@@ IC_@@ POOL_@@ NAME ) ; }
 public static Project@@ Mode getProject@@ Mode ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . PROJECT_@@ MODE , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get@@ EnumValue ( Web@@ Config@@ Key . PROJECT_@@ MODE , Web@@ Config@@ Default . PROJECT_@@ MODE , true ) ; } } ) ; return ( Project@@ Mode ) cached@@ Config ; }
 @ Converter public static V@@ Q@@ Q_@@ Q@@ 01 to@@ V@@ qq@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( V@@ Q@@ Q_@@ Q@@ 01 . class , body ) ; }
 public static void set@@ Repo ( Repo new@@ Repo ) { repo = new@@ Repo ; }
 @ Nullable public static VirtualFile get@@ Py@@ Env@@ Default@@ Locations ( ) { final String path = System . getenv ( ) . get ( " PY@@ ENV _ ROOT " ) ; if ( ! StringUtil . isEmpty ( path ) ) { final VirtualFile py@@ Env@@ Root = LocalFileSystem . getInstance ( ) . find@@ File@@ ByPath ( FileUtil . expand@@ User@@ Home ( path ) . replace ( ' \ \@@ ' , ' / ' ) ) ; if ( py@@ Env@@ Root != null ) { return py@@ Env@@ Root . find@@ File@@ By@@ RelativePath ( " versions " ) ; } } final VirtualFile user@@ Home = LocalFileSystem . getInstance ( ) . find@@ File@@ ByPath ( SystemProperties . getUser@@ Home ( ) . replace ( ' \ \@@ ' , ' / ' ) ) ; if ( user@@ Home != null ) { return user@@ Home . find@@ File@@ By@@ RelativePath ( " . py@@ env / versions " ) ; } return null ; }
 public static boolean [ ] getVariable@@ Possi@@ b@@ ly@@ Un@@ assigned@@ Offsets ( @ NotNull Psi@@ Variable variable , @ NotNull Control@@ Flow flow ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < boolean [ ] > { private final boolean [ ] maybe@@ Un@@ assigned = new boolean [ flow . getSize ( ) + 1 ] ; { maybe@@ Un@@ assigned [ maybe@@ Un@@ assigned . length - 1 ] = true ; } @ Override public void visit@@ Write@@ Variable@@ Instruction ( Write@@ Variable@@ Instruction instruction , int offset , int next@@ Offset ) { if ( instruction . variable == variable ) { maybe@@ Un@@ assigned [ offset ] = false ; } else { visit@@ Instruction ( instruction , offset , next@@ Offset ) ; } } @ Override public void visit@@ Conditional@@ Throw@@ To@@ Instruction ( Conditional@@ Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean unassigned = offset == flow . getSize ( ) - 1 || ! is@@ Leaf ( next@@ Offset ) && maybe@@ Un@@ assigned [ next@@ Offset ] ; maybe@@ Un@@ assigned [ offset ] |= unassigned ; } @ Override public void visit@@ Call@@ Instruction ( Call@@ Instruction instruction , int offset , int next@@ Offset ) { visit@@ Instruction ( instruction , offset , next@@ Offset ) ; for ( int i = instruction . proc@@ Begin ; i < instruction . proc@@ End + 3 ; i ++ ) { maybe@@ Un@@ assigned [ i ] = false ; } } @ Override public void visit@@ GoTo@@ Instruction ( GoTo@@ Instruction instruction , int offset , int next@@ Offset ) { if ( instruction . is@@ Return && variable instanceof Psi@@ Local@@ Variable ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean unassigned = ! is@@ Leaf ( next@@ Offset ) && maybe@@ Un@@ assigned [ next@@ Offset ] ; maybe@@ Un@@ assigned [ offset ] |= unassigned ; } else { super . visit@@ GoTo@@ Instruction ( instruction , offset , next@@ Offset ) ; } } @ Override public void visit@@ Throw@@ To@@ Instruction ( Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean unassigned = ! is@@ Leaf ( next@@ Offset ) && maybe@@ Un@@ assigned [ next@@ Offset ] ; maybe@@ Un@@ assigned [ offset ] |= unassigned ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean unassigned = is@@ Leaf ( next@@ Offset ) || maybe@@ Un@@ assigned [ next@@ Offset ] ; maybe@@ Un@@ assigned [ offset ] |= unassigned ; } @ Override @ NotNull public boolean [ ] getResult ( ) { return maybe@@ Un@@ assigned ; } } if ( flow . getSize ( ) == 0 ) return new boolean [ ] { true } ; My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( ) ; }
 private static boolean IsValid@@ Address ( String i@@ P@@ address ) { InetAddress address = null ; try { address = InetAddress . getByName ( i@@ P@@ address ) ; } catch ( UnknownHostException e ) { return false ; } return true ; }
 public static void pause ( long timeout , @ Nonnull TimeUnit unit ) { checkNotNull ( unit ) ; pause ( unit . toMillis ( timeout ) ) ; }
 public static boolean getAuto@@ Sync ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getBoolean ( " enable@@ Sync@@ Pref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 @ AfterClass public static void after@@ All ( ) { server@@ Binding . unbind ( ) . then@@ Accept ( u -> system . terminate ( ) ) ; }
 public static boolean is@@ Unknown ( @ Nullable Py@@ Type type , boolean generic@@ sAre@@ Unknown , @ NotNull Type@@ Eval@@ Context context ) { if ( type == null || ( generic@@ sAre@@ Unknown && type instanceof Py@@ Generic@@ Type ) ) { return true ; } if ( type instanceof Py@@ FunctionType ) { final Py@@ Callable callable = ( ( Py@@ FunctionType ) type ) . get@@ Callable ( ) ; if ( callable instanceof Py@@ Decor@@ atable && Py@@ Known@@ Decorator@@ Util . has@@ Unknown@@ Or@@ Ch@@ ang@@ ing@@ Return@@ Type@@ Decorator ( ( Py@@ Decor@@ atable ) callable , context ) ) { return true ; } } if ( type instanceof Py@@ Union@@ Type ) { final Py@@ Union@@ Type union = ( Py@@ Union@@ Type ) type ; for ( Py@@ Type t : union . get@@ Members ( ) ) { if ( is@@ Unknown ( t , generic@@ sAre@@ Unknown , context ) ) { return true ; } } } return false ; }
 public static ArrayList < String > like@@ Start ( List < String > list , String like ) { if ( like == null || list == null ) return null ; ArrayList < String > like@@ List = new ArrayList < > ( ) ; if ( like . length ( ) == 0 ) { like@@ List . addAll ( list ) ; return like@@ List ; } String aux ; for ( String s : list ) { aux = s ; if ( s . length ( ) >= like . length ( ) ) { s = s . substring ( 0 , like . length ( ) ) ; if ( s . toUpperCase ( ) . contains ( like . toUpperCase ( ) ) ) { like@@ List . add ( aux ) ; } } } return like@@ List ; }
 public static Vector@@ 4b create ( ) { return new Vector@@ 4b ( ) ; }
 private static boolean match@@ Class@@ Object@@ And@@ Met@@ aclass ( @ NotNull Py@@ Type expected , @ NotNull Py@@ Class@@ Like@@ Type actual , @ NotNull Match@@ Context context ) { if ( ! actual . is@@ Definition ( ) ) { return false ; } final Py@@ Class@@ Like@@ Type meta@@ Class = actual . getMeta@@ ClassType ( context . context , true ) ; return meta@@ Class != null && match ( expected , meta@@ Class , context ) . orElse ( true ) ; }
 public static Temporal@@ Query < LocalTime > local@@ Time ( ) { return Temporal@@ Queries . LOCAL_@@ TIME ; }
 protected static < T > void store ( Global@@ Property < T > p ) { try { String k = p . getName ( ) ; T v = p . getValue ( ) ; String s ; if ( v == null ) { s = null ; } else { StringConverter < T > c = p . get@@ Converter ( ) ; s = c . toString ( v ) ; } Global@@ Settings . setString ( k , s ) ; } catch ( Exception e ) { Log . ex ( e ) ; } }
 private static boolean match ( @ NotNull Py@@ Struc@@ tur@@ alType expected , @ NotNull Py@@ ClassType actual , @ NotNull Type@@ Eval@@ Context context ) { if ( overri@@ des@@ Get@@ Attr ( actual . get@@ Py@@ Class ( ) , context ) ) { return true ; } final Set < String > actual@@ Attributes = actual . getMember@@ Names ( true , context ) ; return actual@@ Attributes . containsAll ( expected . getAttribute@@ Names ( ) ) ; }
 @ Converter public static RR@@ E_@@ O@@ 01 to@@ R@@ re@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( RR@@ E_@@ O@@ 01 . class , body ) ; }
 static public PsiElement@@ Pattern . Capture < StringLiteral@@ Expression > method@@ With@@ First@@ String@@ Pattern ( ) { return Platform@@ Patterns . psiElement ( StringLiteral@@ Expression . class ) . with@@ Parent ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . PARAMETER_@@ LIST ) . with@@ FirstChild ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . STRING ) ) . with@@ Parent ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . METHOD_@@ REFERENCE ) ) ) . with@@ Language ( Ph@@ p@@ Language . INSTANCE ) ; }
 @ Converter public static VX@@ Q_@@ V@@ 01 to@@ V@@ x@@ q@@ V@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( VX@@ Q_@@ V@@ 01 . class , body ) ; }
 public static boolean is@@ Jsp@@ Implicit ( PsiElement element ) { return Boolean . TRUE . equals ( element . getUser@@ Data ( IS_@@ J@@ SP_@@ IMPLIC@@ IT ) ) ; }
 public static Entry@@ Resolver new@@ Search@@ Entry@@ Resolver ( final Ldap@@ Authentication@@ Properties l ) { final var entry@@ Resolver = new Search@@ Entry@@ Resolver ( ) ; entry@@ Resolver . setBase@@ Dn ( l . getBase@@ Dn ( ) ) ; entry@@ Resolver . setUser@@ Filter ( l . getUser@@ Filter ( ) ) ; entry@@ Resolver . setSub@@ tree@@ Search ( l . isSub@@ tree@@ Search ( ) ) ; entry@@ Resolver . set@@ ConnectionFactory ( Ldap@@ tive@@ Authenticator@@ Builder . new@@ Pooled@@ ConnectionFactory ( l ) ) ; return entry@@ Resolver ; }
 public static void show@@ Mu@@ ted ( Activity activity , int message ) { Simple@@ Toast . muted ( activity , activity . getResources ( ) . getString ( message ) ) ; }
 private static Map < String , String > load ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; InputStream in = null ; try { in = Country@@ Code . class . getResourceAsStream ( " country@@ code . txt " ) ; if ( in == null ) return map ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { String name = line . substring ( 0 , 48 ) . trim ( ) ; String [ ] cd = StringUtil . tokenizer ( line . substring ( 48 ) , " ▁ \t " ) ; map . put ( cd [ 0 ] , name ) ; line = reader . readLine ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { FileUtil . close ( in ) ; } return map ; }
 public static boolean isReadOnly ( ) { return locked ; }
 public static float [ ] read@@ Temperature@@ Values ( byte [ ] bytes ) { List < Byte > b@@ List = new ArrayList ( ) ; int i = 0 ; while ( i < bytes . length ) { if ( i % 2 == 0 && ( bytes [ i ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) != 250 ) { b@@ List . add ( Byte . valueOf ( bytes [ i ] ) ) ; } i ++ ; } float [ ] b@@ Array = new float [ b@@ List . size ( ) ] ; for ( int x = 0 ; x < b@@ List . size ( ) ; x ++ ) { b@@ Array [ x ] = ( ( float ) ( ( ( Byte ) b@@ List . get ( x ) ) . byteValue ( ) & Motion@@ Event@@ Compat . ACTION_@@ MASK ) ) / 4.0f ; } return b@@ Array ; }
 static public boolean is@@ Method@@ With@@ First@@ String@@ Or@@ Field@@ Reference ( PsiElement psiElement , String ... methodName ) { if ( ! Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . METHOD_@@ REFERENCE ) . with@@ Child ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . PARAMETER_@@ LIST ) . with@@ FirstChild ( Platform@@ Patterns . or ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . STRING ) , Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . FIELD_@@ REFERENCE ) , Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . class_@@ CONSTANT_@@ REFERENCE ) ) ) ) . accepts ( psiElement ) ) { return false ; } String method@@ Ref@@ Name = ( ( Method@@ Reference ) psiElement ) . getName ( ) ; return null != method@@ Ref@@ Name && Arrays . asList ( methodName ) . contains ( method@@ Ref@@ Name ) ; }
 private static void process@@ Goto@@ Statement ( @ NotNull Collection < ? super Psi@@ Statement > exit@@ Statements , Psi@@ Statement statement , @ NotNull Class ... classes@@ Filter ) { if ( statement != null && isElement@@ Of@@ Class ( statement , classes@@ Filter ) ) { exit@@ Statements . add ( statement ) ; } }
 private static TreeMap < Key , Value > create@@ InputData ( ) { TreeMap < Key , Value > data = new TreeMap < > ( ) ; data . put ( new Key ( "1" , " a " , " a " , 1 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " a " , 5 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " a " , 10 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " b " , 1 ) , new Value ( bytes ( "5" ) ) ) ; data . put ( new Key ( "1" , " a " , " b " , 5 ) , new Value ( bytes ( "2" ) ) ) ; data . put ( new Key ( "1" , " a " , " f " , 1 ) , new Value ( bytes ( "0" ) ) ) ; data . put ( new Key ( "1" , " a " , " g " , 5 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " g " , 10 ) , new Value ( bytes ( " - 11" ) ) ) ; data . put ( new Key ( "1" , " b " , " d " , 10 ) , new Value ( bytes ( " - 5" ) ) ) ; data . put ( new Key ( "1" , " b " , " e " , 10 ) , new Value ( bytes ( Long . toString ( Long . MAX_VALUE ) ) ) ) ; data . put ( new Key ( "1" , " d " , " d " , 10 ) , new Value ( bytes ( Long . toString ( Long . MIN_VALUE ) ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 1 ) , new Value ( bytes ( "5" ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 5 ) , new Value ( bytes ( "10" ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 10 ) , new Value ( bytes ( "@@ 15" ) ) ) ; return data ; }
 public static int getUserId ( String name ) { name = name . replaceAll ( " ' " , " ' ' " ) ; try { Statement s@@ mt = conn . createStatement ( ) ; String sql = " SELECT ▁ * ▁ FROM ▁ T@@ USER ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ; ResultSet rs = s@@ mt . executeQuery ( sql ) ; if ( ! rs . next ( ) ) { sql = " INSERT ▁ INTO ▁ T@@ USER ▁ ( Name ) ▁ VALUES ▁ ( ' " + name + " ' ) ; " ; s@@ mt . executeUpdate ( sql ) ; } else { return rs . getInt ( " id " ) ; } sql = " SELECT ▁ * ▁ FROM ▁ T@@ USER ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ; rs = s@@ mt . executeQuery ( sql ) ; if ( rs . next ( ) ) return rs . getInt ( " id " ) ; s@@ mt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return - 1 ; }
 private static String detai@@ led@@ Error ( String httpMethod , String path , @ Nullable String request , String response , int http@@ Code ) { StringBuilder sb = new StringBuilder ( " GitHub ▁ API ▁ call ▁ failed ▁ with ▁ code ▁ " ) . append ( http@@ Code ) . append ( " ▁ The ▁ request ▁ was ▁ " ) . append ( httpMethod ) . append ( ' ▁ ' ) . append ( path ) . append ( ' \n ' ) ; if ( request != null ) { sb . append ( " Request ▁ object : \n " ) . append ( request ) . append ( " \n " ) ; } sb . append ( " Response : \n " ) . append ( response ) . append ( " \n " ) ; return sb . toString ( ) ; }
 public static Camera@@ Manager get ( ) { return camera@@ Manager ; }
 public static void POST ( int n , Exception e ) { if ( e . getMessage ( ) != null ) { POST ( n , e . getMessage ( ) ) ; } POST ( n , e . toString ( ) ) ; StackTraceElement [ ] els = e . getStackTrace ( ) ; for ( int i = 0 ; i < els . length ; i ++ ) { POST ( n , els [ i ] . toString ( ) ) ; } }
 public static ZonedDateTime to@@ DateTime ( java . util . Date d , String time@@ Zone@@ ID ) { ZonedDateTime dt = ( d == null ? null : ZonedDateTime . of@@ Instant ( d . to@@ Instant ( ) , ZoneId . of ( time@@ Zone@@ ID ) ) ) ; return dt ; }
 public static boolean verify@@ Permissions ( int [ ] grant@@ Results ) { if ( grant@@ Results . length < 1 ) { return false ; } for ( int result : grant@@ Results ) { if ( result != PackageManager . PERMISSION_@@ GRAN@@ TED ) { return false ; } } return true ; }
 public static Builder newBuilder ( com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . common . protobuf . Register@@ Bulk@@ Key@@ Noti@@ f@@ Response@@ Protocol . Register@@ Bulk@@ Key@@ Noti@@ f@@ Response prototype ) { return newBuilder ( ) . mergeFrom ( prototype ) ; }
 @ Converter public static AD@@ T_@@ A@@ 41 to@@ Ad@@ t@@ A@@ 41 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 41 . class , body ) ; }
 public final static int final@@ Add ( int i , int j ) { return i + j ; }
 public static ZonedDateTime to@@ Date@@ Mid@@ night ( java . sql . Date d , String time@@ Zone@@ ID ) { ZonedDateTime dm = ( d == null ? null : d . to@@ LocalDate ( ) . at@@ StartOf@@ Day ( ZoneId . of ( time@@ Zone@@ ID ) ) ) ; return dm ; }
 @ Converter public static PTR_@@ PC@@ F to@@ Ptr@@ P@@ cf ( String body ) throws HL7@@ Exception { return to@@ Message ( PTR_@@ PC@@ F . class , body ) ; }
 @ NotNull public static List < ControlFlow@@ Edge > get@@ Edges ( @ NotNull Control@@ Flow flow , int start ) { final List < ControlFlow@@ Edge > list = new ArrayList < > ( ) ; depth@@ First@@ Search ( flow , new Instruction@@ Client@@ Visitor < Void > ( ) { @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { list . add ( new ControlFlow@@ Edge ( offset , next@@ Offset ) ) ; } @ Override public Void getResult ( ) { return null ; } } , start , flow . getSize ( ) ) ; return list ; }
 public static boolean match ( @ Nullable Py@@ Type expected , @ Nullable Py@@ Type actual , @ NotNull Type@@ Eval@@ Context context , @ NotNull Map < Py@@ Generic@@ Type , Py@@ Type > substitutions ) { return match ( expected , actual , new Match@@ Context ( context , substitutions ) ) . orElse ( true ) ; }
 public static void pause ( @ Nonnull Condition [ ] conditions ) { pause ( conditions , DEFAULT_@@ DELAY ) ; }
 private static String format@@ Release@@ Notes ( String release@@ Notes ) { while ( release@@ Notes . startsWith ( " \n " ) ) { release@@ Notes = release@@ Notes . substring ( 1 ) ; } String [ ] rn@@ Lines = release@@ Notes . split ( " \n " ) ; int lead@@ Space@@ s@@ Num = 0 ; for ( int i = 0 ; i < rn@@ Lines [ 0 ] . length ( ) ; i ++ ) { if ( rn@@ Lines [ 0 ] . charAt ( i ) == ' ▁ ' ) { lead@@ Space@@ s@@ Num ++ ; } else { break ; } } StringBuilder result = new StringBuilder ( ) ; for ( String rn@@ Line : rn@@ Lines ) { if ( rn@@ Line . length ( ) > lead@@ Space@@ s@@ Num ) { if ( result . length ( ) > 0 ) result . append ( " \n " ) ; result . append ( rn@@ Line . substring ( lead@@ Space@@ s@@ Num ) ) ; } } return result . toString ( ) ; }
 private static void zip@@ Output ( @ NotNull String trace@@ FilePath ) { Path trace@@ File = Paths . get ( trace@@ FilePath ) ; Path parent = trace@@ File . getParent ( ) ; String zip@@ Name = trace@@ File . getFileName ( ) + " . zip " ; System . out . println ( " Prepar@@ ing ▁ zip . " ) ; try { Path zipFile = parent . resolve ( zip@@ Name ) ; Zip@@ Util . compress@@ File ( trace@@ File , zipFile ) ; FileUtil . delete ( trace@@ File ) ; System . out . println ( " archive ▁ " + zipFile + " ▁ prepared " ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
 public static String getApi@@ Config@@ ClassName ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ API_@@ CONFIG_@@ CLASS , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . CORE_@@ API_@@ CONFIG_@@ CLASS , Web@@ Config@@ Default . CORE_@@ API_@@ CONFIG_@@ CLASS ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static String get@@ Admin@@ Dashboard@@ Br@@ and@@ Text ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ D@@ ASH@@ BOARD_@@ BRAN@@ D_@@ TEXT , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ D@@ ASH@@ BOARD_@@ BRAN@@ D_@@ TEXT , Web@@ Config@@ Default . WEB_@@ ADMIN_@@ D@@ ASH@@ BOARD_@@ BRAN@@ D_@@ TEXT ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static void addNew@@ Group ( String name , final long [ ] ids ) { final Group group = Group . newInstance ( ) ; group . setName ( name ) ; group . setState ( B@@ link@@ App . STATE_@@ ADDED ) ; B@@ link@@ App . get@@ Dao@@ Session ( ) . getGroup@@ Dao ( ) . insert ( group ) ; Event . broadcast ( Group . KEY ) ; Event . observe ( Group . KEY , new Observer ( ) { @ Override public void update ( Observable observable , Object data ) { Event . ignore ( Group . KEY , this ) ; for ( long id : ids ) { group . add@@ Device ( id ) ; } } } ) ; Syn@@ cr@@ o . getInstance ( ) . sync@@ Devices ( ) ; }
 private static int promo@@ te@@ Through@@ Goto@@ Chain ( @ NotNull Control@@ Flow flow , int offset ) { List < Instruction > instructions = flow . get@@ Instructions ( ) ; while ( true ) { if ( offset >= instructions . size ( ) ) break ; Instruction instruction = instructions . get ( offset ) ; if ( ! ( instruction instanceof GoTo@@ Instruction ) || ( ( GoTo@@ Instruction ) instruction ) . is@@ Return ) break ; offset = ( ( Branch@@ ing@@ Instruction ) instruction ) . offset ; } return offset ; }
 public static int getSub@@ scription@@ s@@ Cnt ( final Context context ) { return getSub@@ scriptions ( context ) . asMap ( ) . size ( ) ; }
 private static TypeAdapter make@@ Adapter@@ For@@ Regex@@ Method ( String name , Fixture fixture , Matcher matcher ) { return make@@ Adapter@@ For@@ Method ( name , fixture , matcher , true ) ; }
 @ Converter public static AD@@ T_@@ AX@@ X to@@ Ad@@ t@@ AX@@ X ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ AX@@ X . class , body ) ; }
 public static Typeface load@@ Font ( String _font@@ Path ) { if ( ! m_@@ fonts . containsKey ( _font@@ Path ) ) { Typeface font = Typeface . create@@ FromFile ( _font@@ Path ) ; if ( font == null ) { font = Typeface . DEFAULT ; } m_@@ fonts . put ( _font@@ Path , font ) ; } return m_@@ fonts . get ( _font@@ Path ) ; }
 @ Converter public static P@@ EX_@@ P@@ 08 to@@ P@@ ex@@ P@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( P@@ EX_@@ P@@ 08 . class , body ) ; }
 public static Virtual@@ Env@@ Sdk@@ Flavor getInstance ( ) { return Python@@ Sdk@@ Flavor . EP_@@ NAME . find@@ Extension ( Virtual@@ Env@@ Sdk@@ Flavor . class ) ; }
 @ Converter public static SR@@ M_S@@ 11 to@@ S@@ rm@@ S@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 11 . class , body ) ; }
 public static void add@@ Val ( Flat@@ Buffer@@ Builder builder , long val ) { builder . add@@ Long ( 1 , val , 0 ) ; }
 @ Nullable private static PsiElement getExpression ( @ NotNull PsiElement element ) { if ( element instanceof Psi@@ Assignment@@ Expression ) { PsiExpression target = PsiUtil . skip@@ Parenthe@@ sized@@ Expr@@ Down ( ( ( Psi@@ Assignment@@ Expression ) element ) . getL@@ Expression ( ) ) ; return ObjectUtils . try@@ Cast ( target , PsiReferenceExpression . class ) ; } if ( element instanceof Psi@@ Unary@@ Expression ) { PsiExpression target = PsiUtil . skip@@ Parenthe@@ sized@@ Expr@@ Down ( ( ( Psi@@ Unary@@ Expression ) element ) . getOperand ( ) ) ; return ObjectUtils . try@@ Cast ( target , PsiReferenceExpression . class ) ; } if ( element instanceof Psi@@ Declaration@@ Statement ) { return element ; } return null ; }
 public static boolean add ( Metric@@ Type type ) { return type == null ? false : registry . add@@ Metric@@ Type ( type ) ; }
 public static final Parcelable . Creator CRE@@ ATOR = new Parcelable . Creator ( ) { public Movie createFrom@@ Parcel ( Parcel in ) { return new Movie ( in ) ; } public Movie [ ] newArray ( int size ) { return new Movie [ size ] ; } }
 private static boolean is@@ Mag@@ ical@@ Property ( String key ) { return key . startsWith ( " = " ) ; }
 public static List < J@@ Meter@@ Element > get@@ ListType ( TYPE find@@ Type , List < J@@ Meter@@ Element > in@@ List ) { List < J@@ Meter@@ Element > j@@ meter@@ E@@ ls = new ArrayList < J@@ Meter@@ Element > ( ) ; for ( J@@ Meter@@ Element je : in@@ List ) { if ( je . type == find@@ Type ) j@@ meter@@ E@@ ls . add ( je ) ; } return j@@ meter@@ E@@ ls ; }
 public static void set@@ Metric@@ NameSpace ( String metric@@ NameSpace ) { if ( metric@@ NameSpace == null || metric@@ NameSpace . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( ) ; Aws@@ Sdk@@ Metrics . metric@@ NameSpace = metric@@ NameSpace ; }
 public static double log2 ( int x ) { return ( Math . log ( x ) / Math . log ( 2 ) ) ; }
 public static void test_@@ dateTime ( ) { System . out . println ( " Test ▁ ZonedDateTime " ) ; ZonedDateTime dt1 = ZonedDateTime . now ( ) ; java . sql . Timestamp ts = to@@ SQL@@ Timestamp ( dt1 ) ; ZonedDateTime dt2 = to@@ DateTime ( ts ) ; System . out . println ( " ZonedDateTime ▁ 1 ▁ = ▁ " + dt1 ) ; System . out . println ( " Timestamp ▁ ▁ = ▁ " + ts ) ; System . out . println ( " ZonedDateTime ▁ 2 ▁ = ▁ " + dt2 ) ; if ( ! dt2 . equals ( dt1 ) ) { throw new IllegalStateException ( ) ; } }
 public static < T extends Collection < Pattern > > T collect@@ Pattern ( String text , T result ) { String ant@@ Pattern = FileUtil . convert@@ Ant@@ To@@ Regexp ( text . trim ( ) ) ; try { result . add ( Pattern . compile ( ant@@ Pattern ) ) ; } catch ( Pattern@@ SyntaxException ignore ) { } return result ; }
 public static String getGlobal@@ Obj@@ Satisfied ( String i@@ Obj@@ ID , String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getGlobal@@ Obj@@ Satisfied " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Obj@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Lear@@ ner@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Scope@@ ID ) ; } String satis@@ fied@@ Status = null ; System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : getGlobal@@ Obj@@ Satisfied " ) ; return satis@@ fied@@ Status ; }
 private static String get@@ With@@ Ref@@ lect ( String key , String defValue ) { if ( s@@ Class@@ SystemProperties == null || s@@ Method@@ GetString == null ) { return defValue ; } String value = defValue ; try { value = ( String ) s@@ Method@@ GetString . invoke ( s@@ Class@@ SystemProperties , key , defValue ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } return value ; }
 public static String getA@@ jax@@ Config@@ ClassName ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ A@@ JA@@ X_@@ CONFIG_@@ CLASS , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . CORE_@@ A@@ JA@@ X_@@ CONFIG_@@ CLASS , Web@@ Config@@ Default . CORE_@@ A@@ JA@@ X_@@ CONFIG_@@ CLASS ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static String expand@@ Properties ( String text ) { if ( StringUtil . isEmpty@@ Or@@ Spaces ( text ) ) return text ; Properties props = Maven@@ Fac@@ ade@@ Util . collect@@ SystemProperties ( ) ; for ( Map . Entry < Object , Object > each : props . entrySet ( ) ) { Object val = each . getValue ( ) ; text = text . replace ( " $ { " + each . getKey ( ) + " } " , val instanceof CharSequence ? ( CharSequence ) val : val . toString ( ) ) ; } return text ; }
 @ Converter public static CR@@ M_@@ C@@ 04 to@@ C@@ rm@@ C@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 04 . class , body ) ; }
 static int compute@@ List@@ Capacity ( int arraySize ) { return ( int ) Math . min ( 5L + arraySize + ( arraySize / 10 ) , Integer . MAX_VALUE ) ; }
 @ Nullable private static PsiElement getContext@@ Element@@ In@@ Text ( PsiFile psiFile , int lineNumber ) { if ( lineNumber < 0 ) { return psiFile ; } final Document document = Psi@@ DocumentManager . getInstance ( psiFile . getProject ( ) ) . getDocument ( psiFile ) ; if ( document == null ) { return null ; } if ( lineNumber >= document . getLine@@ Count ( ) ) { return psiFile ; } int startOffset = document . getLine@@ StartOffset ( lineNumber ) ; if ( startOffset == - 1 ) { return null ; } PsiElement element ; PsiElement rootElement = psiFile ; List < PsiFile > all@@ Files = psiFile . getView@@ Provider ( ) . getAll@@ Files ( ) ; if ( all@@ Files . size ( ) > 1 ) { Psi@@ Class@@ Owner owner = ContainerUtil . find@@ Instance ( all@@ Files , Psi@@ Class@@ Owner . class ) ; if ( owner != null ) { PsiClass [ ] classes = owner . get@@ Classes ( ) ; if ( classes . length == 1 && classes [ 0 ] instanceof Synthe@@ tic@@ Element ) { rootElement = classes [ 0 ] ; } } } while ( true ) { final CharSequence chars@@ Sequence = document . getChar@@ s@@ Sequence ( ) ; for ( ; startOffset < chars@@ Sequence . length ( ) ; startOffset ++ ) { char c = chars@@ Sequence . charAt ( startOffset ) ; if ( c != ' ▁ ' && c != ' \t ' ) { break ; } } element = rootElement . find@@ ElementAt ( startOffset ) ; if ( element instanceof Psi@@ Comment ) { startOffset = element . getText@@ Range ( ) . getEndOffset ( ) + 1 ; } else { break ; } } if ( element != null && element . getParent ( ) instanceof Psi@@ For@@ Statement ) { return ( ( Psi@@ For@@ Statement ) element . getParent ( ) ) . get@@ Initialization ( ) ; } else { return element ; } }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Fi@@ ve ( ) { return new float [ ] { 0.03@@ 7f , - 0.07@@ 4f , 0.03@@ 7f } ; }
 public static String getS@@ co@@ ut@@ ing@@ URL@@ No@@ Default ( Context context ) { String ret = PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " database@@ URL@@ Pref " , " " ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } return ret ; }
 public static boolean isNotEmpty ( Object str ) { return ! isEmpty ( str ) ; }
 @ NotNull static public Map < String , PsiElement > getArray@@ Creation@@ KeyMap ( @ NotNull Array@@ Creation@@ Expression array@@ Creation@@ Expression ) { Map < String , PsiElement > keys = new HashMap < String , PsiElement > ( ) ; for ( Array@@ Hash@@ Element array@@ Hash@@ Element : array@@ Creation@@ Expression . get@@ Hash@@ Elements ( ) ) { Ph@@ p@@ PsiElement child = array@@ Hash@@ Element . getKey ( ) ; if ( child instanceof StringLiteral@@ Expression ) { keys . put ( ( ( StringLiteral@@ Expression ) child ) . getContents ( ) , child ) ; } } return keys ; }
 private static boolean match@@ Generics ( @ NotNull Py@@ Collection@@ Type expected , @ NotNull Py@@ Type actual , @ NotNull Match@@ Context context ) { final List < Py@@ Type > super@@ ElementTypes = expected . getElement@@ Types ( ) ; final Py@@ Collection@@ Type actual@@ Collection@@ Type = as ( actual , Py@@ Collection@@ Type . class ) ; final List < Py@@ Type > sub@@ ElementTypes = actual@@ Collection@@ Type != null ? actual@@ Collection@@ Type . getElement@@ Types ( ) : Collections . emptyList ( ) ; for ( int i = 0 ; i < super@@ ElementTypes . size ( ) ; i ++ ) { final Py@@ Type sub@@ ElementType = i < sub@@ ElementTypes . size ( ) ? sub@@ ElementTypes . get ( i ) : null ; if ( ! match ( super@@ ElementTypes . get ( i ) , sub@@ ElementType , context ) . orElse ( true ) ) { return false ; } } return true ; }
 public static long parseLong ( String string , int radix ) throws NumberFormatException { if ( string == null || radix < Character . MIN_@@ RADI@@ X || radix > Character . MAX_@@ RADI@@ X ) { throw new NumberFormatException ( ) ; } int length = string . length ( ) , i = 0 ; if ( length == 0 ) { throw new NumberFormatException ( string ) ; } boolean negative = string . charAt ( i ) == ' - ' ; if ( negative && ++ i == length ) { throw new NumberFormatException ( string ) ; } return parse ( string , i , radix , negative ) ; }
 static public void info_@@ no_@@ D@@ KV ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , false , false ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ Point@@ Fi@@ ve ( ) { float a = 1.@@ f / 25@@ 6.@@ f ; return new float [ ] { 1 * a , 5 * a , 12 * a , 10 * a , - 13 * a , - 30 * a , - 13 * a , 10 * a , 12 * a , 5 * a , 1 * a } ; }
 @ Converter public static PP@@ G_@@ PC@@ G to@@ P@@ pg@@ P@@ cg ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ G_@@ PC@@ G . class , body ) ; }
 public static float [ ] get@@ Kernel ( float sigma , float mu ) { float hw@@ i = estimate@@ HW@@ Z@@ I ( sigma , 0.001f ) ; if ( hw@@ i < 0 ) { hw@@ i *= - 1.@@ f ; } int half@@ Width@@ In@@ Pixels = ( int ) Math . ceil ( hw@@ i ) ; int n@@ Points = 2 * half@@ Width@@ In@@ Pixels + 1 ; return get@@ Kernel ( sigma , mu , n@@ Points ) ; }
 private static boolean match ( @ NotNull Py@@ Collection@@ Type expected , @ NotNull Py@@ TupleType actual , @ NotNull Match@@ Context context ) { if ( ! match@@ Classes ( expected . get@@ Py@@ Class ( ) , actual . get@@ Py@@ Class ( ) , context . context ) ) { return false ; } final Py@@ Type super@@ ElementType = expected . get@@ Iter@@ ated@@ ItemType ( ) ; final Py@@ Type sub@@ ElementType = actual . get@@ Iter@@ ated@@ ItemType ( ) ; if ( ! match ( super@@ ElementType , sub@@ ElementType , context ) . orElse ( true ) ) { return false ; } return true ; }
 public static boolean is@@ Api@@ Enabled ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ API_@@ ENABLED , key -> { return properties . getBoolean@@ Value ( key , Web@@ Config@@ Default . WEB_@@ API_@@ ENABLED ) ; } ) ; return ( boolean ) cached@@ Config ; }
 " ) public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { Wire@@ Type . TEXT } , { Wire@@ Type . BINARY } } ) ; }
 private static void assert@@ Read@@ Access@@ Not@@ Gran@@ ted ( Segment@@ Node@@ Store@@ Persistence persistence ) { try { assert@@ Read@@ Access@@ Gran@@ ted ( persistence , BLO@@ BS ) ; fail ( " Read ▁ access ▁ should ▁ not ▁ be ▁ granted , ▁ but ▁ reading ▁ from ▁ the ▁ storage ▁ succeeded . " ) ; } catch ( Exception e ) { } }
 public static < A , B > B fold@@ Left ( Bi@@ Function < B , A , B > fn , B b , List < A > as ) { return null ; }
 public static boolean isDefault@@ Metrics@@ Enabled ( ) { return default@@ Metrics@@ Enabled ; }
 public synchronized static Col@@ d@@ Weather@@ DB getInstance ( Context context ) { if ( col@@ d@@ Weather@@ DB == null ) { col@@ d@@ Weather@@ DB = new Col@@ d@@ Weather@@ DB ( context ) ; } return col@@ d@@ Weather@@ DB ; }
 public static Voice get@@ Voice@@ At@@ Lang ( List < Voice > vo@@ ices , String lang ) { String h@@ if@@ un = lang . replace ( ' _ ' , ' - ' ) ; for ( int i = 0 ; i < vo@@ ices . size ( ) ; i ++ ) { if ( vo@@ ices . get ( i ) . getL@@ ang ( ) . equals ( lang ) || vo@@ ices . get ( i ) . getL@@ ang ( ) . equals ( h@@ if@@ un ) ) { return vo@@ ices . get ( i ) ; } } return null ; }
 public static boolean is@@ Per@@ Host@@ Metric@@ Included ( ) { return per@@ Host@@ Metrics@@ Included ; }
 public static File unzip ( File z@@ ipped ) throws Zip@@ Exception { ZipFile zipFile = new ZipFile ( z@@ ipped . getAbsolutePath ( ) ) ; zipFile . extract@@ All ( OUTPUT_@@ FOLDER ) ; return new File ( OUTPUT_@@ FOLDER ) ; }
 public static LocalDate to@@ LocalDate ( java . util . Date d ) { LocalDate ld = ( d == null ? null : d . to@@ Instant ( ) . at@@ Zone ( par@@ is ) . to@@ LocalDate ( ) ) ; return ld ; }
 public static int [ ] [ ] read@@ Bio@@ Data ( byte [ ] deco@@ bb@@ ed , int packet@@ Size ) { int [ ] [ ] temp@@ Channel@@ Data = ( int [ ] [ ] ) Array . newInstance ( Integer . TYPE , new int [ ] { 2 , packet@@ Size - 8 } ) ; int index@@ Samples = 0 ; int nr@@ BytesTo@@ Ignore = 0 ; for ( int j = deco@@ bb@@ ed . length - 1 ; j >= 0 ; j -- ) { nr@@ BytesTo@@ Ignore ++ ; if ( deco@@ bb@@ ed [ j ] != ( byte ) 0 ) { break ; } } int i = 0 ; while ( i < deco@@ bb@@ ed . length - nr@@ BytesTo@@ Ignore ) { int bio@@ MQ@@ Value = 0 ; try { int bio@@ MI@@ Value = ( deco@@ bb@@ ed [ i ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) | ( ( deco@@ bb@@ ed [ i + 1 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 8 ) ; if ( deco@@ bb@@ ed . length > i + 2 && deco@@ bb@@ ed . length > i + 3 ) { bio@@ MQ@@ Value = ( deco@@ bb@@ ed [ i + 2 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) | ( ( deco@@ bb@@ ed [ i + 3 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 8 ) ; } temp@@ Channel@@ Data [ 0 ] [ index@@ Samples ] = bio@@ MI@@ Value ; temp@@ Channel@@ Data [ 1 ] [ index@@ Samples ] = bio@@ MQ@@ Value ; if ( ! ( bio@@ MI@@ Value == B@@ IO_@@ IGNORE_@@ PATTERN || bio@@ MQ@@ Value == B@@ IO_@@ IGNORE_@@ PATTERN ) ) { index@@ Samples ++ ; } } catch ( ArrayIndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } i += 4 ; } int [ ] [ ] valid@@ Samples = ( int [ ] [ ] ) Array . newInstance ( Integer . TYPE , new int [ ] { 2 , index@@ Samples } ) ; for ( i = 0 ; i < index@@ Samples ; i ++ ) { valid@@ Samples [ 0 ] [ i ] = temp@@ Channel@@ Data [ 0 ] [ i ] ; valid@@ Samples [ 1 ] [ i ] = temp@@ Channel@@ Data [ 1 ] [ i ] ; } return valid@@ Samples ; }
 public static boolean set@@ Global@@ Obj@@ Measure ( String i@@ Obj@@ ID , String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID , String i@@ Measure ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " set@@ Global@@ Obj@@ Measure " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Obj@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Lear@@ ner@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Scope@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Measure ) ; } boolean good@@ Measure = true ; boolean success = true ; if ( ! i@@ Measure . equals ( " unknown " ) ) { try { Double temp@@ Measure = new Double ( i@@ Measure ) ; double range = temp@@ Measure . doubleValue ( ) ; if ( range < - 1.0 || range > 1.0 ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ range : ▁ ▁ " + i@@ Measure ) ; } good@@ Measure = false ; } } catch ( NumberFormatException e ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ ▁ " + i@@ Measure ) ; } good@@ Measure = false ; } if ( ! good@@ Measure ) { success = false ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getGlobal@@ Obj@@ Measure " ) ; } return success ; } } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : set@@ Global@@ Obj@@ Measure " ) ; return success ; }
 public static Stat getRoot@@ As@@ Stat ( ByteBuffer _b@@ b ) { return getRoot@@ As@@ Stat ( _b@@ b , new Stat ( ) ) ; }
 public static String get@@ Admin@@ Ajax@@ Config@@ ClassName ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ ADMIN_@@ A@@ JA@@ X_@@ CONFIG_@@ CLASS , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . CORE_@@ ADMIN_@@ A@@ JA@@ X_@@ CONFIG_@@ CLASS , Web@@ Config@@ Default . CORE_@@ ADMIN_@@ A@@ JA@@ X_@@ CONFIG_@@ CLASS ) ; } } ) ; return ( String ) cached@@ Config ; }
 @ Converter public static EQ@@ Q_@@ Q@@ 01 to@@ E@@ qq@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( EQ@@ Q_@@ Q@@ 01 . class , body ) ; }
 public static int create@@ Stat ( Flat@@ Buffer@@ Builder builder , int id , long val , int count ) { builder . startObject ( 3 ) ; Stat . add@@ Val ( builder , val ) ; Stat . add@@ Id ( builder , id ) ; Stat . add@@ Count ( builder , count ) ; return Stat . end@@ Stat ( builder ) ; }
 @ Converter public static MF@@ K_@@ M@@ 03 to@@ M@@ fk@@ M@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ K_@@ M@@ 03 . class , body ) ; }
 @ NotNull public static List < PsiReferenceExpression > getRead@@ Before@@ Write@@ Locals ( @ NotNull Control@@ Flow flow ) { final Instruction@@ Client@@ Visitor < List < PsiReferenceExpression > > visitor = new Read@@ Before@@ Write@@ Client@@ Visitor ( flow , true ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( ) ; }
 @ Converter public static R@@ RA_@@ O@@ 02 to@@ R@@ ra@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ RA_@@ O@@ 02 . class , body ) ; }
 public static String get@@ Credential@@ File ( ) { return credential@@ File ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_@@ ID ; default : return null ; } }
 public static void main ( String [ ] args ) throws IOException { B@@ un@@ ny@@ Server server ; if ( args . length > 0 ) server = new B@@ un@@ ny@@ Server ( Integer . parseInt ( args [ 0 ] ) , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; else server = new B@@ un@@ ny@@ Server ( ) ; Thread t = new Thread ( server ) ; t . start ( ) ; }
 private static final String getString@@ Key ( byte [ ] key@@ Byte ) { try { return new String ( key@@ Byte , " UTF - 8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return null ; }
 private static void assert@@ Write@@ Access@@ Gran@@ ted ( Segment@@ Node@@ Store@@ Persistence persistence ) throws Exception { getContainer@@ From ( persistence ) . getBlock@@ Blob@@ Reference ( " test . txt " ) . upload@@ Text ( " test " ) ; }
 @ Converter public static AD@@ T_@@ A@@ 37 to@@ Ad@@ t@@ A@@ 37 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 37 . class , body ) ; }
 @ Converter public static CR@@ M_@@ C@@ 01 to@@ C@@ rm@@ C@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 01 . class , body ) ; }
 public static void test_@@ date@@ Time_@@ tz ( ) { System . out . println ( " Test ▁ ZonedDateTime ▁ with ▁ timezone " ) ; ZonedDateTime dt1 = ZonedDateTime . now ( los@@ Ange@@ les ) ; java . sql . Timestamp ts = to@@ SQL@@ Timestamp ( dt1 ) ; String tz@@ ID = to@@ TimeZone@@ ID ( dt1 ) ; ZonedDateTime dt2 = to@@ DateTime ( ts , tz@@ ID ) ; System . out . println ( " ZonedDateTime ▁ 1 ▁ = ▁ " + dt1 ) ; System . out . println ( " Timestamp ▁ ▁ = ▁ " + ts ) ; System . out . println ( " TimeZone@@ ID ▁ = ▁ " + tz@@ ID ) ; System . out . println ( " ZonedDateTime ▁ 2 ▁ = ▁ " + dt2 ) ; if ( ! dt2 . equals ( dt1 ) ) { throw new IllegalStateException ( ) ; } }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Four ( ) { float a = 1.@@ f / 3@@ 15.@@ f ; return new float [ ] { ( float ) ( 0.00@@ 13@@ 49@@ 615@@ 79@@ 339@@ 84@@ 04@@ 5 ) * a , ( float ) ( 0.00@@ 38@@ 12@@ 25@@ 314@@ 812@@ 07@@ 98 ) * a , ( float ) ( 0.00@@ 9@@ 85@@ 46@@ 64@@ 101@@ 18@@ 65@@ 2 ) * a , ( float ) ( 0.02@@ 33@@ 54@@ 25@@ 09@@ 37@@ 08@@ 468@@ 8 ) * a , ( float ) ( 0.05@@ 07@@ 9@@ 39@@ 312@@ 409@@ 85@@ 246 ) * a , ( float ) ( 0.@@ 101@@ 410@@ 62@@ 66@@ 034@@ 688@@ 6 ) * a , ( float ) ( 0.18@@ 57@@ 17@@ 626@@ 97@@ 88@@ 544@@ 7 ) * a , ( float ) ( 0.3@@ 11@@ 32@@ 423@@ 87@@ 16@@ 22@@ 195 ) * a , ( float ) ( 0.@@ 47@@ 577@@ 164@@ 76@@ 25@@ 97@@ 89 ) * a , ( float ) ( 0.65@@ 804@@ 316@@ 708@@ 07@@ 84@@ 7 ) * a , ( float ) ( 0.8@@ 13@@ 00@@ 47@@ 466@@ 8@@ 2009@@ 1 ) * a , ( float ) ( 0.87@@ 468@@ 01@@ 74@@ 27@@ 01@@ 37@@ 2 ) * a , ( float ) ( 0.@@ 77@@ 27@@ 267@@ 28@@ 39@@ 00@@ 054 ) * a , ( float ) ( 0.@@ 46@@ 06@@ 218@@ 14@@ 66@@ 94@@ 77@@ 1 ) * a , ( float ) ( 0.05@@ 400@@ 65@@ 704@@ 27@@ 53@@ 325 ) * a , ( float ) ( - 0.@@ 69@@ 08@@ 9@@ 45@@ 68@@ 132@@ 16@@ 93 ) * a , ( float ) ( - 1.@@ 299@@ 503@@ 65@@ 36@@ 35@@ 67@@ 18 ) * a , ( float ) ( - 1.@@ 68@@ 289@@ 89@@ 218@@ 28@@ 288 ) * a , ( float ) ( - 1.9@@ 58@@ 212@@ 39@@ 32@@ 01@@ 23@@ 66 ) * a , ( float ) ( - 1.@@ 68@@ 289@@ 89@@ 218@@ 28@@ 288 ) * a , ( float ) ( - 1.@@ 299@@ 503@@ 65@@ 36@@ 35@@ 67@@ 18 ) * a , ( float ) ( - 0.@@ 69@@ 08@@ 9@@ 45@@ 68@@ 132@@ 16@@ 93 ) * a , ( float ) ( 0.05@@ 400@@ 65@@ 704@@ 27@@ 53@@ 325 ) * a , ( float ) ( 0.@@ 46@@ 06@@ 218@@ 14@@ 66@@ 94@@ 77@@ 1 ) * a , ( float ) ( 0.@@ 77@@ 27@@ 267@@ 28@@ 39@@ 00@@ 054 ) * a , ( float ) ( 0.87@@ 468@@ 01@@ 74@@ 27@@ 01@@ 37@@ 2 ) * a , ( float ) ( 0.8@@ 13@@ 00@@ 47@@ 466@@ 8@@ 2009@@ 1 ) * a , ( float ) ( 0.65@@ 804@@ 316@@ 708@@ 07@@ 84@@ 7 ) * a , ( float ) ( 0.@@ 47@@ 577@@ 164@@ 76@@ 25@@ 97@@ 89 ) * a , ( float ) ( 0.3@@ 11@@ 32@@ 423@@ 87@@ 16@@ 22@@ 195 ) * a , ( float ) ( 0.18@@ 577@@ 39@@ 169@@ 132@@ 10@@ 74 ) * a , ( float ) ( 0.@@ 101@@ 416@@ 12@@ 05@@ 69@@ 709@@ 53 ) * a , ( float ) ( 0.05@@ 07@@ 94@@ 23@@ 855@@ 7@@ 12@@ 4@@ 116 ) * a , ( float ) ( 0.02@@ 33@@ 54@@ 255@@ 36@@ 97@@ 29@@ 46@@ 7 ) * a , ( float ) ( 0.00@@ 9@@ 85@@ 46@@ 64@@ 101@@ 18@@ 65@@ 2 ) * a , ( float ) ( 0.00@@ 38@@ 12@@ 25@@ 314@@ 812@@ 07@@ 98 ) * a , ( float ) ( 0.00@@ 13@@ 49@@ 615@@ 79@@ 339@@ 84@@ 04@@ 5 ) * a } ; }
 private static TypeAdapter make@@ Adapter@@ For@@ Method ( String name , Fixture fixture , Matcher matcher ) { return make@@ Adapter@@ For@@ Method ( name , fixture , matcher , false ) ; }
 @ Converter public static AD@@ T_@@ A@@ 06 to@@ Ad@@ t@@ A@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 06 . class , body ) ; }
 @ Nullable private static PsiElement resolve@@ Type@@ Member ( @ NotNull Py@@ Type type , @ NotNull String name , @ NotNull Type@@ Eval@@ Context context ) { final Py@@ Resolve@@ Context resolve@@ Context = Py@@ Resolve@@ Context . no@@ Imp@@ lic@@ its ( ) . with@@ Type@@ Eval@@ Context ( context ) ; final List < ? extends R@@ ated@@ ResolveResult > results = type . resolve@@ Member ( name , null , Access@@ Direction . READ , resolve@@ Context ) ; return ! ContainerUtil . isEmpty ( results ) ? results . get ( 0 ) . getElement ( ) : null ; }
 @ Converter public static SQ@@ R@@ _S@@ 25 to@@ Sq@@ r@@ S@@ 25 ( String body ) throws HL7@@ Exception { return to@@ Message ( SQ@@ R@@ _S@@ 25 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 36 to@@ Ad@@ t@@ A@@ 36 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 36 . class , body ) ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
 @ Converter public static R@@ Q@@ Q_@@ Q@@ 01 to@@ R@@ qq@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ Q_@@ Q@@ 01 . class , body ) ; }
 private static JMX@@ Connector@@ Server get@@ Connector@@ Server@@ As@@ Service ( ClassLoader loader , JMX@@ Service@@ URL url , Map < String , ? > map , MBeanServer mbs ) throws IOException { Iterator < JMX@@ Connector@@ Server@@ Provider > providers = JMX@@ Connector@@ Factory . getProvider@@ Iterator ( JMX@@ Connector@@ Server@@ Provider . class , loader ) ; IOException exception = null ; while ( providers . hasNext ( ) ) { try { return providers . next ( ) . new@@ JMX@@ Connector@@ Server ( url , map , mbs ) ; } catch ( JMX@@ Provider@@ Exception e ) { throw e ; } catch ( Exception e ) { if ( logger . trace@@ On ( ) ) logger . trace ( " get@@ Connector@@ As@@ Service " , " URL [ " + url + " ] ▁ Service ▁ provider ▁ exception : ▁ " + e ) ; if ( ! ( e instanceof MalformedURLException ) ) { if ( exception == null ) { if ( e instanceof IOException ) { exception = ( IOException ) e ; } else { exception = Env@@ Help . initCause ( new IOException ( e . getMessage ( ) ) , e ) ; } } } continue ; } } if ( exception == null ) return null ; else throw exception ; }
 public static void run@@ Or@@ Apply@@ Maven@@ Project@@ File@@ Template ( Project project , VirtualFile file , Maven@@ Id projectId , Maven@@ Id parentId , boolean interactive ) throws IOException { Properties properties = new Properties ( ) ; Properties conditions = new Properties ( ) ; properties . setProperty ( " GROUP _ ID " , projectId . get@@ GroupId ( ) ) ; properties . setProperty ( " ARTI@@ FAC@@ T _ ID " , projectId . get@@ Artifact@@ Id ( ) ) ; properties . setProperty ( " VERSION " , projectId . getVersion ( ) ) ; if ( parentId != null ) { conditions . setProperty ( " HAS _ PARENT " , " true " ) ; properties . setProperty ( " PARENT _ GROUP _ ID " , parentId . get@@ GroupId ( ) ) ; properties . setProperty ( " PARENT _ ARTI@@ FAC@@ T _ ID " , parentId . get@@ Artifact@@ Id ( ) ) ; properties . setProperty ( " PARENT _ VERSION " , parentId . getVersion ( ) ) ; } run@@ Or@@ Apply@@ File@@ Template ( project , file , Maven@@ File@@ Template@@ Group@@ Factory . MAV@@ EN_@@ PROJECT_@@ XML_@@ TEMPLATE , properties , conditions , interactive ) ; }
 private static int check@@ Style ( int style ) { if ( ( style & SWT . BORDER ) != 0 ) style |= SWT . SHADOW_@@ IN ; int mask = SWT . SHADOW_@@ IN | SWT . SHADOW_@@ OUT | SWT . SHADOW_@@ NONE | SWT . LEFT_@@ TO_@@ RIGHT | SWT . RIGHT_@@ TO_@@ LEFT ; style = style & mask ; return style |= SWT . NO_@@ FOCUS | SWT . DOUBLE_@@ BUFFER@@ ED ; }
 public static int add@@ Subscription ( final Context context , final String title , final String category , final String url ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final String current@@ Title = getCurrent@@ Feed@@ Title ( context ) ; subscriptions . putAll ( title , Arrays . asList ( category , " " , url ) ) ; save@@ Sub@@ scriptions ( context , subscriptions ) ; return update@@ Current@@ Feed@@ Position ( context , current@@ Title ) ; }
 private static < T > Collection < T > toSet ( final Collection < T > collection ) { return ( collection instanceof Set ? collection : new TH@@ ash@@ Set < T > ( collection ) ) ; }
 public static byte [ ] int@@ _to_@@ bin ( int number , int width ) { if ( number < 0 ) { number += ( 1 << width ) ; } int i = width - 1 ; byte [ ] bits = new byte [ width ] ; while ( i >= 0 ) { bits [ i ] = ( byte ) ( number & 1 ) ; number >>= 1 ; i -= 1 ; } return bits ; }
 public static String pad@@ Right ( String stringTo@@ Pad , int size ) { StringBuilder str@@ b = new StringBuilder ( stringTo@@ Pad ) ; while ( str@@ b . length ( ) < size ) if ( str@@ b . length ( ) < size ) str@@ b . append ( ' ▁ ' ) ; return str@@ b . toString ( ) ; }
 public static String copy ( Context context , int id , String path ) { return copy ( context , id , path , false ) ; }
 public static void main ( String [ ] args ) { Solution solution = new Solution ( ) ; solution . users . put ( " Hu@@ bert " , new User ( 172 , " Hu@@ bert " ) ) ; solution . users . put ( " Z@@ app " , new User ( 41 , " Z@@ app " ) ) ; Solution clone = null ; try { clone = solution . clone ( ) ; System . out . println ( solution ) ; System . out . println ( clone ) ; System . out . println ( solution . users ) ; System . out . println ( clone . users ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( System . err ) ; } }
 @ Nullable public static Source@@ Position getSource@@ Position ( final Stack@@ Frame@@ Context context ) { if ( context == null ) { return null ; } Debug@@ Process@@ Impl debug@@ Process = ( Debug@@ Process@@ Impl ) context . getDebug@@ Process ( ) ; if ( debug@@ Process == null ) { return null ; } final Stack@@ Frame@@ Proxy frame@@ Proxy = context . getFrame@@ Proxy ( ) ; if ( frame@@ Proxy == null ) { return null ; } Location location = null ; try { location = frame@@ Proxy . location ( ) ; } catch ( Throwable th ) { LOG . debug ( th ) ; } final Compound@@ Position@@ Manager position@@ Manager = debug@@ Process . getPosition@@ Manager ( ) ; if ( position@@ Manager == null ) { return null ; } try { return position@@ Manager . getSource@@ Position ( location ) ; } catch ( Index@@ Not@@ Ready@@ Exception e ) { return null ; } }
 @ Converter public static R@@ Q@@ A_@@ I@@ 09 to@@ R@@ q@@ a@@ I@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ A_@@ I@@ 09 . class , body ) ; }
 public static void clear@@ DB@@ Type ( ) { context@@ Holder . remove ( ) ; }
 private static void assert@@ Tra@@ vers@@ als ( final Graph@@ Traversal t , final Traversal eval@@ d ) { final List < Step > steps = t . as@@ Admin ( ) . get@@ Steps ( ) ; for ( int ix = 0 ; ix < steps . size ( ) ; ix ++ ) { assertEquals ( steps . get ( ix ) . getClass ( ) , eval@@ d . as@@ Admin ( ) . get@@ Steps ( ) . get ( ix ) . getClass ( ) ) ; } }
 private static boolean match ( @ NotNull Py@@ Union@@ Type expected , @ NotNull Py@@ Type actual , @ NotNull Match@@ Context context ) { return Stream@@ Ex . of ( expected . get@@ Members ( ) ) . any@@ Match ( type -> match ( type , actual , context ) . orElse ( true ) ) ; }
 @ Converter public static R@@ OR_@@ R@@ OR to@@ R@@ or@@ R@@ or ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ OR_@@ R@@ OR . class , body ) ; }
 static public void debug ( Object ... objects ) { if ( flag ( Sys . WATER ) == false ) return ; Event e = Event . make ( Sys . WATER , Kind . DE@@ BG , null , objects ) ; write ( e , false , true ) ; }
 private static void ed@@ t ( @ NotNull final Throwable@@ Runnable < Exception > runnable ) throws Exception { final AtomicReference < Exception > exception = new AtomicReference < Exception > ( ) ; UIUtil . invoke@@ And@@ Wait@@ IfNeeded ( new Runnable ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Exception throwable ) { exception . set ( throwable ) ; } } } ) ; if ( exception . get ( ) != null ) { throw exception . get ( ) ; } }
 public static synchronized boolean enable@@ Default@@ Metrics ( ) { if ( mc == null || ! mc . isEnabled ( ) ) { if ( dirty@@ En@@ abling ) { throw new IllegalStateException ( " Reentran@@ cy ▁ is ▁ not ▁ allowed " ) ; } dirty@@ En@@ abling = true ; try { Class < ? > c = Class . forName ( DEFAULT_@@ METRIC_@@ COLLEC@@ TOR_@@ FACTORY ) ; Metric@@ Collector . Factory f = ( Metric@@ Collector . Factory ) c . newInstance ( ) ; Metric@@ Collector instance = f . getInstance ( ) ; if ( instance != null ) { set@@ Metric@@ Collector ( instance ) ; return true ; } } catch ( Exception e ) { LogFactory . getLog ( Aws@@ Sdk@@ Metrics . class ) . warn ( " Failed ▁ to ▁ enable ▁ the ▁ default ▁ metrics " , e ) ; } finally { dirty@@ En@@ abling = false ; } } return false ; }
 public static void run@@ When@@ Initialized ( final Project project , final Runnable r ) { if ( project . isDisposed ( ) ) return ; if ( is@@ No@@ Background@@ Mode ( ) ) { r . run ( ) ; return ; } if ( ! project . isInitialized ( ) ) { Startup@@ Manager . getInstance ( project ) . register@@ Post@@ Startup@@ Activity ( r ) ; return ; } run@@ Dumb@@ Aware ( project , r ) ; }
 @ Converter public static R@@ Q@@ A_@@ I@@ 11 to@@ R@@ q@@ a@@ I@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ A_@@ I@@ 11 . class , body ) ; }
 public static void register@@ Classes ( Class ... classes ) { for ( Class c : classes ) { register@@ Class ( c ) ; } }
 @ Converter public static MD@@ M_@@ T@@ 08 to@@ M@@ dm@@ T@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 08 . class , body ) ; }
 public static Policy@@ Builder of ( Policy policy ) { return new Policy@@ Builder ( policy ) ; }
 public static Serializer@@ Registration register@@ Class ( Class cls , boolean fail@@ On@@ Mis@@ s ) { if ( cls . is@@ Annotation@@ Present ( Serializable . class ) ) { Serializable serializable = ( Serializable ) cls . getAnnotation ( Serializable . class ) ; Class serializer@@ Class = serializable . serializer ( ) ; short class@@ Id = serializable . id ( ) ; if ( class@@ Id == 0 ) class@@ Id = next@@ Id ( ) ; Serializer serializer = get@@ Serializer ( serializer@@ Class , false ) ; if ( serializer == null ) serializer = field@@ Serializer ; Serializer@@ Registration existing@@ Reg = get@@ Exact@@ Serializer@@ Registration ( cls ) ; if ( existing@@ Reg != null ) class@@ Id = existing@@ Reg . getId ( ) ; Serializer@@ Registration reg = new Serializer@@ Registration ( serializer , cls , class@@ Id ) ; return register@@ Class@@ For@@ Id ( class@@ Id , cls , serializer ) ; } if ( fail@@ On@@ Mis@@ s ) { throw new IllegalArgumentException ( " Class ▁ is ▁ not ▁ marked ▁ @ Serializable : " + cls ) ; } return null ; }
 public static void enable@@ Component ( Context context , Class component@@ Class ) { try { Component@@ Util . setState ( context , true , component@@ Class ) ; Mobile@@ Messaging@@ Logger . w ( " Enabled ▁ " + component@@ Class . getName ( ) + " ▁ for ▁ compatibility ▁ reasons " ) ; } catch ( Exception e ) { Mobile@@ Messaging@@ Logger . d ( " Cannot ▁ enable ▁ " + component@@ Class . getName ( ) + " : ▁ " , e ) ; } }
 private static < I extends Async@@ Iface > Map < String , org . apache . thrift . Async@@ Process@@ Function < I , ? extends org . apache . thrift . T@@ Base , ? > > getProcess@@ Map ( Map < String , org . apache . thrift . Async@@ Process@@ Function < I , ? extends org . apache . thrift . T@@ Base , ? > > process@@ Map ) { process@@ Map . put ( " create@@ Interpreter " , new create@@ Interpreter ( ) ) ; process@@ Map . put ( " open " , new open ( ) ) ; process@@ Map . put ( " close " , new close ( ) ) ; process@@ Map . put ( " interpret " , new interpret ( ) ) ; process@@ Map . put ( " cancel " , new cancel ( ) ) ; process@@ Map . put ( " getProgress " , new getProgress ( ) ) ; process@@ Map . put ( " getForm@@ Type " , new getForm@@ Type ( ) ) ; process@@ Map . put ( " completion " , new completion ( ) ) ; process@@ Map . put ( " shutdown " , new shutdown ( ) ) ; process@@ Map . put ( " getStatus " , new getStatus ( ) ) ; process@@ Map . put ( " get@@ Event " , new get@@ Event ( ) ) ; process@@ Map . put ( " angular@@ Object@@ Update " , new angular@@ Object@@ Update ( ) ) ; process@@ Map . put ( " angular@@ Object@@ Add " , new angular@@ Object@@ Add ( ) ) ; process@@ Map . put ( " angular@@ Object@@ Remove " , new angular@@ Object@@ Remove ( ) ) ; return process@@ Map ; }
 @ Converter public static MD@@ M_@@ T@@ 04 to@@ M@@ dm@@ T@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 04 . class , body ) ; }
 public static Map < String , Integer > Commit@@ s_@@ Month ( String proj@@ Name ) { Map < String , Integer > res = new LinkedHashMap < String , Integer > ( ) ; try { Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ strftime ( ' % m - % Y ' , ▁ T@@ Commit . Date ) ▁ as ▁ ' month - year ' , ▁ " + " COUNT ( T@@ Commit . Date ) ▁ AS ▁ Total@@ Month ▁ FROM ▁ T@@ COMMIT , ▁ TRE@@ POSI@@ TORY , ▁ T@@ FILE ▁ " + " WHERE ▁ T@@ COMMIT . Repo@@ Id ▁ = ▁ TRE@@ POSI@@ TORY . id ▁ AND ▁ " + " T@@ FILE . commit@@ Id ▁ = ▁ T@@ COMMIT . id ▁ AND ▁ T@@ File . newname ▁ like ▁ ' java / engine / org / apache / der@@ by / impl / jdbc / Embed@@ Connection . java ' ▁ AND ▁ " + " TRE@@ POSI@@ TORY . Name ▁ = ▁ ' " + proj@@ Name + " ' ▁ " + " GROUP ▁ BY ▁ strftime ( ' % m - % Y ' , ▁ Date ) ▁ ORDER ▁ BY ▁ Total@@ Month ▁ desc ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { res . put ( rs . getString ( " month - year " ) , rs . getInt ( " Total@@ Month " ) ) ; } rs . close ( ) ; s@@ mt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return res ; }
 public static boolean defin@@ es@@ Get@@ Attr ( @ NotNull Py@@ File file , @ NotNull Type@@ Eval@@ Context context ) { if ( file instanceof Py@@ Typed@@ Element ) { final Py@@ Type type = context . getType ( ( Py@@ Typed@@ Element ) file ) ; if ( type != null ) { return resolve@@ Type@@ Member ( type , Py@@ Names . GE@@ TA@@ TT@@ R , context ) != null ; } } return false ; }
 public static Configuration@@ Option@@ Description@@ StaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new Configuration@@ Option@@ Description@@ StaxUnmarshaller ( ) ; return instance ; }
 @ Converter public static AD@@ T_@@ A@@ 47 to@@ Ad@@ t@@ A@@ 47 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 47 . class , body ) ; }
 private static double parse@@ Arg ( Chars chars ) { int start = chars . index ( ) ; while ( chars . hasNext ( ) && LEG@@ AL_@@ NUMBER_@@ CHAR . contains ( chars . peek ( ) ) ) { chars . next ( ) ; } int end = chars . index ( ) ; return Double . parseDouble ( chars . sub@@ String ( start , end ) ) ; }
 public static Integer extract@@ P@@ mid ( Article article ) { try { List < Article@@ Id > ids = article . get@@ Front ( ) . get@@ Article@@ Meta ( ) . get@@ Article@@ Id ( ) ; for ( Article@@ Id id : ids ) { if ( " pm@@ id " . equals ( id . get@@ Pub@@ Id@@ Type ( ) ) ) { return parseInt ( id . getContent ( ) ) ; } } if ( ! ids . isEmpty ( ) && is@@ Numeric ( ids . get ( 0 ) . getContent ( ) ) ) { return parseInt ( ids . get ( 0 ) . getContent ( ) ) ; } } catch ( Exception e ) { System . err . println ( e ) ; } return null ; }
 protected static Map < Integer , Inventory > to@@ Inventory@@ Map ( ResultSet resultSet , Map < Integer , Item > item@@ Map , Map < Integer , Company > company@@ Map , Map < Integer , Location > location@@ Map , Map < Integer , Bar@@ code > bar@@ code@@ Map ) throws SQLException { Map < Integer , Inventory > result = new HashMap < Integer , Inventory > ( ) ; while ( resultSet . next ( ) ) { Inventory inventory = new Inventory ( resultSet . getInt ( 1 ) , item@@ Map . get ( resultSet . getInt ( 2 ) ) , resultSet . getInt ( 3 ) , company@@ Map . get ( resultSet . getInt ( 4 ) ) , resultSet . getInt ( 5 ) , resultSet . getInt ( 6 ) , resultSet . getDate ( 7 ) , resultSet . getDate ( 8 ) , location@@ Map . get ( resultSet . getInt ( 9 ) ) , bar@@ code@@ Map . get ( resultSet . getInt ( 10 ) ) ) ; result . put ( resultSet . getInt ( 1 ) , inventory ) ; } return result ; }
 public static String html ( String content ) { if ( content == null ) { return " " ; } String html = content ; html = html . replace ( " ' " , " & apos ; " ) ; html = html . replace ( " \@@ " " , " & quot ; " ) ; html = html . replace ( " \t " , " & nbsp ; & nbsp ; " ) ; html = html . replace ( " < " , " & lt ; " ) ; html = html . replace ( " > " , " & gt ; " ) ; return html ; }
 public static String getLog@@ Path@@ FileName ( ) { return getLog@@ Path@@ FileName@@ Ste@@ m ( ) + " - 2 - debug . log " ; }
 public static String get@@ Jvm@@ Metric@@ Name ( ) { return jvm@@ Metric@@ Name ; }
 private static String getAttribute ( Node i@@ Node , String i@@ Attribute ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ getAttribute " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ Attribute ) ; } String value = null ; NamedNodeMap attrs = i@@ Node . getAttributes ( ) ; if ( attrs != null ) { Node attr = attrs . getNamed@@ Item ( i@@ Attribute ) ; if ( attr != null ) { value = attr . getNodeValue ( ) ; } else { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ The ▁ attribute ▁ \@@ " " + i@@ Attribute + " \@@ " ▁ does ▁ not ▁ exist . " ) ; } } } else { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ This ▁ node ▁ has ▁ no ▁ attributes . " ) ; } } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + value ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ - ▁ getAttribute " ) ; } return value ; }
 public static void setFlag ( Sys t ) { t . _@@ enable = true ; }
 private static void create@@ HBase@@ Table@@ 2 ( ) { TableName tableName = TableName . valueOf ( TEST_@@ TABLE_@@ 2 ) ; createTable ( tableName , F@@ AM@@ ILI@@ ES , SP@@ LIT_@@ KEYS ) ; }
 private static void pre@@ Transform ( Render@@ Item render@@ Item , ItemStack stack ) { IB@@ a@@ ked@@ Model i@@ ba@@ ked@@ model = render@@ Item . getItem@@ Model@@ Mesh@@ er ( ) . getItem@@ Model ( stack ) ; Item item = stack . getItem ( ) ; if ( item != null ) { boolean flag = i@@ ba@@ ked@@ model . is@@ Gui@@ 3d ( ) ; if ( ! flag ) { Gl@@ StateManager . scale ( 2.@@ 0F , 2.@@ 0F , 2.@@ 0F ) ; } Gl@@ StateManager . color ( 1.0F , 1.0F , 1.0F , 1.0F ) ; } }
 public static void test@@ Types ( ) { try { Types@@ Testing tt = new Types@@ Testing ( ) ; tt . set@@ L ( 1000 ) ; Types@@ Testing loaded = broker . load@@ Entity ( tt , false ) ; System . out . println ( loaded ) ; broker . commit@@ Transaction ( ) ; System . out . println ( " Types ▁ testing ▁ - ▁ OK ! " ) ; } catch ( SQLException ex ) { broker . rollback@@ Transaction ( ) ; System . out . println ( " Types ▁ testing ▁ - ▁ Error : ▁ " + ex . getMessage ( ) ) ; } }
 @ Converter public static MF@@ K_@@ M@@ 07 to@@ M@@ fk@@ M@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ K_@@ M@@ 07 . class , body ) ; }
 @ BeforeClass public static void activate@@ HBase@@ Cluster ( ) throws IOException { prepare@@ Tables ( ) ; }
 private static boolean has@@ Calls ( @ NotNull Control@@ Flow flow ) { for ( Instruction instruction : flow . get@@ Instructions ( ) ) { if ( instruction instanceof Call@@ Instruction ) { return true ; } } return false ; }
 @ Converter public static AD@@ T_@@ A@@ 34 to@@ Ad@@ t@@ A@@ 34 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 34 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 12 to@@ Ad@@ t@@ A@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 12 . class , body ) ; }
 public static void main ( String [ ] args ) { Spring@@ Application . run ( TestConfiguration . class , args ) ; }
 public static void foo ( final List < Co@@ Product@@ 2 < String > > criteria ) { fold@@ Left ( ( t ) -> t . into ( ) , map ( Co@@ Product@@ 2 :: project , criteria ) ) ; }
 static Optional < SSLContext > ssl@@ Context ( String store , String pw ) { try { char [ ] password = pw . toCharArray ( ) ; KeyStore ks = KeyStore . getInstance ( " J@@ KS " ) ; InputStream keystore = Client@@ Flow@@ Http@@ sTest . class . getClassLoader ( ) . getResourceAsStream ( " Client@@ Flow@@ Https@@ Spec / " + store ) ; assert keystore != null ; ks . load ( keystore , password ) ; Key@@ ManagerFactory key@@ ManagerFactory = Key@@ ManagerFactory . getInstance ( " Sun@@ X509@@ " ) ; key@@ ManagerFactory . init ( ks , password ) ; Trust@@ ManagerFactory t@@ mf = Trust@@ ManagerFactory . getInstance ( " Sun@@ X509@@ " ) ; t@@ mf . init ( ks ) ; SSLContext ssl@@ Context = SSLContext . getInstance ( " TLS " ) ; ssl@@ Context . init ( key@@ ManagerFactory . getKey@@ Managers ( ) , t@@ mf . get@@ Trust@@ Managers ( ) , new SecureRandom ( ) ) ; return Optional . of ( ssl@@ Context ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return Optional . empty ( ) ; } }
 public static int bin@@ _to_@@ int ( byte [ ] bits , boolean signed ) { int number = 0 ; int bias = 0 ; int i = 0 ; if ( bits . length == 0 ) return 0 ; if ( signed && bits [ 0 ] == ( byte ) 1 ) { i ++ ; bias = 1 << ( bits . length - 1 ) ; } for ( int j = i ; j < bits . length ; j ++ ) { number <<= 1 ; number |= bits [ j ] ; } return number - bias ; }
 private static Compare@@ Authentication@@ Handler getP@@ oo@@ led@@ Compare@@ Authentication@@ Handler ( final Ldap@@ Authentication@@ Properties l ) { final var handler = new Compare@@ Authentication@@ Handler ( new@@ Pooled@@ ConnectionFactory ( l ) ) ; handler . set@@ Password@@ Attribute ( l . get@@ Principal@@ Attribute@@ Password ( ) ) ; return handler ; }
 @ Converter public static R@@ RI@@ _@@ I@@ 14 to@@ R@@ ri@@ I@@ 14 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ RI@@ _@@ I@@ 14 . class , body ) ; }
 public static int getPrevious@@ Feed@@ Position ( final Context context ) { return get ( context , KEY_@@ PREVI@@ OUS_@@ FE@@ ED_@@ POSITION , Integer . class ) ; }
 public static String extract@@ Title ( Article article ) { return null ; }
 private static void report@@ Missing@@ Component ( Context context , Class cls ) { ConfigurationException exception = new ConfigurationException ( ConfigurationException . Reason . MISSING_@@ REQUIRED_@@ COMPONENT , cls . getCanonicalName ( ) ) ; if ( Software@@ Information . isDebug@@ g@@ able@@ Application@@ Build ( context ) ) { throw exception ; } else { Mobile@@ Messaging@@ Logger . e ( exception . getMessage ( ) ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 28 to@@ Ad@@ t@@ A@@ 28 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 28 . class , body ) ; }
 public static String getS@@ it@@ ename ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB@@ _S@@ IT@@ ENAME , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . WEB@@ _S@@ IT@@ ENAME , Web@@ Config@@ Default . WEB@@ _S@@ IT@@ ENAME ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static void set@@ Web@@ Credential@@ sFrom@@ Preferences ( Context context ) { final SharedPreferences settings = PreferenceManager . getDefault@@ SharedPreferences ( context ) ; String username = getUserName ( settings ) ; String password = getPassword ( settings ) ; if ( username == null || username . isEmpty ( ) ) return ; String host = Uri . parse ( getServer ( settings , context ) ) . getHost ( ) ; Web@@ Utils . add@@ Credentials ( username , password , host ) ; }
 public static int getRe@@ dis@@ Port ( ) { return ( int ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . RE@@ DI@@ S_@@ PORT , key -> properties . getInt@@ Value ( key , Web@@ Config@@ Default . RE@@ DI@@ S_@@ PORT ) ) ; }
 @ Converter public static AD@@ T_@@ A@@ 22 to@@ Ad@@ t@@ A@@ 22 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 22 . class , body ) ; }
 @ Converter public static OR@@ M_@@ O@@ 01 to@@ Or@@ m@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ M_@@ O@@ 01 . class , body ) ; }
 public static Intern@@ Map@@ Storage of ( boolean thread@@ Safe , Intern@@ Storage . Value@@ Constructor value@@ Constructor ) { if ( thread@@ Safe ) { return new Intern@@ Map@@ Storage ( new ConcurrentHashMap < > ( ) , value@@ Constructor ) ; } return new Intern@@ Map@@ Storage ( new HashMap < > ( ) , value@@ Constructor ) ; }
 protected static Map < Integer , Item > to@@ Item@@ Map ( ResultSet resultSet , Map < Integer , Bar@@ code > bar@@ code@@ Map , Map < Integer , Company > company@@ Map ) throws SQLException { Map < Integer , Item > result = new HashMap < Integer , Item > ( ) ; while ( resultSet . next ( ) ) { Item item = new Item ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , company@@ Map . get ( resultSet . getInt ( 3 ) ) , bar@@ code@@ Map . get ( resultSet . getInt ( 4 ) ) , resultSet . getString ( 5 ) ) ; result . put ( resultSet . getInt ( 1 ) , item ) ; } return result ; }
 public static void set@@ Strict@@ Registration ( boolean b ) { strict@@ Registration = b ; }
 public static < T extends Metric@@ Type > boolean addAll ( Collection < T > types ) { return types == null || types . size ( ) == 0 ? false : registry . add@@ Metric@@ Types ( types ) ; }
 public static < E > List < E > asList ( E ... elements ) { if ( elements == null || elements . length == 0 ) { return Collections . emptyList ( ) ; } return Arrays . asList ( elements ) ; }
 static public PsiElement find@@ Array@@ KeyValue@@ Inside@@ Reference ( PsiElement psiElement , String method@@ Reference@@ Name , String keyName ) { if ( psiElement == null ) { return null ; } Collection < Method@@ Reference > tests = PsiTreeUtil . find@@ Children@@ OfType ( psiElement , Method@@ Reference . class ) ; for ( Method@@ Reference method@@ Reference : tests ) { if ( Ph@@ p@@ Elements@@ Util . is@@ Equal@@ Method@@ Reference@@ Name ( method@@ Reference , method@@ Reference@@ Name ) ) { PsiElement [ ] parameters = method@@ Reference . getParameters ( ) ; if ( parameters . length > 0 && parameters [ 0 ] instanceof Array@@ Creation@@ Expression ) { PsiElement key@@ Value = Ph@@ p@@ Elements@@ Util . getArray@@ Value ( ( Array@@ Creation@@ Expression ) parameters [ 0 ] , keyName ) ; if ( key@@ Value != null ) { return key@@ Value ; } } } } return null ; }
 private static Configuration getConfiguration@@ With@@ Access@@ Key ( String access@@ Key ) { return getConfiguration ( null , access@@ Key , null ) ; }
 private static void check@@ Big@@ Query@@ Options ( String dataset , String table ) { Preconditions . checkArgument ( dataset != null , " Please ▁ specify ▁ - - big@@ Query@@ Dataset ▁ option ▁ if ▁ you ▁ want ▁ to ▁ publish ▁ to ▁ Big@@ Query " ) ; Preconditions . checkArgument ( table != null , " Please ▁ specify ▁ - - big@@ Query@@ Table ▁ option ▁ if ▁ you ▁ want ▁ to ▁ publish ▁ to ▁ Big@@ Query " ) ; }
 public static String get@@ Event ( Context context , String defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " event@@ Pref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static Object read@@ Class@@ And@@ Object ( ByteBuffer buffer ) throws IOException { Serializer@@ Registration reg = read@@ Class ( buffer ) ; if ( reg == NULL_@@ CLASS ) return null ; if ( reg == null ) throw new Serializer@@ Exception ( " Class ▁ not ▁ found ▁ for ▁ buffer ▁ data . " ) ; return reg . get@@ Serializer ( ) . readObject ( buffer , reg . getType ( ) ) ; }
 public static long reverse@@ Bytes ( long v ) { v = ( ( v >@@ >> 8 ) & 0x00@@ FF@@ 00@@ FF@@ 00@@ FF@@ 00@@ FF@@ L ) | ( ( v & 0x00@@ FF@@ 00@@ FF@@ 00@@ FF@@ 00@@ FF@@ L ) << 8 ) ; v = ( ( v >@@ >> 16 ) & 0x0000@@ FFFF@@ 0000@@ FFFF@@ L ) | ( ( v & 0x0000@@ FFFF@@ 0000@@ FFFF@@ L ) << 16 ) ; return ( ( v >@@ >> 32 ) ) | ( ( v ) << 32 ) ; }
 public static Header parse ( List < String > lines ) throws IOException { Header header = new Header ( ) ; lines . forEach ( line -> { if ( header . getRequest@@ Method ( ) == null ) { for ( RequestMethod request@@ Method : RequestMethod . values ( ) ) { if ( line . startsWith ( request@@ Method . name ( ) + " ▁ " ) ) { header . setRequest@@ URL ( line . split ( " ▁ " ) [ 1 ] ) ; header . setRequest@@ Method ( request@@ Method ) ; break ; } } } for ( Header@@ Field header@@ Field : Header@@ Field . values ( ) ) { if ( header@@ Field . getType ( ) != Header@@ Type . RESPONSE ) { if ( line . toLowerCase ( ) . startsWith ( header@@ Field . getName ( ) . toLowerCase ( ) + " : " ) ) { header@@ Field . setContent ( line . substring ( line . indexOf ( " : " ) + 1 , line . length ( ) ) . trim ( ) ) ; header . add@@ Header@@ Field ( header@@ Field ) ; } } } } ) ; return header ; }
 public static String [ ] getRe@@ dis@@ Sent@@ in@@ els ( ) { String str = ( String ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . RE@@ DIS@@ _S@@ ENT@@ IN@@ EL@@ S , key -> { try { return properties . get ( key ) ; } catch ( Property@@ NotFoundException e ) { throw new RuntimeException ( e ) ; } } ) ; Assert . has@@ Text ( str , ( ) -> Web@@ Config@@ Key . RE@@ DIS@@ _S@@ ENT@@ IN@@ EL@@ S + " can ▁ not ▁ be ▁ empty " ) ; return str . split ( " , " ) ; }
 @ Converter public static Q@@ CK_@@ Q@@ 02 to@@ Q@@ ck@@ Q@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( Q@@ CK_@@ Q@@ 02 . class , body ) ; }
 public static Collection < Application@@ Gateway@@ Tier > values ( ) { return values ( Application@@ Gateway@@ Tier . class ) ; }
 public static LocalDate to@@ LocalDate ( java . sql . Date d ) { LocalDate ld = ( d == null ? null : d . to@@ LocalDate ( ) ) ; return ld ; }
 public static void main ( String [ ] args ) { System . out . println ( load ( ) ) ; }
 public static void test_@@ local@@ D@@ ate_@@ shift_@@ java_@@ tz ( ) { System . out . println ( " Test ▁ LocalDate ▁ with ▁ shifted ▁ Java ▁ timezone " ) ; TimeZone original@@ TZ = TimeZone . getDefault ( ) ; TimeZone los@@ Ange@@ les@@ TZ = TimeZone . getTimeZone ( " America / Lo@@ s _ Ange@@ les " ) ; TimeZone . setDefault ( los@@ Ange@@ les@@ TZ ) ; LocalDate ld@@ 1 = LocalDate . now ( ) ; System . out . println ( " ld@@ 1 ▁ LocalDate ( ) ▁ ▁ ▁ = ▁ " + ld@@ 1 + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; java . sql . Date d = to@@ SQL@@ Date ( ld@@ 1 ) ; System . out . println ( " d ▁ to@@ SQL@@ Date ( ld@@ 1 ) ▁ ▁ = ▁ " + d + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; TimeZone . setDefault ( original@@ TZ ) ; System . out . println ( " d ▁ to@@ SQL@@ Date ( ld@@ 1 ) ▁ ▁ = ▁ " + d + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; LocalDate ld@@ 2 = to@@ LocalDate ( d ) ; System . out . println ( " ld@@ 2 ▁ to@@ LocalDate ( d ) ▁ = ▁ " + ld@@ 2 + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; TimeZone . setDefault ( original@@ TZ ) ; if ( ! ld@@ 2 . equals ( ld@@ 1 ) ) { throw new IllegalStateException ( ) ; } }
 private static Iterator@@ Test@@ Input get@@ Iterator@@ Input ( ) { Iterator@@ Setting setting = new Iterator@@ Setting ( 50 , Sum@@ ming@@ Combiner . class ) ; Long@@ Combiner . set@@ Encoding@@ Type ( setting , Long@@ Combiner . Type . STRING ) ; Combiner . set@@ Combine@@ All@@ Columns ( setting , true ) ; return new Iterator@@ Test@@ Input ( Sum@@ ming@@ Combiner . class , setting . getOptions ( ) , new Range ( ) , INPUT_@@ DATA ) ; }
 @ Converter public static AD@@ T_@@ A@@ 14 to@@ Ad@@ t@@ A@@ 14 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 14 . class , body ) ; }
 public static String get@@ Html@@ String ( String message ) { return message . replaceAll ( " < " , " & lt ; " ) . replaceAll ( " > " , " & gt ; " ) ; }
 public static void show@@ Mu@@ ted ( Activity activity , String message ) { Simple@@ Toast . muted ( activity , message ) ; }
 public static void render@@ Item@@ Custom ( ItemStack is , int rotation , float scale ) { if ( ! is . isEmpty ( ) ) { Gl@@ StateManager . push@@ Matrix ( ) ; Gl@@ StateManager . scale ( scale , scale , scale ) ; if ( rotation != 0 ) { Gl@@ StateManager . rotate ( rotation , 0F , 1F , 0F ) ; } custom@@ Render@@ Item ( is ) ; Gl@@ StateManager . pop@@ Matrix ( ) ; } }
 @ Converter public static R@@ RO_@@ O@@ 02 to@@ R@@ ro@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ RO_@@ O@@ 02 . class , body ) ; }
 private static Authenticator get@@ Direct@@ Bind@@ Authenticator ( final Ldap@@ Authentication@@ Properties l ) { if ( Common@@ Helper . isBlank ( l . getD@@ n@@ Format ( ) ) ) { throw new IllegalArgumentException ( " Dn ▁ format ▁ cannot ▁ be ▁ empty / blank ▁ for ▁ direct ▁ bind ▁ authentication " ) ; } final var resolver = new Format@@ Dn@@ Resolver ( l . getD@@ n@@ Format ( ) ) ; final var authenticator = new Authenticator ( resolver , getP@@ oo@@ led@@ Bind@@ Authentication@@ Handler ( l ) ) ; if ( l . is@@ Enhance@@ With@@ Entry@@ Resolver ( ) ) { authenticator . set@@ Entry@@ Resolver ( new@@ Search@@ Entry@@ Resolver ( l ) ) ; } return authenticator ; }
 private static EntityManager getE@@ m ( ) { Initial@@ Context ic ; try { ic = new Initial@@ Context ( ) ; return ( EntityManager ) ic . lookup ( " java : comp / env / blue@@ mix@@ bou@@ ti@@ que@@ pu / entity@@ manager " ) ; } catch ( NamingException e ) { System . out . println ( " ERROR ▁ obtaining ▁ EntityManager " ) ; e . printStackTrace ( ) ; } return null ; }
 public static < T extends Metric@@ Type > void set ( Collection < T > types ) { registry . set@@ Metric@@ Types ( types ) ; }
 @ Nullable static public Ph@@ p@@ Class getClass@@ Interface ( Project project , @ NotNull String className ) { if ( ! className . startsWith ( " \ \@@ " ) ) { className = " \ \@@ " + className ; } Collection < Ph@@ p@@ Class > php@@ Classes = Ph@@ p@@ Index . getInstance ( project ) . get@@ Any@@ By@@ FQ@@ N ( className ) ; return php@@ Classes . size ( ) == 0 ? null : php@@ Classes . iterator ( ) . next ( ) ; }
 public static FT@@ PS@@ Client create@@ Connection ( String hostname , int port , char [ ] username , char [ ] password , String working@@ Directory , FileSystem@@ Options file@@ System@@ Options , Integer default@@ Timeout ) throws FileSystem@@ Exception { if ( username == null ) { username = " anonymous " . toCharArray ( ) ; } if ( password == null ) { password = " anonymous " . toCharArray ( ) ; } try { final FT@@ PS@@ Client client ; if ( Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getF@@ t@@ ps@@ Type ( file@@ System@@ Options ) . equals ( " explicit " ) ) { client = new FT@@ PS@@ Client ( ) ; } else if ( Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getF@@ t@@ ps@@ Type ( file@@ System@@ Options ) . equals ( " implicit " ) ) { client = new FT@@ PS@@ Client ( true ) ; } else { throw new FileSystem@@ Exception ( " Invalid ▁ FT@@ PS ▁ type ▁ of ▁ " + Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getF@@ t@@ ps@@ Type ( file@@ System@@ Options ) + " ▁ specified . ▁ Must ▁ be ▁ ' implicit ' ▁ or ▁ ' explicit ' " ) ; } String key = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getEntry@@ Parser ( file@@ System@@ Options ) ; if ( key != null ) { FTP@@ ClientConfig config = new FTP@@ ClientConfig ( key ) ; String server@@ Language@@ Code = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getServer@@ Language@@ Code ( file@@ System@@ Options ) ; if ( server@@ Language@@ Code != null ) { config . set@@ Server@@ Language@@ Code ( server@@ Language@@ Code ) ; } String default@@ DateFormat = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getDefault@@ DateFormat ( file@@ System@@ Options ) ; if ( default@@ DateFormat != null ) { config . setDefault@@ DateFormat@@ Str ( default@@ DateFormat ) ; } String recent@@ DateFormat = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . get@@ Recent@@ DateFormat ( file@@ System@@ Options ) ; if ( recent@@ DateFormat != null ) { config . set@@ Recent@@ DateFormat@@ Str ( recent@@ DateFormat ) ; } String server@@ TimeZone@@ Id = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getServer@@ TimeZone@@ Id ( file@@ System@@ Options ) ; if ( server@@ TimeZone@@ Id != null ) { config . set@@ Server@@ TimeZone@@ Id ( server@@ TimeZone@@ Id ) ; } String [ ] short@@ Month@@ Names = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getShort@@ Month@@ Names ( file@@ System@@ Options ) ; if ( short@@ Month@@ Names != null ) { StringBuilder short@@ Month@@ Names@@ Str = new StringBuilder ( 40 ) ; for ( int i = 0 ; i < short@@ Month@@ Names . length ; i ++ ) { if ( short@@ Month@@ Names@@ Str . length ( ) > 0 ) { short@@ Month@@ Names@@ Str . append ( " | " ) ; } short@@ Month@@ Names@@ Str . append ( short@@ Month@@ Names [ i ] ) ; } config . set@@ Short@@ Month@@ Names ( short@@ Month@@ Names@@ Str . toString ( ) ) ; } client . configure ( config ) ; } FTP@@ File@@ Entry@@ ParserFactory my@@ Factory = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getEntry@@ ParserFactory ( file@@ System@@ Options ) ; if ( my@@ Factory != null ) { client . set@@ ParserFactory ( my@@ Factory ) ; } try { add@@ SSL@@ Parameters ( client , file@@ System@@ Options ) ; if ( default@@ Timeout != null && ( default@@ Timeout > 0 ) ) { client . setDefault@@ Timeout ( default@@ Timeout ) ; } client . connect ( hostname , port ) ; if ( default@@ Timeout != null && ( default@@ Timeout > 0 ) ) { client . set@@ So@@ Timeout ( default@@ Timeout ) ; } log . info ( " Successfully ▁ connected ▁ to ▁ the ▁ FTP ▁ server " ) ; int reply = client . getRe@@ ply@@ Code ( ) ; if ( ! FTP@@ Reply . is@@ Positive@@ Completion ( reply ) ) { throw new FileSystem@@ Exception ( " vfs . provider . ftp / connect - rejected . error " , hostname ) ; } if ( ! client . login ( User@@ Authenticator@@ Utils . toString ( username ) , User@@ Authenticator@@ Utils . toString ( password ) ) ) { throw new FileSystem@@ Exception ( " vfs . provider . ftp / login . error " , new Object [ ] { hostname , User@@ Authenticator@@ Utils . toString ( username ) } , null ) ; } Integer fileType = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getFile@@ Type ( file@@ System@@ Options ) ; if ( fileType == null ) { fileType = FTP . BINARY_@@ FILE_@@ TYPE ; } if ( ! client . set@@ FileType ( fileType ) ) { throw new FileSystem@@ Exception ( " vfs . provider . ftp / set - fileType . error " , hostname ) ; } Integer data@@ Timeout = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getData@@ Timeout ( file@@ System@@ Options ) ; if ( data@@ Timeout != null ) { client . setData@@ Timeout ( data@@ Timeout . intValue ( ) ) ; } Boolean user@@ Dir@@ Is@@ Root = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getUser@@ Dir@@ Is@@ Root ( file@@ System@@ Options ) ; if ( working@@ Directory != null && ( user@@ Dir@@ Is@@ Root == null || ! user@@ Dir@@ Is@@ Root . booleanValue ( ) ) ) { if ( ! client . change@@ WorkingDirectory ( working@@ Directory ) ) { throw new FileSystem@@ Exception ( " vfs . provider . ftp / change - work - directory . error " , working@@ Directory ) ; } } Boolean pas@@ sive@@ Mode = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getP@@ assive@@ Mode ( file@@ System@@ Options ) ; if ( pas@@ sive@@ Mode != null && pas@@ sive@@ Mode . booleanValue ( ) ) { client . enter@@ Local@@ Passive@@ Mode ( ) ; } } catch ( final IOException e ) { if ( client . isConnected ( ) ) { client . disconnect ( ) ; } throw e ; } return client ; } catch ( final Exception exc ) { log . error ( exc ) ; throw new FileSystem@@ Exception ( " vfs . provider . ftp / connect . error " , new Object [ ] { hostname } , exc ) ; } }
 public static void main ( String [ ] args ) { Iter@@ ative@@ Two i2 = new Iter@@ ative@@ Two ( ) ; System . out . println ( i2 . solution@@ Steps ( 3 ) ) ; }
 public static LocalDateTime to@@ LocalDateTime ( java . util . Date d ) { LocalDateTime ld@@ t = ( d == null ? null : d . to@@ Instant ( ) . at@@ Zone ( par@@ is ) . to@@ LocalDateTime ( ) ) ; return ld@@ t ; }
 public static synchronized void set@@ Metric@@ Collector ( Metric@@ Collector mc ) { Metric@@ Collector old = Aws@@ Sdk@@ Metrics . mc ; Aws@@ Sdk@@ Metrics . mc = mc ; if ( old != null ) { old . stop ( ) ; } }
 @ Converter public static MD@@ M_@@ T@@ 07 to@@ M@@ dm@@ T@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 07 . class , body ) ; }
 public static boolean has@@ Generics ( @ Nullable Py@@ Type type , @ NotNull Type@@ Eval@@ Context context ) { final Set < Py@@ Generic@@ Type > collected = new HashSet < > ( ) ; collect@@ Generics ( type , context , collected , new HashSet < > ( ) ) ; return ! collected . isEmpty ( ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ SQ@@ RT@@ 2 ( ) { float a = 1.@@ f / 25@@ 6.@@ f ; return new float [ ] { 1 * a , 5 * a , 13 * a , 13 * a , - 14 * a , - 36 * a , - 14 * a , 13 * a , 13 * a , 5 * a , 1 * a } ; }
 public static String toHexString ( long v ) { return Integr@@ al@@ ToString . long@@ To@@ HexString ( v ) ; }
 public static void put@@ Current@@ Feed@@ Position ( final Context context , final int position ) { put@@ Previous@@ Feed@@ Position ( context , getCurrent@@ Feed@@ Position ( context ) ) ; put ( context , KEY_@@ CURRENT_@@ FE@@ ED_@@ POSITION , position ) ; }
 public static Redis@@ Type getRe@@ dis@@ Type ( ) { return ( Redis@@ Type ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . RE@@ DI@@ S_@@ TYPE , key -> properties . get@@ EnumValue ( key , Web@@ Config@@ Default . RE@@ DI@@ S_@@ TYPE , true ) ) ; }
 public static void run@@ File@@ Template ( Project project , VirtualFile file , String template@@ Name ) throws IOException { run@@ Or@@ Apply@@ File@@ Template ( project , file , template@@ Name , new Properties ( ) , new Properties ( ) , true ) ; }
 public static String toString ( @ Image@@ Load@@ Status int image@@ Load@@ Status ) { switch ( image@@ Load@@ Status ) { case Image@@ Load@@ Status . REQUEST@@ ED : return " requested " ; case Image@@ Load@@ Status . ORIG@@ IN_@@ AVAILABLE : return " origin _ available " ; case Image@@ Load@@ Status . SUCCESS : return " success " ; case Image@@ Load@@ Status . CANCE@@ LED : return " canceled " ; case Image@@ Load@@ Status . INTER@@ MEDI@@ ATE_@@ AVAILABLE : return " intermediate _ available " ; case Image@@ Load@@ Status . ERROR : return " error " ; default : return " unknown " ; } }
 public static String getLog@@ Path@@ FileName@@ Ste@@ m ( ) { String ip ; if ( H2@@ O . SE@@ LF_@@ ADDRESS == null ) { ip = " Unknown@@ IP " ; } else { ip = H2@@ O . SE@@ LF_@@ ADDRESS . getHost@@ Address ( ) ; } int port = H2@@ O . API_@@ PORT ; String port@@ String = Integer . toString ( port ) ; String log@@ FileName = getLog@@ Dir ( ) + File . separator + " h2o _ " + ip + " _ " + port@@ String ; return log@@ FileName ; }
 private static void prepare@@ Tables ( ) throws IOException { create@@ HBase@@ Table@@ 1 ( ) ; create@@ HBase@@ Table@@ 2 ( ) ; create@@ HBase@@ Table@@ 3 ( ) ; }
 public static void show@@ Info ( Activity activity , int message ) { Simple@@ Toast . info ( activity , activity . getResources ( ) . getString ( message ) ) ; }
 public static Serializer@@ Registration get@@ Serializer@@ Registration ( Class cls , boolean fail@@ On@@ Mis@@ s ) { Serializer@@ Registration reg = class@@ Registr@@ ations . get ( cls ) ; if ( reg != null ) return reg ; for ( Map . Entry < Class , Serializer@@ Registration > entry : class@@ Registr@@ ations . entrySet ( ) ) { if ( entry . getKey ( ) . isAssignableFrom ( Serializable . class ) ) continue ; if ( entry . getKey ( ) . isAssignableFrom ( cls ) ) return entry . getValue ( ) ; } if ( cls . isArray ( ) ) return register@@ Class ( cls , array@@ Serializer ) ; if ( Serializable . class . isAssignableFrom ( cls ) ) { return get@@ Exact@@ Serializer@@ Registration ( java . io . Serializable . class ) ; } if ( cls . is@@ Annotation@@ Present ( Serializable . class ) ) { Serializable serializable = ( Serializable ) cls . getAnnotation ( Serializable . class ) ; short class@@ Id = serializable . id ( ) ; if ( class@@ Id != 0 ) { fail@@ On@@ Mis@@ s = false ; } } if ( fail@@ On@@ Mis@@ s ) { throw new IllegalArgumentException ( " Class ▁ has ▁ not ▁ been ▁ registered : " + cls ) ; } return register@@ Class ( cls , field@@ Serializer ) ; }
 static void configure@@ S@@ sl ( Binder binder ) { final SSLContext context ; try { context = SSLContext . getDefault ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } binder . bind ( SSLContext . class ) . to@@ Provider ( Providers . of ( context ) ) . in ( Lazy@@ Singleton . class ) ; }
 private static boolean match ( @ NotNull Py@@ Generic@@ Type expected , @ Nullable Py@@ Type actual , @ NotNull Match@@ Context context ) { final Py@@ Type substitution = context . substitutions . get ( expected ) ; Py@@ Type bound = expected . get@@ Bound ( ) ; if ( expected . is@@ Definition ( ) && bound instanceof Py@@ Instanti@@ able@@ Type ) { bound = ( ( Py@@ Instanti@@ able@@ Type ) bound ) . to@@ Class ( ) ; } Optional < Boolean > match = match ( bound , actual , context ) ; if ( match . isPresent ( ) && ! match . get ( ) ) { return false ; } if ( substitution != null ) { if ( expected . equals ( actual ) || substitution . equals ( expected ) ) { return true ; } if ( context . recursive ) { Optional < Boolean > recursive@@ Match = match ( substitution , actual , context . not@@ Recursive ( ) ) ; if ( recursive@@ Match . isPresent ( ) ) { return recursive@@ Match . get ( ) ; } } return false ; } if ( actual != null ) { context . substitutions . put ( expected , actual ) ; } else if ( bound != null ) { context . substitutions . put ( expected , bound ) ; } return true ; }
 public static boolean is@@ Variable@@ Defin@@ ite@@ ly@@ Assigned ( @ NotNull final Psi@@ Variable variable , @ NotNull final Control@@ Flow flow ) { final int variable@@ Declaration@@ Offset = flow . getStartOffset ( variable . getParent ( ) ) ; int offset = variable@@ Declaration@@ Offset > - 1 ? variable@@ Declaration@@ Offset : 0 ; boolean [ ] un@@ assigned@@ Offsets = getVariable@@ Possi@@ b@@ ly@@ Un@@ assigned@@ Offsets ( variable , flow ) ; return ! un@@ assigned@@ Offsets [ offset ] ; }
 @ Converter public static AD@@ T_@@ A@@ 50 to@@ Ad@@ t@@ A@@ 50 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 50 . class , body ) ; }
 public static void start@@ Stat ( Flat@@ Buffer@@ Builder builder ) { builder . startObject ( 3 ) ; }
 static BigInteger fi@@ bon@@ ac@@ ci ( int n ) { if ( fi@@ b [ n ] == null ) { if ( ( n == 1 ) || ( n == 2 ) ) { fi@@ b [ n ] = BigInteger . valueOf ( 1 ) ; } else { fi@@ b [ n ] = fi@@ bon@@ ac@@ ci ( n - 1 ) . add ( fi@@ bon@@ ac@@ ci ( n - 2 ) ) ; } } return fi@@ b [ n ] ; }
 private static boolean match ( @ NotNull Py@@ Struc@@ tur@@ alType expected , @ NotNull Py@@ Struc@@ tur@@ alType actual ) { if ( expected . isIn@@ ferred@@ From@@ Usages ( ) ) { return true ; } return expected . getAttribute@@ Names ( ) . containsAll ( actual . getAttribute@@ Names ( ) ) ; }
 @ Converter public static PP@@ T_@@ PC@@ L to@@ P@@ pt@@ P@@ cl ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ T_@@ PC@@ L . class , body ) ; }
 public static boolean is@@ TestClass ( @ NotNull Ph@@ p@@ Class php@@ Class ) { if ( Ph@@ p@@ Unit@@ Util . is@@ TestClass ( php@@ Class ) ) { return true ; } String fq@@ n = php@@ Class . get@@ Presentable@@ FQ@@ N ( ) ; if ( fq@@ n == null ) { return false ; } return fq@@ n . contains ( " \\ Test@@ \ \@@ " ) || fq@@ n . contains ( " \\ Test@@ s\ \@@ " ) ; }
 public static Process@@ Runtime@@ Factory@@ Service getProcess@@ Runtime@@ Factory@@ Service ( ) { return provider ; }
 public static Metric < Long > gen@@ Counter@@ Def ( ) { return ( Metric < Long > ) gen@@ Def ( Metric@@ Type . COUNTER ) ; }
 public static Group newInstance ( ) { Group group = new Group ( ) ; group . set@@ Attribu@@ table@@ Type ( ATTRIBU@@ TABLE_@@ TYPE ) ; return group ; }
 public static < I extends Writable@@ Comparable , V extends Writable , E extends Writable , M extends Writable > void assert@@ Valid ( Basic@@ Vertex < I , V , E , M > expected , Basic@@ Vertex < I , V , E , M > actual ) { assertEquals ( expected . getVertex@@ Id ( ) , actual . getVertex@@ Id ( ) ) ; assertEquals ( expected . getVertex@@ Value ( ) , actual . getVertex@@ Value ( ) ) ; assertEquals ( expected . getNum@@ Edges ( ) , actual . getNum@@ Edges ( ) ) ; List < Edge < I , E > > expected@@ Edges = Lists . newArrayList ( ) ; List < Edge < I , E > > actual@@ Edges = Lists . newArrayList ( ) ; for ( I actual@@ Dest@@ Id : actual ) { actual@@ Edges . add ( new Edge < I , E > ( actual@@ Dest@@ Id , actual . getEdge@@ Value ( actual@@ Dest@@ Id ) ) ) ; } for ( I expected@@ Dest@@ Id : expected ) { expected@@ Edges . add ( new Edge < I , E > ( expected@@ Dest@@ Id , expected . getEdge@@ Value ( expected@@ Dest@@ Id ) ) ) ; } Collections . sort ( expected@@ Edges ) ; Collections . sort ( actual@@ Edges ) ; for ( int i = 0 ; i < expected@@ Edges . size ( ) ; i ++ ) { assertEquals ( expected@@ Edges . get ( i ) , actual@@ Edges . get ( i ) ) ; } }
 @ Converter public static SR@@ R@@ _S@@ 03 to@@ S@@ rr@@ S@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 03 . class , body ) ; }
 @ AfterClass public static void tearDown@@ AfterClass ( ) throws Exception { if ( client != null ) { client . destroy ( ) ; client = null ; } }
 @ Converter public static AD@@ T_@@ A@@ 01 to@@ Ad@@ t@@ A@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 01 . class , body ) ; }
 static public < T extends Throwable > T err ( T exception ) { return err ( Sys . WATER , " " , exception ) ; }
 @ Nullable private static PsiElement getUn@@ reachable@@ Expression@@ Parent ( @ Nullable PsiElement element ) { if ( element instanceof PsiExpression ) { final PsiElement expression = PsiTreeUtil . find@@ First@@ Parent ( element , e -> ! ( e . getParent ( ) instanceof Psi@@ Parenthe@@ sized@@ Expression ) ) ; if ( expression != null ) { final PsiElement parent = expression . getParent ( ) ; if ( parent instanceof Psi@@ Expression@@ Statement ) { return getUn@@ reachable@@ Statement@@ Parent ( parent ) ; } if ( parent instanceof Psi@@ If@@ Statement && ( ( Psi@@ If@@ Statement ) parent ) . getCondition ( ) == expression || parent instanceof Psi@@ Switch@@ Block && ( ( Psi@@ Switch@@ Block ) parent ) . getExpression ( ) == expression || parent instanceof Psi@@ While@@ Statement && ( ( Psi@@ While@@ Statement ) parent ) . getCondition ( ) == expression || parent instanceof Psi@@ Fore@@ ach@@ Statement && ( ( Psi@@ Fore@@ ach@@ Statement ) parent ) . get@@ Iter@@ ated@@ Value ( ) == expression ) { return parent ; } } } return null ; }
 @ Converter public static SR@@ M_S@@ 10 to@@ S@@ rm@@ S@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 10 . class , body ) ; }
 public static ZonedDateTime to@@ Date@@ Mid@@ night ( java . sql . Date d ) { ZonedDateTime dm = ( d == null ? null : d . to@@ LocalDate ( ) . at@@ StartOf@@ Day ( par@@ is ) ) ; return dm ; }
 @ Converter public static SR@@ M_S@@ 04 to@@ S@@ rm@@ S@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 04 . class , body ) ; }
 public static String get@@ Admin@@ Dashboard@@ Br@@ and@@ Icon ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ D@@ ASH@@ BOARD_@@ BRAN@@ D_@@ ICON , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ D@@ ASH@@ BOARD_@@ BRAN@@ D_@@ ICON , Web@@ Config@@ Default . WEB_@@ ADMIN_@@ D@@ ASH@@ BOARD_@@ BRAN@@ D_@@ ICON ) ; } } ) ; return ( String ) cached@@ Config ; }
 private static boolean get@@ Roll@@ up@@ Rules ( Node i@@ Node , Seq@@ Activity io@@ Act ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " get@@ Roll@@ up@@ Rules " ) ; } boolean ok = true ; String temp@@ Val = null ; List < Seq@@ Roll@@ up@@ Rule > roll@@ up@@ Rules = new ArrayList < Seq@@ Roll@@ up@@ Rule > ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " roll@@ up@@ Objective@@ Satisfied " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setIs@@ Obj@@ Rol@@ led@@ Up ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " objec@@ tive@@ Measure@@ Weight " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Obj@@ Measure@@ Weight ( ( new Double ( temp@@ Val ) ) . doubleValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " roll@@ up@@ Progress@@ Completion " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setIs@@ Progress@@ Rol@@ led@@ Up ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " roll@@ up@@ Rule " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < roll@@ up@@ Rule > ▁ " + " element " ) ; } Seq@@ Roll@@ up@@ Rule rule = new Seq@@ Roll@@ up@@ Rule ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " child@@ Activity@@ Set " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { rule . m@@ Child@@ Activity@@ Set = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " minimum@@ Count " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { rule . mMin@@ Count = ( Long . valueOf ( temp@@ Val ) ) . longValue ( ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " minimum@@ Percent " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { rule . mMin@@ Percent = ( new Double ( temp@@ Val ) ) . doubleValue ( ) ; } } rule . m@@ Conditions = new Seq@@ Condition@@ Set ( true ) ; List < Seq@@ Condition > conditions = new ArrayList < Seq@@ Condition > ( ) ; NodeList rule@@ Info = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < rule@@ Info . getLength ( ) ; j ++ ) { Node cur@@ Rule = rule@@ Info . item ( j ) ; if ( cur@@ Rule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( cur@@ Rule . getLocalName ( ) . equals ( " roll@@ up@@ Conditions " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < roll@@ up@@ Conditions > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Rule , " condition@@ Combination " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { rule . m@@ Conditions . m@@ Combination = temp@@ Val ; } } else { rule . m@@ Conditions . m@@ Combination = Seq@@ Condition@@ Set . COMBIN@@ ATION_@@ ANY ; } NodeList con@@ ds = cur@@ Rule . getChildNodes ( ) ; for ( int k = 0 ; k < con@@ ds . getLength ( ) ; k ++ ) { Node con = con@@ ds . item ( k ) ; if ( con . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( con . getLocalName ( ) . equals ( " roll@@ up@@ Condition " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < roll@@ up@@ Condition > ▁ " + " element " ) ; } Seq@@ Condition cond = new Seq@@ Condition ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( con , " condition " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { cond . m@@ Condition = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( con , " operator " ) ; if ( temp@@ Val != null ) { if ( temp@@ Val . equals ( " not " ) ) { cond . m@@ Not = true ; } else { cond . m@@ Not = false ; } } conditions . add ( cond ) ; } } } } else if ( cur@@ Rule . getLocalName ( ) . equals ( " roll@@ up@@ Action " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < roll@@ up@@ Action > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Rule , " action " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { rule . set@@ Roll@@ up@@ Action ( temp@@ Val ) ; } } } } } rule . m@@ Conditions . m@@ Conditions = conditions ; roll@@ up@@ Rules . add ( rule ) ; } } } if ( roll@@ up@@ Rules != null ) { I@@ Seq@@ Roll@@ up@@ Rule@@ set rules = new Seq@@ Roll@@ up@@ Rule@@ set ( roll@@ up@@ Rules ) ; io@@ Act . set@@ Roll@@ up@@ Rules ( rules ) ; } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " get@@ Roll@@ up@@ Rules " ) ; } return ok ; }
 public static void create@@ Json ( ) { String Create@@ String = " { } " ; File file = new File ( Player@@ G@@ low . getInstance ( ) . getConfig@@ Dir ( ) , " color@@ Data . json " ) ; if ( ! file . exists ( ) ) { try { create ( " color@@ Data . json " , Create@@ String ) ; } catch ( IOException e1 ) { Player@@ G@@ low . getInstance ( ) . getLogger ( ) . error ( " [ Player@@ G@@ low ] ▁ Error ▁ writing ▁ config ▁ file ! " ) ; } } }
 private static void validate@@ Sql@@ Server@@ NotFound ( Sql@@ Server sql@@ Server ) { Assert . assertNull ( sql@@ Server@@ Manager . sql@@ Servers ( ) . get@@ ById ( sql@@ Server . id ( ) ) ) ; }
 @ Converter public static R@@ RI@@ _@@ I@@ 12 to@@ R@@ ri@@ I@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ RI@@ _@@ I@@ 12 . class , body ) ; }
 public static boolean get@@ Sensitive@@ Logging ( ) { return settings . getBoolean ( GLOB@@ AL@@ _SETT@@ ING_S@@ EN@@ SI@@ TIVE_@@ LOGGING , false ) ; }
 public static long reverse ( long v ) { v = ( ( v >@@ >> 1 ) & 0x5@@ 5555@@ 5555@@ 5555@@ 55@@ 5L ) | ( ( v & 0x5@@ 5555@@ 5555@@ 5555@@ 55@@ 5L ) << 1 ) ; v = ( ( v >@@ >> 2 ) & 0x3@@ 33333333@@ 333333@@ 3L ) | ( ( v & 0x3@@ 33333333@@ 333333@@ 3L ) << 2 ) ; v = ( ( v >@@ >> 4 ) & 0x0@@ F@@ 0F@@ 0F@@ 0F@@ 0F@@ 0F@@ 0F@@ 0@@ FL ) | ( ( v & 0x0@@ F@@ 0F@@ 0F@@ 0F@@ 0F@@ 0F@@ 0F@@ 0@@ FL ) << 4 ) ; v = ( ( v >@@ >> 8 ) & 0x00@@ FF@@ 00@@ FF@@ 00@@ FF@@ 00@@ FF@@ L ) | ( ( v & 0x00@@ FF@@ 00@@ FF@@ 00@@ FF@@ 00@@ FF@@ L ) << 8 ) ; v = ( ( v >@@ >> 16 ) & 0x0000@@ FFFF@@ 0000@@ FFFF@@ L ) | ( ( v & 0x0000@@ FFFF@@ 0000@@ FFFF@@ L ) << 16 ) ; return ( ( v >@@ >> 32 ) ) | ( ( v ) << 32 ) ; }
 public static String toString ( long n ) { return Integr@@ al@@ ToString . long@@ ToString ( n ) ; }
 public static java . util . Date to@@ Java@@ Date ( LocalDate ld ) { java . util . Date d = ( ld == null ? null : Date . from ( ld . at@@ StartOf@@ Day ( par@@ is ) . to@@ Instant ( ) ) ) ; return d ; }
 private static int [ ] gen@@ Digit@@ Fac@@ tori@@ als ( ) { int [ ] res = new int [ 10 ] ; res [ 0 ] = 1 ; int f = 1 ; for ( int i = 1 ; i < 10 ; i ++ ) { f *= i ; res [ i ] = f ; } return res ; }
 public static void main ( String [ ] ag ) { String resultCode = get@@ Security@@ Code ( 6 , Security@@ Code@@ Level . Medium , true ) ; System . out . println ( resultCode ) ; }
 public static String getRegion@@ Name ( ) { return region == null ? null : region . getName ( ) ; }
 public static void validate@@ Range@@ Request ( long resource@@ Size , long range@@ Start , long range@@ End ) { if ( range@@ Start < 0 ) { throw new IllegalArgumentException ( String . format ( " range@@ Start ▁ = ▁ % d ▁ is ▁ < ▁ 0" , range@@ Start ) ) ; } if ( range@@ Start > range@@ End ) { throw new IllegalArgumentException ( String . format ( " range@@ Start ▁ = ▁ % d ▁ is ▁ not ▁ < = ▁ % d ▁ range@@ End " , range@@ Start , range@@ End ) ) ; } if ( range@@ End > ( resource@@ Size - 1 ) ) { throw new IllegalArgumentException ( String . format ( " range@@ End ▁ = ▁ % d ▁ is ▁ not ▁ < = ▁ ( resource@@ Size ▁ - 1 ) ▁ = ▁ % d " , range@@ End , ( resource@@ Size - 1 ) ) ) ; } }
 @ Converter public static R@@ Q@@ A_@@ I@@ 10 to@@ R@@ q@@ a@@ I@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ A_@@ I@@ 10 . class , body ) ; }
 @ TargetApi ( 16 ) private static void assert@@ Optional@@ V@@ 16 ( Media@@ Format format , String key , float value ) { if ( value == Format . NO_@@ VALUE ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getFloat ( key ) ) . isEqualTo ( value ) ; } }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return class_@@ NAME ; case 2 : return PROPERTIES ; default : return null ; } }
 public static boolean is@@ Metric@@ Admin@@ MBean@@ Registered ( ) { Sdk@@ MBean@@ Registry registry = Sdk@@ MBean@@ Registry . Factory . get@@ MBean@@ Registry ( ) ; return registered@@ Admin@@ M@@ bean@@ Name != null && registry . is@@ MBean@@ Registered ( registered@@ Admin@@ M@@ bean@@ Name ) ; }
 private static void create@@ HBase@@ Table@@ 3 ( ) { byte [ ] [ ] families = new byte [ ] [ ] { Bytes . toBytes ( FAMIL@@ Y1 ) , Bytes . toBytes ( FAMIL@@ Y2 ) , Bytes . toBytes ( FAMIL@@ Y@@ 3 ) , Bytes . toBytes ( FAMIL@@ Y@@ 4 ) , } ; TableName tableName = TableName . valueOf ( TEST_@@ TABLE_@@ 3 ) ; createTable ( tableName , families , SP@@ LIT_@@ KEYS ) ; }
 @ BeforeClass public static void init ( ) { final Framework framework = Framework . getInstance ( ) ; framework . init ( ) ; }
 public static String [ ] getSub@@ scription@@ Categories ( final Context context , final boolean edit ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final Set < String > categories = new TreeSet < > ( ) ; if ( ! edit ) { categories . add ( context . getString ( R . string . all_@@ categories ) ) ; } else { categories . add ( context . getString ( R . string . clear_@@ category ) ) ; } for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { categories . add ( subscriptions . get ( title ) . get ( 0 ) ) ; } return categories . toArray ( new String [ categories . size ( ) ] ) ; }
 public static List < VirtualFile > collect@@ Files ( Collection < MavenProject > projects ) { return ContainerUtil . map ( projects , new Function < MavenProject , VirtualFile > ( ) { public VirtualFile fun ( MavenProject project ) { return project . getFile ( ) ; } } ) ; }
 public static int getMax@@ Speech@@ Input@@ Length ( ) { return 4000 ; }
 @ Deprecated static public PsiElement [ ] getClass@@ Interface@@ Psi@@ Elements ( Project project , String FQ@@ N@@ Class@@ Or@@ Interface@@ Name ) { List < PsiElement > results = new ArrayList < PsiElement > ( ) ; for ( ResolveResult result : getClass@@ Interface@@ ResolveResult ( project , FQ@@ N@@ Class@@ Or@@ Interface@@ Name ) ) { results . add ( result . getElement ( ) ) ; } return results . toArray ( new PsiElement [ results . size ( ) ] ) ; }
 protected static Map < Integer , Location > to@@ Location@@ Map ( ResultSet resultSet ) throws SQLException { Map < Integer , Location > result = new HashMap < Integer , Location > ( ) ; while ( resultSet . next ( ) ) { Location location = new Location ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getInt ( 3 ) , resultSet . getInt ( 4 ) ) ; result . put ( resultSet . getInt ( 1 ) , location ) ; } return result ; }
 @ Converter public static SR@@ R@@ _S@@ 09 to@@ S@@ rr@@ S@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 09 . class , body ) ; }
 @ Converter public static SI@@ U@@ _S@@ 26 to@@ Si@@ u@@ S@@ 26 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 26 . class , body ) ; }
 public static Parsed@@ Value@@ Count from@@ XContent ( XContentParser parser , final String name ) { Parsed@@ Value@@ Count sum = PARSER . apply ( parser , null ) ; sum . setName ( name ) ; return sum ; }
 public static void test@@ Collections ( ) throws SQLException { Class@@ F f = new Class@@ F ( ) ; f . set@@ F2 ( " F@@ 1" ) ; List < String > search = new ArrayList < > ( ) ; search . add ( " f@@ 2" ) ; List < Class@@ F > loaded@@ F = broker . load@@ Entities ( f , null , true ) ; for ( Class@@ F fe : loaded@@ F ) { System . out . println ( fe ) ; } }
 public static void show@@ Warning ( Activity activity , int message ) { Simple@@ Toast . warning ( activity , activity . getResources ( ) . getString ( message ) ) ; }
 @ Converter public static SI@@ U@@ _S@@ 20 to@@ Si@@ u@@ S@@ 20 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 20 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 20 to@@ Ad@@ t@@ A@@ 20 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 20 . class , body ) ; }
 public static boolean isDebug@@ Mode ( ) { return getProject@@ Mode ( ) . equals ( Project@@ Mode . DEVELO@@ P ) || getProject@@ Mode ( ) . equals ( Project@@ Mode . DEBUG ) ; }
 public static N@@ v@@ GLSL@@ Program createFrom@@ Files ( GL@@ 4 gl@@ 4 , String root , String shader@@ Name , boolean strict ) { ShaderProgram shader@@ Program = new ShaderProgram ( ) ; Shader@@ Code vert@@ Shader@@ Code = Shader@@ Code . create ( gl@@ 4 , GL_@@ VERTEX@@ _SHA@@ DER , N@@ v@@ GLSL@@ Program . class , root , null , shader@@ Name , " vert " , null , true ) ; Shader@@ Code frag@@ Shader@@ Code = Shader@@ Code . create ( gl@@ 4 , GL_@@ FRAGMENT_@@ SHADER , N@@ v@@ GLSL@@ Program . class , root , null , shader@@ Name , " frag " , null , true ) ; shader@@ Program . add ( vert@@ Shader@@ Code ) ; shader@@ Program . add ( frag@@ Shader@@ Code ) ; shader@@ Program . init ( gl@@ 4 ) ; shader@@ Program . link ( gl@@ 4 , System . out ) ; return new N@@ v@@ GLSL@@ Program ( shader@@ Program . program ( ) , strict ) ; }
 @ Converter public static CR@@ M_@@ C@@ 06 to@@ C@@ rm@@ C@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 06 . class , body ) ; }
 @ Nullable private static PsiElement get@@ PsiElement ( Inspection@@ Results@@ View view ) { final Ref@@ Entity [ ] selected@@ Elements = view . get@@ Tree ( ) . getSelected@@ Elements ( ) ; final PsiElement psiElement ; if ( selected@@ Elements . length > 0 && selected@@ Elements [ 0 ] instanceof Ref@@ Element ) { psiElement = ( ( Ref@@ Element ) selected@@ Elements [ 0 ] ) . getElement ( ) ; } else { psiElement = null ; } return psiElement ; }
 public static String join ( String connector , Object ... objects ) { StringBuffer s@@ Buffer = new StringBuffer ( ) ; for ( Object object : objects ) { s@@ Buffer . append ( object ) . append ( connector ) ; } if ( s@@ Buffer . length ( ) > 0 ) { s@@ Buffer . delete ( s@@ Buffer . length ( ) - connector . length ( ) , s@@ Buffer . length ( ) ) ; } return s@@ Buffer . toString ( ) ; }
 public static void set@@ Graph@@ State ( Basic@@ Vertex vertex , Graph@@ State graph@@ State ) throws Exception { Class < ? extends Basic@@ Vertex > c = Basic@@ Vertex . class ; Method m = c . getDeclared@@ Method ( " set@@ Graph@@ State " , Graph@@ State . class ) ; m . setAccessible ( true ) ; m . invoke ( vertex , graph@@ State ) ; }
 public static LocalTime to@@ LocalTime ( String s ) { LocalTime lt = ( s == null ? null : LocalTime . parse ( s ) ) ; return lt ; }
 private static void load@@ Form@@ Str ( ) { Fore@@ st forest = new Fore@@ st ( ) ; Value value = new Value ( " 三@@ 个@@ 和@@ 尚 " , " 三@@ 个 " , " m " , " 和@@ 尚 " , " n " ) ; Library . insert@@ Word ( forest , value ) ; User@@ Define@@ Library . ambigu@@ ity@@ Fore@@ st = forest ; }
 public static < A , B > List < B > map ( Function < A , B > fn , List < A > as ) { return null ; }
 private static void internal@@ Depth@@ First@@ Search ( @ NotNull List < ? extends Instruction > instructions , @ NotNull Instruction@@ Client@@ Visitor client@@ Visitor , int startOffset , int endOffset ) { final Walk@@ Through@@ Stack walk@@ Through@@ Stack = new Walk@@ Through@@ Stack ( instructions . size ( ) / 2 ) ; walk@@ Through@@ Stack . push ( startOffset ) ; synchronized ( instructions ) { final Int@@ ArrayList current@@ Procedure@@ Return@@ Offsets = new Int@@ ArrayList ( ) ; ControlFlow@@ Instruction@@ Visitor getNext@@ Offset@@ Visitor = new ControlFlow@@ Instruction@@ Visitor ( ) { @ Override public void visit@@ Call@@ Instruction ( Call@@ Instruction instruction , int offset , int next@@ Offset ) { instruction . execute ( offset + 1 ) ; int new@@ Offset = instruction . offset ; int i ; for ( i = instruction . proc@@ Begin ; i < client@@ Visitor . processed@@ Instructions . length && ( i < instruction . proc@@ End || i < instructions . size ( ) && instructions . get ( i ) instanceof Return@@ Instruction ) ; i ++ ) { client@@ Visitor . processed@@ Instructions [ i ] = false ; } client@@ Visitor . proce@@ dure@@ Entered ( instruction . proc@@ Begin , i ) ; walk@@ Through@@ Stack . push ( offset , new@@ Offset ) ; walk@@ Through@@ Stack . push ( new@@ Offset ) ; current@@ Procedure@@ Return@@ Offsets . add ( offset + 1 ) ; } @ Override public void visit@@ Return@@ Instruction ( Return@@ Instruction instruction , int offset , int next@@ Offset ) { int new@@ Offset = instruction . execute ( false ) ; if ( new@@ Offset != - 1 ) { walk@@ Through@@ Stack . push ( offset , new@@ Offset ) ; walk@@ Through@@ Stack . push ( new@@ Offset ) ; } } @ Override public void visit@@ Branch@@ ing@@ Instruction ( Branch@@ ing@@ Instruction instruction , int offset , int next@@ Offset ) { int new@@ Offset = instruction . offset ; walk@@ Through@@ Stack . push ( offset , new@@ Offset ) ; walk@@ Through@@ Stack . push ( new@@ Offset ) ; } @ Override public void visit@@ Conditional@@ Branch@@ ing@@ Instruction ( Conditional@@ Branch@@ ing@@ Instruction instruction , int offset , int next@@ Offset ) { int new@@ Offset = instruction . offset ; walk@@ Through@@ Stack . push ( offset , new@@ Offset ) ; walk@@ Through@@ Stack . push ( offset , offset + 1 ) ; walk@@ Through@@ Stack . push ( new@@ Offset ) ; walk@@ Through@@ Stack . push ( offset + 1 ) ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { int new@@ Offset = offset + 1 ; walk@@ Through@@ Stack . push ( offset , new@@ Offset ) ; walk@@ Through@@ Stack . push ( new@@ Offset ) ; } } ; while ( ! walk@@ Through@@ Stack . isEmpty ( ) ) { final int offset = walk@@ Through@@ Stack . peek@@ Old@@ Offset ( ) ; final int new@@ Offset = walk@@ Through@@ Stack . pop@@ New@@ Offset ( ) ; if ( offset >= endOffset ) { continue ; } Instruction instruction = instructions . get ( offset ) ; if ( client@@ Visitor . processed@@ Instructions [ offset ] ) { if ( new@@ Offset != - 1 ) { instruction . accept ( client@@ Visitor , offset , new@@ Offset ) ; } if ( ! current@@ Procedure@@ Return@@ Offsets . isEmpty ( ) && current@@ Procedure@@ Return@@ Offsets . get ( current@@ Procedure@@ Return@@ Offsets . size ( ) - 1 ) - 1 == offset ) { current@@ Procedure@@ Return@@ Offsets . remove ( current@@ Procedure@@ Return@@ Offsets . size ( ) - 1 ) ; } continue ; } if ( ! current@@ Procedure@@ Return@@ Offsets . isEmpty ( ) ) { int return@@ Offset = current@@ Procedure@@ Return@@ Offsets . get ( current@@ Procedure@@ Return@@ Offsets . size ( ) - 1 ) ; Call@@ Instruction call@@ Instruction = ( Call@@ Instruction ) instructions . get ( return@@ Offset - 1 ) ; synchronized ( call@@ Instruction . stack ) { if ( call@@ Instruction . proc@@ Begin <= offset && offset < call@@ Instruction . proc@@ End + 2 && ( call@@ Instruction . stack . size ( ) == 0 || call@@ Instruction . stack . peek@@ Return@@ Offset ( ) != return@@ Offset ) ) { call@@ Instruction . stack . push ( return@@ Offset , call@@ Instruction ) ; } } } client@@ Visitor . processed@@ Instructions [ offset ] = true ; instruction . accept ( getNext@@ Offset@@ Visitor , offset , new@@ Offset ) ; } } }
 public static void set@@ Geo@@ Names@@ Username ( String value ) { Plugin@@ Options . setOption ( Selection@@ Action@@ Geo@@ Names . GE@@ ON@@ AME@@ S_@@ USERNAME , value ) ; }
 @ Converter public static MF@@ N_@@ M@@ 06 to@@ M@@ fn@@ M@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 06 . class , body ) ; }
 public static void set@@ Force@@ TypeOf@@ Http@@ Requests ( Force@@ TypeOf@@ HttpRequest force@@ TypeOf@@ Http@@ Requests ) { Sc@@ ri@@ be@@ Java@@ Config . force@@ TypeOf@@ Http@@ Requests = force@@ TypeOf@@ Http@@ Requests ; }
 static Scanner new@@ Input ( ) throws IOException { if ( System . getProperty ( " J@@ UD@@ GE " ) != null ) { return new Scanner ( new File ( " ch@@ airs . in " ) ) ; } else { return new Scanner ( System . in ) ; } }
 @ Converter public static RP@@ L_@@ I@@ 02 to@@ R@@ pl@@ I@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ L_@@ I@@ 02 . class , body ) ; }
 @ Nullable private static String find@@ Interpreter ( VirtualFile dir ) { for ( VirtualFile child : dir . getChildren ( ) ) { if ( ! child . isDirectory ( ) ) { final String child@@ Name = StringUtil . toLowerCase ( child . getName ( ) ) ; for ( String name : NAMES ) { if ( SystemInfo . is@@ Windows ) { if ( child@@ Name . equals ( name ) ) { return FileUtil . to@@ System@@ Dependent@@ Name ( child . getPath ( ) ) ; } } else { if ( child@@ Name . startsWith ( name ) || PYTHON_@@ RE . matcher ( child@@ Name ) . matches ( ) ) { if ( ! child@@ Name . endsWith ( " - config " ) ) { return child . getPath ( ) ; } } } } } } return null ; }
 private static void render@@ Handle ( Grid@@ TE te , int x , int y , boolean half ) { ItemStack stack@@ In@@ Slot = te . getStack@@ In@@ Slot ( y * 3 + x ) ; if ( ! stack@@ In@@ Slot . isEmpty ( ) ) { render@@ Item@@ Stack@@ In@@ World ( new Vec3d ( x * .@@ 3 - .@@ 3 , .1 + ( half ? 0.2 : 1 ) , y * .@@ 3 - .@@ 3 ) , stack@@ In@@ Slot ) ; } }
 @ NonNull public static Sequence@@ Thread parse@@ Snapshot ( @ NonNull Data@@ Snapshot snapshot ) { Log . d ( TAG , " parse@@ Snapshot ▁ " + snapshot . toString ( ) ) ; Sequence@@ Thread sequence@@ Thread = snapshot . getValue ( Sequence@@ Thread . class ) ; sequence@@ Thread . setKey ( snapshot . getKey ( ) ) ; return sequence@@ Thread ; }
 static public List < ResolveResult > getClass@@ Interface@@ ResolveResult ( Project project , String fq@@ n@@ Class@@ Or@@ Interface@@ Name ) { if ( ! fq@@ n@@ Class@@ Or@@ Interface@@ Name . startsWith ( " \ \@@ " ) ) { fq@@ n@@ Class@@ Or@@ Interface@@ Name = " \ \@@ " + fq@@ n@@ Class@@ Or@@ Interface@@ Name ; } List < ResolveResult > results = new ArrayList < ResolveResult > ( ) ; for ( Ph@@ p@@ Class php@@ Class : Ph@@ p@@ Index . getInstance ( project ) . get@@ Any@@ By@@ FQ@@ N ( fq@@ n@@ Class@@ Or@@ Interface@@ Name ) ) { results . add ( new PsiElement@@ ResolveResult ( php@@ Class ) ) ; } return results ; }
 public static void generate@@ Java@@ Sdk ( ) { String path = Path@@ Util . join ( System . getProperty ( " user . home " ) , " zstack - sdk / java " ) ; File folder = new File ( path ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } try { Class cl@@ z = Groovy@@ Utils . getClass ( " scripts / Sdk@@ Api@@ Template . groovy " , Rest@@ Server . class . getClassLoader ( ) ) ; Set < Class < ? > > api@@ Classes = Platform . get@@ Reflec@@ tions ( ) . getType@@ s@@ Annotated@@ With ( RestRequest . class ) . stream ( ) . filter ( it -> it . is@@ Annotation@@ Present ( RestRequest . class ) ) . collect ( Collectors . toSet ( ) ) ; List < Sdk@@ File > all@@ Files = new ArrayList < > ( ) ; for ( Class api@@ Cl@@ z : api@@ Classes ) { if ( Modifier . is@@ Abstract ( api@@ Cl@@ z . getModifiers ( ) ) ) { continue ; } Sdk@@ Template tmp = ( Sdk@@ Template ) cl@@ z . getConstructor ( Class . class ) . newInstance ( api@@ Cl@@ z ) ; all@@ Files . addAll ( tmp . generate ( ) ) ; } Sdk@@ Template tmp = Groovy@@ Utils . newInstance ( " scripts / Sdk@@ Data@@ Structure@@ Generator . groovy " , Rest@@ Server . class . getClassLoader ( ) ) ; all@@ Files . addAll ( tmp . generate ( ) ) ; for ( Sdk@@ File f : all@@ Files ) { String fpath = Path@@ Util . join ( path , f . getFileName ( ) ) ; FileUtils . write@@ StringTo@@ File ( new File ( fpath ) , f . getContent ( ) ) ; } } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; throw new Cloud@@ RuntimeException ( e ) ; } }
 public static void write@@ Class@@ And@@ Object ( ByteBuffer buffer , Object object ) throws IOException { if ( object == null ) { buffer . putShort ( ( short ) - 1 ) ; return ; } Serializer@@ Registration reg = write@@ Class ( buffer , object . getClass ( ) ) ; if ( reg . getType ( ) != object . getClass ( ) ) { throw new IllegalArgumentException ( " Class ▁ has ▁ not ▁ been ▁ registered : " + object . getClass ( ) + " ▁ but ▁ resolved ▁ to ▁ generic ▁ serializer ▁ for : " + reg . getType ( ) ) ; } reg . get@@ Serializer ( ) . writeObject ( buffer , object ) ; }
 private static TypeAdapter make@@ Adapter@@ For@@ Method ( String name , Fixture fixture , Matcher matcher , boolean is@@ Regex ) { Method method = getMethod ( name , fixture , matcher ) ; if ( method == null ) { throw new NoSuch@@ Method@@ Fit@@ FailureException ( name ) ; } else { return TypeAdapter . on ( fixture , method , is@@ Regex ) ; } }
 public static void main ( String [ ] args ) { List < Co@@ Product@@ 2 < String , Integer > > criteria = emptyList ( ) ; fold@@ Left ( ( r , t ) -> t . into ( ( s , i ) -> null ) , new Tuple2 < List < Object > , List < Object > > ( new ArrayList < > ( ) , new ArrayList < > ( ) ) , map ( Co@@ Product@@ 2 :: project , criteria ) ) ; }
 private static String extract@@ Bug@@ Id ( String text , String match ) { String id@@ Bug = " der@@ by - " ; String res = id@@ Bug ; int start = text . toLowerCase ( ) . indexOf ( id@@ Bug ) ; for ( int i = start + id@@ Bug . length ( ) ; i < text . length ( ) ; i ++ ) { if ( ! Character . is@@ Digit ( text . charAt ( i ) ) ) { break ; } res += text . charAt ( i ) ; } if ( id@@ Bug . equals ( res ) ) return null ; return res ; }
 public static < T > Js@@ Array < T > create ( ) { return ( Js@@ Array < T > ) create@@ Array ( ) ; }
 @ NotNull private static Configuration getConfiguration ( String sas@@ Token , String access@@ Key , String connection@@ URL ) { return new Configuration ( ) { @ Override public String accountName ( ) { return Az@@ ur@@ ite@@ Docker@@ Rule . ACCOUNT_@@ NAME ; } @ Override public String container@@ Name ( ) { return Azure@@ Segment@@ Store@@ Service . DEFAULT_@@ CONTAINER_@@ NAME ; } @ Override public String access@@ Key ( ) { return access@@ Key != null ? access@@ Key : " " ; } @ Override public String rootPath ( ) { return Azure@@ Segment@@ Store@@ Service . DEFAULT_@@ ROOT_@@ PATH ; } @ Override public String connection@@ URL ( ) { return connection@@ URL != null ? connection@@ URL : " " ; } @ Override public String shared@@ Access@@ Signature ( ) { return sas@@ Token != null ? sas@@ Token : " " ; } @ Override public String blob@@ Endpoint ( ) { return az@@ ur@@ ite . get@@ Blob@@ Endpoint ( ) ; } @ Override public Class < ? extends Annotation > annotation@@ Type ( ) { return Configuration . class ; } } ; }
 private static PsiReferenceExpression find@@ Reference@@ To ( @ NotNull PsiElement element , @ NotNull Psi@@ Variable variable ) { if ( element instanceof PsiReferenceExpression && Expression@@ Util . is@@ Effec@@ tiv@@ ely@@ Un@@ qualified ( ( PsiReferenceExpression ) element ) && ( ( PsiReferenceExpression ) element ) . resolve ( ) == variable ) { return ( PsiReferenceExpression ) element ; } final PsiElement [ ] children = element . getChildren ( ) ; for ( PsiElement child : children ) { final PsiReferenceExpression reference = find@@ Reference@@ To ( child , variable ) ; if ( reference != null ) return reference ; } return null ; }
 public static LocalTime to@@ LocalTime ( java . sql . Time t ) { LocalTime lt = ( t == null ? null : t . to@@ Instant ( ) . at@@ Zone ( ZoneId . of ( " UTC " ) ) . to@@ LocalTime ( ) ) ; return lt ; }
 public static void al@@ iment@@ ar@@ Anim@@ al@@ es ( J@@ a@@ ula < ? extends An@@ imal > ja@@ ula@@ Anim@@ al@@ es ) { List < ? extends An@@ imal > list@@ a@@ Anim@@ al@@ es = ja@@ ula@@ Anim@@ al@@ es . getList@@ a ( ) ; for ( An@@ imal a : list@@ a@@ Anim@@ al@@ es ) a . al@@ iment@@ ar ( ) ; System . out . println ( " \n " ) ; }
 @ Converter public static AD@@ R_@@ A@@ 19 to@@ Ad@@ r@@ A@@ 19 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ R_@@ A@@ 19 . class , body ) ; }
 static Filter wrap ( Filter filter ) { return SearchContext . current ( ) . filter@@ Cache ( ) . cache ( filter ) ; }
 public static String getSub@@ scription@@ Url@@ At ( final Context context , final int position ) { final String title = getSub@@ scription@@ Title@@ At ( context , position ) ; if ( ! TextUtils . isEmpty ( title ) ) { return getSub@@ scriptions ( context ) . get ( title ) . get ( 2 ) ; } return null ; }
 public static Assets inst ( ) { return instance ; }
 public static Map < String , String > string@@ Ar@@ r2@@ Map ( String ... values ) { Map < String , String > map = new HashMap < > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i += 2 ) { if ( i + 1 < values . length ) { map . put ( values [ i ] , values [ i + 1 ] ) ; } } } return map ; }
 @ Converter public static MD@@ M_@@ T@@ 06 to@@ M@@ dm@@ T@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 06 . class , body ) ; }
 @ Nullable public static Method@@ Reference@@ Bag getMethod@@ Parameter@@ Reference@@ Bag ( PsiElement psiElement ) { return getMethod@@ Parameter@@ Reference@@ Bag ( psiElement , - 1 ) ; }
 @ Converter public static PP@@ G_@@ PC@@ J to@@ P@@ pg@@ P@@ cj ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ G_@@ PC@@ J . class , body ) ; }
 public static S@@ la@@ Alert@@ Action createFrom@@ Json ( final HashMap < String , Object > obj ) throws Exception { final Map < String , Object > json@@ Obj = ( HashMap < String , Object > ) obj ; if ( ! json@@ Obj . get ( " type " ) . equals ( type ) ) { throw new Exception ( " Cannot ▁ create ▁ action ▁ of ▁ " + type + " ▁ from ▁ " + json@@ Obj . get ( " type " ) ) ; } final String actionId = ( String ) json@@ Obj . get ( " actionId " ) ; S@@ la@@ Option s@@ la@@ Option ; List < String > emails ; s@@ la@@ Option = S@@ la@@ Option . from@@ Object ( json@@ Obj . get ( " s@@ la@@ Option " ) ) ; final int exec@@ Id = Integer . valueOf ( ( String ) json@@ Obj . get ( " exec@@ Id " ) ) ; return new S@@ la@@ Alert@@ Action ( actionId , s@@ la@@ Option , exec@@ Id ) ; }
 @ Converter public static SI@@ U@@ _S@@ 21 to@@ Si@@ u@@ S@@ 21 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 21 . class , body ) ; }
 @ NotNull public static Collection < String > find@@ In@@ Root@@ Directory ( @ Nullable VirtualFile rootDir ) { final List < String > candidates = new ArrayList < > ( ) ; if ( rootDir != null && rootDir . isDirectory ( ) ) { final VirtualFile bin = rootDir . findChild ( " bin " ) ; final VirtualFile scripts = rootDir . findChild ( " Scripts " ) ; if ( bin != null ) { final String interpreter = find@@ Interpreter ( bin ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } if ( scripts != null ) { final String interpreter = find@@ Interpreter ( scripts ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } if ( candidates . isEmpty ( ) ) { final String interpreter = find@@ Interpreter ( rootDir ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } } return candidates ; }
 public static String to@@ Oct@@ al@@ String ( long v ) { return Integr@@ al@@ ToString . long@@ To@@ Oct@@ al@@ String ( v ) ; }
 public static String get@@ Admin@@ Web@@ Config@@ ClassName ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ ADMIN_@@ WEB_@@ CONFIG_@@ CLASS , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . CORE_@@ ADMIN_@@ WEB_@@ CONFIG_@@ CLASS , Web@@ Config@@ Default . CORE_@@ ADMIN_@@ WEB_@@ CONFIG_@@ CLASS ) ; } } ) ; return ( String ) cached@@ Config ; }
 static public Throwable warn ( Sys t , String msg ) { return warn ( t , msg , null ) ; }
 @ Converter public static R@@ DE_@@ O@@ 01 to@@ R@@ de@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ DE_@@ O@@ 01 . class , body ) ; }
 private static boolean m@@ ight@@ Be@@ Assign@@ able@@ From@@ Subclass ( @ NotNull final PsiClassType throw@@ Type , @ NotNull PsiType catch@@ Type ) { if ( catch@@ Type instanceof Psi@@ Dis@@ junction@@ Type ) { for ( PsiType catch@@ Dis@@ junction : ( ( Psi@@ Dis@@ junction@@ Type ) catch@@ Type ) . get@@ Dis@@ jun@@ ctions ( ) ) { if ( throw@@ Type . isAssignableFrom ( catch@@ Dis@@ junction ) ) { return true ; } } return false ; } return throw@@ Type . isAssignableFrom ( catch@@ Type ) ; }
 @ Contract ( " _ ▁ - > ▁ new " ) @ NotNull public static DFA@@ Type create ( @ Nullable PsiType type ) { return new DFA@@ Type ( type ) ; }
 private static void validate@@ List@@ Sql@@ Elastic@@ Pool ( List < Sql@@ Elastic@@ Pool > sql@@ Elastic@@ Pools ) { boolean found = false ; for ( Sql@@ Elastic@@ Pool elastic@@ Pool : sql@@ Elastic@@ Pools ) { if ( elastic@@ Pool . name ( ) . equals ( SQL_@@ E@@ LAST@@ IC_@@ POOL_@@ NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
 private static void doTest ( Map < String , String > graph , final String start , final String finish , final int k , String ... expected@@ Paths ) { Graph < String > generator = init@@ Graph ( graph ) ; List < List < String > > paths = get@@ Algorith@@ ms@@ Instance ( ) . find@@ K@@ Shor@@ test@@ Paths ( generator , start , finish , k , new Empty@@ ProgressIndicator ( Modality@@ State . NON_@@ MOD@@ AL ) ) ; List < String > path@@ Strings = new ArrayList < > ( ) ; Set < Integer > sizes = new HashSet < > ( ) ; for ( List < String > path : paths ) { path@@ Strings . add ( StringUtil . join ( path , " " ) ) ; sizes . add ( path . size ( ) ) ; } if ( sizes . size ( ) != paths . size ( ) ) { Use@@ ful@@ TestCase . assert@@ Same@@ Elements ( path@@ Strings , expected@@ Paths ) ; } else { Use@@ ful@@ TestCase . assert@@ Ordered@@ Equals ( path@@ Strings , expected@@ Paths ) ; } }
 public static boolean is@@ Subscription@@ s@@ Empty ( final Context context ) { return getSub@@ scriptions ( context ) . isEmpty ( ) ; }
 public static void set@@ Machine@@ Metrics@@ Exclu@@ ded ( boolean exclude@@ Machine@@ Metrics ) { Aws@@ Sdk@@ Metrics . machine@@ Metrics@@ Exclu@@ ded = exclude@@ Machine@@ Metrics ; }
 public static boolean is@@ Equal@@ ClassName ( @ Nullable Ph@@ p@@ Class php@@ Class , @ Nullable String ... compare@@ ClassNames ) { for ( String className : compare@@ ClassNames ) { if ( is@@ Equal@@ ClassName ( php@@ Class , className ) ) { return true ; } } return false ; }
 public static void set@@ Fade@@ Out@@ Duration ( int fade@@ Out@@ Duration ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putInt ( GLOB@@ AL@@ _SETT@@ ING_@@ FA@@ DE_@@ OUT_@@ DURATION , fade@@ Out@@ Duration ) ; editor . commit ( ) ; }
 public static Vector@@ 4b create ( boolean v ) { return new Vector@@ 4b ( v ) ; }
 public static boolean return@@ Present ( @ NotNull Control@@ Flow flow ) { Instruction@@ Client@@ Visitor < Boolean > visitor = new Return@@ Present@@ Client@@ Visitor ( flow ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static Meta@@ File@@ 2 getMeta@@ File@@ For@@ Url ( Uri uri ) throws Exception { if ( " upnp " . equals ( uri . getScheme ( ) ) ) { return Up@@ np@@ File@@ 2 . from@@ Uri ( uri ) ; } if ( " http " . equals ( uri . getScheme ( ) ) || " https " . equals ( uri . getScheme ( ) ) ) { return Http@@ File@@ 2 . from@@ Uri ( uri ) ; } else return Meta@@ File@@ 2@@ Factory . getMeta@@ File@@ For@@ Url ( uri ) ; }
 private static long getP@@ id ( ) { try { String n = Management@@ Factory . getRuntime@@ MXBean ( ) . getName ( ) ; int i = n . indexOf ( ' @ ' ) ; if ( i == - 1 ) return - 1 ; return Long . parseLong ( n . substring ( 0 , i ) ) ; } catch ( Throwable t ) { return - 1 ; } }
 public static < T > boolean equal@@ As@@ Sets ( final Collection < T > collection@@ 1 , final Collection < T > collection@@ 2 ) { return toSet ( collection@@ 1 ) . equals ( toSet ( collection@@ 2 ) ) ; }
 public static int getCurrent@@ Feed@@ Position ( final Context context ) { return get ( context , KEY_@@ CURRENT_@@ FE@@ ED_@@ POSITION , Integer . class ) ; }
 private static String decode@@ Percent ( String s ) { try { return URL@@ Decoder . decode ( s , " UTF - 8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
 public static void Add@@ Commit ( Commit@@ Node commit , Repository@@ Node repo@@ Node ) { Statement s@@ mt ; String sql ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; try { s@@ mt = conn . createStatement ( ) ; sql = " INSERT ▁ INTO ▁ T@@ COMMIT ▁ ( Repo@@ Id , ▁ UserId , ▁ HashCode , ▁ Date , ▁ Message ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TRE@@ POSI@@ TORY ▁ TR ▁ WHERE ▁ TR . Name ▁ = ▁ ' " + repo@@ Node . getName ( ) + " ' ) , " + Integer . toString ( getUserId ( commit . getUser ( ) . getName ( ) ) ) + " , " + " ' " + commit . getId ( ) + " ' , " + " ' " + sdf . format ( commit . getDate ( ) ) + " ' , " + " ' " + commit . getLog@@ Message ( ) . replaceAll ( " ' " , " ' ' " ) + " ' ) ; " ; for ( FileNode file@@ Node : commit . get@@ Files ( ) ) { sql += " INSERT ▁ INTO ▁ T@@ FILE ▁ ( Commit@@ Id , ▁ New@@ Name , ▁ Old@@ Name , ▁ New@@ Obj@@ Id , ▁ PackageName , ▁ Change@@ Type ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ T@@ COMMIT ▁ TC ▁ WHERE ▁ TC . HashCode ▁ = ▁ ' " + commit . getId ( ) + " ' ) , " + " ' " + file@@ Node . newName + " ' , " + " ' " + file@@ Node . oldName + " ' , " + " ' " + file@@ Node . new@@ Obj@@ Id + " ' , " + " ' " + file@@ Node . packageName + " ' , " + " ' " + file@@ Node . change@@ Type + " ' ) ; " ; for ( ClassNode class@@ Node : file@@ Node . get@@ Classes ( ) ) { sql += " INSERT ▁ INTO ▁ T@@ CLASS ▁ ( File@@ Id , ▁ Name , ▁ Line@@ Start , ▁ Line@@ End , ▁ Change@@ Type ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ T@@ FILE ▁ TF ▁ WHERE ▁ TF . New@@ Obj@@ Id ▁ = ▁ ' " + file@@ Node . new@@ Obj@@ Id + " ' ) , " + " ' " + class@@ Node . getName ( ) + " ' , " + class@@ Node . getLine@@ Start ( ) + " , " + class@@ Node . getLine@@ End ( ) + " , " + " ' " + class@@ Node . get@@ Change@@ Type ( ) + " ' ) ; " ; for ( Function@@ Node function@@ Node : class@@ Node . get@@ Functions ( ) ) { sql += " INSERT ▁ INTO ▁ T@@ FUNCTION ▁ ( Class@@ Id , ▁ Name , ▁ Line@@ Start , ▁ Line@@ End , ▁ Change@@ Type ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ TC . id ▁ FROM ▁ T@@ CLASS ▁ TC , ▁ T@@ FILE ▁ TF ▁ WHERE ▁ TC . Name ▁ = ▁ ' " + class@@ Node . getName ( ) + " ' ▁ AND ▁ " + " TF . New@@ Obj@@ Id ▁ = ▁ ' " + file@@ Node . new@@ Obj@@ Id + " ' ▁ AND ▁ TC . File@@ Id ▁ = ▁ TF . id ) , " + " ' " + function@@ Node . getName ( ) + " ' , " + function@@ Node . getLine@@ Start ( ) + " , " + function@@ Node . getLine@@ End ( ) + " , " + " ' " + function@@ Node . get@@ Change@@ Type ( ) + " ' ) ; " ; } } } s@@ mt . executeUpdate ( sql ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
 public static void setSingle@@ Metric@@ Namespace ( boolean single@@ Metric@@ Namespace ) { Aws@@ Sdk@@ Metrics . single@@ Metric@@ Namespace = single@@ Metric@@ Namespace ; }
 public static < T extends Service@@ Metric@@ Collector > T getService@@ Metric@@ Collector ( ) { if ( mc == null ) { if ( isDefault@@ Metrics@@ Enabled ( ) ) enable@@ Default@@ Metrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? Service@@ Metric@@ Collector . NONE : mc . getService@@ Metric@@ Collector ( ) ) ; return t ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Two ( ) { float a = 1.@@ f / 64@@ 00@@ 0.@@ f ; return new float [ ] { 1 * a , 14 * a , 89 * a , 336 * a , 8@@ 20 * a , 12@@ 88 * a , 10@@ 92 * a , - 208 * a , - 2002 * a , - 286@@ 0 * a , - 2002 * a , - 208 * a , 10@@ 92 * a , a * 12@@ 88 , a * 8@@ 20 , a * 336 , a * 89 , a * 14 , a } ; }
 public static boolean is@@ Number ( String str ) { if ( isEmpty ( str ) ) { return false ; } else { try { Double . parseDouble ( str ) ; return true ; } catch ( Exception e ) { return false ; } } }
 @ Nullable static public Ph@@ p@@ Class getClass ( Ph@@ p@@ Index php@@ Index , String className ) { Collection < Ph@@ p@@ Class > classes = php@@ Index . get@@ Classes@@ By@@ FQ@@ N ( className ) ; return classes . isEmpty ( ) ? null : classes . iterator ( ) . next ( ) ; }
 public static void test@@ Entity@@ Processor@@ And@@ QueryBuilders ( ) { Class@@ D d = new Class@@ D ( 41 , " d@@ 1" ) ; Class@@ C c = new Class@@ C ( 31 , 3 ) ; Class@@ B b = new Class@@ B ( 21 , " b@@ 1" , c ) ; Class@@ A a = new Class@@ A ( 11 , 111 , " a1" , b , d ) ; Class@@ F f = new Class@@ F ( ) ; Database@@ Entity dbe@@ 1 = Entity@@ Processor . create@@ Entity ( a . getClass ( ) ) ; Entity@@ Processor . print@@ Entity ( dbe@@ 1 ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; QueryBuilder qb = new QueryBuilder ( new Select@@ QueryBuilder ( true ) ) ; qb . build@@ Query ( dbe@@ 1 ) ; Query query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new Update@@ QueryBuilder ( ) ) ; qb . build@@ Query ( dbe@@ 1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new Insert@@ QueryBuilder ( ) ) ; qb . build@@ Query ( dbe@@ 1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new Delete@@ QueryBuilder ( false ) ) ; qb . build@@ Query ( dbe@@ 1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; }
 static public void trace ( Object ... objects ) { if ( flag ( Sys . WATER ) == false ) return ; Event e = Event . make ( Sys . WATER , Kind . TRA@@ C , null , objects ) ; write ( e , false , true ) ; }
 public static N@@ v@@ GLSL@@ Program createFrom@@ Files ( GL@@ 4 gl@@ 4 , String root , String shader@@ Name ) { return createFrom@@ Files ( gl@@ 4 , root , shader@@ Name , false ) ; }
 @ Nullable static public String getArray@@ Hash@@ Value ( Array@@ Creation@@ Expression array@@ Creation@@ Expression , String keyName ) { Array@@ Hash@@ Element translation@@ Array@@ Hash@@ Element = PsiElement@@ Utils . getChild@@ ren@@ OfType ( array@@ Creation@@ Expression , Platform@@ Patterns . psiElement ( Array@@ Hash@@ Element . class ) . with@@ FirstChild ( Platform@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . ARRAY_@@ KEY ) . with@@ Text ( Platform@@ Patterns . string ( ) . one@@ Of ( " ' " + keyName + " ' " , " \@@ " " + keyName + " \@@ " " ) ) ) ) ; if ( translation@@ Array@@ Hash@@ Element == null ) { return null ; } if ( ! ( translation@@ Array@@ Hash@@ Element . getValue ( ) instanceof StringLiteral@@ Expression ) ) { return null ; } StringLiteral@@ Expression value@@ String = ( StringLiteral@@ Expression ) translation@@ Array@@ Hash@@ Element . getValue ( ) ; if ( value@@ String == null ) { return null ; } return value@@ String . getContents ( ) ; }
 @ Converter public static R@@ Q@@ I_@@ I@@ 02 to@@ R@@ qi@@ I@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ I_@@ I@@ 02 . class , body ) ; }
 public static < T > Option@@ List < T > cast@@ To@@ Enum ( T value , Symbol className ) { String class@@ Name@@ Str = strip@@ Enum@@ Suffix ( className . getName ( ) ) ; try { Class < ? > clazz = Class . forName ( class@@ Name@@ Str ) ; if ( ! Option@@ List . class . isAssignableFrom ( clazz ) ) { throw new IllegalArgumentException ( class@@ Name@@ Str + " ▁ does ▁ not ▁ identify ▁ an ▁ Option@@ List ▁ type . " ) ; } for ( Method m : clazz . get@@ Methods ( ) ) { if ( " from@@ Underlying@@ Value " . equals ( m . getName ( ) ) ) { return ( Option@@ List < T > ) m . invoke ( clazz , value ) ; } } return null ; } catch ( ClassNotFoundException e ) { return null ; } catch ( InvocationTargetException e ) { return null ; } catch ( IllegalAccessException e ) { return null ; } }
 @ Converter public static RP@@ A_@@ I@@ 09 to@@ R@@ pa@@ I@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ A_@@ I@@ 09 . class , body ) ; }
 public static int getMin@@ Defin@@ ite@@ ly@@ Reached@@ Offset ( @ NotNull Control@@ Flow flow , final int source@@ Offset , @ NotNull List < ? extends PsiElement > references ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Integer > { private final TInt@@ HashSet [ ] exit@@ Points = new TInt@@ HashSet [ flow . getSize ( ) ] ; @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( exit@@ Points [ offset ] == null ) { exit@@ Points [ offset ] = new TInt@@ HashSet ( ) ; } if ( is@@ Leaf ( next@@ Offset ) ) { exit@@ Points [ offset ] . add ( offset ) ; } else if ( exit@@ Points [ next@@ Offset ] != null ) { exit@@ Points [ offset ] . addAll ( exit@@ Points [ next@@ Offset ] . toArray ( ) ) ; } } @ Override @ NotNull public Integer getResult ( ) { int min@@ Offset = flow . getSize ( ) ; int max@@ Exit@@ Points = 0 ; next@@ Offset : for ( int i = source@@ Offset ; i < exit@@ Points . length ; i ++ ) { TInt@@ HashSet exit@@ Point@@ Set = exit@@ Points [ i ] ; final int size = exit@@ Point@@ Set == null ? 0 : exit@@ Point@@ Set . size ( ) ; if ( size > max@@ Exit@@ Points ) { for ( PsiElement element : references ) { final PsiElement statement = PsiUtil . get@@ Enclosing@@ Statement ( element ) ; if ( statement == null ) continue ; final int endOffset = flow . getEndOffset ( statement ) ; if ( endOffset == - 1 ) continue ; if ( i != endOffset && ! is@@ Instruction@@ Reachable ( flow , i , endOffset ) ) continue next@@ Offset ; } min@@ Offset = i ; max@@ Exit@@ Points = size ; } } return min@@ Offset ; } } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( ) . intValue ( ) ; }
 public static < T , U > List < T > collect@@ First@@ s ( List < Pair < T , U > > pairs ) { List < T > result = new ArrayList < T > ( pairs . size ( ) ) ; for ( Pair < T , ? > each : pairs ) { result . add ( each . first ) ; } return result ; }
 @ Converter public static O@@ SQ@@ _@@ Q@@ 06 to@@ O@@ sq@@ Q@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( O@@ SQ@@ _@@ Q@@ 06 . class , body ) ; }
 public static Record valueOf ( final String value ) { for ( final Comparator comparator : values ( ) ) { final String expression = escap@@ er . matcher ( comparator . toString ( ) ) . replaceAll ( " \\ \\ $ 1" ) . replace ( " ^ " , " \\ ^ " ) ; final String regex = " ^ " + expression + " . * " ; logger . log ( FINE , regex ) ; if ( value . matches ( regex ) ) { return new Record ( value . replaceAll ( expression , " " ) , comparator ) ; } } return new Record ( value , EQUAL ) ; }
 public static void start ( final Component@@ Type@@ Property@@ Editor editor , final Poly@@ Struct pl@@ Struct ) { New@@ Template@@ Types@@ Dialog templ@@ Types = new New@@ Template@@ Types@@ Dialog ( editor , pl@@ Struct ) ; Dialog@@ Descriptor dd@@ scr = new Dialog@@ Descriptor ( templ@@ Types , Nb@@ Bundle . getMessage ( Component@@ Wizard@@ Iterator . class , " LB@@ L _ Template@@ Types _ Title " ) ) ; dd@@ scr . set@@ Button@@ Listener ( templ@@ Types ) ; Dialog d = Dialog@@ Disp@@ layer . getDefault ( ) . create@@ Dialog ( dd@@ scr ) ; d . setVisible ( true ) ; }
 public static Stat getRoot@@ As@@ Stat ( ByteBuffer _b@@ b , Stat obj ) { _b@@ b . order ( ByteOrder . LITTLE_ENDIAN ) ; return ( obj . __@@ init ( _b@@ b . getInt ( _b@@ b . position ( ) ) + _b@@ b . position ( ) , _b@@ b ) ) ; }
 public static void pause ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } }
 public static void drop@@ Table ( Database db , boolean if@@ Exists ) { String sql = " DROP ▁ TABLE ▁ " + ( if@@ Exists ? " IF ▁ EXISTS ▁ " : " " ) + " \@@ " contact _ email _ sensor \@@ " " ; db . exec@@ SQL ( sql ) ; }
 @ BeforeClass public static void start@@ Service ( ) { Object implement@@ or = new Gre@@ eter@@ Impl ( ) ; String address = " http : // localhost : " + port1 + " / Soap@@ Context / Soap@@ Port " ; endpoint = Endpoint . publish ( address , implement@@ or ) ; }
 @ Nullable public static Ph@@ p@@ Class getFirst@@ Class@@ FromFile ( Ph@@ pFile ph@@ pFile ) { Collection < Ph@@ p@@ Class > php@@ Classes = PsiTreeUtil . collect@@ Element@@ sOf@@ Type ( ph@@ pFile , Ph@@ p@@ Class . class ) ; return php@@ Classes . size ( ) == 0 ? null : php@@ Classes . iterator ( ) . next ( ) ; }
 public static Temporal@@ Query < Temporal@@ Unit > precision ( ) { return Temporal@@ Queries . PRECISION ; }
 private static void validate@@ Sql@@ Database@@ With@@ Elastic@@ Pool ( Sql@@ Database sql@@ Database , String databaseName ) { validate@@ Sql@@ Database ( sql@@ Database , databaseName ) ; Assert . assertEquals ( SQL_@@ E@@ LAST@@ IC_@@ POOL_@@ NAME , sql@@ Database . elastic@@ Pool@@ Name ( ) ) ; }
 public static SystemInfo getInstance ( ) { if ( current@@ System == null ) current@@ System = new SystemInfo ( ) ; return current@@ System ; }
 public static boolean flag ( Sys t ) { return t . _@@ enable || print@@ All ; }
 private static void write@@ 0 ( Event e , boolean print@@ On@@ Out , boolean log@@ To@@ KV ) { org . apache . log4j . Logger l@@ 4j = getLog@@ 4j@@ Logger ( ) ; if ( ( l@@ 4j == null ) && ! logger@@ Create@@ Was@@ Called && ! H2@@ O . DEBUG ) { if ( H2@@ O . SELF != null ) { File dir ; boolean windows@@ Path = H2@@ O . ICE_@@ ROOT . toString ( ) . matches ( " ^ [ a - zA - Z ] : . * " ) ; if ( windows@@ Path ) dir = new File ( H2@@ O . ICE_@@ ROOT . toString ( ) ) ; else if ( H2@@ O . ICE_@@ ROOT . getScheme ( ) == null || Sche@@ mes . FILE . equals ( H2@@ O . ICE_@@ ROOT . getScheme ( ) ) ) dir = new File ( H2@@ O . ICE_@@ ROOT . getPath ( ) ) ; else dir = new File ( H2@@ O . DEFAULT_@@ ICE_@@ ROOT ( ) ) ; logger@@ Create@@ Was@@ Called = true ; l@@ 4j = create@@ Log@@ 4j@@ Logger ( dir . toString ( ) ) ; } } if ( l@@ 4j == null ) { e . toString ( ) ; synchronized ( startup@@ Log@@ Events@@ Lock ) { if ( startup@@ Log@@ Events != null ) { startup@@ Log@@ Events . add ( e ) ; } else { } } } else { if ( startup@@ Log@@ Events != null ) { synchronized ( startup@@ Log@@ Events@@ Lock ) { for ( int i = 0 ; i < startup@@ Log@@ Events . size ( ) ; i ++ ) { Event buffered@@ Event = startup@@ Log@@ Events . get ( i ) ; log@@ 0 ( l@@ 4j , buffered@@ Event ) ; } startup@@ Log@@ Events = null ; } } log@@ 0 ( l@@ 4j , e ) ; } if ( print@@ On@@ Out || print@@ All ) unwrap ( System . out , e . to@@ Short@@ String ( ) ) ; e . print@@ Me = false ; }
 public static String get@@ DB@@ Type ( ) { return ( String ) context@@ Holder . get ( ) ; }
 private static void Log@@ Event ( String msg ) { Event@@ Log@@ EntryType type = Event@@ Log@@ EntryType . Error ; try { } finally { } }
 public static void Serialize ( Repository@@ Node repo ) { Statement s@@ mt ; String sql ; try { s@@ mt = conn . createStatement ( ) ; Date last@@ Commit@@ Date = Add@@ Repository ( repo ) ; Insert@@ Users ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; List < Commit@@ Node > commits = repo . get@@ Comm@@ its ( ) ; for ( Commit@@ Node commit : commits ) { if ( last@@ Commit@@ Date == null || ( last@@ Commit@@ Date != null && commit . getDate ( ) . after ( last@@ Commit@@ Date ) ) ) { sql = " INSERT ▁ INTO ▁ T@@ COMMIT ▁ ( Repo@@ Id , ▁ UserId , ▁ HashCode , ▁ Date , ▁ Message ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TRE@@ POSI@@ TORY ▁ TR ▁ WHERE ▁ TR . Name ▁ = ▁ ' " + repo . getName ( ) + " ' ) , " + " ( SELECT ▁ id ▁ FROM ▁ T@@ USER ▁ TU ▁ WHERE ▁ TU . Name ▁ = ▁ ' " + commit . getUser ( ) . getName ( ) + " ' ) , " + " ' " + commit . getId ( ) + " ' , " + " ' " + sdf . format ( commit . getDate ( ) ) + " ' , " + " ' " + commit . getLog@@ Message ( ) . replaceAll ( " ' " , " ' ' " ) + " ' ) ; " ; for ( FileNode file@@ Node : commit . get@@ Files ( ) ) { sql += " INSERT ▁ INTO ▁ T@@ FILE ▁ ( Commit@@ Id , ▁ New@@ Name , ▁ Old@@ Name , ▁ New@@ Obj@@ Id , ▁ Change@@ Type ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ T@@ COMMIT ▁ TC ▁ WHERE ▁ TC . HashCode ▁ = ▁ ' " + commit . getId ( ) + " ' ) , " + " ' " + file@@ Node . newName + " ' , " + " ' " + file@@ Node . oldName + " ' , " + " ' " + file@@ Node . new@@ Obj@@ Id + " ' , " + " ' " + file@@ Node . change@@ Type + " ' ) ; " ; for ( ClassNode class@@ Node : file@@ Node . get@@ Classes ( ) ) { sql += " INSERT ▁ INTO ▁ T@@ CLASS ▁ ( File@@ Id , ▁ Name , ▁ Line@@ Start , ▁ Line@@ End , ▁ Change@@ Type ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ T@@ FILE ▁ TF ▁ WHERE ▁ TF . New@@ Obj@@ Id ▁ = ▁ ' " + file@@ Node . new@@ Obj@@ Id + " ' ) , " + " ' " + class@@ Node . getName ( ) + " ' , " + class@@ Node . getLine@@ Start ( ) + " , " + class@@ Node . getLine@@ End ( ) + " , " + " ' " + class@@ Node . get@@ Change@@ Type ( ) + " ' ) ; " ; for ( Function@@ Node function@@ Node : class@@ Node . get@@ Functions ( ) ) { sql += " INSERT ▁ INTO ▁ T@@ FUNCTION ▁ ( Class@@ Id , ▁ Name , ▁ Line@@ Start , ▁ Line@@ End , ▁ Change@@ Type ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ TC . id ▁ FROM ▁ T@@ CLASS ▁ TC , ▁ T@@ FILE ▁ TF ▁ WHERE ▁ TC . Name ▁ = ▁ ' " + class@@ Node . getName ( ) + " ' ▁ AND ▁ " + " TF . New@@ Obj@@ Id ▁ = ▁ ' " + file@@ Node . new@@ Obj@@ Id + " ' ▁ AND ▁ TC . File@@ Id ▁ = ▁ TF . id ) , " + " ' " + function@@ Node . getName ( ) + " ' , " + function@@ Node . getLine@@ Start ( ) + " , " + function@@ Node . getLine@@ End ( ) + " , " + " ' " + function@@ Node . get@@ Change@@ Type ( ) + " ' ) ; " ; } } } sql += " UPDATE ▁ TRE@@ POSI@@ TORY ▁ SET ▁ Last@@ Commit@@ Id ▁ = ▁ " + " ( SELECT ▁ distinct ( id ) ▁ FROM ▁ T@@ COMMIT ▁ where ▁ date ▁ = ▁ ( select ▁ max ( date ) ▁ from ▁ T@@ COMMIT ) ) " + " WHERE ▁ Name ▁ = ▁ ' " + repo . getName ( ) + " ' ; " ; s@@ mt . executeUpdate ( sql ) ; } } s@@ mt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
 @ Nullable private static Psi@@ Try@@ Statement get@@ Enclosing@@ Try@@ Statement@@ H@@ av@@ ing@@ Catch@@ Or@@ Finally ( @ Nullable PsiElement startElement , @ NotNull PsiElement enclosing@@ Code@@ Fragment ) { for ( PsiElement element = startElement ; element != null && element != enclosing@@ Code@@ Fragment ; element = element . getParent ( ) ) { if ( element instanceof Psi@@ CodeBlock ) { final PsiElement parent = element . getParent ( ) ; if ( parent instanceof Psi@@ Try@@ Statement ) { final Psi@@ Try@@ Statement try@@ Statement = ( Psi@@ Try@@ Statement ) parent ; if ( try@@ Statement . get@@ Try@@ Block ( ) == element && ( try@@ Statement . get@@ Fin@@ ally@@ Block ( ) != null || try@@ Statement . getC@@ atch@@ Blocks ( ) . length != 0 ) ) { return try@@ Statement ; } } } } return null ; }
 public static Matrix@@ 2D Extract@@ Developer@@ Commit@@ Matrix ( String _re@@ pository , String filename ) throws SQLException { String sql ; Matrix@@ Descriptor descriptor = new Matrix@@ Descriptor ( InfoType . USER , InfoType . COMMIT ) ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR , ▁ T@@ FILE ▁ TF ▁ " + " WHERE ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . comm@@ iti@@ d ▁ = ▁ TC . id ▁ AND ▁ TF . newname ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . Add@@ Col@@ Desc ( rs . getString ( " HashCode " ) ) ; } sql = " SELECT ▁ Distin@@ ct ( TU . name ) ▁ FROM ▁ T@@ User ▁ TU , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TC . userID ▁ = ▁ TU . id ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . Add@@ Row@@ Desc ( rs . getString ( " name " ) ) ; } Matrix@@ 2D mat = new Matrix@@ 2D ( descriptor ) ; sql = " SELECT ▁ TU . name , ▁ TC . HashCode ▁ FROM ▁ T@@ User ▁ TU , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR , ▁ T@@ FILE ▁ TF ▁ " + " WHERE ▁ TC . userID ▁ = ▁ TU . id ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . comm@@ iti@@ d ▁ = ▁ TC . id ▁ AND ▁ TF . newname ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . Set@@ Element ( rs . getString ( " name " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; s@@ mt . close ( ) ; return mat ; }
 public static boolean isEmpty@@ Or@@ Spaces ( @ Nullable String str ) { return str == null || str . length ( ) == 0 || str . trim ( ) . length ( ) == 0 ; }
 public static java . util . Date to@@ Java@@ Date ( LocalDateTime ld@@ t ) { java . util . Date d = ( ld@@ t == null ? null : Date . from ( ld@@ t . at@@ Zone ( par@@ is ) . to@@ Instant ( ) ) ) ; return d ; }
 public static boolean connectivity ( Context c ) { if ( c != null ) { Connectivity@@ Manager con@@ ne@@ c = ( Connectivity@@ Manager ) c . getSystemService ( Context . CONNEC@@ TI@@ VI@@ TY@@ _SERVICE ) ; try { android . net . Network@@ Info wifi = con@@ ne@@ c . getNetwork@@ Info ( Connectivity@@ Manager . TYPE_@@ WI@@ FI ) ; android . net . Network@@ Info mobile = con@@ ne@@ c . getNetwork@@ Info ( Connectivity@@ Manager . TYPE_@@ MOBI@@ LE ) ; if ( wifi . isConnected ( ) || mobile . isConnected ( ) ) return true ; else if ( wifi . isConnected ( ) && mobile . isConnected ( ) ) return true ; else return false ; } catch ( NullPointerException e ) { Log . d ( " Con@@ Status " , " No ▁ Active ▁ Connection " ) ; return false ; } } else { Log . v ( " utils - - " , " null " ) ; return false ; } }
 @ Converter public static AD@@ T_@@ A@@ 11 to@@ Ad@@ t@@ A@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 11 . class , body ) ; }
 private static int find@@ Un@@ processed ( int startOffset , int endOffset , @ NotNull Instruction@@ Client@@ Visitor < ? > visitor ) { for ( int i = startOffset ; i < endOffset ; i ++ ) { if ( ! visitor . processed@@ Instructions [ i ] ) { return i ; } } return endOffset ; }
 private static < A@@ l > void fold@@ Left ( Consumer < A@@ l > fn , List < A@@ l > as ) { }
 @ Converter public static RP@@ I_@@ I@@ 04 to@@ R@@ pi@@ I@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ I_@@ I@@ 04 . class , body ) ; }
 @ AfterClass public static void tearDown@@ AfterClass ( ) throws Exception { CC@@ N@@ TestBase . tearDown@@ AfterClass ( ) ; }
 public static void setContext ( Context c ) { Log . i ( " ND@@ K@@ Helper " , " setContext : " + c ) ; context = c ; }
 public static String get@@ Prev@@ Sibling@@ As@@ Text@@ Until ( PsiElement psiElement , Element@@ Pattern pattern , boolean include@@ Matching ) { String prev@@ Text = " " ; for ( PsiElement child = psiElement . get@@ Prev@@ Sibling ( ) ; child != null ; child = child . get@@ Prev@@ Sibling ( ) ) { if ( pattern . accepts ( child ) ) { if ( include@@ Matching ) { return child . getText ( ) + prev@@ Text ; } return prev@@ Text ; } else { prev@@ Text = child . getText ( ) + prev@@ Text ; } } return prev@@ Text ; }
 public static void Mine@@ Bu@@ gs ( String bug@@ Match , Repository@@ Node repository ) throws SQLException { String sql ; Matrix@@ Descriptor descriptor = new Matrix@@ Descriptor ( InfoType . USER , InfoType . COMMIT ) ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Message ▁ FROM ▁ T@@ Commit ▁ TC , ▁ T@@ Repository ▁ TR ▁ " + " WHERE ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + repository . getName ( ) + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date ; " ; rs = s@@ mt . executeQuery ( sql ) ; List < Entry < String , String > > bug@@ Commit = new ArrayList < Map . Entry < String , String > > ( ) ; while ( rs . next ( ) ) { String hashCode = rs . getString ( " HashCode " ) ; String message = rs . getString ( " Message " ) ; String bug@@ Id = extract@@ Bug@@ Id ( message , bug@@ Match ) ; if ( bug@@ Id != null ) { Map . Entry < String , String > pair = new Abstract@@ Map . Simple@@ Entry ( bug@@ Id , hashCode ) ; bug@@ Commit . add ( pair ) ; } } for ( Entry < String , String > record : bug@@ Commit ) { sql = " INSERT ▁ INTO ▁ T@@ BUG ▁ ( id , ▁ commit@@ Id ) " + " ▁ VALUES ▁ ( ' " + record . getKey ( ) + " ' , ▁ ' " + record . getValue ( ) + " ' ) ; " ; s@@ mt . executeUpdate ( sql ) ; } rs . close ( ) ; s@@ mt . close ( ) ; }
 private static Configuration getConfiguration@@ With@@ Configuration@@ URL ( String access@@ Key ) { String connection@@ String = " Default@@ Endpoint@@ s@@ Protocol = https ; " + " Blob@@ Endpoint = " + az@@ ur@@ ite . get@@ Blob@@ Endpoint ( ) + ' ; ' + " Account@@ Name = " + Az@@ ur@@ ite@@ Docker@@ Rule . ACCOUNT_@@ NAME + ' ; ' + " Account@@ Key = " + access@@ Key + ' ; ' ; return getConfiguration ( null , null , connection@@ String ) ; }
 private static Put put@@ Row ( int row@@ Key , int f1@@ c1 , String f2@@ c1 , long f2@@ c2 , double f3@@ c1 , boolean f3@@ c2 , String f3@@ c3 , Timestamp f4@@ c1 , Date f4@@ c2 , Time f@@ 4c@@ 3 , BigDecimal f@@ 4c@@ 4 ) { Put put = new Put ( Bytes . toBytes ( row@@ Key ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y1 ) , Bytes . toBytes ( F@@ 1@@ COL@@ 1 ) , Bytes . toBytes ( f1@@ c1 ) ) ; if ( f2@@ c1 != null ) { put . addColumn ( Bytes . toBytes ( FAMIL@@ Y2 ) , Bytes . toBytes ( F2@@ COL@@ 1 ) , Bytes . toBytes ( f2@@ c1 ) ) ; } put . addColumn ( Bytes . toBytes ( FAMIL@@ Y2 ) , Bytes . toBytes ( F2@@ COL@@ 2 ) , Bytes . toBytes ( f2@@ c2 ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 3 ) , Bytes . toBytes ( F3@@ COL@@ 1 ) , Bytes . toBytes ( f3@@ c1 ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 3 ) , Bytes . toBytes ( F3@@ COL@@ 2 ) , Bytes . toBytes ( f3@@ c2 ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 3 ) , Bytes . toBytes ( F3@@ COL@@ 3 ) , Bytes . toBytes ( f3@@ c3 ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 4 ) , Bytes . toBytes ( F4@@ COL@@ 1 ) , Bytes . toBytes ( timestamp@@ To@@ Internal ( f4@@ c1 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 4 ) , Bytes . toBytes ( F4@@ COL@@ 2 ) , Bytes . toBytes ( date@@ To@@ Internal ( f4@@ c2 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 4 ) , Bytes . toBytes ( F4@@ COL@@ 3 ) , Bytes . toBytes ( timeTo@@ Internal ( f@@ 4c@@ 3 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMIL@@ Y@@ 4 ) , Bytes . toBytes ( F4@@ COL@@ 4 ) , Bytes . toBytes ( f@@ 4c@@ 4 ) ) ; return put ; }
 public static String get@@ Prev@@ Sibling@@ As@@ Text@@ Until ( PsiElement psiElement , Element@@ Pattern pattern ) { return get@@ Prev@@ Sibling@@ As@@ Text@@ Until ( psiElement , pattern , false ) ; }
 @ Converter public static RP@@ A_@@ I@@ 11 to@@ R@@ pa@@ I@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ A_@@ I@@ 11 . class , body ) ; }
 @ Converter public static PP@@ P_@@ PC@@ C to@@ P@@ pp@@ P@@ cc ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ P_@@ PC@@ C . class , body ) ; }
 public static < Stream@@ MessageType > void contains@@ In@@ Order ( List < Stream@@ MessageType > expected , InMemory@@ Output@@ Descriptor < Stream@@ MessageType > output@@ Descriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( output@@ Descriptor ) ; assertThat ( TestRunner . consume@@ Stream ( output@@ Descriptor , timeout ) . entrySet ( ) . stream ( ) . flatMap ( entry -> entry . getValue ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) , Is@@ Iterable@@ Containing@@ In@@ Order . contains ( expected . toArray ( ) ) ) ; }
 public static Instruction [ ] getAll@@ Instructions ( ) { Collection < Instruction > ins = instruction@@ Map . values ( ) ; return ins . toArray ( new Instruction [ ins . size ( ) ] ) ; }
 static C@@ ord@@ a@@ Component@@ Builder cor@@ da ( ) { return new C@@ ord@@ a@@ Component@@ Builder@@ Impl ( ) ; }
 @ Converter public static SR@@ R@@ _S@@ 01 to@@ S@@ rr@@ S@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 01 . class , body ) ; }
 @ Nullable private static Ph@@ p@@ Class getNew@@ Expression@@ Ph@@ p@@ Class ( @ NotNull New@@ Expression new@@ Expression ) { Class@@ Reference class@@ Reference = new@@ Expression . getClass@@ Reference ( ) ; if ( class@@ Reference != null ) { String fq@@ n = class@@ Reference . getF@@ Q@@ N ( ) ; if ( fq@@ n != null ) { return Ph@@ p@@ Elements@@ Util . getClass ( new@@ Expression . getProject ( ) , fq@@ n ) ; } } return null ; }
 public static void createTable ( Database db , boolean if@@ Not@@ Exists ) { String constraint = if@@ Not@@ Exists ? " IF ▁ NOT ▁ EXISTS ▁ " : " " ; db . exec@@ SQL ( " CREATE ▁ TABLE ▁ " + constraint + " \@@ " contact _ email _ sensor \@@ " ▁ ( " + " \@@ " _ id \@@ " ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT ▁ , " + " \@@ " MA@@ IL _ ID \@@ " ▁ INTEGER , " + " \@@ " ADDRESS \@@ " ▁ TEXT , " + " \@@ " TYPE \@@ " ▁ TEXT , " + " \@@ " IS _ NEW \@@ " ▁ INTEGER , " + " \@@ " IS _ UPDATED \@@ " ▁ INTEGER , " + " \@@ " IS _ DELETED \@@ " ▁ INTEGER , " + " \@@ " CREATED \@@ " ▁ TEXT ▁ NOT ▁ NULL ▁ , " + " \@@ " CONTA@@ CT _ ID \@@ " ▁ INTEGER ▁ NOT ▁ NULL ▁ , " + " \@@ " DEVICE _ ID \@@ " ▁ INTEGER ▁ NOT ▁ NULL ▁ ) ; " ) ; db . exec@@ SQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ _ id ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \@@ " _ id \@@ " ) ; " ) ; db . exec@@ SQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ CONTA@@ CT _ ID ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \@@ " CONTA@@ CT _ ID \@@ " ) ; " ) ; db . exec@@ SQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ DEVICE _ ID ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \@@ " DEVICE _ ID \@@ " ) ; " ) ; }
 public static Serializer get@@ Serializer ( Class cls ) { return get@@ Serializer ( cls , true ) ; }
 public static Intent prepare ( Context context ) { try { if ( getService ( ) . prepare@@ V@@ pn ( context . getPackageName ( ) , null , User@@ Handle . my@@ UserId ( ) ) ) { return null ; } } catch ( RemoteException e ) { } return Vpn@@ Config . getInt@@ ent@@ For@@ Confirmation ( ) ; }
 public static boolean text@@ To@@ MP@@ 3 ( File destination , String speech ) throws Vide@@ vox@@ Exception { File temp@@ WA@@ V = Model@@ Helper . enforce@@ File@@ Extension ( destination , " . wav " ) ; logger . debug ( " File ▁ name ▁ is ▁ actually : ▁ " + temp@@ WA@@ V . getAbsolutePath ( ) ) ; destination = Model@@ Helper . enforce@@ File@@ Extension ( destination , " . mp@@ 3" ) ; String cmd = " echo ▁ ' " + speech + " ' ▁ | ▁ text@@ 2@@ wave ▁ " + " - o ▁ " + " \@@ " " + temp@@ WA@@ V . getAbsolutePath ( ) + " \@@ " " ; logger . debug ( " text@@ To@@ MP@@ 3 ▁ - ▁ cmd ▁ = ▁ " + cmd ) ; Process@@ Builder builder = new Process@@ Builder ( " / bin / bash " , " - c " , cmd ) ; try { Process process = builder . start ( ) ; int return@@ Val = process . waitFor ( ) ; if ( return@@ Val != 0 ) { throw new Vide@@ vox@@ Exception ( " Wa@@ v ▁ file ▁ unable ▁ to ▁ be ▁ created : ▁ Check ▁ that ▁ fe@@ sti@@ val ▁ is ▁ installed ▁ correctly " ) ; } logger . trace ( " created ▁ wav ▁ at : ▁ " + temp@@ WA@@ V . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new Vide@@ vox@@ Exception ( " Unknown ▁ IO ▁ Exception ▁ during ▁ WA@@ V ▁ creation " ) ; } catch ( InterruptedException e ) { throw new Vide@@ vox@@ Exception ( " Fe@@ sti@@ val ▁ thread ▁ interrupted : ▁ Unknown ▁ source " ) ; } cmd = " ffmpeg ▁ - i ▁ " + " \@@ " " + temp@@ WA@@ V . getAbsolutePath ( ) + " \@@ " " + " ▁ - y ▁ - f ▁ mp@@ 3 ▁ " + " \@@ " " + destination . getAbsolutePath ( ) + " \@@ " " ; logger . debug ( " cmd ▁ = ▁ " + cmd ) ; builder = new Process@@ Builder ( " / bin / bash " , " - c " , cmd ) ; try { Process process = builder . start ( ) ; int return@@ Val = process . waitFor ( ) ; if ( return@@ Val != 0 ) { throw new Vide@@ vox@@ Exception ( " Unable ▁ to ▁ convert ▁ to ▁ mp@@ 3 : ▁ Check ▁ that ▁ fe@@ sti@@ val ▁ is ▁ installed ▁ correctly " ) ; } logger . debug ( " Created ▁ mp@@ 3 ▁ at : ▁ " + destination . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new Vide@@ vox@@ Exception ( " Unknown ▁ IO ▁ Exception ▁ during ▁ mp@@ 3 ▁ conversion " ) ; } catch ( InterruptedException e ) { throw new Vide@@ vox@@ Exception ( " Fe@@ sti@@ val ▁ thread ▁ interrupted : ▁ Unknown ▁ source " ) ; } logger . trace ( " Done ▁ with ▁ text@@ To@@ MP@@ 3" ) ; return true ; }
 public static boolean match ( @ Nullable Py@@ Type expected , @ Nullable Py@@ Type actual , @ NotNull Type@@ Eval@@ Context context ) { return match ( expected , actual , new Match@@ Context ( context , new HashMap < > ( ) ) ) . orElse ( true ) ; }
 @ Nullable public static String getStringValue ( @ Nullable PsiElement psiElement ) { return getStringValue ( psiElement , 0 ) ; }
 public static int numberOf@@ Leading@@ Zeros ( long v ) { if ( v < 0 ) { return 0 ; } if ( v == 0 ) { return 64 ; } int n = 1 ; int i = ( int ) ( v >@@ >> 32 ) ; if ( i == 0 ) { n += 32 ; i = ( int ) v ; } if ( i >@@ >> 16 == 0 ) { n += 16 ; i <<= 16 ; } if ( i >@@ >> 24 == 0 ) { n += 8 ; i <<= 8 ; } if ( i >@@ >> 28 == 0 ) { n += 4 ; i <<= 4 ; } if ( i >@@ >> 30 == 0 ) { n += 2 ; i <<= 2 ; } return n - ( i >@@ >> 31 ) ; }
 private static byte [ ] check@@ Bytes ( byte [ ] bytes ) { if ( bytes == null ) { throw new NullPointerException ( " bytes " ) ; } return bytes ; }
 private static Context@@ Service getContext@@ Service ( ) { return AccessController . doPrivileged ( new PrivilegedAction < Context@@ Service > ( ) { public Context@@ Service run ( ) { return Context@@ Service . getFactory ( ) ; } } ) ; }
 public static void main ( String [ ] args ) { Test@@ Literal@@ Code@@ In@@ Pre tester = new Test@@ Literal@@ Code@@ In@@ Pre ( ) ; run ( tester , ARGS , TEST , NEG@@ ATED_@@ TEST ) ; tester . print@@ Summary ( ) ; }
 public static Matrix@@ 2D Extract@@ File@@ Class@@ Method@@ Composition ( String _re@@ pository ) throws SQLException { String sql ; Matrix@@ Descriptor descriptor = new Matrix@@ Descriptor ( InfoType . ARTI@@ FAC@@ T , InfoType . ARTI@@ FAC@@ T ) ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ DISTINCT ▁ TF@@ L . New@@ Name ▁ AS ▁ FileName ▁ " + " FROM ▁ T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TC@@ L . fileId ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ " + " AND ▁ TF@@ L . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TF@@ L . New@@ Name , ▁ TC@@ L . name ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . Add@@ Row@@ Desc ( rs . getString ( " FileName " ) ) ; } sql = " SELECT ▁ DISTINCT ▁ TF@@ L . New@@ Name ▁ AS ▁ FileName , ▁ TC@@ L . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ Func@@ Name ▁ " + " FROM ▁ T@@ Function ▁ TF , ▁ T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . classi@@ d ▁ = ▁ TC@@ L . id ▁ AND ▁ TC@@ L . file@@ id ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ " + " AND ▁ TF@@ L . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TF@@ L . New@@ Name , ▁ TC@@ L . name , ▁ TF . Name ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . Add@@ Col@@ Desc ( rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " Func@@ Name " ) ) ; } Matrix@@ 2D result = new Matrix@@ 2D ( descriptor ) ; sql = " SELECT ▁ DISTINCT ▁ TF@@ L . New@@ Name ▁ AS ▁ FileName , ▁ TC@@ L . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ Func@@ Name ▁ " + " FROM ▁ T@@ Function ▁ TF , ▁ T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . classi@@ d ▁ = ▁ TC@@ L . id ▁ AND ▁ TC@@ L . file@@ id ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ " + " AND ▁ TF@@ L . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TF@@ L . New@@ Name , ▁ TC@@ L . Name , ▁ TF . Name ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) result . Set@@ Element ( rs . getString ( " FileName " ) , rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " Func@@ Name " ) , 1 ) ; return result ; }
 private static Sql@@ Server create@@ Sql@@ Server ( String SQL@@ _SERVER_@@ NAME ) { return sql@@ Server@@ Manager . sql@@ Servers ( ) . define ( SQL@@ _SERVER_@@ NAME ) . with@@ Region ( Region . US_@@ CENTR@@ AL ) . with@@ New@@ Resource@@ Group ( R@@ G_@@ NAME ) . with@@ Administr@@ ator@@ Login ( " userName " ) . with@@ Administr@@ ator@@ Password ( " P @ ss@@ word ~ 1" ) . create ( ) ; }
 private static < I extends Iface > Map < String , org . apache . thrift . Process@@ Function < I , ? extends org . apache . thrift . T@@ Base > > getProcess@@ Map ( Map < String , org . apache . thrift . Process@@ Function < I , ? extends org . apache . thrift . T@@ Base > > process@@ Map ) { process@@ Map . put ( " create@@ Interpreter " , new create@@ Interpreter ( ) ) ; process@@ Map . put ( " open " , new open ( ) ) ; process@@ Map . put ( " close " , new close ( ) ) ; process@@ Map . put ( " interpret " , new interpret ( ) ) ; process@@ Map . put ( " cancel " , new cancel ( ) ) ; process@@ Map . put ( " getProgress " , new getProgress ( ) ) ; process@@ Map . put ( " getForm@@ Type " , new getForm@@ Type ( ) ) ; process@@ Map . put ( " completion " , new completion ( ) ) ; process@@ Map . put ( " shutdown " , new shutdown ( ) ) ; process@@ Map . put ( " getStatus " , new getStatus ( ) ) ; process@@ Map . put ( " get@@ Event " , new get@@ Event ( ) ) ; process@@ Map . put ( " angular@@ Object@@ Update " , new angular@@ Object@@ Update ( ) ) ; process@@ Map . put ( " angular@@ Object@@ Add " , new angular@@ Object@@ Add ( ) ) ; process@@ Map . put ( " angular@@ Object@@ Remove " , new angular@@ Object@@ Remove ( ) ) ; return process@@ Map ; }
 private static void put@@ Previous@@ Feed@@ Position ( final Context context , final int position ) { put ( context , KEY_@@ PREVI@@ OUS_@@ FE@@ ED_@@ POSITION , position ) ; }
 private static < A@@ m , B@@ m > List < B@@ m > map ( Function < A@@ m , B@@ m > fn , List < A@@ m > as ) { return null ; }
 @ NotNull private static Optional < Boolean > match ( @ NotNull Py@@ Instanti@@ able@@ Type expected , @ NotNull Py@@ Instanti@@ able@@ Type actual , @ NotNull Match@@ Context context ) { if ( expected instanceof Py@@ Generic@@ Type && type@@ Var@@ Accep@@ ts@@ Both@@ Class@@ And@@ Instance@@ Types ( ( Py@@ Generic@@ Type ) expected ) ) { return Optional . empty ( ) ; } if ( expected . is@@ Definition ( ) ^ actual . is@@ Definition ( ) ) { if ( actual . is@@ Definition ( ) && actual instanceof Py@@ Class@@ Like@@ Type && match@@ Class@@ Object@@ And@@ Met@@ aclass ( expected , ( Py@@ Class@@ Like@@ Type ) actual , context ) ) { return Optional . of ( true ) ; } return Optional . of ( false ) ; } return Optional . empty ( ) ; }
 private static double parse@@ Expression ( Chars chars ) { double term = parse@@ Term ( chars ) ; while ( chars . hasNext ( ) ) { char c = chars . peek ( ) ; if ( c == ' + ' ) { chars . next ( ) ; term += parse@@ Term ( chars ) ; } else if ( c == ' - ' ) { chars . next ( ) ; term -= parse@@ Term ( chars ) ; } else { break ; } } return term ; }
 public static LocalDate to@@ LocalDate ( String s ) { LocalDate ld = ( s == null ? null : LocalDate . parse ( s , local@@ Date@@ Formatter . with@@ Zone ( ZoneId . of ( " UTC " ) ) ) ) ; return ld ; }
 @ Converter public static CR@@ M_@@ C@@ 07 to@@ C@@ rm@@ C@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 07 . class , body ) ; }
 @ NotNull public static Parameter [ ] getFunction@@ Required@@ Parameter ( @ NotNull Function function ) { Parameter [ ] parameters = function . getParameters ( ) ; if ( parameters . length == 0 ) { return new Parameter [ 0 ] ; } int last = - 1 ; for ( int i = parameters . length - 1 ; i >= 0 ; i -- ) { if ( ! parameters [ i ] . is@@ Optional ( ) ) { last = i ; break ; } } if ( last == - 1 ) { return new Parameter [ 0 ] ; } return Arrays . copy@@ Of@@ Range ( parameters , 0 , last + 1 ) ; }
 private static void validate@@ Sql@@ Elastic@@ Pool@@ NotFound ( Sql@@ Server sql@@ Server , String elastic@@ Pool@@ Name ) { Assert . assertNull ( sql@@ Server . elastic@@ Pools ( ) . get ( elastic@@ Pool@@ Name ) ) ; }
 public static void create ( String name , String text ) throws IOException { File dir = Player@@ G@@ low . getInstance ( ) . getConfig@@ Dir ( ) ; dir . mkdirs ( ) ; FileWriter file = new FileWriter ( new File ( dir , name ) ) ; file . write ( text ) ; file . flush ( ) ; file . close ( ) ; }
 protected static float [ ] get@@ Kernel@@ Sig@@ ma@@ One ( ) { return new float [ ] { 0.00@@ 2007@@ 45@@ 35@@ f , 0.03@@ 545@@ 47@@ 87@@ f , 0.16@@ 197@@ 29@@ 1f , - 0.0f , - 0.39@@ 89@@ 423@@ f , 0.0f , 0.16@@ 197@@ 29@@ 1f , 0.03@@ 545@@ 47@@ 87@@ f , 0.00@@ 2007@@ 45@@ 35@@ f } ; }
 @ Converter public static QR@@ Y_@@ P@@ CE to@@ Qry@@ P@@ CE ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ P@@ CE . class , body ) ; }
 static public ArrayList < Method > getClass@@ Public@@ Method ( Ph@@ p@@ Class php@@ Class ) { ArrayList < Method > methods = new ArrayList < Method > ( ) ; for ( Method method : php@@ Class . get@@ Methods ( ) ) { if ( method . get@@ Access ( ) . is@@ Public ( ) && ! method . getName ( ) . startsWith ( " _ _ " ) ) { methods . add ( method ) ; } } return methods ; }
 public static void n@@ ail@@ Main ( NG@@ Context ctx ) { n@@ ail . main ( ctx ) ; }
 public static void show@@ Success ( Activity activity , int message ) { Simple@@ Toast . ok ( activity , activity . getResources ( ) . getString ( message ) ) ; }
 public static boolean isValid@@ Maven@@ Home ( File home ) { return get@@ Maven@@ Conf@@ File ( home ) . exists ( ) ; }
 @ NotNull public static Map < Py@@ Generic@@ Type , Py@@ Type > un@@ ify@@ Receiver ( @ Nullable Py@@ Expression receiver , @ NotNull Type@@ Eval@@ Context context ) { final Map < Py@@ Generic@@ Type , Py@@ Type > substitutions = new LinkedHashMap < > ( ) ; final Set < Py@@ Generic@@ Type > generics = new LinkedHashSet < > ( ) ; final Py@@ Type qualifier@@ Type = receiver != null ? context . getType ( receiver ) : null ; collect@@ Generics ( qualifier@@ Type , context , generics , new HashSet < > ( ) ) ; for ( Py@@ Generic@@ Type t : generics ) { substitutions . put ( t , t ) ; } if ( qualifier@@ Type != null ) { for ( Py@@ ClassType type : to@@ Possible@@ Class@@ Types ( qualifier@@ Type ) ) { for ( Py@@ Type@@ Provider provider : Extensions . get@@ Extensions ( Py@@ Type@@ Provider . EP_@@ NAME ) ) { final Py@@ Type generic@@ Type = provider . getGeneric@@ Type ( type . get@@ Py@@ Class ( ) , context ) ; final Set < Py@@ Generic@@ Type > provi@@ ded@@ Type@@ Generics = new LinkedHashSet < > ( ) ; if ( generic@@ Type != null ) { match ( generic@@ Type , type , context , substitutions ) ; collect@@ Generics ( generic@@ Type , context , provi@@ ded@@ Type@@ Generics , new HashSet < > ( ) ) ; } for ( Map . Entry < Py@@ Type , Py@@ Type > entry : provider . getGeneric@@ Substitu@@ tions ( type . get@@ Py@@ Class ( ) , context ) . entrySet ( ) ) { final Py@@ Generic@@ Type generic@@ Key = as ( entry . getKey ( ) , Py@@ Generic@@ Type . class ) ; final Py@@ Type value = entry . getValue ( ) ; if ( generic@@ Key != null && value != null && ! substitutions . containsKey ( generic@@ Key ) && ! provi@@ ded@@ Type@@ Generics . contains ( generic@@ Key ) ) { substitutions . put ( generic@@ Key , value ) ; } } } } } replace@@ Unresolved@@ Generic@@ sWith@@ Any ( substitutions ) ; return substitutions ; }
 public static void main ( String [ ] args ) { Scanner console = new Scanner ( System . in ) ; int food = Integer . parseInt ( console . nextLine ( ) ) ; int foo@@ d@@ In@@ Gram@@ s = food * 1000 ; String command = console . nextLine ( ) ; int eat@@ en@@ F@@ ood = 0 ; int total@@ F@@ ood = 0 ; while ( ! command . equals ( " Ad@@ op@@ ted " ) ) { eat@@ en@@ F@@ ood = Integer . parseInt ( command ) ; total@@ F@@ ood += eat@@ en@@ F@@ ood ; command = console . nextLine ( ) ; } if ( foo@@ d@@ In@@ Gram@@ s >= total@@ F@@ ood ) { System . out . printf ( " F@@ ood ▁ is ▁ enough ! ▁ Le@@ f@@ to@@ vers : ▁ % s ▁ grams . " , foo@@ d@@ In@@ Gram@@ s - total@@ F@@ ood ) ; } else { System . out . printf ( " F@@ ood ▁ is ▁ not ▁ enough . ▁ You ▁ need ▁ % s ▁ grams ▁ more . " , total@@ F@@ ood - foo@@ d@@ In@@ Gram@@ s ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 30 to@@ Ad@@ t@@ A@@ 30 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 30 . class , body ) ; }
 public static void main ( String [ ] args ) { TreeNode tree = generate ( ) ; int [ ] post@@ Order = getPost@@ Order ( tree ) ; boolean verify@@ B@@ ST@@ Post@@ Order = verify@@ B@@ ST@@ Post@@ Order ( post@@ Order ) ; System . out . println ( verify@@ B@@ ST@@ Post@@ Order ) ; }
 @ Converter public static QR@@ Y_@@ R@@ 02 to@@ Qry@@ R@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ R@@ 02 . class , body ) ; }
 public static void initialize ( ) { id@@ Registr@@ ations . clear ( ) ; class@@ Registr@@ ations . clear ( ) ; registrations . clear ( ) ; next@@ Available@@ Id = - 2 ; locked = false ; register@@ Class@@ For@@ Id ( Disconnect@@ Message . SERIALIZ@@ ER_@@ ID , Disconnect@@ Message . class , new Disconnect@@ Message . Disconnect@@ Serializer ( ) ) ; register@@ Class@@ For@@ Id ( Client@@ Registration@@ Message . SERIALIZ@@ ER_@@ ID , Client@@ Registration@@ Message . class , new Client@@ Registration@@ Message . Client@@ Registration@@ Serializer ( ) ) ; register@@ Class ( boolean . class , new Boolean@@ Serializer ( ) ) ; register@@ Class ( byte . class , new Byte@@ Serializer ( ) ) ; register@@ Class ( char . class , new Char@@ Serializer ( ) ) ; register@@ Class ( short . class , new Short@@ Serializer ( ) ) ; register@@ Class ( int . class , new Int@@ Serializer ( ) ) ; register@@ Class ( long . class , new Long@@ Serializer ( ) ) ; register@@ Class ( float . class , new Float@@ Serializer ( ) ) ; register@@ Class ( double . class , new Double@@ Serializer ( ) ) ; register@@ Class ( Boolean . class , new Boolean@@ Serializer ( ) ) ; register@@ Class ( Byte . class , new Byte@@ Serializer ( ) ) ; register@@ Class ( Character . class , new Char@@ Serializer ( ) ) ; register@@ Class ( Short . class , new Short@@ Serializer ( ) ) ; register@@ Class ( Integer . class , new Int@@ Serializer ( ) ) ; register@@ Class ( Long . class , new Long@@ Serializer ( ) ) ; register@@ Class ( Float . class , new Float@@ Serializer ( ) ) ; register@@ Class ( Double . class , new Double@@ Serializer ( ) ) ; register@@ Class ( String . class , new String@@ Serializer ( ) ) ; register@@ Class ( Vector3f . class , new Vector3@@ Serializer ( ) ) ; register@@ Class ( Date . class , new Date@@ Serializer ( ) ) ; register@@ Class ( Abstract@@ Collection . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( Abstract@@ List . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( Abstract@@ Set . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( ArrayList . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( HashSet . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( LinkedHashSet . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( LinkedList . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( TreeSet . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( Vector . class , new Collection@@ Serializer ( ) ) ; register@@ Class ( Abstract@@ Map . class , new Map@@ Serializer ( ) ) ; register@@ Class ( Attributes . class , new Map@@ Serializer ( ) ) ; register@@ Class ( HashMap . class , new Map@@ Serializer ( ) ) ; register@@ Class ( Hashtable . class , new Map@@ Serializer ( ) ) ; register@@ Class ( Identity@@ HashMap . class , new Map@@ Serializer ( ) ) ; register@@ Class ( TreeMap . class , new Map@@ Serializer ( ) ) ; register@@ Class ( Weak@@ HashMap . class , new Map@@ Serializer ( ) ) ; register@@ Class ( Enum . class , new Enum@@ Serializer ( ) ) ; register@@ Class ( G@@ ZIP@@ Compressed@@ Message . class , new G@@ ZIP@@ Serializer ( ) ) ; register@@ Class ( ZIP@@ Compressed@@ Message . class , new ZIP@@ Serializer ( ) ) ; register@@ Class ( Channel@@ Info@@ Message . class ) ; }
 public static Serializer@@ Registration write@@ Class ( ByteBuffer buffer , Class type ) throws IOException { Serializer@@ Registration reg = get@@ Serializer@@ Registration ( type ) ; if ( reg == null ) { throw new Serializer@@ Exception ( " Class ▁ not ▁ registered : " + type ) ; } if ( log . isLoggable ( Level . FIN@@ ER ) ) { log . log ( Level . FIN@@ ER , " writing ▁ class : { 0 } ▁ with ▁ ID : { 1 } " , new Object [ ] { type , reg . getId ( ) } ) ; } buffer . putShort ( reg . getId ( ) ) ; return reg ; }
 @ Converter public static OR@@ D_@@ O@@ 02 to@@ Or@@ d@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ D_@@ O@@ 02 . class , body ) ; }
 public static boolean are@@ Variables@@ Un@@ modified@@ At@@ Locations ( @ NotNull Control@@ Flow flow , int startOffset , int endOffset , @ NotNull Set < ? extends Psi@@ Variable > variables , @ NotNull Iterable < ? extends PsiElement > locations ) { List < Instruction > instructions = flow . get@@ Instructions ( ) ; startOffset = Math . max ( startOffset , 0 ) ; endOffset = Math . min ( endOffset , instructions . size ( ) ) ; Int@@ ArrayList location@@ Offset@@ List = new Int@@ ArrayList ( ) ; for ( PsiElement location : locations ) { int offset = flow . getStartOffset ( location ) ; if ( offset >= startOffset && offset < endOffset ) { location@@ Offset@@ List . add ( offset ) ; } } int [ ] location@@ Offsets = location@@ Offset@@ List . toArray ( ) ; for ( int offset = startOffset ; offset < endOffset ; offset ++ ) { Instruction instruction = instructions . get ( offset ) ; if ( instruction instanceof Write@@ Variable@@ Instruction && variables . contains ( ( ( Write@@ Variable@@ Instruction ) instruction ) . variable ) ) { if ( are@@ Instruction@@ s@@ Reachable ( flow , location@@ Offsets , offset ) ) { return false ; } } } return true ; }
 public static SSLContext getEffective@@ SSLContext ( Http@@ Emitter@@ SSL@@ ClientConfig ssl@@ Config , SSLContext ssl@@ Context ) { SSLContext effective@@ SSLContext ; if ( ssl@@ Config . isUse@@ Default@@ Java@@ Context ( ) ) { try { effective@@ SSLContext = SSLContext . getDefault ( ) ; } catch ( NoSuchAlgorithmException ns@@ ae ) { throw new RuntimeException ( ns@@ ae ) ; } } else if ( ssl@@ Config . get@@ Trust@@ Store@@ Path ( ) != null ) { log . info ( " Creating ▁ SSLContext ▁ for ▁ Http@@ Emitter ▁ client ▁ using ▁ config ▁ [ % s ] " , ssl@@ Config ) ; effective@@ SSLContext = new TLS@@ Utils . Client@@ SSL@@ Context@@ Builder ( ) . set@@ Protocol ( ssl@@ Config . getProtocol ( ) ) . set@@ Trust@@ Store@@ Type ( ssl@@ Config . get@@ Trust@@ Store@@ Type ( ) ) . set@@ Trust@@ Store@@ Path ( ssl@@ Config . get@@ Trust@@ Store@@ Path ( ) ) . set@@ Trust@@ Store@@ Algorithm ( ssl@@ Config . get@@ Trust@@ Store@@ Algorithm ( ) ) . set@@ Trust@@ Store@@ Password@@ Provider ( ssl@@ Config . get@@ Trust@@ Store@@ Password@@ Provider ( ) ) . build ( ) ; } else { effective@@ SSLContext = ssl@@ Context ; } return effective@@ SSLContext ; }
 @ Deprecated public static String get@@ Cred@@ ent@@ ail@@ File ( ) { return credential@@ File ; }
 public static void disable@@ Metrics ( ) { set@@ Metric@@ Collector ( Metric@@ Collector . NONE ) ; }
 public static Multi@@ Part@@ Config get@@ Multi@@ Part@@ Config ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ MU@@ LI@@ T@@ PART , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { String location = properties . get ( Web@@ Config@@ Key . WEB_@@ MU@@ LI@@ T@@ PART_@@ LOCATION , Web@@ Config@@ Default . WEB_@@ MU@@ LI@@ T@@ PART_@@ LOCATION ) ; long max@@ FileSize = properties . getLong@@ Value ( Web@@ Config@@ Key . WEB_@@ MU@@ LI@@ T@@ PART_@@ MAX_@@ FILE_@@ SIZE , Web@@ Config@@ Default . WEB_@@ MU@@ LI@@ T@@ PART_@@ MAX_@@ FILE_@@ SIZE ) ; long max@@ Request@@ Size = properties . getLong@@ Value ( Web@@ Config@@ Key . WEB_@@ MU@@ LI@@ T@@ PART_@@ MAX_@@ REQUEST@@ _SIZE , Web@@ Config@@ Default . WEB_@@ MU@@ LI@@ T@@ PART_@@ MAX_@@ REQUEST@@ _SIZE ) ; int file@@ Size@@ Threshold = properties . getInt@@ Value ( Web@@ Config@@ Key . WEB_@@ MU@@ LI@@ T@@ PART_@@ FILE_@@ SIZE_@@ THRESHOLD , Web@@ Config@@ Default . WEB_@@ MU@@ LI@@ T@@ PART_@@ FILE_@@ SIZE_@@ THRESHOLD ) ; Multi@@ Part@@ Config result = new Multi@@ Part@@ Config ( location , max@@ FileSize , max@@ Request@@ Size , file@@ Size@@ Threshold ) ; return result ; } } ) ; return ( Multi@@ Part@@ Config ) cached@@ Config ; }
 public static void main ( String [ ] args ) { Solution solution = new Solution ( ) ; solution . read@@ Input ( ) ; solution . calculate@@ L@@ CS ( 0 , 0 ) ; solution . print@@ L@@ CS ( ) ; }
 public static Matcher < View > at@@ Position ( final int position , @ NonNull final Matcher < View > item@@ Matcher ) { return new Bounded@@ Matcher < View , RecyclerView > ( RecyclerView . class ) { @ Override public void describe@@ To ( Description description ) { description . append@@ Text ( " adapter ▁ position ▁ " + position + " : ▁ " ) ; item@@ Matcher . describe@@ To ( description ) ; } @ Override protected boolean matches@@ Saf@@ ely ( final RecyclerView view ) { RecyclerView . ViewHolder viewHolder = view . findView@@ Holder@@ For@@ Adapter@@ Position ( position ) ; return viewHolder != null && item@@ Matcher . matches ( viewHolder . itemView ) ; } } ; }
 private static void validate@@ Multi@@ Creation ( String database@@ 2@@ Name , String database@@ 1@@ In@@ EP@@ Name , String database@@ 2@@ In@@ EP@@ Name , String elastic@@ Pool@@ 1@@ Name , String elastic@@ Pool@@ 2@@ Name , String elastic@@ Pool@@ 3@@ Name , Sql@@ Server sql@@ Server , boolean delete@@ Using@@ Update ) { validate@@ Sql@@ Server ( sql@@ Server ) ; validate@@ Sql@@ Server ( sql@@ Server@@ Manager . sql@@ Servers ( ) . getBy@@ Resource@@ Group ( R@@ G_@@ NAME , SQL@@ _SERVER_@@ NAME ) ) ; validate@@ Sql@@ Database ( sql@@ Server . databases ( ) . get ( SQL_@@ DATABASE_@@ NAME ) , SQL_@@ DATABASE_@@ NAME ) ; validate@@ Sql@@ Firewall@@ Rule ( sql@@ Server . fire@@ wall@@ Rules ( ) . get ( SQL_@@ FIRE@@ WAL@@ L@@ RULE_@@ NAME ) , SQL_@@ FIRE@@ WAL@@ L@@ RULE_@@ NAME ) ; List < Sql@@ Firewall@@ Rule > fire@@ walls = sql@@ Server . fire@@ wall@@ Rules ( ) . list ( ) ; Assert . assertEquals ( 3 , fire@@ walls . size ( ) ) ; int start@@ IPAddress = 0 ; int end@@ IPAddress = 0 ; for ( Sql@@ Firewall@@ Rule firewall : fire@@ walls ) { if ( ! firewall . name ( ) . equalsIgnoreCase ( SQL_@@ FIRE@@ WAL@@ L@@ RULE_@@ NAME ) ) { Assert . assertEquals ( firewall . start@@ IPAddress ( ) , START_@@ IP@@ ADDRESS ) ; if ( firewall . end@@ IPAddress ( ) . equalsIgnoreCase ( START_@@ IP@@ ADDRESS ) ) { start@@ IPAddress ++ ; } else if ( firewall . end@@ IPAddress ( ) . equalsIgnoreCase ( END_@@ IP@@ ADDRESS ) ) { end@@ IPAddress ++ ; } } } Assert . assertEquals ( start@@ IPAddress , 1 ) ; Assert . assertEquals ( end@@ IPAddress , 1 ) ; Assert . assertNotNull ( sql@@ Server . databases ( ) . get ( database@@ 2@@ Name ) ) ; Assert . assertNotNull ( sql@@ Server . databases ( ) . get ( database@@ 1@@ In@@ EP@@ Name ) ) ; Assert . assertNotNull ( sql@@ Server . databases ( ) . get ( database@@ 2@@ In@@ EP@@ Name ) ) ; Sql@@ Elastic@@ Pool ep@@ 1 = sql@@ Server . elastic@@ Pools ( ) . get ( elastic@@ Pool@@ 1@@ Name ) ; validate@@ Sql@@ Elastic@@ Pool ( ep@@ 1 , elastic@@ Pool@@ 1@@ Name ) ; Sql@@ Elastic@@ Pool ep@@ 2 = sql@@ Server . elastic@@ Pools ( ) . get ( elastic@@ Pool@@ 2@@ Name ) ; Assert . assertNotNull ( ep@@ 2 ) ; Assert . assertEquals ( ep@@ 2 . edition ( ) , Elastic@@ Pool@@ Edi@@ tions . PRE@@ MI@@ UM ) ; Assert . assertEquals ( ep@@ 2 . list@@ Databases ( ) . size ( ) , 2 ) ; Assert . assertNotNull ( ep@@ 2 . get@@ Database ( database@@ 1@@ In@@ EP@@ Name ) ) ; Assert . assertNotNull ( ep@@ 2 . get@@ Database ( database@@ 2@@ In@@ EP@@ Name ) ) ; Sql@@ Elastic@@ Pool ep@@ 3 = sql@@ Server . elastic@@ Pools ( ) . get ( elastic@@ Pool@@ 3@@ Name ) ; Assert . assertNotNull ( ep@@ 3 ) ; Assert . assertEquals ( ep@@ 3 . edition ( ) , Elastic@@ Pool@@ Edi@@ tions . STANDARD ) ; if ( ! delete@@ Using@@ Update ) { sql@@ Server . databases ( ) . delete ( database@@ 2@@ Name ) ; sql@@ Server . databases ( ) . delete ( database@@ 1@@ In@@ EP@@ Name ) ; sql@@ Server . databases ( ) . delete ( database@@ 2@@ In@@ EP@@ Name ) ; sql@@ Server . databases ( ) . delete ( SQL_@@ DATABASE_@@ NAME ) ; Assert . assertEquals ( ep@@ 1 . list@@ Databases ( ) . size ( ) , 0 ) ; Assert . assertEquals ( ep@@ 2 . list@@ Databases ( ) . size ( ) , 0 ) ; Assert . assertEquals ( ep@@ 3 . list@@ Databases ( ) . size ( ) , 0 ) ; sql@@ Server . elastic@@ Pools ( ) . delete ( elastic@@ Pool@@ 1@@ Name ) ; sql@@ Server . elastic@@ Pools ( ) . delete ( elastic@@ Pool@@ 2@@ Name ) ; sql@@ Server . elastic@@ Pools ( ) . delete ( elastic@@ Pool@@ 3@@ Name ) ; fire@@ walls = sql@@ Server . fire@@ wall@@ Rules ( ) . list ( ) ; for ( Sql@@ Firewall@@ Rule fire@@ wall@@ Rule : fire@@ walls ) { fire@@ wall@@ Rule . delete ( ) ; } } else { sql@@ Server . update ( ) . without@@ Database ( database@@ 2@@ Name ) . without@@ Elastic@@ Pool ( elastic@@ Pool@@ 1@@ Name ) . without@@ Elastic@@ Pool ( elastic@@ Pool@@ 2@@ Name ) . without@@ Elastic@@ Pool ( elastic@@ Pool@@ 3@@ Name ) . without@@ Elastic@@ Pool ( elastic@@ Pool@@ 1@@ Name ) . without@@ Database ( database@@ 1@@ In@@ EP@@ Name ) . without@@ Database ( SQL_@@ DATABASE_@@ NAME ) . without@@ Database ( database@@ 2@@ In@@ EP@@ Name ) . without@@ Firewall@@ Rule ( SQL_@@ FIRE@@ WAL@@ L@@ RULE_@@ NAME ) . apply ( ) ; Assert . assertEquals ( sql@@ Server . elastic@@ Pools ( ) . list ( ) . size ( ) , 0 ) ; fire@@ walls = sql@@ Server . fire@@ wall@@ Rules ( ) . list ( ) ; Assert . assertEquals ( fire@@ walls . size ( ) , 2 ) ; for ( Sql@@ Firewall@@ Rule fire@@ wall@@ Rule : fire@@ walls ) { fire@@ wall@@ Rule . delete ( ) ; } } Assert . assertEquals ( sql@@ Server . elastic@@ Pools ( ) . list ( ) . size ( ) , 0 ) ; Assert . assertEquals ( sql@@ Server . databases ( ) . list ( ) . size ( ) , 1 ) ; }
 @ Converter public static AD@@ T_@@ A@@ 16 to@@ Ad@@ t@@ A@@ 16 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 16 . class , body ) ; }
 public static File get@@ Profile@@ s@@ Xml@@ Io@@ File ( VirtualFile po@@ mFile ) { return new File ( po@@ mFile . getParent ( ) . getPath ( ) , Maven@@ Constants . PRO@@ FILES_@@ XML ) ; }
 public static int [ ] read@@ I@@ ll@@ umin@@ ance@@ Values ( byte [ ] bytes ) { List < Byte > b@@ List = new ArrayList ( ) ; int i = 0 ; while ( i < bytes . length ) { if ( ! ( i % 2 == 0 || ( bytes [ i ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) == 250 ) ) { b@@ List . add ( Byte . valueOf ( bytes [ i ] ) ) ; } i ++ ; } int [ ] b@@ Array = new int [ b@@ List . size ( ) ] ; for ( int x = 0 ; x < b@@ List . size ( ) ; x ++ ) { b@@ Array [ x ] = Math . round ( ( float ) ( ( ( Byte ) b@@ List . get ( x ) ) . byteValue ( ) & Motion@@ Event@@ Compat . ACTION_@@ MASK ) ) ; } return b@@ Array ; }
 public static String getProject@@ Version ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . PROJECT_@@ VERSION , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { try { return properties . get ( Web@@ Config@@ Key . PROJECT_@@ VERSION ) ; } catch ( Property@@ NotFoundException e ) { throw new RuntimeException ( " Couldn ' t ▁ load ▁ " + Web@@ Config@@ Key . PROJECT_@@ VERSION ) ; } } } ) ; return ( String ) cached@@ Config ; }
 public static @ Nonnull Affinity@@ Group@@ Filter@@ Options getInstance ( boolean matches@@ Any , @ Nonnull String regex ) { Affinity@@ Group@@ Filter@@ Options options = new Affinity@@ Group@@ Filter@@ Options ( matches@@ Any ) ; options . regex = regex ; return options ; }
 public static boolean overri@@ des@@ Get@@ Attr ( @ NotNull Py@@ Class cls , @ NotNull Type@@ Eval@@ Context context ) { final Py@@ Type type = context . getType ( cls ) ; if ( type != null ) { if ( resolve@@ Type@@ Member ( type , Py@@ Names . GE@@ TA@@ TT@@ R , context ) != null ) { return true ; } final PsiElement method = resolve@@ Type@@ Member ( type , Py@@ Names . GE@@ TA@@ T@@ TRIBU@@ TE , context ) ; if ( method != null && ! Py@@ Builtin@@ Cache . getInstance ( cls ) . is@@ Builtin ( method ) ) { return true ; } } return false ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return JOB_@@ ID ; default : return null ; } }
 public static Long valueOf ( String string , int radix ) throws NumberFormatException { return valueOf ( parseLong ( string , radix ) ) ; }
 @ Converter public static BAR_@@ P@@ 05 to@@ Bar@@ P@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( BAR_@@ P@@ 05 . class , body ) ; }
 public static @ Nonnull Affinity@@ Group@@ Filter@@ Options getInstance ( ) { return new Affinity@@ Group@@ Filter@@ Options ( false ) ; }
 public static com . google . protobuf . Descriptors . FileDescriptor getDescriptor ( ) { return descriptor ; }
 public static Long valueOf ( String string ) throws NumberFormatException { return valueOf ( parseLong ( string ) ) ; }
 private static Sql@@ Server create@@ Sql@@ Server ( ) { return create@@ Sql@@ Server ( SQL@@ _SERVER_@@ NAME ) ; }
 public static String getDefault@@ Team@@ Number ( Context context , String defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " team@@ Pref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static boolean should@@ Permission@@ Show@@ R@@ ational@@ e ( @ NonNull Activity activity , @ NonNull String permission ) { return Activity@@ Compat . should@@ Show@@ Request@@ Permission@@ R@@ ational@@ e ( activity , permission ) ; }
 @ Converter public static MF@@ N_@@ M@@ 02 to@@ M@@ fn@@ M@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 02 . class , body ) ; }
 private static boolean isIn@@ side@@ Return@@ Statement ( PsiElement element ) { while ( element instanceof PsiExpression ) element = element . getParent ( ) ; return element instanceof Psi@@ Return@@ Statement ; }
 @ Converter public static OM@@ N_@@ O@@ 01 to@@ O@@ mn@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( OM@@ N_@@ O@@ 01 . class , body ) ; }
 public static VirtualFile find@@ Profile@@ s@@ XmlFile ( VirtualFile po@@ mFile ) { return po@@ mFile . getParent ( ) . findChild ( Maven@@ Constants . PRO@@ FILES_@@ XML ) ; }
 @ NotNull private static List < Py@@ ClassType > to@@ Possible@@ Class@@ Types ( @ NotNull Py@@ Type type ) { final Py@@ ClassType classType = as ( type , Py@@ ClassType . class ) ; if ( classType != null ) { return Collections . singletonList ( classType ) ; } final Py@@ Union@@ Type union@@ Type = as ( type , Py@@ Union@@ Type . class ) ; if ( union@@ Type != null ) { return Stream@@ Ex . of ( union@@ Type . get@@ Members ( ) ) . non@@ Null ( ) . flatMap ( t -> to@@ Possible@@ Class@@ Types ( t ) . stream ( ) ) . toList ( ) ; } return Collections . emptyList ( ) ; }
 private static List < Class > find@@ Classes ( File dir , String pkg@@ Name ) throws ClassNotFoundException { List < Class > classes = new ArrayList < Class > ( ) ; if ( ! dir . exists ( ) ) { return classes ; } File [ ] files = dir . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { assert ! file . getName ( ) . contains ( " . " ) ; classes . addAll ( find@@ Classes ( file , pkg@@ Name + " . " + file . getName ( ) ) ) ; } else if ( file . getName ( ) . endsWith ( " . class " ) ) { classes . add ( Class . forName ( pkg@@ Name + ' . ' + file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - 6 ) ) ) ; } } return classes ; }
 public static Instruction safe@@ get ( String name ) { Instruction res = instruction@@ Map . get ( name ) ; if ( res == null ) { throw new RuntimeException ( " Instruction ▁ with ▁ name ▁ " + name + " ▁ not ▁ found " ) ; } return res ; }
 public static String parse@@ GroupName ( String namespace@@ And@@ Name@@ Combo ) { if ( namespace@@ And@@ Name@@ Combo == null ) { return null ; } String [ ] group@@ Data = namespace@@ And@@ Name@@ Combo . split ( Ke@@ w@@ Api@@ Constants . K@@ IM_@@ GROUP_@@ NAMESPACE_@@ NAME_@@ DELIMI@@ TER_@@ CHARACTER ) ; if ( group@@ Data . length == 1 ) { return group@@ Data [ 0 ] . trim ( ) ; } else if ( group@@ Data . length == 2 ) { return group@@ Data [ 1 ] . trim ( ) ; } else { return null ; } }
 @ Converter public static SR@@ M_S@@ 08 to@@ S@@ rm@@ S@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 08 . class , body ) ; }
 public static Test suite ( ) { return new TestSuite ( Test@@ In@@ mem@@ Queue@@ Bound@@ Small@@ Ep@@ hemer@@ al@@ Disabled . class ) ; }
 @ Converter public static AD@@ T_@@ A@@ 43 to@@ Ad@@ t@@ A@@ 43 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 43 . class , body ) ; }
 @ NotNull private static Optional < Boolean > match ( @ NotNull Py@@ Callable@@ Type expected , @ NotNull Py@@ Callable@@ Type actual , @ NotNull Match@@ Context context ) { if ( expected . is@@ Callable ( ) && actual . is@@ Callable ( ) ) { final List < Py@@ Callable@@ Parameter > expected@@ Parameters = expected . getParameters ( context . context ) ; final List < Py@@ Callable@@ Parameter > actual@@ Parameters = actual . getParameters ( context . context ) ; if ( expected@@ Parameters != null && actual@@ Parameters != null ) { final int size = Math . min ( expected@@ Parameters . size ( ) , actual@@ Parameters . size ( ) ) ; for ( int i = 0 ; i < size ; i ++ ) { final Py@@ Callable@@ Parameter expected@@ Param = expected@@ Parameters . get ( i ) ; final Py@@ Callable@@ Parameter actual@@ Param = actual@@ Parameters . get ( i ) ; if ( ! match ( expected@@ Param . getType ( context . context ) , actual@@ Param . getType ( context . context ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } } if ( ! match ( expected . getReturnType ( context . context ) , actual . getReturnType ( context . context ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } return Optional . of ( true ) ; } return Optional . empty ( ) ; }
 @ Converter public static R@@ ER_@@ RE@@ R to@@ Rer@@ R@@ er ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ ER_@@ RE@@ R . class , body ) ; }
 private static void save@@ Sub@@ scriptions ( final Context context , final Linked@@ ListMultimap < String , String > subscriptions ) { if ( subscriptions != null ) { final JSONObject JSON = new JSONObject ( ) ; final JSONArray title@@ s@@ JSON = new JSONArray ( ) ; final JSONArray categ@@ ories@@ JSON = new JSONArray ( ) ; final JSONArray ids@@ JSON = new JSONArray ( ) ; final JSONArray url@@ s@@ JSON = new JSONArray ( ) ; final List < String > titles = new ArrayList < > ( subscriptions . asMap ( ) . keySet ( ) ) ; Collections . sort ( titles ) ; for ( final String title : titles ) { final Iterator < String > iter = subscriptions . get ( title ) . iterator ( ) ; title@@ s@@ JSON . put ( title ) ; categ@@ ories@@ JSON . put ( iter . next ( ) ) ; ids@@ JSON . put ( iter . next ( ) ) ; url@@ s@@ JSON . put ( iter . next ( ) ) ; } try { JSON . put ( KEY@@ _SUB@@ SCRIP@@ TION_@@ TIT@@ LES , title@@ s@@ JSON ) ; JSON . put ( KEY@@ _SUB@@ SCRIP@@ TION_@@ CATEG@@ ORI@@ ES , categ@@ ories@@ JSON ) ; JSON . put ( KEY@@ _SUB@@ SCRIP@@ TION_@@ IDS , ids@@ JSON ) ; JSON . put ( KEY@@ _SUB@@ SCRIP@@ TION_@@ URL@@ S , url@@ s@@ JSON ) ; put ( context , KEY@@ _SUB@@ SCRIP@@ TIONS , JSON . toString ( ) ) ; } catch ( final JSONException e ) { Log@@ Utils . logError ( e ) ; } } else { put ( context , KEY@@ _SUB@@ SCRIP@@ TIONS , null ) ; } s@@ Sub@@ scriptions = null ; s@@ Subscription@@ List = null ; }
 @ Nullable static public String getArray@@ KeyValue@@ Inside@@ Signature ( PsiElement psi@@ Element@@ Inside@@ Class , String call@@ To , String methodName , String keyName ) { return getArray@@ KeyValue@@ Inside@@ Signature ( psi@@ Element@@ Inside@@ Class , new String [ ] { call@@ To } , methodName , keyName ) ; }
 public static Versioned@@ GestureDetector newInstance ( Context context , On@@ Gesture@@ Listener listener ) { final int sdk@@ Version = Build . VERSION . SDK_INT ; Versioned@@ GestureDetector detector = null ; if ( sdk@@ Version < Build . VERSION_CODES . EC@@ LAI@@ R ) { detector = new C@@ up@@ ca@@ ke@@ Detector ( context ) ; } else if ( sdk@@ Version < Build . VERSION_CODES . FRO@@ Y@@ O ) { detector = new E@@ cl@@ air@@ Detector ( context ) ; } else { detector = new Fro@@ yo@@ Detector ( context ) ; } detector . mListener = listener ; return detector ; }
 public static long highest@@ One@@ Bit ( long v ) { v |= ( v >> 1 ) ; v |= ( v >> 2 ) ; v |= ( v >> 4 ) ; v |= ( v >> 8 ) ; v |= ( v >> 16 ) ; v |= ( v >> 32 ) ; return v - ( v >@@ >> 1 ) ; }
 @ Converter public static C@@ SU@@ _C@@ 10 to@@ C@@ su@@ C@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( C@@ SU@@ _C@@ 10 . class , body ) ; }
 public static void replace@@ With@@ PO@@ Join@@ Package ( Physical@@ Plan plan , MapReduce@@ Oper mr , PO@@ Package pack , PO@@ For@@ Each forEach , String chunkSize ) throws Visitor@@ Exception { String scope = pack . get@@ Operator@@ Key ( ) . scope ; Node@@ Id@@ Generator ni@@ g = Node@@ Id@@ Generator . get@@ Generator ( ) ; PO@@ Join@@ Package join@@ Package ; join@@ Package = new PO@@ Join@@ Package ( new Operator@@ Key ( scope , ni@@ g . getNext@@ NodeId ( scope ) ) , - 1 , pack , forEach ) ; join@@ Package . set@@ ChunkSize ( Long . parseLong ( chunkSize ) ) ; List < Physical@@ Operator > suc@@ cs = plan . get@@ Success@@ ors ( forEach ) ; if ( suc@@ cs != null ) { if ( suc@@ cs . size ( ) != 1 ) { int errCode = 202@@ 8 ; String msg = " For@@ Each ▁ can ▁ only ▁ have ▁ one ▁ successor . ▁ Found ▁ " + suc@@ cs . size ( ) + " ▁ successors . " ; throw new MR@@ Compiler@@ Exception ( msg , errCode , Pig@@ Exception . BUG ) ; } } plan . remove ( pack ) ; try { plan . replace ( forEach , join@@ Package ) ; } catch ( Plan@@ Exception e ) { int errCode = 202@@ 9 ; String msg = " Error ▁ re@@ writing ▁ PO@@ Join@@ Package . " ; throw new MR@@ Compiler@@ Exception ( msg , errCode , Pig@@ Exception . BUG , e ) ; } mr . phy@@ To@@ MR@@ Map . put ( forEach , join@@ Package ) ; LogFactory . getLog ( Last@@ Input@@ Streaming@@ Optimizer . class ) . info ( " Rewrite : ▁ PO@@ Package - > PO@@ For@@ Each ▁ to ▁ PO@@ Join@@ Package " ) ; }
 public static boolean should@@ Permissions@@ Show@@ R@@ ational@@ e ( @ NonNull Activity activity , @ NonNull String ... permissions ) { for ( String permission : permissions ) { if ( Activity@@ Compat . should@@ Show@@ Request@@ Permission@@ R@@ ational@@ e ( activity , permission ) ) { return true ; } } return false ; }
 public static boolean is@@ Unknown ( @ Nullable Py@@ Type type , @ NotNull Type@@ Eval@@ Context context ) { return is@@ Unknown ( type , true , context ) ; }
 @ Converter public static OR@@ U_@@ R@@ 01 to@@ O@@ ru@@ R@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ U_@@ R@@ 01 . class , body ) ; }
 public static void main ( String [ ] args ) { Fast@@ Scanner in = new Fast@@ Scanner ( ) ; int cases = in . nextInt ( ) ; for ( int q = 0 ; q < cases ; q ++ ) { int n = in . nextInt ( ) ; int [ ] ar@@ r1 = new int [ n ] ; int [ ] ar@@ r2 = new int [ n ] ; HashSet < Integer > set = new HashSet < Integer > ( ) ; for ( int a = 0 ; a < n ; a ++ ) { ar@@ r1 [ a ] = in . nextInt ( ) ; } for ( int a = 0 ; a < n ; a ++ ) { ar@@ r2 [ a ] = in . nextInt ( ) ; } int start = 1 ; int end = 1 ; StringBuilder out = new StringBuilder ( ) ; for ( int a = 0 ; a < n ; a ++ ) { add@@ Remove@@ Set ( ar@@ r1 [ a ] , set ) ; add@@ Remove@@ Set ( ar@@ r2 [ a ] , set ) ; if ( set . size ( ) == 0 ) { out . append ( start + " - " + end + " ▁ " ) ; start = end + 1 ; end = start ; } else { end ++ ; } } System . out . println ( out ) ; } }
 public static Intent get@@ Calling@@ Intent ( Context context , long trip@@ Id ) { Intent call@@ ing@@ Intent = new Intent ( context , Trip@@ Activity . class ) ; call@@ ing@@ Intent . putExtra ( TRI@@ P_@@ ID_@@ KEY , trip@@ Id ) ; return call@@ ing@@ Intent ; }
 private static boolean match ( @ NotNull Py@@ Collection@@ Type expected , @ NotNull Py@@ ClassType actual , @ NotNull Match@@ Context context ) { if ( actual instanceof Py@@ TupleType ) { return match ( expected , ( Py@@ TupleType ) actual , context ) ; } final Py@@ Class superClass = expected . get@@ Py@@ Class ( ) ; final Py@@ Class sub@@ Class = actual . get@@ Py@@ Class ( ) ; return match@@ Classes ( superClass , sub@@ Class , context . context ) && match@@ Generics ( expected , actual , context ) ; }
 @ Nullable public static Py@@ Type to@@ Non@@ Weak@@ Type ( @ Nullable Py@@ Type type , @ NotNull Type@@ Eval@@ Context context ) { if ( type instanceof Py@@ Union@@ Type ) { final Py@@ Union@@ Type union@@ Type = ( Py@@ Union@@ Type ) type ; if ( union@@ Type . is@@ We@@ ak ( ) ) { return union@@ Type . exclude@@ Null ( context ) ; } } return type ; }
 @ Converter public static SR@@ R@@ _S@@ 08 to@@ S@@ rr@@ S@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 08 . class , body ) ; }
 public static void main ( String [ ] args ) { String mac = " " ; try { Process p = new Process@@ Builder ( " if@@ config " ) . start ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { Pattern pat = Pattern . compile ( " \\ b \\ w + : \\ w + : \\ w + : \\ w + : \\ w + : \\ w + \\ b " ) ; Matcher mat = pat . matcher ( line ) ; if ( mat . find ( ) ) { mac = mat . group ( 0 ) ; } } br . close ( ) ; } catch ( IOException e ) { } System . out . println ( " 本@@ 机@@ MAC@@ 地@@ 址@@ 为 : \n " + mac ) ; }
 public static void delete@@ Course@@ Status ( String i@@ Course@@ ID , String i@@ Lear@@ ner@@ ID ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " delete@@ Course@@ Status " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : delete@@ Course@@ Status " ) ; }
 private static boolean isElement@@ Of@@ Class ( @ NotNull PsiElement element , @ NotNull Class ... classes@@ Filter ) { for ( Class a@@ Classes@@ Filter : classes@@ Filter ) { if ( Reflection@@ Util . isAssign@@ able ( a@@ Classes@@ Filter , element . getClass ( ) ) ) { return true ; } } return false ; }
 @ Converter public static SR@@ R@@ _S@@ 05 to@@ S@@ rr@@ S@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 05 . class , body ) ; }
 public static J@@ Meter@@ Element getType ( TYPE find@@ Type , List < J@@ Meter@@ Element > in@@ List ) { for ( J@@ Meter@@ Element je : in@@ List ) { if ( je . type == find@@ Type ) return je ; } return null ; }
 public static < T > void put ( final Context context , final String key , @ Nullable final T value ) { final SharedPreferences . Editor preferences = get@@ SharedPreferences ( context ) . edit ( ) ; if ( value == null || value instanceof String ) { preferences . putString ( key , ( String ) value ) ; } else { preferences . putInt ( key , ( Integer ) value ) ; } preferences . apply ( ) ; }
 @ Converter public static R@@ AS_@@ O@@ 01 to@@ R@@ as@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ AS_@@ O@@ 01 . class , body ) ; }
 static public Throwable warn ( String msg ) { return warn ( Sys . WATER , msg , null ) ; }
 @ Converter public static RG@@ V_@@ O@@ 01 to@@ Rg@@ v@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( RG@@ V_@@ O@@ 01 . class , body ) ; }
 private static String [ ] [ ] [ ] read@@ Annotations ( final int plate@@ Count , final int rows , final int cols , final String annotation@@ FileName ) throws IOException { final String [ ] [ ] [ ] ret = new String [ plate@@ Count ] [ rows * cols ] [ 2 ] ; if ( annotation@@ FileName . isEmpty ( ) ) { return ret ; } InputStream stream ; try { stream = Open@@ Stream . open ( Open@@ Stream . convert@@ URI ( annotation@@ FileName ) ) ; } catch ( final URISyntaxException e ) { throw new RuntimeException ( e ) ; } try { final Reader file@@ Reader = new InputStreamReader ( stream ) ; try { final BufferedReader br = new BufferedReader ( file@@ Reader ) ; try { String line = null ; while ( ( line = br . readLine ( ) ) != null ) { final int [ ] indices = get@@ Indices ( line , rows , cols ) ; if ( indices != null ) { try { final String [ ] parts = line . split ( " \t " ) ; ret [ indices [ 0 ] ] [ indices [ 1 ] ] [ 0 ] = parts . length > 2 ? parts [ 2 ] : null ; ret [ indices [ 0 ] ] [ indices [ 1 ] ] [ 1 ] = line . substring ( line . lastIndexOf ( ' \t ' ) + 1 ) ; } catch ( final RuntimeException e ) { } } } return ret ; } finally { br . close ( ) ; } } finally { file@@ Reader . close ( ) ; } } finally { stream . close ( ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 02 to@@ Ad@@ t@@ A@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 02 . class , body ) ; }
 @ Converter public static DF@@ T_@@ P@@ 03 to@@ D@@ ft@@ P@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( DF@@ T_@@ P@@ 03 . class , body ) ; }
 public static void Close ( ) { try { conn . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
 private static boolean are@@ Satisfied ( @ Nonnull Condition [ ] conditions ) { for ( Condition condition : conditions ) { checkNotNull ( condition ) ; if ( ! condition . test ( ) ) { return false ; } } return true ; }
 public static String toString ( Object object ) { return object == null ? EMPTY : object . toString ( ) ; }
 static public RuntimeException err@@ RT@@ Except ( Throwable exception ) { return new RuntimeException ( err ( Sys . WATER , " " , exception ) ) ; }
 @ NotNull public static VirtualFile resolve@@ Super@@ Po@@ mFile ( @ Nullable File maven@@ Home ) { VirtualFile result = null ; if ( maven@@ Home != null ) { result = do@@ Resolve@@ Super@@ Po@@ mFile ( new File ( maven@@ Home , LIB_@@ DIR ) ) ; } if ( result == null ) { result = do@@ Resolve@@ Super@@ Po@@ mFile ( Maven@@ Fac@@ ade@@ Manager . collect@@ ClassPath@@ And@@ LI@@ bs@@ Folder ( ) . second ) ; } return result ; }
 public static void main ( String [ ] args ) throws Exception { Loader . load@@ Native@@ Libraries ( ) ; Cp@@ Model model = new Cp@@ Model ( ) ; int num@@ Vals = 3 ; Int@@ Var x = model . new@@ Int@@ Var ( 0 , num@@ Vals - 1 , " x " ) ; Int@@ Var y = model . new@@ Int@@ Var ( 0 , num@@ Vals - 1 , " y " ) ; Int@@ Var z = model . new@@ Int@@ Var ( 0 , num@@ Vals - 1 , " z " ) ; model . add@@ Different ( x , y ) ; Cp@@ Solver solver = new Cp@@ Solver ( ) ; Var@@ Array@@ Solution@@ Printer cb = new Var@@ Array@@ Solution@@ Printer ( new Int@@ Var [ ] { x , y , z } ) ; solver . getParameters ( ) . set@@ Enumerate@@ All@@ Solutions ( true ) ; solver . solve ( model , cb ) ; System . out . println ( cb . get@@ Solution@@ Count ( ) + " ▁ solutions ▁ found . " ) ; }
 public static FT@@ PS@@ Client create@@ Connection ( String hostname , int port , char [ ] username , char [ ] password , String working@@ Directory , FileSystem@@ Options file@@ System@@ Options ) throws FileSystem@@ Exception { return create@@ Connection ( hostname , port , username , password , working@@ Directory , file@@ System@@ Options , null ) ; }
 public static void do@@ Action ( Action@@ Context action@@ Context ) throws IOException { World world = World . getInstance ( ) ; HttpServletRequest request = ( HttpServletRequest ) action@@ Context . get ( " request " ) ; String data@@ Object@@ Path = request . getParameter ( " data@@ Object@@ Path " ) ; Thing data@@ Object@@ Config = world . get@@ Thing ( data@@ Object@@ Path ) ; if ( ! SecurityManager . do@@ Check ( " WEB " , Permission@@ Constants . X@@ WOR@@ KER_@@ DATA@@ OBJECT , " read " , data@@ Object@@ Path , action@@ Context ) ) { return ; } String record = " { } " ; Map < String , Object > result = Util@@ Map . toMap ( new Object [ ] { " success " , " true " , " msg " , " " } ) ; action@@ Context . peek ( ) . put ( " result " , result ) ; if ( data@@ Object@@ Config == null ) { result . put ( " success " , " false " ) ; result . put ( " msg " , " 数据@@ 对@@ 象@@ 定@@ 义@@ 不@@ 存@@ 在 ， data@@ Object = " + request . getParameter ( " data@@ Object@@ Path " ) ) ; } else { try { DataObject theData = new DataObject ( data@@ Object@@ Config ) ; Thing key@@ Thing = ( Thing ) theData . getKey@@ And@@ Datas ( ) [ 0 ] [ 0 ] ; theData . put ( key@@ Thing . getString ( " name " ) , request . getParameter ( " id " ) ) ; theData . do@@ Action ( " load " , action@@ Context ) ; Thing json@@ Factory = world . get@@ Thing ( " x@@ worker . text . Json@@ DataFormat " ) ; record = ( String ) json@@ Factory . do@@ Action ( " format " , action@@ Context , Util@@ Map . toMap ( new Object [ ] { " data " , theData } ) ) ; if ( result . get ( " msg " ) == null ) { result . put ( " msg " , " 数据@@ 读@@ 取@@ 成@@ 功 " ) ; } } catch ( Exception e ) { Executor . error ( TAG , " 数据@@ 读@@ 取@@ 失@@ 败 " , e ) ; result . put ( " success " , " false " ) ; result . put ( " msg " , Json@@ Format@@ or . format@@ String ( Exception@@ Util . getRoot@@ Message ( e ) ) ) ; } } HttpServletResponse response = ( HttpServletResponse ) action@@ Context . get ( " response " ) ; if ( Servlet@@ File@@ Upload . is@@ Multipart@@ Content ( request ) ) { response . setContentType ( " text / html ; ▁ charset = utf - 8" ) ; } else { response . setContentType ( " text / plain ; ▁ charset = utf - 8" ) ; } String code = " { \n " + " \@@ " success \@@ " : " + result . get ( " success " ) + " , \n " + " \@@ " msg \@@ " : \@@ " " + result . get ( " msg " ) + " \@@ " , \n " + " \@@ " data \@@ " : " + record + " \n " + " } " ; response . getWriter ( ) . println ( code ) ; }
 private static void doTest ( Map < String , String > graph , String ... expected@@ Paths ) { doTest ( graph , 10 , expected@@ Paths ) ; }
 protected static Bra@@ int@@ ree@@ Api@@ Name getApi@@ Name ( Class < ? extends Api@@ Method > api@@ Method ) { return Bra@@ int@@ ree@@ Api@@ Collection . get@@ Collection ( ) . getApi@@ Name ( api@@ Method ) ; }
 @ Converter public static R@@ Q@@ C_@@ I@@ 06 to@@ R@@ q@@ c@@ I@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ C_@@ I@@ 06 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 45 to@@ Ad@@ t@@ A@@ 45 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 45 . class , body ) ; }
 public static void set@@ Dont@@ Prompt ( Context context , boolean dont@@ Prompt ) { SharedPreferences prefs = PreferenceManager . getDefault@@ SharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( " doNot@@ Ask@@ URL " , dont@@ Prompt ) ; editor . apply ( ) ; }
 private static long count@@ Versions ( final F@@ ed@@ ora@@ Session session , final F@@ ed@@ ora@@ Resource resource ) throws RepositoryException { final Version@@ History versions = getJ@@ cr@@ Session ( session ) . get@@ Workspace ( ) . getVersion@@ Manager ( ) . getVersion@@ History ( getJ@@ cr@@ Node ( resource ) . getPath ( ) ) ; return versions . getAll@@ Versions ( ) . getSize ( ) ; }
 public static < T > T get ( final Context context , final String key , final Class < T > clazz ) { if ( clazz . equals ( String . class ) ) { return ( T ) get@@ SharedPreferences ( context ) . getString ( key , null ) ; } return ( T ) ( Integer ) get@@ SharedPreferences ( context ) . getInt ( key , 0 ) ; }
 public static LocalTime to@@ LocalTime ( Long i ) { LocalTime lt = ( i == null ? null : LocalTime . of@@ Nano@@ OfDay ( i ) ) ; return lt ; }
 @ Converter public static AD@@ T_@@ A@@ 32 to@@ Ad@@ t@@ A@@ 32 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 32 . class , body ) ; }
 private static int update@@ Current@@ Feed@@ Position ( final Context context , final String title ) { if ( ! TextUtils . isEmpty ( title ) ) { final int position = getSub@@ scription@@ Position@@ After@@ Edit ( context , title ) ; put@@ Current@@ Feed@@ Position ( context , position ) ; return position ; } return 0 ; }
 public static int get@@ Fade@@ Out@@ Duration ( ) { return settings . getInt ( GLOB@@ AL@@ _SETT@@ ING_@@ FA@@ DE_@@ OUT_@@ DURATION , 0 ) ; }
 private static TreeMap < Key , Value > create@@ Output@@ Data ( ) { TreeMap < Key , Value > data = new TreeMap < > ( ) ; Key last@@ Key = null ; long sum = 0 ; for ( Entry < Key , Value > entry : INPUT_@@ DATA . entrySet ( ) ) { if ( null == last@@ Key ) { last@@ Key = entry . getKey ( ) ; sum += Long . parseLong ( entry . getValue ( ) . toString ( ) ) ; } else { if ( 0 != last@@ Key . compareTo ( entry . getKey ( ) , Partial@@ Key . ROW_@@ COL@@ F@@ AM_@@ COL@@ QU@@ AL_@@ COL@@ V@@ IS ) ) { data . put ( last@@ Key , new Value ( Long . toString ( sum ) ) ) ; last@@ Key = entry . getKey ( ) ; sum = 0 ; } sum += Long . parseLong ( entry . getValue ( ) . toString ( ) ) ; } } data . put ( last@@ Key , new Value ( Long . toString ( sum ) ) ) ; return data ; }
 @ Converter public static AD@@ T_@@ A@@ 10 to@@ Ad@@ t@@ A@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 10 . class , body ) ; }
 @ Nullable private static PsiElement get@@ Enclosing@@ Un@@ reachable@@ Statement ( @ NotNull PsiElement statement ) { final PsiElement parent = statement . getParent ( ) ; if ( parent instanceof Psi@@ Do@@ While@@ Statement && ( ( Psi@@ Do@@ While@@ Statement ) parent ) . getBody ( ) == statement ) { return parent ; } if ( parent instanceof Psi@@ CodeBlock && PsiTreeUtil . getNext@@ Sibling@@ OfType ( parent . getFirstChild ( ) , Psi@@ Statement . class ) == statement ) { final Psi@@ Block@@ Statement block@@ Statement = ObjectUtils . try@@ Cast ( parent . getParent ( ) , Psi@@ Block@@ Statement . class ) ; if ( block@@ Statement != null ) { final PsiElement block@@ Parent = block@@ Statement . getParent ( ) ; if ( block@@ Parent instanceof Psi@@ Do@@ While@@ Statement && ( ( Psi@@ Do@@ While@@ Statement ) block@@ Parent ) . getBody ( ) == block@@ Statement ) { return block@@ Parent ; } } } return getUn@@ reachable@@ Statement@@ Parent ( statement ) ; }
 public static String get@@ NotNull@@ String ( Map < String , Object > map , String key ) { if ( map == null || ! map . containsKey ( key ) ) { return EMPTY ; } return toString ( map . get ( key ) ) ; }
 public static void add@@ Activity ( Activity activity ) { activities . add ( activity ) ; }
 @ Converter public static AD@@ T_@@ A@@ 04 to@@ Ad@@ t@@ A@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 04 . class , body ) ; }
 private static void collect@@ Method@@ Element@@ sWith@@ Parents ( final @ NotNull Method method , final int depth , @ NotNull final Collection < PsiElement > elements , @ NotNull final Processor < PsiElement > processor ) { method . accept@@ Children ( new Psi@@ Recursive@@ Element@@ Walk@@ ing@@ Visitor ( ) { @ Override public void visit@@ Element ( PsiElement psiElement ) { if ( processor . process ( psiElement ) ) { elements . add ( psiElement ) ; } if ( psiElement instanceof Method@@ Reference && ( ( Method@@ Reference ) psiElement ) . getReference@@ Type ( ) == Ph@@ p@@ Modifier . State . PARENT && method . getName ( ) . equals ( ( ( Method@@ Reference ) psiElement ) . getName ( ) ) ) { PsiElement resolve = ( ( Method@@ Reference ) psiElement ) . resolve ( ) ; if ( depth > 0 && resolve instanceof Method ) { collect@@ Method@@ Element@@ sWith@@ Parents ( ( Method ) resolve , depth - 1 , elements , processor ) ; } } super . visit@@ Element ( psiElement ) ; } } ) ; }
 public static Temporal@@ Query < ZoneId > zoneId ( ) { return Temporal@@ Queries . ZONE_@@ ID ; }
 @ Converter public static PP@@ P_@@ PC@@ D to@@ P@@ pp@@ P@@ cd ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ P_@@ PC@@ D . class , body ) ; }
 public static String getPosition ( Context context , String defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " position@@ Pref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static long getAnd@@ Add@@ Request ( AtomicLong requested , long n ) { while ( true ) { long current = requested . get ( ) ; long next = add@@ Cap ( current , n ) ; if ( requested . compareAndSet ( current , next ) ) { return current ; } } }
 public static void execute@@ No@@ Catch ( String projectId ) throws Exception { try ( Cluster@@ Controller@@ Client client = Cluster@@ Controller@@ Client . create ( ) ) { String project@@ Id2 = projectId ; String region = " global " ; List@@ Cluster@@ s@@ Paged@@ Response page@@ d@@ Response = client . list@@ Clusters ( project@@ Id2 , region ) ; } }
 public static synchronized void set@@ Credential@@ Provider ( AWS@@ CredentialsProvider provider ) { credential@@ Provider = provider ; }
 public static Singleton@@ Graph getInstance ( ) throws ConfigurationException { if ( Singleton@@ Graph . instance == null ) { Singleton@@ Graph . instance = new Singleton@@ Graph ( ) ; } return Singleton@@ Graph . instance ; }
 public static CharSequence of ( String s ) { return s ; }
 private static Map < String , Object > find@@ Build@@ Info@@ In@@ Up@@ stream@@ Stage ( Stage current@@ Stage , List < Pattern > package@@ File@@ Patterns ) { Stage up@@ stream@@ Stage = current@@ Stage . ancestors ( ) . stream ( ) . filter ( it -> { Map < String , Object > build@@ Info = ( Map < String , Object > ) it . get@@ Outputs ( ) . get ( " build@@ Info " ) ; return build@@ Info != null && artifact@@ Match ( ( List < Map < String , String > > ) build@@ Info . get ( " artifacts " ) , package@@ File@@ Patterns ) ; } ) . find@@ First ( ) . orElse ( null ) ; return up@@ stream@@ Stage != null ? ( Map < String , Object > ) up@@ stream@@ Stage . get@@ Outputs ( ) . get ( " build@@ Info " ) : emptyMap ( ) ; }
 @ Converter public static AD@@ T_@@ A@@ 08 to@@ Ad@@ t@@ A@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 08 . class , body ) ; }
 public static Map@@ Provider@@ Factory getInstance ( ) { if ( map@@ Factory == null ) { map@@ Factory = new Map@@ Provider@@ Factory ( ) ; } return map@@ Factory ; }
 public static < Stream@@ MessageType > void contains@@ In@@ Order ( Map < Integer , List < Stream@@ MessageType > > expected , InMemory@@ Output@@ Descriptor < Stream@@ MessageType > output@@ Descriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( output@@ Descriptor ) ; Map < Integer , List < Stream@@ MessageType > > actual = TestRunner . consume@@ Stream ( output@@ Descriptor , timeout ) ; for ( Integer par@@ ition@@ Id : expected . keySet ( ) ) { assertThat ( actual . get ( par@@ ition@@ Id ) , Is@@ Iterable@@ Containing@@ In@@ Order . contains ( expected . get ( par@@ ition@@ Id ) . toArray ( ) ) ) ; } }
 private static boolean match@@ Numeric@@ Types ( Py@@ Type expected , Py@@ Type actual ) { final String super@@ Name = expected . getName ( ) ; final String sub@@ Name = actual . getName ( ) ; final boolean sub@@ Is@@ Bool = " bool " . equals ( sub@@ Name ) ; final boolean sub@@ Is@@ Int = Py@@ Names . TYPE_@@ INT . equals ( sub@@ Name ) ; final boolean sub@@ Is@@ Long = Py@@ Names . TYPE_@@ LONG . equals ( sub@@ Name ) ; final boolean sub@@ Is@@ Float = " float " . equals ( sub@@ Name ) ; final boolean sub@@ Is@@ Complex = " complex " . equals ( sub@@ Name ) ; if ( super@@ Name == null || sub@@ Name == null || super@@ Name . equals ( sub@@ Name ) || ( Py@@ Names . TYPE_@@ INT . equals ( super@@ Name ) && sub@@ Is@@ Bool ) || ( ( Py@@ Names . TYPE_@@ LONG . equals ( super@@ Name ) || Py@@ Names . AB@@ C_@@ INTEGR@@ AL . equals ( super@@ Name ) ) && ( sub@@ Is@@ Bool || sub@@ Is@@ Int ) ) || ( ( " float " . equals ( super@@ Name ) || Py@@ Names . AB@@ C_@@ REAL . equals ( super@@ Name ) ) && ( sub@@ Is@@ Bool || sub@@ Is@@ Int || sub@@ Is@@ Long ) ) || ( ( " complex " . equals ( super@@ Name ) || Py@@ Names . AB@@ C_@@ COMPLE@@ X . equals ( super@@ Name ) ) && ( sub@@ Is@@ Bool || sub@@ Is@@ Int || sub@@ Is@@ Long || sub@@ Is@@ Float ) ) || ( Py@@ Names . AB@@ C_@@ NUMBER . equals ( super@@ Name ) && ( sub@@ Is@@ Bool || sub@@ Is@@ Int || sub@@ Is@@ Long || sub@@ Is@@ Float || sub@@ Is@@ Complex ) ) ) { return true ; } return false ; }
 public static void reset ( ) { completed = false ; }
 @ Converter public static DS@@ R_@@ Q@@ 03 to@@ D@@ sr@@ Q@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( DS@@ R_@@ Q@@ 03 . class , body ) ; }
 public static Http2@@ Stream getOrCreate@@ Stream ( Http2@@ Connection connection , int streamId , boolean half@@ Closed ) throws Http2@@ Exception { if ( connection != null ) { Http2@@ Stream stream = connection . stream ( streamId ) ; if ( stream == null ) { if ( connection . is@@ Server ( ) && streamId % 2 == 0 || ! connection . is@@ Server ( ) && streamId % 2 != 0 ) { stream = connection . local ( ) . create@@ Stream ( streamId , half@@ Closed ) ; } else { stream = connection . remote ( ) . create@@ Stream ( streamId , half@@ Closed ) ; } } return stream ; } return null ; }
 public static Short@@ Image@@ Buffer norm ( Short@@ Image@@ Buffer input ) { Short@@ Image@@ Buffer after = input . copy@@ Shape ( ) ; int min = 0xFFFF ; int max = 0 ; for ( int y = 0 ; y < input . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < input . getWidth ( ) ; x ++ ) { int v = input . get ( y , x ) & 0xFFFF ; min = ( v < min ) ? v : min ; max = ( v > max ) ? v : max ; } } int diff = ( max - min ) ; if ( diff > 0 ) { float scale = ( ( float ) 0xFF ) / diff ; for ( int y = 0 ; y < input . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < input . getWidth ( ) ; x ++ ) { int v = input . get ( y , x ) & 0xFFFF ; after . set ( y , x , ( short ) ( ( int ) ( ( v - min ) * scale ) & 0xFF ) ) ; } } } return after ; }
 private static void replace@@ Unresolved@@ Generic@@ sWith@@ Any ( @ NotNull Map < Py@@ Generic@@ Type , Py@@ Type > substitutions ) { final List < Py@@ Type > un@@ resolved@@ Generics = ContainerUtil . filter ( substitutions . values ( ) , type -> type instanceof Py@@ Generic@@ Type && ! substitutions . containsKey ( type ) ) ; for ( Py@@ Type un@@ resolved@@ Generic : un@@ resolved@@ Generics ) { substitutions . put ( ( Py@@ Generic@@ Type ) un@@ resolved@@ Generic , null ) ; } }
 public static Start@@ Schema@@ Extension@@ Request@@ Marshaller getInstance ( ) { return instance ; }
 public static VirtualFile getDefault@@ Location ( ) { final String path = System . getenv ( ) . get ( " WORK@@ ON _ HOME " ) ; if ( ! StringUtil . isEmpty ( path ) ) { return LocalFileSystem . getInstance ( ) . find@@ File@@ ByPath ( FileUtil . expand@@ User@@ Home ( path ) . replace ( ' \ \@@ ' , ' / ' ) ) ; } final VirtualFile user@@ Home = LocalFileSystem . getInstance ( ) . find@@ File@@ ByPath ( SystemProperties . getUser@@ Home ( ) . replace ( ' \ \@@ ' , ' / ' ) ) ; if ( user@@ Home != null ) { final VirtualFile pre@@ defined@@ Folder = user@@ Home . findChild ( " . virtual@@ en@@ vs " ) ; if ( pre@@ defined@@ Folder == null ) return user@@ Home ; return pre@@ defined@@ Folder ; } return null ; }
 private static void validate@@ Sql@@ Database@@ NotFound ( String new@@ Database ) { Assert . assertNull ( sql@@ Server@@ Manager . sql@@ Servers ( ) . getBy@@ Resource@@ Group ( R@@ G_@@ NAME , SQL@@ _SERVER_@@ NAME ) . databases ( ) . get ( new@@ Database ) ) ; }
 @ Nullable static public Method getClass@@ Method ( Ph@@ p@@ Class php@@ Class , String methodName ) { return php@@ Class . find@@ Method@@ ByName ( methodName ) ; }
 public static String get@@ Admin@@ Jsp@@ Path ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ J@@ SP_@@ PATH , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( properties . get ( Web@@ Config@@ Key . WEB_@@ ADMIN_@@ J@@ SP_@@ PATH , Web@@ Config@@ Default . WEB_@@ ADMIN_@@ J@@ SP_@@ PATH ) , true ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static float [ ] get@@ Kernel ( SIG@@ MA sigma ) { if ( sigma . ordinal ( ) == SIG@@ MA . ZER@@ O@@ POINT@@ FIVE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Fi@@ ve ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ZER@@ O@@ POINT@@ SE@@ VEN@@ ONE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Se@@ ven@@ One ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ SQ@@ RT@@ 2 ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ POINT@@ FIVE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ Point@@ Fi@@ ve ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . TWO . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Two ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ POINT@@ FI@@ VE@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One@@ Point@@ Fi@@ ve@@ SQ@@ RT@@ 2 ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . TW@@ O@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Two@@ SQ@@ RT@@ 2 ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . THREE . ordinal ( ) ) { return get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Three ( ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . FOUR . ordinal ( ) ) { return get@@ Kernel ( SIG@@ MA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . FOUR@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Kernel ( SIG@@ MA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . E@@ IGHT . ordinal ( ) ) { return get@@ Kernel ( SIG@@ MA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . E@@ IGHT . ordinal ( ) ) { return get@@ Kernel ( SIG@@ MA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . EIG@@ HT@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 87 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . SI@@ X@@ TE@@ EN . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 121 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . SI@@ X@@ TE@@ EN@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 171 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . THIR@@ TY@@ TWO . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 239 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . THIR@@ TY@@ TW@@ O@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 33@@ 9 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . SI@@ X@@ TY@@ FOUR . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 47@@ 7 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . SI@@ X@@ TY@@ FOUR@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 675 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ H@@ UND@@ RED@@ AND@@ TW@@ EN@@ TY@@ E@@ IGHT . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 95@@ 3 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . ONE@@ H@@ UND@@ RED@@ AND@@ TW@@ EN@@ TY@@ EIG@@ HT@@ SQ@@ RT@@ 2 . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 13@@ 47 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . TW@@ O@@ H@@ UND@@ RED@@ AND@@ FI@@ F@@ TY@@ SI@@ X . ordinal ( ) ) { return get@@ Kernel ( sigma , 0 , 19@@ 05 ) ; } else if ( sigma . ordinal ( ) == SIG@@ MA . TW@@ O@@ H@@ UND@@ RED@@ AND@@ FI@@ F@@ TY@@ SI@@ X . ordinal ( ) ) { return get@@ Kernel ( SIG@@ MA . getValue ( sigma ) ) ; } throw new IllegalArgumentException ( " haven ' t ▁ implemented ▁ a ▁ method ▁ for ▁ " + " ▁ sigma = " + sigma ) ; }
 public static int calculate@@ Score ( boolean game@@ Over , int score , int level@@ Completed , int bonus ) { if ( game@@ Over ) { int final@@ Score = score + ( level@@ Completed * bonus ) ; final@@ Score += 2000 ; return final@@ Score ; } return - 1 ; }
 protected static Map < Integer , User > to@@ User@@ Map ( ResultSet resultSet ) throws SQLException { Map < Integer , User > result = new HashMap < Integer , User > ( ) ; while ( resultSet . next ( ) ) { User user = new User ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getString ( 4 ) , resultSet . getInt ( 5 ) ) ; user . set@@ Hash ( resultSet . getString ( 3 ) ) ; result . put ( resultSet . getInt ( 1 ) , user ) ; } return result ; }
 public static String getSub@@ scription@@ Title@@ At ( final Context context , final int position ) { final List < String > titles = new ArrayList < > ( getSub@@ scriptions ( context ) . asMap ( ) . keySet ( ) ) ; if ( titles . size ( ) > position ) { return titles . get ( position ) ; } return null ; }
 private static void validate@@ Sql@@ Elastic@@ Pool ( Sql@@ Elastic@@ Pool sql@@ Elastic@@ Pool , String elastic@@ Pool@@ Name ) { Assert . assertNotNull ( sql@@ Elastic@@ Pool ) ; Assert . assertEquals ( R@@ G_@@ NAME , sql@@ Elastic@@ Pool . resourceGroupName ( ) ) ; Assert . assertEquals ( elastic@@ Pool@@ Name , sql@@ Elastic@@ Pool . name ( ) ) ; Assert . assertEquals ( SQL@@ _SERVER_@@ NAME , sql@@ Elastic@@ Pool . sql@@ ServerName ( ) ) ; Assert . assertEquals ( Elastic@@ Pool@@ Edi@@ tions . STANDARD , sql@@ Elastic@@ Pool . edition ( ) ) ; Assert . assertNotNull ( sql@@ Elastic@@ Pool . creation@@ Date ( ) ) ; Assert . assertNotEquals ( 0 , sql@@ Elastic@@ Pool . database@@ D@@ tu@@ Max ( ) ) ; Assert . assertNotEquals ( 0 , sql@@ Elastic@@ Pool . dt@@ u ( ) ) ; }
 public static final Mac getInstance ( String algorithm ) throws NoSuchAlgorithmException { List services = GetInstance . get@@ Services ( " Mac " , algorithm ) ; Iterator t = services . iterator ( ) ; while ( t . hasNext ( ) ) { Service s = ( Service ) t . next ( ) ; if ( J@@ ce@@ Security . can@@ Use@@ Provider ( s . getProvider ( ) ) == false ) { continue ; } return new Mac ( s , t , algorithm ) ; } throw new NoSuchAlgorithmException ( " Algorithm ▁ " + algorithm + " ▁ not ▁ available " ) ; }
 public static String extract@@ Do@@ i ( Article article ) { try { List < Article@@ Id > ids = article . get@@ Front ( ) . get@@ Article@@ Meta ( ) . get@@ Article@@ Id ( ) ; for ( Article@@ Id id : ids ) { if ( " doi " . equals ( id . get@@ Pub@@ Id@@ Type ( ) ) ) { return id . getContent ( ) ; } } } catch ( Exception e ) { System . err . println ( e ) ; } return null ; }
 public static boolean is@@ Value@@ Used@@ Without@@ Visi@@ ting@@ Stop ( @ NotNull Control@@ Flow flow , final int start , final int stop , @ NotNull Psi@@ Variable variable ) { if ( start == stop ) return false ; class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { private final boolean [ ] maybe@@ Reference@@ d = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( offset == stop ) { maybe@@ Reference@@ d [ offset ] = false ; return ; } if ( instruction instanceof Write@@ Variable@@ Instruction && ( ( Write@@ Variable@@ Instruction ) instruction ) . variable == variable ) { maybe@@ Reference@@ d [ offset ] = false ; return ; } if ( maybe@@ Reference@@ d [ offset ] ) return ; if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; boolean next@@ State = maybe@@ Reference@@ d [ next@@ Offset ] ; maybe@@ Reference@@ d [ offset ] = next@@ State || instruction instanceof Read@@ Variable@@ Instruction && ( ( Read@@ Variable@@ Instruction ) instruction ) . variable == variable ; } @ Override @ NotNull public Boolean getResult ( ) { return maybe@@ Reference@@ d [ start ] ; } } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , start , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static void main ( String [ ] args ) { J@@ a@@ ula < An@@ imal > ja@@ ula@@ Anim@@ al@@ es = new J@@ a@@ ula < An@@ imal > ( ) ; J@@ a@@ ula < Le@@ on > ja@@ ula@@ Le@@ on = new J@@ a@@ ula < Le@@ on > ( ) ; J@@ a@@ ula < Mari@@ pos@@ a > ja@@ ula@@ Mari@@ pos@@ a = new J@@ a@@ ula < Mari@@ pos@@ a > ( ) ; An@@ imal an@@ imal = new An@@ imal ( ) ; Le@@ on le@@ on = new Le@@ on ( ) ; Mari@@ pos@@ a mari@@ pos@@ a = new Mari@@ pos@@ a ( ) ; ja@@ ula@@ Anim@@ al@@ es . add ( an@@ imal ) ; ja@@ ula@@ Anim@@ al@@ es . add ( le@@ on ) ; ja@@ ula@@ Anim@@ al@@ es . add ( mari@@ pos@@ a ) ; ja@@ ula@@ Le@@ on . add ( le@@ on ) ; ja@@ ula@@ Mari@@ pos@@ a . add ( mari@@ pos@@ a ) ; J@@ a@@ ula < ? extends An@@ imal > ja@@ ula@@ Anim@@ al@@ es@@ Generic@@ a ; ja@@ ula@@ Anim@@ al@@ es@@ Generic@@ a = ja@@ ula@@ Anim@@ al@@ es ; ja@@ ula@@ Anim@@ al@@ es@@ Generic@@ a = ja@@ ula@@ Le@@ on ; ja@@ ula@@ Anim@@ al@@ es@@ Generic@@ a = ja@@ ula@@ Mari@@ pos@@ a ; Pr@@ ue@@ ba@@ Generics . al@@ iment@@ ar@@ Anim@@ al@@ es ( ja@@ ula@@ Anim@@ al@@ es ) ; Pr@@ ue@@ ba@@ Generics . al@@ iment@@ ar@@ Anim@@ al@@ es ( ja@@ ula@@ Mari@@ pos@@ a ) ; Pr@@ ue@@ ba@@ Generics . al@@ iment@@ ar@@ Anim@@ al@@ es ( ja@@ ula@@ Le@@ on ) ; Pr@@ ue@@ ba@@ Generics . al@@ iment@@ ar@@ Anim@@ al@@ es ( ja@@ ula@@ Anim@@ al@@ es@@ Generic@@ a ) ; }
 @ Converter public static RP@@ R_@@ I@@ 03 to@@ R@@ pr@@ I@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ R_@@ I@@ 03 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 48 to@@ Ad@@ t@@ A@@ 48 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 48 . class , body ) ; }
 @ Converter public static RD@@ S_@@ O@@ 01 to@@ R@@ ds@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( RD@@ S_@@ O@@ 01 . class , body ) ; }
 static Async@@ HttpClient create@@ Async@@ HttpClient ( String name@@ Format , String timer@@ Thread@@ Name@@ Format , @ Nullable SSLContext ssl@@ Context ) { final Default@@ Async@@ HttpClient@@ Config . Builder builder = new Default@@ Async@@ HttpClient@@ Config . Builder ( ) . set@@ ThreadFactory ( Exec@@ s . make@@ ThreadFactory ( name@@ Format ) ) . set@@ Netty@@ Timer ( new Hashed@@ Wheel@@ Timer ( Exec@@ s . make@@ ThreadFactory ( timer@@ Thread@@ Name@@ Format ) ) ) ; if ( ssl@@ Context != null ) { builder . set@@ Ssl@@ Context ( new Jdk@@ Ssl@@ Context ( ssl@@ Context , true , Client@@ Auth . NONE ) ) ; } return new Default@@ Async@@ HttpClient ( builder . build ( ) ) ; }
 @ Converter public static P@@ GL_@@ PC@@ 7 to@@ P@@ gl@@ P@@ c@@ 7 ( String body ) throws HL7@@ Exception { return to@@ Message ( P@@ GL_@@ PC@@ 7 . class , body ) ; }
 @ NotNull private static Optional < Boolean > match@@ Impl ( @ Nullable Py@@ Type expected , @ Nullable Py@@ Type actual , @ NotNull Match@@ Context context ) { if ( expected instanceof Py@@ ClassType ) { Optional < Boolean > match = match@@ Object ( ( Py@@ ClassType ) expected , actual ) ; if ( match . isPresent ( ) ) { return match ; } } if ( expected instanceof Py@@ Instanti@@ able@@ Type && actual instanceof Py@@ Instanti@@ able@@ Type ) { Optional < Boolean > match = match ( ( Py@@ Instanti@@ able@@ Type ) expected , ( Py@@ Instanti@@ able@@ Type ) actual , context ) ; if ( match . isPresent ( ) ) { return match ; } } if ( expected instanceof Py@@ Generic@@ Type ) { return Optional . of ( match ( ( Py@@ Generic@@ Type ) expected , actual , context ) ) ; } if ( expected == null || actual == null || is@@ Unknown ( actual , context . context ) ) { return Optional . of ( true ) ; } if ( actual instanceof Py@@ Union@@ Type ) { return Optional . of ( match ( expected , ( Py@@ Union@@ Type ) actual , context ) ) ; } if ( expected instanceof Py@@ Union@@ Type ) { return Optional . of ( match ( ( Py@@ Union@@ Type ) expected , actual , context ) ) ; } if ( expected instanceof Py@@ ClassType && actual instanceof Py@@ ClassType ) { Optional < Boolean > match = match ( ( Py@@ ClassType ) expected , ( Py@@ ClassType ) actual , context ) ; if ( match . isPresent ( ) ) { return match ; } } if ( actual instanceof Py@@ Struc@@ tur@@ alType && ( ( Py@@ Struc@@ tur@@ alType ) actual ) . isIn@@ ferred@@ From@@ Usages ( ) ) { return Optional . of ( true ) ; } if ( expected instanceof Py@@ Struc@@ tur@@ alType ) { return Optional . of ( match ( ( Py@@ Struc@@ tur@@ alType ) expected , actual , context . context ) ) ; } if ( actual instanceof Py@@ Struc@@ tur@@ alType && expected instanceof Py@@ ClassType ) { final Set < String > expected@@ Attributes = ( ( Py@@ ClassType ) expected ) . getMember@@ Names ( true , context . context ) ; return Optional . of ( expected@@ Attributes . containsAll ( ( ( Py@@ Struc@@ tur@@ alType ) actual ) . getAttribute@@ Names ( ) ) ) ; } if ( actual instanceof Py@@ Callable@@ Type && expected instanceof Py@@ Callable@@ Type ) { final Py@@ Callable@@ Type expected@@ Callable = ( Py@@ Callable@@ Type ) expected ; final Py@@ Callable@@ Type actual@@ Callable = ( Py@@ Callable@@ Type ) actual ; final Optional < Boolean > match = match ( expected@@ Callable , actual@@ Callable , context ) ; if ( match . isPresent ( ) ) { return match ; } } return Optional . of ( match@@ Numeric@@ Types ( expected , actual ) ) ; }
 @ Converter public static RG@@ R_@@ RG@@ R to@@ R@@ gr@@ R@@ gr ( String body ) throws HL7@@ Exception { return to@@ Message ( RG@@ R_@@ RG@@ R . class , body ) ; }
 private static void notify@@ Custom@@ Region@@ s@@ Unavailable ( @ NotNull Editor editor , @ NotNull Project project ) { final JB@@ Popup@@ Factory popup@@ Factory = JB@@ Popup@@ Factory . getInstance ( ) ; Ballo@@ on ballo@@ on = popup@@ Factory . create@@ Html@@ Text@@ Ballo@@ on@@ Builder ( Ide@@ Bundle . message ( " goto . custom . region . message . unavailable " ) , MessageType . INFO , null ) . set@@ Fade@@ out@@ Time ( 2000 ) . set@@ Hide@@ On@@ Click@@ Outside ( true ) . set@@ Hide@@ On@@ Key@@ Outside ( true ) . create@@ Ballo@@ on ( ) ; Dispo@@ ser . register ( project , ballo@@ on ) ; ballo@@ on . show ( popup@@ Factory . guess@@ Best@@ Popup@@ Location ( editor ) , Ballo@@ on . Position . below ) ; }
 public static String extract@@ Text ( Article article ) { StringBuilder sb = new StringBuilder ( ) ; List < Abstract > abstr@@ acts = article . get@@ Front ( ) . get@@ Article@@ Meta ( ) . get@@ Abstract ( ) ; for ( Abstract abstr@@ ct : abstr@@ acts ) { for ( Sec sec : abstr@@ ct . get@@ Sec ( ) ) { process@@ Text@@ Content ( sec . getAddress@@ Or@@ Alternative@@ s@@ Or@@ Array ( ) , sb , true ) ; } } sb . append ( ' \n ' ) ; Body body = article . getBody ( ) ; if ( body != null ) { for ( Sec sec : body . get@@ Sec ( ) ) { Title title = sec . getTitle ( ) ; if ( title != null && title . getContent ( ) != null ) { process@@ Text@@ Content ( title . getContent ( ) , sb , true ) ; sb . append ( ' \n ' ) ; } process@@ Text@@ Content ( sec . getAddress@@ Or@@ Alternative@@ s@@ Or@@ Array ( ) , sb , false ) ; } } return remove@@ Noise ( sb . toString ( ) ) ; }
 @ NotNull private static Shared@@ Access@@ Blob@@ Policy policy ( EnumSet < Shared@@ Access@@ Blob@@ Permissions > permissions , Instant expiration@@ Time ) { Shared@@ Access@@ Blob@@ Policy shared@@ Access@@ Blob@@ Policy = new Shared@@ Access@@ Blob@@ Policy ( ) ; shared@@ Access@@ Blob@@ Policy . set@@ Permissions ( permissions ) ; shared@@ Access@@ Blob@@ Policy . set@@ Shared@@ Access@@ Expiry@@ Time ( Date . from ( expiration@@ Time ) ) ; return shared@@ Access@@ Blob@@ Policy ; }
 public static Serializer get@@ Serializer ( Class cls , boolean fail@@ On@@ Mis@@ s ) { return get@@ Serializer@@ Registration ( cls , fail@@ On@@ Mis@@ s ) . get@@ Serializer ( ) ; }
 public static void main ( String [ ] args ) throws IOException { try ( Scanner in = new@@ Input ( ) ; PrintWriter out = new@@ Output ( ) ) { double [ ] sides = new double [ 3 ] ; double avg = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = ( in . nextDouble ( ) ) / 2.0 ; avg += sides [ i ] ; } avg /= 3 ; NumberFormat f = new DecimalFormat ( " # 0.000000@@ 0" ) ; out . println ( f . format ( avg ) ) ; } }
 public static Delete@@ Flow@@ Log@@ s@@ Result@@ StaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new Delete@@ Flow@@ Log@@ s@@ Result@@ StaxUnmarshaller ( ) ; return instance ; }
 public static String parse@@ Group@@ Namespace@@ Code ( String namespace@@ And@@ Name@@ Combo ) { if ( namespace@@ And@@ Name@@ Combo == null ) { return null ; } String [ ] group@@ Data = namespace@@ And@@ Name@@ Combo . split ( Ke@@ w@@ Api@@ Constants . K@@ IM_@@ GROUP_@@ NAMESPACE_@@ NAME_@@ DELIMI@@ TER_@@ CHARACTER ) ; if ( group@@ Data . length == 1 ) { return K@@ im@@ Constants . K@@ IM_@@ GROUP_@@ WORK@@ FLOW_@@ NAMESPACE_@@ CODE ; } else if ( group@@ Data . length == 2 ) { return group@@ Data [ 0 ] . trim ( ) ; } else { return null ; } }
 public static final void open ( String directory@@ Path ) { String os@@ Name = System . getProperty ( " os . name " ) ; System . out . println ( " os . name ▁ = ▁ " + os@@ Name ) ; if ( os@@ Name != null && os@@ Name . startsWith ( " Windows " ) ) { Runtime runtime = Runtime . getRuntime ( ) ; String command = " explorer . exe ▁ " + EXP@@ LOR@@ ER_@@ OPTION + conv@@ Path ( directory@@ Path ) ; System . out . println ( command ) ; try { runtime . exec ( command ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( " エ@@ ク@@ ス@@ プ@@ ロ@@ ー@@ ラ@@ 起@@ 動@@ し@@ な@@ い 。 " ) ; } }
 public static void POST ( int n , String s ) { return ; }
 private static boolean check@@ Keys@@ Equal ( PublicKey pk@@ 1 , PublicKey pk@@ 2 ) { String format@@ 1 = pk@@ 1 . getFormat ( ) ; String format@@ 2 ; if ( ( pk@@ 2 == null ) || ( ( ( format@@ 2 = pk@@ 2 . getFormat ( ) ) != null ) ^ ( format@@ 1 != null ) ) || ( ( format@@ 1 != null ) && ! format@@ 1 . equals ( format@@ 2 ) ) ) { return false ; } return Arrays . equals ( pk@@ 1 . get@@ Encoded ( ) , pk@@ 2 . get@@ Encoded ( ) ) ; }
 public static boolean check@@ Date@@ Ranges ( String from@@ Date , String toDate ) { try { Date parsed@@ Date = Core@@ Api@@ ServiceLocator . get@@ DateTime@@ Service ( ) . convertTo@@ Date ( from@@ Date . trim ( ) ) ; Calendar from@@ Calendar = Calendar . getInstance ( ) ; from@@ Calendar . set@@ Leni@@ ent ( false ) ; from@@ Calendar . setTime ( parsed@@ Date ) ; from@@ Calendar . set ( Calendar . HOUR_@@ OF_@@ DAY , 0 ) ; from@@ Calendar . set ( Calendar . MINUTE , 0 ) ; from@@ Calendar . set ( Calendar . SECOND , 0 ) ; from@@ Calendar . set ( Calendar . MILLI@@ SECOND , 0 ) ; parsed@@ Date = Core@@ Api@@ ServiceLocator . get@@ DateTime@@ Service ( ) . convertTo@@ Date ( toDate . trim ( ) ) ; Calendar to@@ Calendar = Calendar . getInstance ( ) ; to@@ Calendar . set@@ Leni@@ ent ( false ) ; to@@ Calendar . setTime ( parsed@@ Date ) ; to@@ Calendar . set ( Calendar . HOUR_@@ OF_@@ DAY , 0 ) ; to@@ Calendar . set ( Calendar . MINUTE , 0 ) ; to@@ Calendar . set ( Calendar . SECOND , 0 ) ; to@@ Calendar . set ( Calendar . MILLI@@ SECOND , 0 ) ; if ( from@@ Calendar . after ( to@@ Calendar ) ) { return false ; } return true ; } catch ( Exception ex ) { return false ; } }
 public static boolean isValid ( String str ) { return ! isEmpty ( str ) ; }
 @ Converter public static SR@@ M_S@@ 09 to@@ S@@ rm@@ S@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 09 . class , body ) ; }
 public static boolean register@@ Metric@@ Admin@@ MBean ( ) { Sdk@@ MBean@@ Registry registry = Sdk@@ MBean@@ Registry . Factory . get@@ MBean@@ Registry ( ) ; synchronized ( Aws@@ Sdk@@ Metrics . class ) { if ( registered@@ Admin@@ M@@ bean@@ Name != null ) return false ; boolean registered = registry . register@@ Metric@@ Admin@@ MBean ( M@@ BEAN_@@ OBJECT_@@ NAME ) ; if ( registered ) { registered@@ Admin@@ M@@ bean@@ Name = M@@ BEAN_@@ OBJECT_@@ NAME ; } else { String mbean@@ Name = M@@ BEAN_@@ OBJECT_@@ NAME ; int count = 0 ; while ( registry . is@@ MBean@@ Registered ( mbean@@ Name ) ) { mbean@@ Name = M@@ BEAN_@@ OBJECT_@@ NAME + " / " + ++ count ; } registered = registry . register@@ Metric@@ Admin@@ MBean ( mbean@@ Name ) ; if ( registered ) registered@@ Admin@@ M@@ bean@@ Name = mbean@@ Name ; } if ( registered ) log . debug ( " Admin ▁ mbean ▁ registered ▁ under ▁ " + registered@@ Admin@@ M@@ bean@@ Name ) ; return registered ; } }
 public static void main ( String [ ] args ) throws Exception { final Machine@@ Events@@ Processor aggregator = new Machine@@ Events@@ Processor ( REPOR@@ TING_@@ INTERVAL ) ; final Event@@ Processor@@ Client client = new Event@@ Processor@@ Client@@ Builder ( ) . consumer@@ Group ( Event@@ Hub@@ Client@@ Builder . DEFAULT_@@ CONSUM@@ ER_@@ GROUP_@@ NAME ) . connection@@ String ( E@@ H_@@ CONNECTION_@@ STRING ) . process@@ Partition@@ Initialization ( context -> aggregator . on@@ Initialize ( context ) ) . process@@ Partition@@ Close ( context -> aggregator . on@@ Close ( context ) ) . process@@ Event ( event -> aggregator . on@@ Event ( event ) ) . process@@ Error ( error -> aggregator . onError ( error ) ) . checkpoint@@ Store ( new Sample@@ Checkpoint@@ Store ( ) ) . build@@ Event@@ Processor@@ Client ( ) ; System . out . println ( " Starting ▁ event ▁ processor " ) ; final AtomicBoolean isRunning = new AtomicBoolean ( true ) ; client . start ( ) ; generate@@ Events ( isRunning ) . subscribe ( ) ; System . out . println ( " Sleep@@ ing . . . " ) ; Thread . sleep ( TimeUnit . SECONDS . toMillis ( 30 ) ) ; isRunning . set ( false ) ; System . out . println ( " Stopping ▁ event ▁ processor " ) ; client . stop ( ) ; System . out . println ( " Exiting ▁ process " ) ; }
 public static boolean is@@ Applicable ( ASTNode node ) { return ( node . getToken ( ) . getType ( ) == Hive@@ Parser . TOK_@@ REPLIC@@ ATION ) ; }
 public static Optional < U@@ Arena > create@@ Arena ( String arena@@ Name , Arena@@ Data data ) { if ( is@@ Data@@ Present ( data ) ) { return Optional . of ( new U@@ Arena ( arena@@ Name , data ) ) ; } else { return Optional . empty ( ) ; } }
 public static Instruction random@@ Instruction ( Random random ) { int choice = random . nextInt ( instruction@@ Map . size ( ) ) ; for ( Instruction ins : instruction@@ Map . values ( ) ) { if ( choice -- == 0 ) { return ins ; } } throw new RuntimeException ( " Dictionary : ▁ should ▁ not ▁ happen " ) ; }
 public static PsiReferenceExpression find@@ Single@@ Read@@ Occurren@@ ce ( @ NotNull Control@@ Flow flow , @ NotNull PsiElement element , @ NotNull Psi@@ Variable variable ) { int read@@ Offset = find@@ Single@@ Read@@ Offset ( flow , flow . getStartOffset ( element ) , flow . getEndOffset ( element ) , variable ) ; if ( read@@ Offset >= 0 ) { PsiElement read@@ Element = flow . getElement ( read@@ Offset ) ; read@@ Element = PsiTreeUtil . find@@ First@@ Parent ( read@@ Element , false , e -> e == element || e instanceof PsiReferenceExpression ) ; if ( read@@ Element instanceof PsiReferenceExpression ) { return ( PsiReferenceExpression ) read@@ Element ; } } return null ; }
 public static int get@@ Completion@@ Re@@ asons ( @ NotNull Control@@ Flow flow , final int offset , final int endOffset ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Integer > { private final boolean [ ] normal@@ Completion = new boolean [ endOffset ] ; private final boolean [ ] return@@ Called = new boolean [ endOffset ] ; @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { boolean ret = next@@ Offset < endOffset && return@@ Called [ next@@ Offset ] ; boolean normal = next@@ Offset < endOffset && normal@@ Completion [ next@@ Offset ] ; final PsiElement element = flow . getElement ( offset ) ; boolean go@@ To@@ Return = instruction instanceof GoTo@@ Instruction && ( ( GoTo@@ Instruction ) instruction ) . is@@ Return ; if ( go@@ To@@ Return || isIn@@ side@@ Return@@ Statement ( element ) ) { ret = true ; } else if ( instruction instanceof Conditional@@ Throw@@ To@@ Instruction ) { final int throw@@ Offset = ( ( Conditional@@ Throw@@ To@@ Instruction ) instruction ) . offset ; boolean normal@@ When@@ Throw = throw@@ Offset < endOffset && normal@@ Completion [ throw@@ Offset ] ; boolean normal@@ When@@ Not@@ Throw = offset == endOffset - 1 || normal@@ Completion [ offset + 1 ] ; normal = normal@@ When@@ Throw || normal@@ When@@ Not@@ Throw ; } else if ( ! ( instruction instanceof Throw@@ To@@ Instruction ) && next@@ Offset >= endOffset ) { normal = true ; } return@@ Called [ offset ] |= ret ; normal@@ Completion [ offset ] |= normal ; } @ Override @ NotNull public Integer getResult ( ) { return ( return@@ Called [ offset ] ? RETURN_@@ COMPLE@@ TION_@@ REAS@@ ON : 0 ) | ( normal@@ Completion [ offset ] ? NORMAL_@@ COMPLE@@ TION_@@ REAS@@ ON : 0 ) ; } } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , offset , endOffset ) ; return visitor . getResult ( ) . intValue ( ) ; }
 public static void Open ( ) { File f = new File ( database@@ _file ) ; boolean create@@ Structure = false ; if ( ! f . exists ( ) ) create@@ Structure = true ; try { Class . forName ( " org . sqlite . JDBC " ) ; conn = DriverManager . getConnection ( " jdbc : sqlite : " + database@@ _file ) ; if ( create@@ Structure ) Create@@ Git@@ Min@@ er@@ Repo@@ Structure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
 public static String getRuntime@@ Path ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ RUNTIME_@@ PATH , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result ; try { result = properties . get ( Web@@ Config@@ Key . CORE_@@ RUNTIME_@@ PATH ) ; } catch ( Property@@ NotFoundException e ) { if ( is@@ Windows ( ) ) { LOGGER . info ( " OS ▁ is ▁ windows " ) ; result = Web@@ Config@@ Default . CORE_@@ RUNTIME_@@ PATH_@@ WIN ; } else { LOGGER . info ( " OS ▁ isn ' t ▁ windows " ) ; result = Web@@ Config@@ Default . CORE_@@ RUNTIME_@@ PATH_@@ UNIX ; } LOGGER . warn ( " Couldn ' t ▁ load ▁ " + Web@@ Config@@ Key . CORE_@@ RUNTIME_@@ PATH + " ▁ , ▁ use ▁ " + result + " ▁ for ▁ default . " ) ; } result = Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( result , true ) ; if ( ! result . startsWith ( " / " ) && ! result . startsWith ( " file : // " ) ) { throw new RuntimeException ( Web@@ Config@@ Key . CORE_@@ RUNTIME_@@ PATH + " ▁ must ▁ b@@ eng@@ in ▁ with ▁ file : // ▁ or ▁ / " ) ; } else { if ( result . startsWith ( " file : // " ) ) { result = result . substring ( " file : // " . length ( ) ) ; } } if ( is@@ Windows ( ) && result . startsWith ( " / " ) ) { result = " C : " + result ; } return Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( result , false ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static float [ ] get@@ Kernel ( SIG@@ MA sigma , float mu , int n@@ Points ) { float s = SIG@@ MA . getValue ( sigma ) ; return get@@ Kernel ( s , mu , n@@ Points ) ; }
 public static Queue [ ] get@@ Filtered@@ Queue@@ List ( Queue [ ] full@@ List , int starting@@ Index , int max@@ Queue@@ Count ) { Queue [ ] queue@@ Details@@ Array ; int result@@ SetSize = max@@ Queue@@ Count ; ArrayList < Queue > resultList = new ArrayList < Queue > ( ) ; Collections . addAll ( resultList , full@@ List ) ; if ( ( resultList . size ( ) - starting@@ Index ) < max@@ Queue@@ Count ) { result@@ SetSize = ( resultList . size ( ) - starting@@ Index ) ; } queue@@ Details@@ Array = new Queue [ result@@ SetSize ] ; int index = 0 ; int queue@@ Details@@ Index = 0 ; for ( Queue queue@@ Detail : resultList ) { if ( starting@@ Index == index || starting@@ Index < index ) { queue@@ Details@@ Array [ queue@@ Details@@ Index ] = new Queue ( ) ; queue@@ Details@@ Array [ queue@@ Details@@ Index ] . set@@ Queue@@ Name ( queue@@ Detail . getQueue@@ Name ( ) ) ; queue@@ Details@@ Array [ queue@@ Details@@ Index ] . set@@ MessageCount ( queue@@ Detail . getMessage@@ Count ( ) ) ; queue@@ Details@@ Index ++ ; if ( queue@@ Details@@ Index == max@@ Queue@@ Count ) { break ; } } index ++ ; } return queue@@ Details@@ Array ; }
 @ Converter public static MF@@ N_@@ M@@ 11 to@@ M@@ fn@@ M@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 11 . class , body ) ; }
 public static String get@@ Registered@@ Admin@@ M@@ bean@@ Name ( ) { return registered@@ Admin@@ M@@ bean@@ Name ; }
 public static synchronized void re@@ Initialize@@ Provider ( ) { provider = initialize@@ Provider ( ) ; }
 public static String getConfig@@ Path ( ) { return getRuntime@@ Path ( ) + " / conf / config . properties " ; }
 @ NotNull public static Collection < Variable@@ Info > get@@ Initialized@@ Tw@@ ice ( @ NotNull Control@@ Flow flow , int startOffset , int endOffset ) { while ( startOffset < endOffset ) { Initialized@@ Twi@@ ce@@ Client@@ Visitor visitor = new Initialized@@ Twi@@ ce@@ Client@@ Visitor ( flow , startOffset ) ; depth@@ First@@ Search ( flow , visitor , startOffset , endOffset ) ; Collection < Variable@@ Info > result = visitor . getResult ( ) ; if ( ! result . isEmpty ( ) ) { return result ; } startOffset = find@@ Un@@ processed ( startOffset , endOffset , visitor ) ; } return Collections . emptyList ( ) ; }
 public static Map@@ Provider getMap@@ Provider@@ ForName ( String provider@@ ClassName ) { return getInstance ( ) . getMap@@ Provider ( provider@@ ClassName ) ; }
 @ Converter public static SR@@ M_S@@ 01 to@@ S@@ rm@@ S@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 01 . class , body ) ; }
 public static Register@@ Bulk@@ Key@@ Noti@@ f@@ Response getDefaultInstance ( ) { return default@@ Instance ; }
 public static Decoder Binary@@ Decoder ( ) { return data -> encode@@ _bin ( data ) ; }
 public static String getNative@@ Library@@ Directory ( Context appContext ) { Application@@ Info ai = context . getApplication@@ Info ( ) ; Log . w ( " ND@@ K@@ Helper " , " ai . native@@ Library@@ Dir : " + ai . native@@ Library@@ Dir ) ; if ( ( ai . flags & Application@@ Info . FLAG_@@ UPDA@@ TED_@@ SYSTEM_@@ APP ) != 0 || ( ai . flags & Application@@ Info . FLAG_@@ SYSTEM ) == 0 ) { return ai . native@@ Library@@ Dir ; } return " / system / lib / " ; }
 private static boolean process ( int [ ] nums , int start , int end ) { if ( start >= end ) { return true ; } int root@@ Val = nums [ end ] ; int i = start ; while ( nums [ i ] < root@@ Val ) { i ++ ; } int j = end - 1 ; while ( nums [ j ] > root@@ Val ) { j ++ ; } return process ( nums , start , i - 1 ) && process ( nums , j , end - 1 ) ; }
 @ Converter public static AD@@ T_@@ A@@ 35 to@@ Ad@@ t@@ A@@ 35 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 35 . class , body ) ; }
 public static Sensor@@ Db@@ Helper initialize ( Context context ) { if ( db@@ Helper == null ) { synchronized ( Sensor@@ Db@@ Helper . class ) { if ( db@@ Helper == null ) { db@@ Helper = new Sensor@@ Db@@ Helper ( context ) ; } } } return db@@ Helper ; }
 static public boolean is@@ Equal@@ Method@@ Reference@@ Name ( Method@@ Reference method@@ Reference , String methodName ) { String name = method@@ Reference . getName ( ) ; return name != null && name . equals ( methodName ) ; }
 public static List < Const@@ Label > of ( List < String > text@@ List ) { List < Const@@ Label > resultList = new ArrayList < Const@@ Label > ( ) ; for ( String text : text@@ List ) { resultList . add ( new Const@@ Label ( text ) ) ; } return resultList ; }
 private static boolean get@@ Sequ@@ enc@@ ing@@ Rules ( Node i@@ Node , Seq@@ Activity io@@ Act ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " get@@ Sequ@@ enc@@ ing@@ Rules " ) ; } boolean ok = true ; String temp@@ Val = null ; List < I@@ Seq@@ Rule > pre@@ Rules = new ArrayList < I@@ Seq@@ Rule > ( ) ; List < I@@ Seq@@ Rule > exit@@ Rules = new ArrayList < I@@ Seq@@ Rule > ( ) ; List < I@@ Seq@@ Rule > post@@ Rules = new ArrayList < I@@ Seq@@ Rule > ( ) ; NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " pre@@ Condition@@ Rule " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < pre@@ Condition@@ Rule > ▁ " + " element " ) ; } Seq@@ Rule rule = new Seq@@ Rule ( ) ; NodeList rule@@ Info = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < rule@@ Info . getLength ( ) ; j ++ ) { Node cur@@ Rule = rule@@ Info . item ( j ) ; if ( cur@@ Rule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( cur@@ Rule . getLocalName ( ) . equals ( " rule@@ Conditions " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rule@@ Conditions > ▁ element " ) ; } rule . m@@ Conditions = extract@@ Seq@@ Rule@@ Conditions ( cur@@ Rule ) ; } else if ( cur@@ Rule . getLocalName ( ) . equals ( " rule@@ Action " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < rule@@ Action > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Rule , " action " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { rule . m@@ Action = temp@@ Val ; } } } } } if ( rule . m@@ Conditions != null && rule . m@@ Action != null ) { pre@@ Rules . add ( rule ) ; } else { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Inv@@ ail@@ d ▁ Pre ▁ Seq@@ Rule " ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " exit@@ Condition@@ Rule " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < exit@@ Condition@@ Rule > ▁ element " ) ; } Seq@@ Rule rule = new Seq@@ Rule ( ) ; NodeList rule@@ Info = curNode . getChildNodes ( ) ; for ( int k = 0 ; k < rule@@ Info . getLength ( ) ; k ++ ) { Node cur@@ Rule = rule@@ Info . item ( k ) ; if ( cur@@ Rule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( cur@@ Rule . getLocalName ( ) . equals ( " rule@@ Conditions " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rule@@ Conditions > ▁ element " ) ; } rule . m@@ Conditions = extract@@ Seq@@ Rule@@ Conditions ( cur@@ Rule ) ; } else if ( cur@@ Rule . getLocalName ( ) . equals ( " rule@@ Action " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < rule@@ Action > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Rule , " action " ) ; if ( temp@@ Val != null ) { rule . m@@ Action = temp@@ Val ; } } } } if ( rule . m@@ Conditions != null && rule . m@@ Action != null ) { exit@@ Rules . add ( rule ) ; } else { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Inv@@ ail@@ d ▁ Exit ▁ Seq@@ Rule " ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " post@@ Condition@@ Rule " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < post@@ Condition@@ Rule > ▁ element " ) ; } Seq@@ Rule rule = new Seq@@ Rule ( ) ; NodeList rule@@ Info = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < rule@@ Info . getLength ( ) ; j ++ ) { Node cur@@ Rule = rule@@ Info . item ( j ) ; if ( cur@@ Rule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( cur@@ Rule . getLocalName ( ) . equals ( " rule@@ Conditions " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rule@@ Conditions > ▁ element " ) ; } rule . m@@ Conditions = extract@@ Seq@@ Rule@@ Conditions ( cur@@ Rule ) ; } else if ( cur@@ Rule . getLocalName ( ) . equals ( " rule@@ Action " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < rule@@ Action > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( cur@@ Rule , " action " ) ; if ( temp@@ Val != null ) { rule . m@@ Action = temp@@ Val ; } } } } if ( rule . m@@ Conditions != null && rule . m@@ Action != null ) { post@@ Rules . add ( rule ) ; } else { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Inv@@ ail@@ d ▁ Post ▁ Seq@@ Rule " ) ; } } } } } if ( pre@@ Rules . size ( ) > 0 ) { I@@ Seq@@ Rule@@ set rules = new Seq@@ Rule@@ set ( pre@@ Rules ) ; io@@ Act . set@@ Pre@@ Seq@@ Rules ( rules ) ; } if ( exit@@ Rules . size ( ) > 0 ) { I@@ Seq@@ Rule@@ set rules = new Seq@@ Rule@@ set ( exit@@ Rules ) ; io@@ Act . set@@ Exit@@ Seq@@ Rules ( rules ) ; } if ( post@@ Rules . size ( ) > 0 ) { I@@ Seq@@ Rule@@ set rules = new Seq@@ Rule@@ set ( post@@ Rules ) ; io@@ Act . set@@ Post@@ Seq@@ Rules ( rules ) ; } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " get@@ Sequ@@ enc@@ ing@@ Rules " ) ; } return ok ; }
 public static Error@@ MessageFactory should@@ End@@ With ( Object actual , Object expected ) { return new Should@@ End@@ With ( actual , expected , Standard@@ Comparison@@ Strategy . instance ( ) ) ; }
 private static void write ( Event e , boolean print@@ On@@ Out , boolean log@@ To@@ KV ) { try { write@@ 0 ( e , print@@ On@@ Out , log@@ To@@ KV ) ; if ( Event . last@@ Event . print@@ Me || Event . missed > 0 ) { synchronized ( Event . class ) { if ( Event . last@@ Event . print@@ Me ) { Event ev = Event . last@@ Event ; write@@ 0 ( ev , true , log@@ To@@ KV ) ; Event . last@@ Event = new Event ( ) ; } if ( Event . missed > 0 ) { if ( Event . last@@ Event . print@@ Me == false ) { Event . last@@ Event . init ( Sys . WATER , Kind . WARN , null , null , " Logging ▁ framework ▁ dropped ▁ a ▁ message " , Event . last@@ Good@@ Timer ) ; Event . missed -- ; } } } } } catch ( OutOf@@ MemoryError xe ) { synchronized ( Event . class ) { if ( Event . last@@ Event . print@@ Me == false ) Event . last@@ Event = e ; else Event . missed ++ ; } } }
 public static void test_@@ local@@ D@@ ate_@@ tz ( ) { System . out . println ( " Test ▁ LocalDate ▁ with ▁ timezone " ) ; LocalDate ld@@ 1 = LocalDate . now ( los@@ Ange@@ les ) ; java . sql . Date d = to@@ SQL@@ Date ( ld@@ 1 ) ; LocalDate ld@@ 2 = to@@ LocalDate ( d ) ; System . out . println ( " LocalDate ▁ 1 ▁ = ▁ " + ld@@ 1 ) ; System . out . println ( " Date ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + d ) ; System . out . println ( " LocalDate ▁ 2 ▁ = ▁ " + ld@@ 2 ) ; if ( ! ld@@ 2 . equals ( ld@@ 1 ) ) { throw new IllegalStateException ( ) ; } }
 static long system@@ Nano@@ Time ( ) { return System . nanoTime ( ) ; }
 @ Converter public static MF@@ N_@@ M@@ 07 to@@ M@@ fn@@ M@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 07 . class , body ) ; }
 public static Ph@@ p@@ Class getNew@@ Expression@@ Ph@@ p@@ Class@@ With@@ Instance ( @ NotNull New@@ Expression new@@ Expression , @ NotNull String instance ) { Ph@@ p@@ Class php@@ Class = getNew@@ Expression@@ Ph@@ p@@ Class ( new@@ Expression ) ; if ( php@@ Class != null && new Sym@@ f@@ ony@@ 2@@ Inter@@ faces@@ Util ( ) . is@@ InstanceOf ( php@@ Class , instance ) ) { return php@@ Class ; } return null ; }
 public static String get@@ Copy@@ right@@ Holder ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . PROJECT_@@ COPY@@ RIGHT_@@ HOLDER , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . PROJECT_@@ COPY@@ RIGHT_@@ HOLDER , Web@@ Config@@ Default . PROJECT_@@ COPY@@ RIGHT_@@ HOLDER ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static void unset@@ Flag ( Sys t ) { t . _@@ enable = false ; }
 private static Mono < Void > generate@@ Events ( AtomicBoolean isRunning ) { final Logger logger = LoggerFactory . getLogger ( " Producer " ) ; final Scheduler scheduler = Schedul@@ ers . elast@@ ic ( ) ; final Duration operation@@ Timeout = Duration . of@@ Seconds ( 5 ) ; final String [ ] machine@@ Ids = new String [ ] { "2@@ A " , "9@@ B " , "6@@ C " } ; final Random random = new Random ( ) ; final Event@@ Hub@@ Producer@@ Async@@ Client client = new Event@@ Hub@@ Client@@ Builder ( ) . connection@@ String ( E@@ H_@@ CONNECTION_@@ STRING ) . build@@ Async@@ Producer@@ Client ( ) ; return Mono . < Void > from@@ Runnable ( ( ) -> { while ( isRunning . get ( ) ) { int milliseconds = random . nextInt ( 1000 ) ; try { TimeUnit . MILLISECONDS . sleep ( milliseconds ) ; } catch ( InterruptedException ignored ) { } final String machine@@ Id = machine@@ Ids [ random . nextInt ( machine@@ Ids . length ) ] ; final int temperature = Math . abs ( random . nextInt ( ) % 101 ) ; logger . info ( " [ { } ] ▁ Temperature : ▁ { } C " , machine@@ Id , temperature ) ; final EventData event = new EventData ( String . valueOf ( temperature ) ) ; final Create@@ Batch@@ Options batch@@ Options = new Create@@ Batch@@ Options ( ) . set@@ Partition@@ Key ( machine@@ Id ) ; client . create@@ Batch ( batch@@ Options ) . flatMap ( batch -> { batch . try@@ Add ( event ) ; return client . send ( batch ) ; } ) . block ( operation@@ Timeout ) ; } } ) . subscribe@@ On ( scheduler ) . do@@ Finally ( signal -> { logger . info ( " Dispo@@ sing ▁ of ▁ producer . " ) ; client . close ( ) ; } ) ; }
 public static String getSub@@ scription@@ Id@@ At ( final Context context , final int position ) { final String title = getSub@@ scription@@ Title@@ At ( context , position ) ; if ( ! TextUtils . isEmpty ( title ) ) { return getSub@@ scriptions ( context ) . get ( title ) . get ( 1 ) ; } return null ; }
 private static Configuration getConfiguration@@ With@@ Shared@@ Access@@ Signature ( String sas@@ Token ) { return getConfiguration ( sas@@ Token , null , null ) ; }
 public static boolean isEmpty ( Principal@@ Collection principals ) { return principals == null || principals . isEmpty ( ) ; }
 @ NotNull public static File do@@ Resolve@@ Local@@ Repository ( @ Nullable File user@@ Settings@@ File , @ Nullable File global@@ Settings@@ File ) { if ( user@@ Settings@@ File != null ) { final String from@@ User@@ Settings = getRepository@@ From@@ Settings ( user@@ Settings@@ File ) ; if ( ! StringUtil . isEmpty ( from@@ User@@ Settings ) ) { return new File ( from@@ User@@ Settings ) ; } } if ( global@@ Settings@@ File != null ) { final String from@@ Global@@ Settings = getRepository@@ From@@ Settings ( global@@ Settings@@ File ) ; if ( ! StringUtil . isEmpty ( from@@ Global@@ Settings ) ) { return new File ( from@@ Global@@ Settings ) ; } } return new File ( resolve@@ M2@@ Dir ( ) , REPOSI@@ TORY_@@ DIR ) ; }
 public static void read@@ Json ( ) { JsonParser parser = new JsonParser ( ) ; try { Object obj = parser . parse ( new FileReader ( new File ( Player@@ G@@ low . getInstance ( ) . getConfig@@ Dir ( ) , " color@@ Data . json " ) ) ) ; Color@@ Data = ( JsonObject ) obj ; } catch ( IOException e2 ) { Player@@ G@@ low . getInstance ( ) . getLogger ( ) . error ( " [ Player@@ G@@ low ] ▁ Error ▁ reading ▁ config ▁ file ! " ) ; } }
 public static boolean isIn@@ Modal@@ Context ( ) { if ( is@@ No@@ Background@@ Mode ( ) ) return false ; return Later@@ Invo@@ c@@ ator . isIn@@ Modal@@ Context ( ) ; }
 private static Authenticator get@@ Authenticated@@ Or@@ An@@ on@@ Search@@ Authenticator ( final Ldap@@ Authentication@@ Properties l ) { final var resolver = new Search@@ Dn@@ Resolver ( ) ; resolver . setBase@@ Dn ( l . getBase@@ Dn ( ) ) ; resolver . setSub@@ tree@@ Search ( l . isSub@@ tree@@ Search ( ) ) ; resolver . setAllow@@ Multiple@@ D@@ ns ( l . is@@ Allow@@ Multiple@@ D@@ ns ( ) ) ; resolver . set@@ ConnectionFactory ( new@@ Pooled@@ ConnectionFactory ( l ) ) ; resolver . setUser@@ Filter ( l . getUser@@ Filter ( ) ) ; final Authenticator auth ; if ( Common@@ Helper . isBlank ( l . get@@ Principal@@ Attribute@@ Password ( ) ) ) { auth = new Authenticator ( resolver , getP@@ oo@@ led@@ Bind@@ Authentication@@ Handler ( l ) ) ; } else { auth = new Authenticator ( resolver , getP@@ oo@@ led@@ Compare@@ Authentication@@ Handler ( l ) ) ; } if ( l . is@@ Enhance@@ With@@ Entry@@ Resolver ( ) ) { auth . set@@ Entry@@ Resolver ( new@@ Search@@ Entry@@ Resolver ( l ) ) ; } return auth ; }
 private static void load@@ Form@@ File ( ) throws Exception { Fore@@ st forest = Library . make@@ Fore@@ st ( " new _ Library _ Path " ) ; User@@ Define@@ Library . ambigu@@ ity@@ Fore@@ st = forest ; }
 static void assert@@ Top@@ Docs ( Top@@ Docs actual , Top@@ Docs expected ) { assertThat ( " actual . total@@ Hits ▁ ! = ▁ expected . total@@ Hits " , actual . total@@ Hits , equalTo ( expected . total@@ Hits ) ) ; assertThat ( " actual . getMax@@ Score ( ) ▁ ! = ▁ expected . getMax@@ Score ( ) " , actual . getMax@@ Score ( ) , equalTo ( expected . getMax@@ Score ( ) ) ) ; assertThat ( " actual . score@@ Docs . length ▁ ! = ▁ expected . score@@ Docs . length " , actual . score@@ Docs . length , equalTo ( actual . score@@ Docs . length ) ) ; for ( int i = 0 ; i < actual . score@@ Docs . length ; i ++ ) { Score@@ Doc actual@@ Hit = actual . score@@ Docs [ i ] ; Score@@ Doc expected@@ Hit = expected . score@@ Docs [ i ] ; assertThat ( " actual@@ Hit . doc ▁ ! = ▁ expected@@ Hit . doc " , actual@@ Hit . doc , equalTo ( expected@@ Hit . doc ) ) ; assertThat ( " actual@@ Hit . score ▁ ! = ▁ expected@@ Hit . score " , actual@@ Hit . score , equalTo ( expected@@ Hit . score ) ) ; } }
 @ Converter public static P@@ EX_@@ P@@ 07 to@@ P@@ ex@@ P@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( P@@ EX_@@ P@@ 07 . class , body ) ; }
 public static void main ( String args [ ] ) { System . out . println ( " Test _ Socket@@ Listen " ) ; Test_@@ Socket@@ Listen app = new Test_@@ Socket@@ Listen ( ) ; app . run ( ) ; }
 private static void log@@ 0 ( org . apache . log4j . Logger l@@ 4j , Event e ) { if ( e . sys == Sys . HT@@ LOG ) { e . sys = Sys . HTTP@@ D ; String s = " tid ( " + Thread . currentThread ( ) . getId ( ) + " ) ▁ " + e . toString ( ) ; org . apache . log4j . Logger http@@ d@@ Logger = LogManager . getLogger ( " water . api . Request@@ Server " ) ; if ( e . kind == Kind . INFO ) { http@@ d@@ Logger . info ( s ) ; } else { http@@ d@@ Logger . error ( s ) ; } return ; } String s = e . toString ( ) ; if ( e . kind == Kind . F@@ AT@@ L ) { l@@ 4j . fatal ( s ) ; } else if ( e . kind == Kind . ERR@@ R ) { l@@ 4j . error ( s ) ; } else if ( e . kind == Kind . WARN ) { l@@ 4j . warn ( s ) ; } else if ( e . kind == Kind . INFO ) { l@@ 4j . info ( s ) ; } else if ( e . kind == Kind . DE@@ BG ) { l@@ 4j . debug ( s ) ; } else if ( e . kind == Kind . TRA@@ C ) { l@@ 4j . trace ( s ) ; } else { l@@ 4j . error ( s ) ; } }
 @ BeforeClass public static void setUp@@ BeforeClass ( ) throws Exception { CC@@ N@@ TestBase . setUp@@ BeforeClass ( ) ; }
 public static Boolean getRe@@ d@@ Left ( Context context , Boolean defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getBoolean ( " red@@ Left " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 private static Authenticator getS@@ asl@@ Authenticator ( final Ldap@@ Authentication@@ Properties l ) { final var resolver = new Search@@ Dn@@ Resolver ( ) ; resolver . setBase@@ Dn ( l . getBase@@ Dn ( ) ) ; resolver . setSub@@ tree@@ Search ( l . isSub@@ tree@@ Search ( ) ) ; resolver . setAllow@@ Multiple@@ D@@ ns ( l . is@@ Allow@@ Multiple@@ D@@ ns ( ) ) ; resolver . set@@ ConnectionFactory ( new@@ Pooled@@ ConnectionFactory ( l ) ) ; resolver . setUser@@ Filter ( l . getUser@@ Filter ( ) ) ; return new Authenticator ( resolver , getP@@ oo@@ led@@ Bind@@ Authentication@@ Handler ( l ) ) ; }
 @ Nullable public static Py@@ Type getTarget@@ TypeFrom@@ Tuple@@ Assignment ( @ NotNull Py@@ Target@@ Expression target , @ NotNull Py@@ Tuple@@ Expression parent@@ Tuple , @ NotNull Py@@ Type assigned@@ Type , @ NotNull Type@@ Eval@@ Context context ) { if ( assigned@@ Type instanceof Py@@ TupleType ) { return getTarget@@ TypeFrom@@ Tuple@@ Assignment ( target , parent@@ Tuple , ( Py@@ TupleType ) assigned@@ Type ) ; } else if ( assigned@@ Type instanceof Py@@ Class@@ Like@@ Type ) { return Stream@@ Ex . of ( ( ( Py@@ Class@@ Like@@ Type ) assigned@@ Type ) . get@@ Ancestor@@ Types ( context ) ) . select ( Py@@ Named@@ TupleType . class ) . find@@ First ( ) . map ( t -> getTarget@@ TypeFrom@@ Tuple@@ Assignment ( target , parent@@ Tuple , t ) ) . orElse ( null ) ; } return null ; }
 @ Converter public static RC@@ L_@@ I@@ 06 to@@ R@@ cl@@ I@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( RC@@ L_@@ I@@ 06 . class , body ) ; }
 public static void generate@@ Mark@@ down@@ Doc ( String path ) { Document@@ Generator rg = Groovy@@ Utils . newInstance ( " scripts / Rest@@ Documentation@@ Generator . groovy " ) ; rg . generate@@ Mark@@ Down ( path , Path@@ Util . join ( System . getProperty ( " user . home " ) , " zstack - markdown " ) ) ; }
 @ Deployment public static Web@@ Archive process@@ Archive ( ) { return init@@ Web@@ Archive@@ Deployment ( ) . addAs@@ Libraries ( Shrink@@ Wrap . create ( Java@@ Archive . class , " engine@@ 1 . jar " ) . addAs@@ Resource ( " single@@ Engine . xml " , " META - INF / processes . xml " ) ) ; }
 public static String getS@@ co@@ ut@@ ing@@ URL ( Context context ) { String ret = PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " database@@ URL@@ Pref " , URL ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } return ret ; }
 @ Converter public static OR@@ F_@@ R@@ 02 to@@ Or@@ fR@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ F_@@ R@@ 02 . class , body ) ; }
 public static char to@@ Base64 ( int value ) { assert ( value <= 63 && value >= 0 ) : " value ▁ out ▁ of ▁ range : " + value ; return BASE@@ 64_@@ MAP . charAt ( value ) ; }
 private static byte [ ] get@@ Nested@@ Jar@@ Data ( ) throws Exception { ByteArrayOutputStream byteArray@@ OutputStream = new ByteArrayOutputStream ( ) ; Jar@@ OutputStream jar@@ OutputStream = new Jar@@ OutputStream ( byteArray@@ OutputStream ) ; write@@ Manifest ( jar@@ OutputStream , " j@@ 2" ) ; write@@ Entry ( jar@@ OutputStream , "3 . dat " , 3 ) ; write@@ Entry ( jar@@ OutputStream , "4 . dat " , 4 ) ; write@@ Entry ( jar@@ OutputStream , " \u00@@ E4 . dat " , ' \u00@@ E@@ 4' ) ; jar@@ OutputStream . close ( ) ; return byteArray@@ OutputStream . toByteArray ( ) ; }
 public static String getJ@@ sp@@ Path ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ J@@ SP_@@ PATH , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( properties . get ( Web@@ Config@@ Key . WEB_@@ J@@ SP_@@ PATH , Web@@ Config@@ Default . WEB_@@ J@@ SP_@@ PATH ) , true ) ; } } ) ; return ( String ) cached@@ Config ; }
 public static String substitu@@ te@@ Config@@ Parameters ( String applicationId , String string ) { Str@@ Substitutor sub = new Str@@ Substitutor ( new Config@@ String@@ Lookup ( applicationId ) ) ; return sub . replace ( string ) ; }
 public static Process@@ Output execute@@ Process ( Configuration@@ Holder configuration@@ Holder , String command ) { String className = configuration@@ Holder . getConfiguration@@ Value ( Process@@ Executor . PROCESS_@@ EXEC@@ UT@@ ER_@@ class_@@ NAME_@@ PROPERTY_@@ KEY ) ; if ( className == null ) { className = Default@@ Process@@ Executor . class . getName ( ) ; } Process@@ Executor process@@ Executor = Process@@ Executor@@ Helper . PROCESS_@@ EXEC@@ UT@@ ERS . get ( className ) ; if ( process@@ Executor == null ) { process@@ Executor = ( Process@@ Executor ) Reflection@@ Helper . createInstance ( className ) ; Process@@ Executor@@ Helper . PROCESS_@@ EXEC@@ UT@@ ERS . put ( className , process@@ Executor ) ; } Process@@ Output process@@ Output = null ; try { process@@ Output = process@@ Executor . execute@@ Process ( configuration@@ Holder , command ) ; } catch ( RuntimeException exception ) { throw exception ; } catch ( Exception exception ) { throw new F@@ ax@@ Exception ( " Error ▁ while ▁ invoking ▁ process , ▁ command : ▁ " + command , exception ) ; } return process@@ Output ; }
 public static List < String > collect@@ Paths ( List < VirtualFile > files ) { return ContainerUtil . map ( files , new Function < VirtualFile , String > ( ) { public String fun ( VirtualFile file ) { return file . getPath ( ) ; } } ) ; }
 @ Converter public static AD@@ T_@@ A@@ 26 to@@ Ad@@ t@@ A@@ 26 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 26 . class , body ) ; }
 public static void add@@ Count ( Flat@@ Buffer@@ Builder builder , int count ) { builder . add@@ Short ( 2 , ( short ) ( count & 0xFFFF ) , 0 ) ; }
 private static void process@@ Go@@ to ( @ NotNull Control@@ Flow flow , int start , int end , @ NotNull Int@@ ArrayList exit@@ Points , @ NotNull Collection < ? super Psi@@ Statement > exit@@ Statements , @ NotNull Branch@@ ing@@ Instruction instruction , final Psi@@ Statement statement , @ NotNull Class ... classes@@ Filter ) { if ( statement == null ) return ; int goto@@ Offset = instruction . offset ; if ( start > goto@@ Offset || goto@@ Offset >= end || isElement@@ Of@@ Class ( statement , classes@@ Filter ) ) { goto@@ Offset = promo@@ te@@ Through@@ Goto@@ Chain ( flow , goto@@ Offset ) ; if ( goto@@ Offset > 0 && ( goto@@ Offset >= end || goto@@ Offset < start ) && ! exit@@ Points . contains ( goto@@ Offset ) ) { exit@@ Points . add ( goto@@ Offset ) ; } if ( goto@@ Offset >= end || goto@@ Offset < start ) { process@@ Goto@@ Statement ( exit@@ Statements , statement , classes@@ Filter ) ; } else { boolean is@@ Return = instruction instanceof GoTo@@ Instruction && ( ( GoTo@@ Instruction ) instruction ) . is@@ Return ; final Instruction goto@@ Instruction = flow . get@@ Instructions ( ) . get ( goto@@ Offset ) ; is@@ Return |= goto@@ Instruction instanceof GoTo@@ Instruction && ( ( GoTo@@ Instruction ) goto@@ Instruction ) . is@@ Return ; if ( is@@ Return ) { process@@ Goto@@ Statement ( exit@@ Statements , statement , classes@@ Filter ) ; } } } }
 public static String getS@@ mt@@ p ( ) { return ( String ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . MA@@ IL@@ _S@@ MT@@ P , key -> { try { return properties . get ( key ) ; } catch ( Property@@ NotFoundException e ) { throw new RuntimeException ( e ) ; } } ) ; }
 private static ResponseCode parse@@ ResponseCode ( int code ) { ResponseCode responseCode = CODE_@@ MAP . get ( code ) ; return responseCode == null ? ResponseCode . UNKNOWN : responseCode ; }
 public static Context getContext ( ) { return initial@@ Context ; }
 @ Nullable protected static PsiElement getContext@@ Element ( final Stack@@ Frame@@ Context context , final Source@@ Position position ) { if ( LOG . isDebugEnabled ( ) ) { final Source@@ Position source@@ Position = getSource@@ Position ( context ) ; LOG . assertTrue ( Comparing . equal ( source@@ Position , position ) ) ; } final PsiElement element = getContext@@ Element ( position ) ; if ( element == null ) { return null ; } final Stack@@ Frame@@ Proxy@@ Impl frame@@ Proxy = ( Stack@@ Frame@@ Proxy@@ Impl ) context . getFrame@@ Proxy ( ) ; if ( frame@@ Proxy == null ) { return element ; } final StringBuilder buf = String@@ Builder@@ Spin@@ Allocator . alloc ( ) ; try { List < Local@@ Variable@@ Proxy@@ Impl > list = frame@@ Proxy . visible@@ Variables ( ) ; Psi@@ Resolve@@ Helper resolve@@ Helper = Java@@ Psi@@ Facade . getInstance ( element . getProject ( ) ) . get@@ Resolve@@ Helper ( ) ; buf . append ( ' { ' ) ; for ( Local@@ Variable@@ Proxy@@ Impl local@@ Variable : list ) { final String varName = local@@ Variable . name ( ) ; if ( resolve@@ Helper . resolve@@ Referenced@@ Variable ( varName , element ) == null ) { buf . append ( local@@ Variable . getVariable ( ) . typeName ( ) ) . append ( " ▁ " ) . append ( varName ) . append ( " ; " ) ; } } buf . append ( ' } ' ) ; if ( buf . length ( ) <= 2 ) { return element ; } final PsiElement@@ Factory element@@ Factory = Java@@ Psi@@ Facade . getInstance ( element . getProject ( ) ) . getElement@@ Factory ( ) ; final Psi@@ CodeBlock code@@ Block@@ FromText = element@@ Factory . create@@ Code@@ Block@@ FromText ( buf . toString ( ) , element ) ; final Psi@@ Statement [ ] statements = code@@ Block@@ FromText . get@@ Statements ( ) ; for ( Psi@@ Statement statement : statements ) { if ( statement instanceof Psi@@ Declaration@@ Statement ) { Psi@@ Declaration@@ Statement decl@@ Statement = ( Psi@@ Declaration@@ Statement ) statement ; PsiElement [ ] declared@@ Elements = decl@@ Statement . getDeclared@@ Elements ( ) ; for ( PsiElement declared@@ Element : declared@@ Elements ) { declared@@ Element . put@@ UserData ( IS_@@ J@@ SP_@@ IMPLIC@@ IT , Boolean . TRUE ) ; } } } return code@@ Block@@ FromText ; } catch ( IncorrectOperationException e ) { return element ; } catch ( Evaluate@@ Exception e ) { return element ; } finally { String@@ Builder@@ Spin@@ Allocator . dispose ( buf ) ; } }
 public static void main ( String [ ] args ) { boolean game@@ Over = true ; int score = 800 ; int level@@ Completed = 5 ; int bonus = 100 ; int high@@ Score = calculate@@ Score ( game@@ Over , score , level@@ Completed , bonus ) ; System . out . println ( " Your ▁ final ▁ score ▁ was ▁ " + high@@ Score ) ; score = 10000 ; level@@ Completed = 8 ; bonus = 200 ; high@@ Score = calculate@@ Score ( game@@ Over , score , level@@ Completed , bonus ) ; System . out . println ( " Your ▁ final ▁ score ▁ was ▁ " + high@@ Score ) ; int high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 1500 ) ; display@@ High@@ Score@@ Position ( " Tim " , high@@ Score@@ Position ) ; high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 900 ) ; display@@ High@@ Score@@ Position ( " Bob " , high@@ Score@@ Position ) ; high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 400 ) ; display@@ High@@ Score@@ Position ( " Per@@ cy " , high@@ Score@@ Position ) ; high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 50 ) ; display@@ High@@ Score@@ Position ( " Gil@@ bert " , high@@ Score@@ Position ) ; high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 1000 ) ; display@@ High@@ Score@@ Position ( " Lou@@ ise " , high@@ Score@@ Position ) ; high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 500 ) ; display@@ High@@ Score@@ Position ( " Car@@ ol " , high@@ Score@@ Position ) ; high@@ Score@@ Position = calculate@@ High@@ Score@@ Position ( 100 ) ; display@@ High@@ Score@@ Position ( " F@@ rank " , high@@ Score@@ Position ) ; }
 public static Long getQueue@@ Poll@@ Timeout@@ Mil@@ li ( ) { return queue@@ Poll@@ Timeout@@ Mil@@ li ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return class_@@ NAME ; case 2 : return BUF ; case 3 : return CURSOR ; default : return null ; } }
 public static String get@@ Quick@@ ly ( String key , String defValue ) { if ( TextUtils . isEmpty ( key ) ) { return defValue ; } return get@@ With@@ Ref@@ lect ( key , defValue ) ; }
 public static OC@@ SP@@ Response getInstance ( Object obj ) { if ( obj instanceof OC@@ SP@@ Response ) { return ( OC@@ SP@@ Response ) obj ; } else if ( obj != null ) { return new OC@@ SP@@ Response ( ASN1@@ Sequence . getInstance ( obj ) ) ; } return null ; }
 public static Serializer@@ Registration get@@ Exact@@ Serializer@@ Registration ( Class cls ) { return class@@ Registr@@ ations . get ( cls ) ; }
 @ Converter public static SI@@ U@@ _S@@ 12 to@@ Si@@ u@@ S@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 12 . class , body ) ; }
 private static String getPassword ( SharedPreferences settings ) { return settings . getString ( Preference@@ Keys . KEY_@@ PASSWORD , null ) ; }
 @ BeforeClass public static void load@@ Kie@@ Container ( ) { kie@@ Container = K@@ IE_@@ SERVICES . new@@ Kie@@ Container ( RELEASE_@@ ID ) ; }
 public static int add ( int i , int j ) { return i + j ; }
 @ Converter public static SR@@ R@@ _S@@ 02 to@@ S@@ rr@@ S@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 02 . class , body ) ; }
 private static boolean is@@ Byte@@ array@@ Bytes@@ String@@ Match ( @ NotNull Py@@ Class sub@@ Class , @ NotNull Py@@ Class superClass ) { if ( ! Py@@ Names . TYPE_@@ BYTE@@ ARRAY . equals ( sub@@ Class . getName ( ) ) ) return false ; final PsiFile sub@@ Class@@ File = sub@@ Class . getContaining@@ File ( ) ; final boolean is@@ Py@@ 2 = sub@@ Class@@ File instanceof Py@@ i@@ File ? Py@@ Builtin@@ Cache . getInstance ( sub@@ Class ) . get@@ ObjectType ( Py@@ Names . TYPE_@@ UNICODE ) != null : LanguageLevel . for@@ Element ( sub@@ Class ) . is@@ Python@@ 2 ( ) ; final String super@@ ClassName = superClass . getName ( ) ; return is@@ Py@@ 2 && Py@@ Names . TYPE_@@ STR . equals ( super@@ ClassName ) || ! is@@ Py@@ 2 && Py@@ Names . TYPE_@@ BYTES . equals ( super@@ ClassName ) ; }
 protected static Map < Integer , Company > to@@ Company@@ Map ( ResultSet resultSet ) throws SQLException { Map < Integer , Company > result = new HashMap < Integer , Company > ( ) ; while ( resultSet . next ( ) ) { Company company = new Company ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getString ( 3 ) , resultSet . getString ( 4 ) , resultSet . getString ( 5 ) ) ; result . put ( resultSet . getInt ( 1 ) , company ) ; } return result ; }
 private static boolean artifact@@ Match ( List < Map < String , String > > artifacts , List < Pattern > patterns ) { return artifacts != null && artifacts . stream ( ) . any@@ Match ( ( Map artifact ) -> patterns . stream ( ) . any@@ Match ( p -> p . matcher ( String . valueOf ( artifact . get ( " fileName " ) ) ) . matches ( ) ) ) ; }
 public static boolean get@@ Robot@@ Pic@@ Pref ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getBoolean ( " robot@@ Pic@@ Pref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static boolean process@@ Returns ( @ NotNull Control@@ Flow flow , @ NotNull Return@@ Statement@@ s@@ Visitor after@@ Visitor ) throws IncorrectOperationException { final Convert@@ Return@@ Client@@ Visitor instruction@@ s@@ Visitor = new Convert@@ Return@@ Client@@ Visitor ( flow , after@@ Visitor ) ; depth@@ First@@ Search ( flow , instruction@@ s@@ Visitor ) ; instruction@@ s@@ Visitor . after@@ Processing ( ) ; return instruction@@ s@@ Visitor . getResult ( ) . booleanValue ( ) ; }
 static public void tmp ( Object ... objects ) { info ( objects ) ; }
 public static String base64@@ Encode@@ Int ( int value ) { char [ ] c = new char [ 6 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { c [ i ] = Base64 . to@@ Base64 ( ( value >> ( 26 - i * 6 ) ) & 0x3f ) ; } c [ 5 ] = Base64 . to@@ Base64 ( ( value << 4 ) & 0x3f ) ; return new String ( c ) ; }
 public static String token@@ Term ( String input@@ Term ) { StringBuilder builder = new StringBuilder ( ) ; try { TokenStream tokenStream = analyzer . tokenStream ( null , input@@ Term ) ; Offset@@ Attribute offset@@ Attribute = tokenStream . addAttribute ( Offset@@ Attribute . class ) ; Char@@ Term@@ Attribute char@@ Term@@ Attribute = tokenStream . addAttribute ( Char@@ Term@@ Attribute . class ) ; tokenStream . reset ( ) ; while ( tokenStream . increment@@ Token ( ) ) { int startOffset = offset@@ Attribute . startOffset ( ) ; int endOffset = offset@@ Attribute . endOffset ( ) ; String term = char@@ Term@@ Attribute . toString ( ) ; builder . append ( term ) . append ( ' ▁ ' ) ; } tokenStream . end ( ) ; tokenStream . close ( ) ; } catch ( IOException e ) { logger . error ( " Failed ▁ to ▁ tokenize ▁ " + input@@ Term , e ) ; } if ( builder . length ( ) != 0 ) { builder . delete@@ Char@@ At ( builder . length ( ) - 1 ) ; } return builder . toString ( ) ; }
 private static void validate@@ List@@ Sql@@ Firewall@@ Rule ( List < Sql@@ Firewall@@ Rule > sql@@ Firewall@@ Rules ) { boolean found = false ; for ( Sql@@ Firewall@@ Rule fire@@ wall@@ Rule : sql@@ Firewall@@ Rules ) { if ( fire@@ wall@@ Rule . name ( ) . equals ( SQL_@@ FIRE@@ WAL@@ L@@ RULE_@@ NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
 private static void assert@@ Read@@ Access@@ Gran@@ ted ( Segment@@ Node@@ Store@@ Persistence persistence , Set < String > expected@@ Blob@@ s ) throws Exception { Cloud@@ Blob@@ Container container = getContainer@@ From ( persistence ) ; Set < String > actual@@ Blob@@ Names = Stream@@ Support . stream ( container . list@@ Blob@@ s ( ) . spli@@ terator ( ) , false ) . map ( blob -> blob . getUri ( ) . getPath ( ) ) . map ( path -> path . substring ( path . lastIndexOf ( ' / ' ) + 1 ) ) . collect ( toSet ( ) ) ; Set < String > expected@@ Blob@@ Names = expected@@ Blob@@ s . stream ( ) . map ( name -> name + " . txt " ) . collect ( toSet ( ) ) ; assertEquals ( expected@@ Blob@@ Names , actual@@ Blob@@ Names ) ; Set < String > actual@@ Blob@@ Content = actual@@ Blob@@ Names . stream ( ) . map ( name -> { try { return container . getBlock@@ Blob@@ Reference ( name ) . download@@ Text ( ) ; } catch ( StorageException | IOException | URISyntaxException e ) { throw new RuntimeException ( " Error ▁ while ▁ reading ▁ blob ▁ " + name , e ) ; } } ) . collect ( toSet ( ) ) ; assertEquals ( expected@@ Blob@@ s , actual@@ Blob@@ Content ) ; }
 static Plot@@ ted@@ Chunk@@ s@@ Region get@@ Fil@@ led@@ Region ( ) { boolean [ ] [ ] plot@@ ted@@ Chunks = new boolean [ Constants . REGION@@ _SIZE ] [ Constants . REGION@@ _SIZE ] ; for ( int i = 0 ; i < Constants . REGION@@ _SIZE ; i ++ ) { Arrays . fill ( plot@@ ted@@ Chunks [ i ] , true ) ; } return new Plot@@ ted@@ Chunk@@ s@@ Region ( plot@@ ted@@ Chunks ) ; }
 @ Converter public static R@@ RI@@ _@@ I@@ 13 to@@ R@@ ri@@ I@@ 13 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ RI@@ _@@ I@@ 13 . class , body ) ; }
 protected static float [ ] get@@ Kernel@@ Sig@@ ma@@ Zero@@ Point@@ Se@@ ven@@ One ( ) { return new float [ ] { 0 , 0.00@@ 7@@ 2334@@ 423@@ f , 0.02@@ 07@@ 55@@ 37@@ 5f , - 0.05@@ 64@@ 18@@ 96@@ f , 0.02@@ 07@@ 55@@ 37@@ 5f , 0.00@@ 7@@ 2334@@ 423@@ f , 0 } ; }
 private static void add@@ SSL@@ Parameters ( FT@@ PS@@ Client ft@@ ps@@ Client , FileSystem@@ Options file@@ System@@ Options ) throws Exception { KEY@@ STORE = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getKey@@ Store ( file@@ System@@ Options ) ; TR@@ UST@@ STORE = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . get@@ Trust@@ Store ( file@@ System@@ Options ) ; KS_@@ PAS@@ SW@@ D = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getKey@@ Store@@ P@@ W ( file@@ System@@ Options ) ; TS_@@ PAS@@ SW@@ D = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . get@@ Trust@@ Store@@ P@@ W ( file@@ System@@ Options ) ; KEY_@@ PAS@@ SW@@ D = Ft@@ ps@@ FileSystem@@ Config@@ Builder . getInstance ( ) . getKey@@ P@@ W ( file@@ System@@ Options ) ; Key@@ ManagerFactory key@@ ManagerFactory = null ; Trust@@ ManagerFactory trust@@ ManagerFactory = null ; try { FileInputStream key@@ store@@ Path = new FileInputStream ( new File ( KEY@@ STORE ) ) ; FileInputStream trust@@ store@@ Path = new FileInputStream ( new File ( TR@@ UST@@ STORE ) ) ; KeyStore key@@ Store = KeyStore . getInstance ( " j@@ ks " ) ; KeyStore trust@@ Store = KeyStore . getInstance ( " j@@ ks " ) ; key@@ Store . load ( key@@ store@@ Path , KS_@@ PAS@@ SW@@ D . toCharArray ( ) ) ; trust@@ Store . load ( trust@@ store@@ Path , TS_@@ PAS@@ SW@@ D . toCharArray ( ) ) ; key@@ store@@ Path . close ( ) ; trust@@ store@@ Path . close ( ) ; key@@ ManagerFactory = Key@@ ManagerFactory . getInstance ( Key@@ ManagerFactory . getDefault@@ Algorithm ( ) ) ; key@@ ManagerFactory . init ( key@@ Store , KEY_@@ PAS@@ SW@@ D . toCharArray ( ) ) ; trust@@ ManagerFactory = Trust@@ ManagerFactory . getInstance ( Trust@@ ManagerFactory . getDefault@@ Algorithm ( ) ) ; trust@@ ManagerFactory . init ( trust@@ Store ) ; } catch ( Key@@ StoreException e ) { log . error ( " Error ▁ occurred ▁ when ▁ initializing ▁ key@@ stores " , e ) ; throw e ; } catch ( IOException e ) { log . error ( " Error ▁ occurred ▁ while ▁ retrieving ▁ the ▁ keystore ▁ paths " , e ) ; throw e ; } catch ( NoSuchAlgorithmException e ) { log . error ( " Error ▁ when ▁ getting ▁ the ▁ default ▁ algorithm " , e ) ; throw e ; } catch ( CertificateException e ) { log . error ( " Certificate ▁ exception ▁ occurred ▁ when ▁ loading ▁ the ▁ Key@@ Stores ▁ " , e ) ; throw e ; } catch ( Un@@ recover@@ able@@ KeyException e ) { log . error ( " Un@@ recover@@ able ▁ Key ▁ exception ▁ occurred " , e ) ; throw e ; } client@@ Key@@ Manager = key@@ ManagerFactory . getKey@@ Managers ( ) [ 0 ] ; client@@ TrustManager = trust@@ ManagerFactory . get@@ Trust@@ Managers ( ) [ 0 ] ; ft@@ ps@@ Client . setKey@@ Manager ( client@@ Key@@ Manager ) ; ft@@ ps@@ Client . set@@ TrustManager ( client@@ TrustManager ) ; log . info ( " SSL ▁ parameters ▁ added ▁ to ▁ the ▁ FT@@ PS ▁ client " ) ; }
 public static void custom@@ Render@@ Item ( ItemStack is ) { Render@@ Item render@@ Item = Minec@@ raft . getMin@@ ec@@ raft ( ) . get@@ Render@@ Item ( ) ; Texture@@ Manager texture@@ Manager = Minec@@ raft . getMin@@ ec@@ raft ( ) . getTexture@@ Manager ( ) ; Entity@@ Player@@ SP player = Minec@@ raft . getMin@@ ec@@ raft ( ) . player ; IB@@ a@@ ked@@ Model i@@ ba@@ ked@@ model = render@@ Item . getItem@@ Model@@ With@@ Overrides ( is , player . getEntity@@ World ( ) , player ) ; texture@@ Manager . bind@@ Texture ( Texture@@ Map . LOCATION_@@ BLOCK@@ S_@@ TEXTURE ) ; texture@@ Manager . get@@ Texture ( Texture@@ Map . LOCATION_@@ BLOCK@@ S_@@ TEXTURE ) . set@@ Blur@@ Mip@@ map ( false , false ) ; pre@@ Transform ( render@@ Item , is ) ; Gl@@ StateManager . enable@@ Re@@ scale@@ Normal ( ) ; Gl@@ StateManager . alpha@@ Func ( 5@@ 16 , 0.@@ 1F ) ; Gl@@ StateManager . enable@@ Blend ( ) ; Gl@@ StateManager . try@@ Blend@@ Func@@ Separate ( Gl@@ StateManager . Source@@ Factor . SRC_@@ ALPHA , Gl@@ StateManager . Dest@@ Factor . ONE_@@ MIN@@ US@@ _SRC_ALPHA , Gl@@ StateManager . Source@@ Factor . ONE , Gl@@ StateManager . Dest@@ Factor . ZERO ) ; Gl@@ StateManager . push@@ Matrix ( ) ; i@@ ba@@ ked@@ model = net . minecraftforge . client . Forge@@ Hoo@@ ks@@ Client . handle@@ Camera@@ Transforms ( i@@ ba@@ ked@@ model , Item@@ Camera@@ Transforms . Transform@@ Type . NONE , false ) ; render@@ Item . render@@ Item ( is , i@@ ba@@ ked@@ model ) ; Gl@@ StateManager . cull@@ Face ( Gl@@ StateManager . Cull@@ Face . BACK ) ; Gl@@ StateManager . pop@@ Matrix ( ) ; Gl@@ StateManager . disable@@ Re@@ scale@@ Normal ( ) ; Gl@@ StateManager . disable@@ Blend ( ) ; texture@@ Manager . bind@@ Texture ( Texture@@ Map . LOCATION_@@ BLOCK@@ S_@@ TEXTURE ) ; texture@@ Manager . get@@ Texture ( Texture@@ Map . LOCATION_@@ BLOCK@@ S_@@ TEXTURE ) . restore@@ Last@@ Blur@@ Mip@@ map ( ) ; }
 public static byte [ ] serialize ( Object obj ) throws IOException { try ( ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ) { try ( ObjectOutputStream o = new ObjectOutputStream ( b ) ) { o . writeObject ( obj ) ; } return b . toByteArray ( ) ; } }
 @ Nullable static public Ph@@ p@@ Class get@@ Interface ( Ph@@ p@@ Index php@@ Index , String className ) { if ( ! className . startsWith ( " \ \@@ " ) ) { className = " \ \@@ " + className ; } Collection < Ph@@ p@@ Class > classes = php@@ Index . get@@ Inter@@ faces@@ By@@ FQ@@ N ( className ) ; return classes . isEmpty ( ) ? null : classes . iterator ( ) . next ( ) ; }
 private static boolean match ( @ NotNull Py@@ Type expected , @ NotNull Py@@ Union@@ Type actual , @ NotNull Match@@ Context context ) { if ( expected instanceof Py@@ TupleType ) { Optional < Boolean > match = match ( ( Py@@ TupleType ) expected , actual , context ) ; if ( match . isPresent ( ) ) { return match . get ( ) ; } } return Stream@@ Ex . of ( actual . get@@ Members ( ) ) . any@@ Match ( type -> match ( expected , type , context ) . orElse ( false ) ) ; }
 public static String join ( String connector , List < String > objects ) { StringBuffer s@@ Buffer = new StringBuffer ( ) ; for ( String object : objects ) { s@@ Buffer . append ( object ) . append ( connector ) ; } if ( s@@ Buffer . length ( ) > 0 ) { s@@ Buffer . delete ( s@@ Buffer . length ( ) - connector . length ( ) , s@@ Buffer . length ( ) ) ; } return s@@ Buffer . toString ( ) ; }
 public static double calculate ( String source ) { Chars chars = new Chars ( source ) ; return parse@@ Expression ( chars ) ; }
 @ Converter public static CR@@ M_@@ C@@ 03 to@@ C@@ rm@@ C@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 03 . class , body ) ; }
 public static String toString ( long v , int radix ) { return Integr@@ al@@ ToString . long@@ ToString ( v , radix ) ; }
 public static void test@@ Insert ( ) { try { Class@@ D d1 = new Class@@ D ( 41 , null ) ; Class@@ D d2 = new Class@@ D ( 43 , null ) ; Class@@ D d3 = new Class@@ D ( 45 , null ) ; Class@@ B b1 = new Class@@ B ( 21 , null , null ) ; Class@@ B b2 = new Class@@ B ( 23 , null , null ) ; Class@@ A a1 = new Class@@ A ( 14 , 114 , " a4 - b3 - d@@ 5" , b2 , d3 ) ; Class@@ A a2 = new Class@@ A ( 15 , 115 , " a5 - b1 - d@@ 3" , b1 , d2 ) ; Class@@ A a3 = new Class@@ A ( 16 , 116 , " a6 - b3 - d@@ 1" , b2 , d1 ) ; List < Class@@ A > list = new ArrayList < > ( ) ; list . add ( a1 ) ; list . add ( a2 ) ; list . add ( a3 ) ; Class@@ A a4 = new Class@@ A ( 17 , 117 , " a6 - b3 - d@@ 1" , b2 , d1 ) ; broker . insert@@ Entity ( a4 ) ; broker . commit@@ Transaction ( ) ; System . out . println ( " Inser@@ ting ▁ entities ▁ successful . " ) ; } catch ( SQLException ex ) { broker . rollback@@ Transaction ( ) ; System . out . println ( " Inser@@ ting ▁ entities ▁ - ▁ transaction ▁ rollback : ▁ " + ex . getMessage ( ) ) ; } }
 public static Seq@@ Activity@@ Tree build@@ Activity@@ Tree ( Node i@@ Org , Node i@@ Coll ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " build@@ Activity@@ Tree " ) ; } Seq@@ Activity@@ Tree tree = new Seq@@ Activity@@ Tree ( ) ; Seq@@ Activity root = AD@@ L@@ Seq@@ Utilities . build@@ Activity@@ Node ( i@@ Org , i@@ Coll ) ; if ( root != null ) { tree . set@@ Root ( root ) ; tree . set@@ Depth@@ s ( ) ; tree . set@@ Tree@@ Count ( ) ; } else { tree = null ; } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " build@@ Activity@@ Tree " ) ; } return tree ; }
 public static Long decode ( String string ) throws NumberFormatException { int length = string . length ( ) , i = 0 ; if ( length == 0 ) { throw new NumberFormatException ( ) ; } char first@@ Digit = string . charAt ( i ) ; boolean negative = first@@ Digit == ' - ' ; if ( negative ) { if ( length == 1 ) { throw new NumberFormatException ( string ) ; } first@@ Digit = string . charAt ( ++ i ) ; } int base = 10 ; if ( first@@ Digit == '0' ) { if ( ++ i == length ) { return valueOf ( 0L ) ; } if ( ( first@@ Digit = string . charAt ( i ) ) == ' x ' || first@@ Digit == ' X ' ) { if ( i == length ) { throw new NumberFormatException ( string ) ; } i ++ ; base = 16 ; } else { base = 8 ; } } else if ( first@@ Digit == ' # ' ) { if ( i == length ) { throw new NumberFormatException ( string ) ; } i ++ ; base = 16 ; } long result = parse ( string , i , base , negative ) ; return valueOf ( result ) ; }
 private static void validate@@ Sql@@ Database ( Sql@@ Database sql@@ Database , String databaseName ) { Assert . assertNotNull ( sql@@ Database ) ; Assert . assertEquals ( sql@@ Database . name ( ) , databaseName ) ; Assert . assertEquals ( SQL@@ _SERVER_@@ NAME , sql@@ Database . sql@@ ServerName ( ) ) ; Assert . assertEquals ( sql@@ Database . collation ( ) , COL@@ LATION ) ; Assert . assertEquals ( sql@@ Database . edition ( ) , Database@@ Edi@@ tions . STANDARD ) ; }
 @ Converter public static QR@@ Y_@@ PC@@ 4 to@@ Qry@@ PC@@ 4 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ PC@@ 4 . class , body ) ; }
 @ NotNull private static Optional < Boolean > match@@ Object ( @ NotNull Py@@ ClassType expected , @ Nullable Py@@ Type actual ) { if ( ArrayUtil . contains ( expected . getName ( ) , Py@@ Names . OBJECT , Py@@ Names . TYPE ) ) { final Py@@ Builtin@@ Cache builtin@@ Cache = Py@@ Builtin@@ Cache . getInstance ( expected . get@@ Py@@ Class ( ) ) ; if ( expected . equals ( builtin@@ Cache . get@@ ObjectType ( ) ) ) { return Optional . of ( true ) ; } if ( expected . equals ( builtin@@ Cache . getType@@ Type ( ) ) && actual instanceof Py@@ Instanti@@ able@@ Type && ( ( Py@@ Instanti@@ able@@ Type ) actual ) . is@@ Definition ( ) ) { return Optional . of ( true ) ; } } return Optional . empty ( ) ; }
 public static Metric < Availability@@ Type > gen@@ Avail@@ Def ( ) { return ( Metric < Availability@@ Type > ) gen@@ Def ( Metric@@ Type . AVAILA@@ BILITY ) ; }
 private static void fill@@ Grid ( Grid g , int type ) { for ( int i = 0 ; i < g . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < g . getHeight ( ) ; j ++ ) { g . set ( i , j , type ) ; } } }
 public static String getProject@@ Build@@ time ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . PROJECT_@@ BUILD@@ TIME , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { try { return properties . get ( Web@@ Config@@ Key . PROJECT_@@ BUILD@@ TIME ) ; } catch ( Property@@ NotFoundException e ) { throw new RuntimeException ( " Couldn ' t ▁ load ▁ " + Web@@ Config@@ Key . PROJECT_@@ BUILD@@ TIME ) ; } } } ) ; return ( String ) cached@@ Config ; }
 private static TypeAdapter make@@ Adapter@@ For@@ Field ( String name , Fixture fixture ) { Field field = null ; if ( Grace@@ ful@@ Nam@@ er . is@@ Grace@@ ful@@ Name ( name ) ) { String simple@@ Name = Grace@@ ful@@ Nam@@ er . dis@@ gr@@ ace ( name ) . toLowerCase ( ) ; field = find@@ Field ( fixture , simple@@ Name ) ; } else { Matcher matcher = field@@ Pattern . matcher ( name ) ; matcher . find ( ) ; String fieldName = matcher . group ( 1 ) ; Class clazz = getTarget@@ Class ( fixture ) ; try { field = clazz . getField ( fieldName ) ; } catch ( NoSuch@@ FieldException var@@ 9 ) { try { field = getField ( clazz , fieldName ) ; } catch ( NoSuch@@ FieldException var@@ 8 ) { ; } } } if ( field == null ) { throw new NoSuch@@ Field@@ Fit@@ FailureException ( name ) ; } else { return TypeAdapter . on ( fixture , field ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 24 to@@ Ad@@ t@@ A@@ 24 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 24 . class , body ) ; }
 private static boolean eq ( PsiType t1 , PsiType t2 ) { return t1 == t2 || Comparing . equal ( Type@@ Conversion@@ Util . er@@ asure ( t1 ) , Type@@ Conversion@@ Util . er@@ asure ( t2 ) ) ; }
 @ Nullable public static PsiElement getContext@@ Element ( final Source@@ Position position ) { if ( position == null ) { return null ; } return getContext@@ Element@@ In@@ Text ( position . getFile ( ) , position . getLine ( ) ) ; }
 public static void delete@@ Global@@ Objs ( String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID , List < String > i@@ Obj@@ List ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " delete@@ Global@@ Objs " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : delete@@ Global@@ Objs " ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ One ( ) { float a = 1.@@ f / 3@@ 0.@@ f ; return new float [ ] { a , 5 * a , 0 , - 12 * a , 0 , 5 * a , a } ; }
 public static boolean isEmpty ( Object str ) { return str == null || str . equals ( EMPTY ) ; }
 static public Collection < Ph@@ p@@ Class > get@@ Classes@@ Interface ( Project project , @ NotNull String className ) { if ( ! className . startsWith ( " \ \@@ " ) ) { className = " \ \@@ " + className ; } return Ph@@ p@@ Index . getInstance ( project ) . get@@ Any@@ By@@ FQ@@ N ( className ) ; }
 public static byte [ ] hex@@ StringTo@@ ByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i += 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) << 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; }
 public static boolean IsValid@@ IP ( String ip ) { if ( ip == null || ip . isEmpty ( ) ) { return false ; } ip = ip . trim ( ) ; if ( ( ip . length ( ) < 6 ) & ( ip . length ( ) > 15 ) ) { return false ; } try { Pattern pattern = Pattern . compile ( " ^ ( ? : ( ? :@@ 25@@ [0-@@ 5 ] | 2@@ [0-@@ 4 ] [ 0-9 ] | [ 01 ] ? [0-9 ] [ 0-9 ] ? ) \\ . ) { 3 } ( ? : 25@@ [0-@@ 5 ] | 2@@ [0-@@ 4 ] [ 0-9 ] | [ 01 ] ? [0-9 ] [ 0-9 ] ? ) $ " ) ; Matcher matcher = pattern . matcher ( ip ) ; return matcher . matches ( ) ; } catch ( Pattern@@ SyntaxException ex ) { return false ; } }
 @ Converter public static PP@@ R_@@ PC@@ 1 to@@ P@@ pr@@ P@@ c1 ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ R_@@ PC@@ 1 . class , body ) ; }
 public static void main ( String [ ] args ) { launch ( args ) ; }
 public static Candidate@@ Match@@ Comparator getInstance ( ) { if ( self == null ) { self = new Candidate@@ Match@@ Comparator ( ) ; } return self ; }
 public static String to@@ TimeZone@@ ID ( ZonedDateTime dt ) { String s = ( dt == null ? null : dt . get@@ Zone ( ) . getId ( ) ) ; return s ; }
 public static boolean is@@ Variable@@ Assigned@@ In@@ Loop ( @ NotNull PsiReferenceExpression expression , @ NotNull PsiElement resolved ) { if ( ! ( expression . getParent ( ) instanceof Psi@@ Assignment@@ Expression ) || ( ( Psi@@ Assignment@@ Expression ) expression . getParent ( ) ) . getL@@ Expression ( ) != expression ) { return false ; } PsiExpression qualifier = expression . get@@ Qualifier@@ Expression ( ) ; if ( qualifier != null && ! ( qualifier instanceof Psi@@ This@@ Expression ) ) return false ; if ( ! ( resolved instanceof Psi@@ Variable ) ) return false ; Psi@@ Variable variable = ( Psi@@ Variable ) resolved ; final PsiElement codeBlock = PsiUtil . getVariable@@ CodeBlock ( variable , expression ) ; if ( codeBlock == null ) return false ; final Control@@ Flow flow ; try { flow = ControlFlow@@ Factory . getInstance ( codeBlock . getProject ( ) ) . getControl@@ Flow ( codeBlock , Local@@ s@@ Or@@ My@@ Instance@@ Fields@@ ControlFlow@@ Policy . getInstance ( ) , true ) ; } catch ( Analysis@@ Canceled@@ Exception e ) { return false ; } final Psi@@ Assignment@@ Expression assignment@@ Expression = ( Psi@@ Assignment@@ Expression ) expression . getParent ( ) ; int startOffset = flow . getStartOffset ( assignment@@ Expression ) ; return startOffset != - 1 && is@@ Instruction@@ Reachable ( flow , startOffset , startOffset ) ; }
 @ Converter public static MF@@ N_@@ M@@ 03 to@@ M@@ fn@@ M@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 03 . class , body ) ; }
 static final void register@@ Gson ( Gson@@ Builder gb ) { gb . register@@ TypeAdapter ( Object@@ Ref . class , Auto@@ Parcel@@ Adapter . create ( Auto@@ Par@@ cel_@@ Object@@ Ref . class ) ) ; }
 @ Converter public static RR@@ D_@@ O@@ 02 to@@ R@@ rd@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( RR@@ D_@@ O@@ 02 . class , body ) ; }
 public static boolean is@@ Whitespace ( char ch ) { return ch == SP || ch == HT || ch == CR || ch == LF ; }
 @ Nullable static public String getMethod@@ Return@@ AsString ( @ NotNull Ph@@ p@@ Class php@@ Class , @ NotNull String methodName ) { Method method = php@@ Class . find@@ Method@@ ByName ( methodName ) ; if ( method == null ) { return null ; } final Set < String > values = new HashSet < String > ( ) ; method . accept@@ Children ( new Psi@@ Recursive@@ Element@@ Walk@@ ing@@ Visitor ( ) { @ Override public void visit@@ Element ( PsiElement element ) { if ( Ph@@ p@@ Elements@@ Util . getMethod@@ Return@@ Pattern ( ) . accepts ( element ) ) { String value = Ph@@ p@@ Elements@@ Util . getStringValue ( element ) ; if ( value != null && StringUtils . isNotBlank ( value ) ) { values . add ( value ) ; } } super . visit@@ Element ( element ) ; } } ) ; if ( values . size ( ) == 0 ) { return null ; } return values . iterator ( ) . next ( ) ; }
 public static ZonedDateTime to@@ DateTime ( java . sql . Timestamp ts ) { ZonedDateTime dt = ( ts == null ? null : ZonedDateTime . of@@ Instant ( ts . to@@ Instant ( ) , par@@ is ) ) ; return dt ; }
 @ Converter public static ED@@ R_@@ Q@@ 01 to@@ Ed@@ r@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( ED@@ R_@@ Q@@ 01 . class , body ) ; }
 public static void set@@ Per@@ Host@@ Metrics@@ Included ( boolean include@@ Per@@ Host@@ Metrics ) { Aws@@ Sdk@@ Metrics . per@@ Host@@ Metrics@@ Included = include@@ Per@@ Host@@ Metrics ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_@@ ID ; case 3 : return OBJECT ; default : return null ; } }
 @ Nullable private static String getStringValue ( @ Nullable PsiElement psiElement , int depth ) { if ( psiElement == null || ++ depth > 5 ) { return null ; } if ( psiElement instanceof StringLiteral@@ Expression ) { String resolved@@ String = ( ( StringLiteral@@ Expression ) psiElement ) . getContents ( ) ; if ( StringUtils . isEmpty ( resolved@@ String ) ) { return null ; } return resolved@@ String ; } if ( psiElement instanceof Field ) { return getStringValue ( ( ( Field ) psiElement ) . getDefault@@ Value ( ) , depth ) ; } if ( psiElement instanceof Ph@@ p@@ Reference ) { PsiReference psi@@ Reference = psiElement . getReference ( ) ; if ( psi@@ Reference == null ) { return null ; } PsiElement ref = psi@@ Reference . resolve ( ) ; if ( ref instanceof Ph@@ p@@ Reference ) { return getStringValue ( psiElement , depth ) ; } if ( ref instanceof Field ) { PsiElement resolved = ( ( Field ) ref ) . getDefault@@ Value ( ) ; if ( resolved instanceof StringLiteral@@ Expression ) { return ( ( StringLiteral@@ Expression ) resolved ) . getContents ( ) ; } } } return null ; }
 @ Converter public static RC@@ I_@@ I@@ 05 to@@ R@@ ci@@ I@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( RC@@ I_@@ I@@ 05 . class , body ) ; }
 @ Converter public static PP@@ G_@@ PCH to@@ P@@ pg@@ P@@ ch ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ G_@@ PCH . class , body ) ; }
 @ NotNull public static Collection < Psi@@ Statement > find@@ Exit@@ Point@@ sAnd@@ Statements ( @ NotNull Control@@ Flow flow , final int start , final int end , @ NotNull Int@@ ArrayList exit@@ Points , @ NotNull Class < ? extends Psi@@ Statement > ... classes@@ Filter ) { if ( end == start ) { exit@@ Points . add ( end ) ; return Collections . emptyList ( ) ; } final Collection < Psi@@ Statement > exit@@ Statements = new TH@@ ash@@ Set < > ( ) ; Instruction@@ Client@@ Visitor visitor = new Instruction@@ Client@@ Visitor ( ) { @ Override public void visit@@ Throw@@ To@@ Instruction ( Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { process@@ Goto@@ Statement ( exit@@ Statements , find@@ Statement ( flow , offset ) , classes@@ Filter ) ; } @ Override public void visit@@ Branch@@ ing@@ Instruction ( Branch@@ ing@@ Instruction instruction , int offset , int next@@ Offset ) { process@@ Go@@ to ( flow , start , end , exit@@ Points , exit@@ Statements , instruction , find@@ Statement ( flow , offset ) , classes@@ Filter ) ; } @ Override public void visit@@ Return@@ Instruction ( Return@@ Instruction instruction , int offset , int next@@ Offset ) { } @ Override public void visit@@ Call@@ Instruction ( Call@@ Instruction instruction , int offset , int next@@ Offset ) { } @ Override public void visit@@ Conditional@@ Throw@@ To@@ Instruction ( Conditional@@ Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { visit@@ Instruction ( instruction , offset , next@@ Offset ) ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( offset >= end - 1 ) { int exit@@ Offset = end ; exit@@ Offset = promo@@ te@@ Through@@ Goto@@ Chain ( flow , exit@@ Offset ) ; if ( ! exit@@ Points . contains ( exit@@ Offset ) ) { exit@@ Points . add ( exit@@ Offset ) ; } } } @ Override public Object getResult ( ) { return null ; } } ; depth@@ First@@ Search ( flow , visitor , start , end ) ; return exit@@ Statements ; }
 @ Converter public static SR@@ M_S@@ 05 to@@ S@@ rm@@ S@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 05 . class , body ) ; }
 @ Converter public static MF@@ N_@@ M@@ 05 to@@ M@@ fn@@ M@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 05 . class , body ) ; }
 static public void info ( Object ... objects ) { info ( Sys . WATER , objects ) ; }
 public static float [ ] get@@ Kernel ( float sigma ) { return get@@ Kernel ( sigma , 0 ) ; }
 public static LocalDateTime to@@ LocalDateTime ( java . sql . Timestamp ts ) { LocalDateTime ld@@ t = ( ts == null ? null : ts . to@@ LocalDateTime ( ) ) ; return ld@@ t ; }
 public static FW@@ Log@@ Name getCurrent@@ Log@@ Name ( ) { String log@@ Name = MD@@ C . get ( LOG_@@ NAME ) ; FW@@ Log@@ Name ret@@ Name = null ; if ( log@@ Name != null ) { ret@@ Name = FW@@ Log@@ Name . valueOf ( log@@ Name ) ; } return ret@@ Name ; }
 @ Deprecated public static Serializer@@ Registration [ ] register@@ Package ( String pkg@@ Name ) { try { ClassLoader classLoader = Thread . currentThread ( ) . getContext@@ ClassLoader ( ) ; String path = pkg@@ Name . replace ( ' . ' , ' / ' ) ; Enumeration < URL > resources = classLoader . getResources ( path ) ; List < File > dirs = new ArrayList < File > ( ) ; while ( resources . hasMoreElements ( ) ) { URL resource = resources . nextElement ( ) ; dirs . add ( new File ( resource . getFile ( ) ) ) ; } ArrayList < Class > classes = new ArrayList < Class > ( ) ; for ( File directory : dirs ) { classes . addAll ( find@@ Classes ( directory , pkg@@ Name ) ) ; } Serializer@@ Registration [ ] registered@@ Classes = new Serializer@@ Registration [ classes . size ( ) ] ; for ( int i = 0 ; i != classes . size ( ) ; ++ i ) { Class cl@@ z = classes . get ( i ) ; registered@@ Classes [ i ] = register@@ Class ( cl@@ z , false ) ; } return registered@@ Classes ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return new Serializer@@ Registration [ 0 ] ; }
 public static Builder newBuilder ( ) { return Builder . create ( ) ; }
 private static void validate@@ Sql@@ Firewall@@ Rule ( Sql@@ Firewall@@ Rule sql@@ Firewall@@ Rule , String fire@@ wall@@ Name ) { Assert . assertNotNull ( sql@@ Firewall@@ Rule ) ; Assert . assertEquals ( fire@@ wall@@ Name , sql@@ Firewall@@ Rule . name ( ) ) ; Assert . assertEquals ( SQL@@ _SERVER_@@ NAME , sql@@ Firewall@@ Rule . sql@@ ServerName ( ) ) ; Assert . assertEquals ( START_@@ IP@@ ADDRESS , sql@@ Firewall@@ Rule . start@@ IPAddress ( ) ) ; Assert . assertEquals ( END_@@ IP@@ ADDRESS , sql@@ Firewall@@ Rule . end@@ IPAddress ( ) ) ; Assert . assertEquals ( R@@ G_@@ NAME , sql@@ Firewall@@ Rule . resourceGroupName ( ) ) ; Assert . assertEquals ( SQL@@ _SERVER_@@ NAME , sql@@ Firewall@@ Rule . sql@@ ServerName ( ) ) ; Assert . assertEquals ( Region . US_@@ CENTR@@ AL , sql@@ Firewall@@ Rule . region ( ) ) ; }
 private static int getSub@@ scription@@ Position@@ After@@ Edit ( final Context context , final String new@@ Title ) { int i = 0 ; for ( final String title : getSub@@ scriptions ( context ) . asMap ( ) . keySet ( ) ) { if ( title . equals ( new@@ Title ) ) { break ; } i ++ ; } return i ; }
 public static String limit@@ Length ( String str , int i ) { if ( isEmpty ( str ) ) { return " " ; } else { if ( str . length ( ) <= i ) { return str ; } else { return str . substring ( 0 , i - 3 ) + " . . . " ; } } }
 public static ZonedDateTime to@@ DateTime ( java . util . Date d ) { ZonedDateTime dt = ( d == null ? null : ZonedDateTime . of@@ Instant ( d . to@@ Instant ( ) , par@@ is ) ) ; return dt ; }
 public static long parseLong ( String string ) throws NumberFormatException { return parseLong ( string , 10 ) ; }
 private static String build@@ Message ( Configuration@@ PropertyName name , Bind@@ able < ? > target ) { StringBuilder message = new StringBuilder ( ) ; message . append ( " Failed ▁ to ▁ bind ▁ properties " ) ; message . append ( ( name != null ) ? " ▁ under ▁ ' " + name + " ' " : " " ) ; message . append ( " ▁ to ▁ " ) . append ( target . getType ( ) ) ; return message . toString ( ) ; }
 public static Set < Metric@@ Type > getPre@@ defined@@ Metrics ( ) { return registry . pre@@ defined@@ Metrics ( ) ; }
 public static void POST ( int n ) { POST ( n , " " ) ; }
 public static int calculate@@ High@@ Score@@ Position ( int player@@ Score ) { int position = 4 ; if ( player@@ Score >= 1000 ) { position = 1 ; } else if ( player@@ Score >= 500 ) { position = 2 ; } else if ( player@@ Score >= 100 ) { position = 3 ; } return position ; }
 public static boolean is@@ Equal@@ ClassName ( @ Nullable Ph@@ p@@ Class php@@ Class , @ Nullable String compare@@ ClassName ) { if ( php@@ Class == null || compare@@ ClassName == null ) { return false ; } String php@@ ClassName = php@@ Class . get@@ Presentable@@ FQ@@ N ( ) ; if ( php@@ ClassName == null ) { return false ; } if ( php@@ ClassName . startsWith ( " \ \@@ " ) ) { php@@ ClassName = php@@ ClassName . substring ( 1 ) ; } if ( compare@@ ClassName . startsWith ( " \ \@@ " ) ) { compare@@ ClassName = compare@@ ClassName . substring ( 1 ) ; } return php@@ ClassName . equals ( compare@@ ClassName ) ; }
 public static < I extends Writable@@ Comparable , V extends Writable , E extends Writable , M extends Writable > void assert@@ Valid@@ Vertex ( Configuration conf , Graph@@ State < I , V , E , M > graph@@ State , Basic@@ Vertex < I , V , E , M > actual , I expected@@ Id , V expectedValue , Edge < I , E > ... edges ) throws Exception { Basic@@ Vertex < I , V , E , M > expected = B@@ sp@@ Utils . create@@ Vertex ( conf ) ; set@@ Graph@@ State ( expected , graph@@ State ) ; Map < I , E > edge@@ Map = Maps . newHashMap ( ) ; for ( Edge < I , E > edge : edges ) { edge@@ Map . put ( edge . get@@ Dest@@ Vertex@@ Id ( ) , edge . getEdge@@ Value ( ) ) ; } expected . initialize ( expected@@ Id , expectedValue , edge@@ Map , null ) ; assert@@ Valid ( expected , actual ) ; }
 public static Temporal@@ Query < LocalDate > local@@ Date ( ) { return Temporal@@ Queries . LOCAL_@@ DATE ; }
 public static String fixed@@ Length ( String s , int length ) { String r = pad@@ Right ( s , length ) ; if ( r . length ( ) > length ) { int a = Math . max ( r . length ( ) - length + 1 , 0 ) ; int b = Math . max ( a , r . length ( ) ) ; r = " # " + r . substring ( a , b ) ; } return r ; }
 public static Map < String , Object > array@@ 2@@ Map ( Object ... values ) { Map < String , Object > map = new HashMap < > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i += 2 ) { if ( i + 1 < values . length ) { map . put ( String . valueOf ( values [ i ] ) , values [ i + 1 ] ) ; } } } return map ; }
 static public < T extends Throwable > T err ( Sys t , T exception ) { return err ( t , " " , exception ) ; }
 public static Ascii@@ String random@@ String ( ) { return new Ascii@@ String ( random@@ Bytes ( ) ) ; }
 static public void wrap ( ) { System . set@@ Err ( new Wrapper ( System . err ) ) ; }
 public static java . sql . Date to@@ SQL@@ Date ( LocalDate ld ) { java . sql . Date d = ( ld == null ? null : new java . sql . Date ( ld . at@@ StartOf@@ Day ( par@@ is ) . to@@ Instant ( ) . to@@ Epoch@@ Mil@@ li ( ) ) ) ; return d ; }
 public static Record valueOf ( final String [ ] values ) { if ( values . length == 1 ) { return valueOf ( values [ 0 ] ) ; } else { return new Record ( values , EQUAL ) ; } }
 public static void pause ( @ Nonnull Condition condition , @ Nonnull Timeout timeout ) { checkNotNull ( timeout ) ; pause ( condition , timeout . duration ( ) ) ; }
 private static void render@@ Item@@ Stack@@ In@@ World ( Vec3d offset , ItemStack stack ) { net . minecraft . client . renderer . Render@@ Helper . enable@@ Standard@@ Item@@ Lighting ( ) ; Gl@@ StateManager . translate ( offset . x , offset . y , offset . z ) ; render@@ Item@@ Custom ( stack , 0 , 0.1f ) ; Gl@@ StateManager . translate ( - offset . x , - offset . y , - offset . z ) ; }
 public static Download@@ Result download ( @ NotNull Project project , Maven@@ Project@@ s@@ Tree project@@ s@@ Tree , Collection < MavenProject > maven@@ Projects , @ Nullable Collection < Maven@@ Artifact > artifacts , boolean download@@ Sources , boolean download@@ Docs , Maven@@ Embed@@ der@@ Wrapper embed@@ der , Maven@@ ProgressIndicator p ) throws Maven@@ Process@@ Canceled@@ Exception { return new Maven@@ Artifact@@ Downloader ( project , project@@ s@@ Tree , maven@@ Projects , artifacts , embed@@ der , p ) . download ( download@@ Sources , download@@ Docs ) ; }
 public static void pause ( ) { pause ( SLE@@ EP_@@ INTERVAL ) ; }
 private static SharedPreferences get@@ SharedPreferences ( final Context context ) { if ( s@@ SharedPreferences == null ) { s@@ SharedPreferences = context . get@@ SharedPreferences ( KEY@@ _SHAR@@ ED_@@ PREFER@@ EN@@ CES , Context . MODE_@@ PRIVATE ) ; } return s@@ SharedPreferences ; }
 @ NotNull static public Set < String > getArray@@ Values@@ AsString ( @ NotNull Array@@ Creation@@ Expression array@@ Creation@@ Expression ) { return getArray@@ Values@@ As@@ Map ( array@@ Creation@@ Expression ) . keySet ( ) ; }
 @ NotNull public static Collection < Variable@@ Info > get@@ Initialized@@ Tw@@ ice ( @ NotNull Control@@ Flow flow ) { return get@@ Initialized@@ Tw@@ ice ( flow , 0 , flow . getSize ( ) ) ; }
 public static String get@@ Country@@ Name ( String code ) { return table . get ( code ) ; }
 public static void main ( String [ ] args ) { Dimension size = new Dimension ( 200 , 100 ) ; Drawing@@ JPanel panel = new Drawing@@ JPanel ( size ) ; panel . fill ( Color . WHITE . get@@ RGB ( ) ) ; panel . repaint ( ) ; JFrame frame = new JFrame ( " " ) ; frame . add ( panel ) ; frame . setUn@@ decorated ( true ) ; frame . setVisible ( true ) ; frame . set@@ Resiz@@ able ( false ) ; frame . setDefault@@ Close@@ Operation ( JFrame . EXIT_@@ ON_@@ CLOSE ) ; frame . pack ( ) ; }
 @ Converter public static OM@@ S_@@ O@@ 01 to@@ O@@ ms@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( OM@@ S_@@ O@@ 01 . class , body ) ; }
 private static boolean match@@ Classes ( @ Nullable Py@@ Class superClass , @ Nullable Py@@ Class sub@@ Class , @ NotNull Type@@ Eval@@ Context context ) { if ( superClass == null || sub@@ Class == null || sub@@ Class . is@@ Subclass ( superClass , context ) || Py@@ ABC@@ Util . is@@ Subclass ( sub@@ Class , superClass , context ) || is@@ Str@@ Unicode@@ Match ( sub@@ Class , superClass ) || is@@ Byte@@ array@@ Bytes@@ String@@ Match ( sub@@ Class , superClass ) || Py@@ Util . has@@ Unresolved@@ Ance@@ stors ( sub@@ Class , context ) ) { return true ; } else { final String super@@ Name = superClass . getName ( ) ; return super@@ Name != null && super@@ Name . equals ( sub@@ Class . getName ( ) ) ; } }
 @ Converter public static SI@@ U@@ _S@@ 24 to@@ Si@@ u@@ S@@ 24 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 24 . class , body ) ; }
 private static @ Nullable int [ ] get@@ Indices ( final String line , final int rows , final int cols ) { if ( line == null ) { return null ; } final String [ ] parts = line . split ( " \t " ) ; if ( parts . length < 3 ) { return null ; } try { final String well = parts [ 1 ] ; final int well@@ Index = getIndex ( well , rows , cols ) ; if ( well@@ Index == - 1 ) { return null ; } return new int [ ] { Integer . parseInt ( parts [ 0 ] ) - 1 , well@@ Index } ; } catch ( final RuntimeException e ) { return null ; } }
 public static Instruction get@@ Instruction ( String name ) { return instruction@@ Map . get ( name ) ; }
 @ Converter public static RP@@ I_@@ I@@ 01 to@@ R@@ pi@@ I@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ I_@@ I@@ 01 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 23 to@@ Ad@@ t@@ A@@ 23 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 23 . class , body ) ; }
 public static boolean check@@ Permissions@@ Gran@@ ted ( @ NonNull Context context , @ NonNull String ... permissions ) { for ( String permission : permissions ) { if ( Context@@ Compat . check@@ Self@@ Permission ( context , permission ) != PackageManager . PERMISSION_@@ GRAN@@ TED ) { return false ; } } return true ; }
 @ Converter public static R@@ Q@@ A_@@ I@@ 08 to@@ R@@ q@@ a@@ I@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ A_@@ I@@ 08 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 49 to@@ Ad@@ t@@ A@@ 49 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 49 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 09 to@@ Ad@@ t@@ A@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 09 . class , body ) ; }
 public static void put ( String name , Instruction result ) { instruction@@ Map . put ( name , result ) ; }
 static public PsiElement@@ Pattern . Capture < PsiElement > getAction@@ Method@@ Pattern ( ) { return Platform@@ Patterns . psiElement ( Ph@@ p@@ TokenTypes . IDENTIFIER ) . with@@ Text ( Platform@@ Patterns . string ( ) . endsWith ( " Action " ) ) . after@@ Leaf@@ Skipping ( Platform@@ Patterns . psiElement ( Psi@@ WhiteSpace . class ) , Platform@@ Patterns . psiElement ( Ph@@ p@@ TokenTypes . kw@@ FUNCTION ) ) . inside ( Method . class ) . with@@ Language ( Ph@@ p@@ Language . INSTANCE ) ; }
 @ Converter public static MD@@ M_@@ T@@ 05 to@@ M@@ dm@@ T@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 05 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 03 to@@ Ad@@ t@@ A@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 03 . class , body ) ; }
 @ Converter public static QR@@ Y_@@ Q@@ 02 to@@ Qry@@ Q@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ Q@@ 02 . class , body ) ; }
 @ Nullable static public PsiElement get@@ PsiElement@@ sBy@@ Signature@@ Single ( Project project , @ Nullable String signature ) { PsiElement [ ] psi@@ Elements = get@@ PsiElement@@ sBy@@ Signature ( project , signature ) ; if ( psi@@ Elements . length == 0 ) { return null ; } return psi@@ Elements [ 0 ] ; }
 public static Temporal@@ Query < Zone@@ Offset > offset ( ) { return Temporal@@ Queries . OFFSET ; }
 @ Nullable static public Ph@@ p@@ PsiElement getArray@@ Value ( Array@@ Creation@@ Expression array@@ Creation@@ Expression , String name ) { for ( Array@@ Hash@@ Element array@@ Hash@@ Element : array@@ Creation@@ Expression . get@@ Hash@@ Elements ( ) ) { Ph@@ p@@ PsiElement child = array@@ Hash@@ Element . getKey ( ) ; if ( child instanceof StringLiteral@@ Expression ) { if ( ( ( StringLiteral@@ Expression ) child ) . getContents ( ) . equals ( name ) ) { return array@@ Hash@@ Element . getValue ( ) ; } } } return null ; }
 @ Converter public static C@@ SU@@ _C@@ 11 to@@ C@@ su@@ C@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( C@@ SU@@ _C@@ 11 . class , body ) ; }
 public static Mutable@@ WebApp@@ Context@@ Param create ( ) { return new Mutable@@ WebApp@@ Context@@ Param ( ) ; }
 public static void unwrap ( PrintStream stream , String s ) { if ( stream instanceof Wrapper ) ( ( Wrapper ) stream ) . print@@ ln@@ Parent ( s ) ; else stream . println ( s ) ; }
 private static boolean substitu@@ te@@ Expected@@ Element@@ sWith@@ Uni@@ ons ( @ NotNull Py@@ TupleType expected , int elementCount , @ NotNull Py@@ Union@@ Type actual , @ NotNull Match@@ Context context ) { for ( int i = 0 ; i < elementCount ; i ++ ) { final int currentIndex = i ; final Py@@ Type elementType = Py@@ Union@@ Type . union ( Stream@@ Ex . of ( actual . get@@ Members ( ) ) . select ( Py@@ TupleType . class ) . map ( type -> type . getElementType ( currentIndex ) ) . toList ( ) ) ; if ( ! match ( expected . getElementType ( i ) , elementType , context ) . orElse ( true ) ) { return false ; } } return true ; }
 @ Converter public static AD@@ T_@@ A@@ 21 to@@ Ad@@ t@@ A@@ 21 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 21 . class , body ) ; }
 public static void dump@@ TOC ( List < AD@@ L@@ TOC > i@@ TOC ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ dump@@ TOC " ) ; if ( i@@ TOC != null ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ TOC . size ( ) ) ; AD@@ L@@ TOC temp = null ; for ( int i = 0 ; i < i@@ TOC . size ( ) ; i ++ ) { temp = i@@ TOC . get ( i ) ; temp . dump@@ State ( ) ; } } else { System . out . println ( " ▁ ▁ : : - - > ▁ NULL " ) ; } System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ dump@@ TOC " ) ; } }
 public static void clean@@ Close ( Stream@@ Connection connection , Closeable ... additional ) { try { connection . get@@ Sink@@ Channel ( ) . shutdown@@ Writes ( ) ; if ( ! connection . get@@ Sink@@ Channel ( ) . flush ( ) ) { connection . get@@ Sink@@ Channel ( ) . setWrite@@ Listener ( Channel@@ Listeners . flush@@ ing@@ Channel@@ Listener ( new Channel@@ Listener < Condu@@ it@@ Stream@@ Sink@@ Channel > ( ) { @ Override public void handleEvent ( Condu@@ it@@ Stream@@ Sink@@ Channel channel ) { do@@ Dra@@ in ( connection , additional ) ; } } , new Channel@@ ExceptionHandler < Condu@@ it@@ Stream@@ Sink@@ Channel > ( ) { @ Override public void handleException ( Condu@@ it@@ Stream@@ Sink@@ Channel channel , IOException exception ) { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( exception ) ; Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; } } ) ) ; connection . get@@ Sink@@ Channel ( ) . resume@@ Writes ( ) ; } else { do@@ Dra@@ in ( connection , additional ) ; } } catch ( Throwable e ) { if ( e instanceof IOException ) { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( ( IOException ) e ) ; } else { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( new IOException ( e ) ) ; } Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; } }
 @ Converter public static DS@@ R_@@ Q@@ 01 to@@ D@@ sr@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( DS@@ R_@@ Q@@ 01 . class , body ) ; }
 public static void put ( String key , String value ) { MD@@ C . put ( key , value ) ; }
 public static void save@@ To@@ ED@@ F ( byte [ ] deco@@ bb@@ ed , FileOutputStream output ) { try { output . write ( deco@@ bb@@ ed ) ; output . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
 static public PsiElement@@ Pattern . Capture < PsiElement > getClass@@ Name@@ Pattern ( ) { return Platform@@ Patterns . psiElement ( Ph@@ p@@ TokenTypes . IDENTIFIER ) . after@@ Leaf@@ Skipping ( Platform@@ Patterns . psiElement ( Psi@@ WhiteSpace . class ) , Platform@@ Patterns . psiElement ( Ph@@ p@@ TokenTypes . kw@@ CLASS ) ) . with@@ Parent ( Ph@@ p@@ Class . class ) . with@@ Language ( Ph@@ p@@ Language . INSTANCE ) ; }
 private static Builder initialize@@ Ko@@ do@@ ClientConfig ( Under@@ FileSystem@@ Configuration conf ) { Ok@@ HttpClient . Builder builder = new Ok@@ HttpClient . Builder ( ) ; Dispatcher dispatcher = new Dispatcher ( ) ; dispatcher . setMax@@ Requests ( conf . getInt ( Property@@ Key . UNDER@@ FS_@@ KO@@ DO_@@ REQUEST@@ S_@@ MAX ) ) ; builder . connect@@ Timeout ( conf . get@@ Ms ( Property@@ Key . UNDER@@ FS_@@ KO@@ DO_@@ CONNECT_@@ TIMEOUT ) , TimeUnit . SECONDS ) ; return builder ; }
 public static void invoke@@ AndWait ( Project p , Runnable r ) { invoke@@ AndWait ( p , Modality@@ State . default@@ Modality@@ State ( ) , r ) ; }
 @ Converter public static ER@@ P_@@ Q@@ 01 to@@ Er@@ p@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( ER@@ P_@@ Q@@ 01 . class , body ) ; }
 public static boolean set@@ Global@@ Obj@@ Satisfied ( String i@@ Obj@@ ID , String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID , String i@@ Satisfied ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " set@@ Global@@ Obj@@ Satisfied " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Obj@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Lear@@ ner@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Scope@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Satisfied ) ; } boolean success = true ; if ( ! ( i@@ Satisfied . equals ( " unknown " ) || i@@ Satisfied . equals ( " satisfied " ) || i@@ Satisfied . equals ( " not@@ Satisfied " ) ) ) { success = false ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + i@@ Satisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " set@@ Shared@@ Comp@@ Master@@ y " ) ; } return success ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : set@@ Global@@ Obj@@ Satisfied " ) ; return success ; }
 public static java . sql . Time to@@ SQL@@ Time ( LocalTime lt ) { java . sql . Time t = ( lt == null ? null : Time . valueOf ( lt ) ) ; return t ; }
 @ Converter public static MF@@ K_@@ M@@ 05 to@@ M@@ fk@@ M@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ K_@@ M@@ 05 . class , body ) ; }
 public static void set@@ LogLevel ( int log_level ) throws IllegalArgumentException { Level l ; switch ( log_level ) { case 1 : l = Level . TRACE ; break ; case 2 : l = Level . DEBUG ; break ; case 3 : l = Level . INFO ; break ; case 4 : l = Level . WARN ; break ; case 5 : l = Level . ERROR ; break ; case 6 : l = Level . FATAL ; break ; default : throw new IllegalArgumentException ( " Log ▁ level ▁ " + log_level + " ▁ is ▁ invalid " ) ; } _logger . setLevel ( l ) ; System . out . println ( " Set ▁ log ▁ level ▁ to ▁ " + l ) ; _logger . info ( " Set ▁ log ▁ level ▁ to ▁ " + l ) ; }
 public static Encoder Binary@@ Encoder ( ) { return data -> decode@@ _bin ( data . getBytes ( ) ) ; }
 public static String toString ( LocalDate ld ) { String s = ( ld == null ? null : local@@ Date@@ Formatter . with@@ Zone ( ZoneId . of ( " UTC " ) ) . format ( ld ) ) ; return s ; }
 public static Start@@ Lambda@@ Function@@ Failed@@ Event@@ Attributes@@ Marshaller getInstance ( ) { return instance ; }
 public static Vector@@ 4b create ( Vector@@ 4b v ) { return new Vector@@ 4b ( v ) ; }
 @ Nullable public static Map < Py@@ Generic@@ Type , Py@@ Type > un@@ ify@@ Generic@@ Call ( @ Nullable Py@@ Expression receiver , @ NotNull Map < Py@@ Expression , Py@@ Callable@@ Parameter > arguments , @ NotNull Type@@ Eval@@ Context context ) { final Map < Py@@ Generic@@ Type , Py@@ Type > substitutions = un@@ ify@@ Receiver ( receiver , context ) ; for ( Map . Entry < Py@@ Expression , Py@@ Callable@@ Parameter > entry : get@@ Regular@@ Mapped@@ Parameters ( arguments ) . entrySet ( ) ) { final Py@@ Callable@@ Parameter param@@ Wrapper = entry . getValue ( ) ; Py@@ Type actual@@ Type = context . getType ( entry . getKey ( ) ) ; if ( param@@ Wrapper . is@@ Self ( ) ) { final Py@@ Parameter param = param@@ Wrapper . getParameter ( ) ; final Py@@ Function function = as ( Scope@@ Util . get@@ Scope@@ Owner ( param ) , Py@@ Function . class ) ; if ( function != null && function . get@@ Modifier ( ) == Py@@ Function . Modifier . CLASS@@ METHOD ) { final Stream@@ Ex < Py@@ Type > types ; if ( actual@@ Type instanceof Py@@ Union@@ Type ) { types = Stream@@ Ex . of ( ( ( Py@@ Union@@ Type ) actual@@ Type ) . get@@ Members ( ) ) ; } else { types = Stream@@ Ex . of ( actual@@ Type ) ; } actual@@ Type = types . select ( Py@@ Class@@ Like@@ Type . class ) . map ( Py@@ Class@@ Like@@ Type :: to@@ Class ) . select ( Py@@ Type . class ) . fold@@ Left ( Py@@ Union@@ Type :: union ) . orElse ( actual@@ Type ) ; } } final Py@@ Type expected@@ Type = param@@ Wrapper . get@@ Argument@@ Type ( context ) ; if ( ! match ( expected@@ Type , actual@@ Type , context , substitutions ) ) { return null ; } } if ( ! match@@ Container ( get@@ Mapped@@ Position@@ al@@ Container ( arguments ) , get@@ Arguments@@ Mapped@@ To@@ Position@@ al@@ Container ( arguments ) , substitutions , context ) ) { return null ; } if ( ! match@@ Container ( get@@ Mapped@@ Keyword@@ Container ( arguments ) , get@@ Arguments@@ Mapped@@ To@@ Keyword@@ Container ( arguments ) , substitutions , context ) ) { return null ; } return substitutions ; }
 public static < T extends KeyValue > Map < String , String > getKey@@ Value@@ Collection@@ As@@ Map ( List < T > collection ) { Map < String , String > map = new HashMap < String , String > ( collection . size ( ) ) ; for ( KeyValue kv : collection ) { map . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } return map ; }
 public static String getRe@@ dis@@ Password ( ) { return ( String ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . RE@@ DI@@ S_@@ PASSWORD , key -> properties . get ( key , Web@@ Config@@ Default . RE@@ DI@@ S_@@ PASSWORD ) ) ; }
 @ Converter public static SR@@ R@@ _S@@ 07 to@@ S@@ rr@@ S@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 07 . class , body ) ; }
 public static float read@@ Temperature@@ Value ( byte [ ] bytes ) { if ( bytes . length > 0 ) { return ( ( float ) ( bytes [ 0 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) ) / 4.0f ; } return 0.0f ; }
 public static void createTest@@ Jar ( File file , boolean unpack@@ Nested ) throws Exception { FileOutputStream file@@ OutputStream = new FileOutputStream ( file ) ; try ( Jar@@ OutputStream jar@@ OutputStream = new Jar@@ OutputStream ( file@@ OutputStream ) ) { write@@ Manifest ( jar@@ OutputStream , " j@@ 1" ) ; write@@ Entry ( jar@@ OutputStream , "1 . dat " , 1 ) ; write@@ Entry ( jar@@ OutputStream , "2 . dat " , 2 ) ; write@@ Dir@@ Entry ( jar@@ OutputStream , " d / " ) ; write@@ Entry ( jar@@ OutputStream , " d / 9 . dat " , 9 ) ; write@@ Dir@@ Entry ( jar@@ OutputStream , " special / " ) ; write@@ Entry ( jar@@ OutputStream , " special / \u00@@ EB . dat " , ' \u00@@ EB ' ) ; write@@ Nested@@ Entry ( " nested . jar " , unpack@@ Nested , jar@@ OutputStream ) ; write@@ Nested@@ Entry ( " another - nested . jar " , unpack@@ Nested , jar@@ OutputStream ) ; } }
 @ Nullable public static VirtualFile do@@ Resolve@@ Super@@ Po@@ mFile ( @ Nullable File maven@@ Home ) { File lib = resolve@@ Maven@@ Lib ( maven@@ Home ) ; if ( lib == null ) return null ; VirtualFile file = LocalFileSystem . getInstance ( ) . find@@ File@@ By@@ Io@@ File ( lib ) ; if ( file == null ) return null ; VirtualFile root = Jar@@ FileSystem . getInstance ( ) . get@@ Jar@@ Root@@ For@@ LocalFile ( file ) ; if ( root == null ) return null ; return root . find@@ File@@ By@@ RelativePath ( SUP@@ ER_@@ PO@@ M_@@ PATH ) ; }
 @ Nullable public static Method@@ Reference@@ Bag getMethod@@ Parameter@@ Reference@@ Bag ( PsiElement psiElement , int want@@ Index ) { PsiElement variable@@ Context = psiElement . getContext ( ) ; if ( ! ( variable@@ Context instanceof ParameterList ) ) { return null ; } ParameterList parameter@@ List = ( ParameterList ) variable@@ Context ; if ( ! ( parameter@@ List . getContext ( ) instanceof Method@@ Reference ) ) { return null ; } Parameter@@ Bag currentIndex = PsiElement@@ Utils . getCurrent@@ Parameter@@ Index ( psiElement ) ; if ( currentIndex == null ) { return null ; } if ( want@@ Index >= 0 && currentIndex . getIndex ( ) != want@@ Index ) { return null ; } return new Method@@ Reference@@ Bag ( parameter@@ List , ( Method@@ Reference ) parameter@@ List . getContext ( ) , currentIndex ) ; }
 private static boolean extract@@ Seq@@ Info ( Node i@@ Node , Seq@@ Activity io@@ Act ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " extract@@ Seq@@ Info " ) ; } boolean ok = true ; String temp@@ Val = null ; NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " control@@ Mode " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < control@@ Mode > ▁ element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " choice " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Control@@ Mode@@ Choice ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " choice@@ Exit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Control@@ Mode@@ Choice@@ Exit ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " flow " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Control@@ Mode@@ Flow ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " forward@@ Only " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Control@@ Forward@@ Only ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " use@@ Current@@ Attempt@@ Objective@@ Info " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setUse@@ Cur@@ Objective ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " use@@ Current@@ Attempt@@ Progress@@ Info " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setUse@@ Cur@@ Progress ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " sequ@@ enc@@ ing@@ Rules " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < sequ@@ enc@@ ing@@ Rules > ▁ " + " element " ) ; } ok = AD@@ L@@ Seq@@ Utilities . get@@ Sequ@@ enc@@ ing@@ Rules ( curNode , io@@ Act ) ; } else if ( curNode . getLocalName ( ) . equals ( " limit@@ Conditions " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < limit@@ Conditions > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " attempt@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Attempt@@ Limit ( Long . valueOf ( temp@@ Val ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " attempt@@ Absolute@@ Duration@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Attempt@@ Ab@@ D@@ ur ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " attempt@@ Exper@@ i@@ ence@@ d@@ Duration@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Attempt@@ Ex@@ D@@ ur ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " activity@@ Absolute@@ Duration@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Activity@@ Ab@@ D@@ ur ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " activity@@ Exper@@ i@@ ence@@ d@@ Duration@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Activity@@ Ex@@ D@@ ur ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " begin@@ Time@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Begin@@ Time@@ Limit ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " end@@ Time@@ Limit " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setEnd@@ Time@@ Limit ( temp@@ Val ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " auxili@@ ary@@ Resources " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < auxili@@ ary@@ Resource@@ es > ▁ " + " element " ) ; } ok = AD@@ L@@ Seq@@ Utilities . get@@ Aux@@ Resources ( curNode , io@@ Act ) ; } else if ( curNode . getLocalName ( ) . equals ( " roll@@ up@@ Rules " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < roll@@ up@@ Rules > ▁ " + " element " ) ; } ok = AD@@ L@@ Seq@@ Utilities . get@@ Roll@@ up@@ Rules ( curNode , io@@ Act ) ; } else if ( curNode . getLocalName ( ) . equals ( " objec@@ tives " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < objec@@ tives > ▁ " + " element " ) ; } ok = AD@@ L@@ Seq@@ Utilities . get@@ Objec@@ tives ( curNode , io@@ Act ) ; } else if ( curNode . getLocalName ( ) . equals ( " random@@ ization@@ Controls " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < random@@ ization@@ Controls > ▁ element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " random@@ ization@@ Timing " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Random@@ Timing ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " select@@ Count " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Select@@ Count ( ( Integer . valueOf ( temp@@ Val ) ) . intValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " reorder@@ Children " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setRe@@ order@@ Children ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " selection@@ Timing " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setSelection@@ Timing ( temp@@ Val ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " delivery@@ Controls " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < delivery@@ Controls > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " tracked " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . setIs@@ Track@@ ed ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " completion@@ Set@@ By@@ Content " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Set@@ Completion ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " objec@@ tive@@ Set@@ By@@ Content " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Set@@ Objective ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " constra@@ ined@@ Choice@@ Consi@@ der@@ ations " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < constra@@ ined@@ Choice@@ Consi@@ der@@ ations > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " prevent@@ Activation " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Prevent@@ Activation ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " constra@@ in@@ Choice " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Constra@@ in@@ Choice ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " roll@@ up@@ Consi@@ der@@ ations " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < roll@@ up@@ Consi@@ der@@ ations > ▁ " + " element " ) ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " required@@ For@@ Satisfied " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Required@@ For@@ Satisfied ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " required@@ For@@ Not@@ Satisfied " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Required@@ For@@ Not@@ Satisfied ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " required@@ For@@ Completed " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Required@@ For@@ Completed ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " required@@ For@@ In@@ complete " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ Required@@ For@@ In@@ complete ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " measure@@ S@@ atis@@ faction@@ If@@ Active " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { io@@ Act . set@@ S@@ atis@@ faction@@ If@@ Active ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } } } } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + ok ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " extract@@ Seq@@ Info " ) ; } return ok ; }
 @ Converter public static REF_@@ I@@ 15 to@@ Ref@@ I@@ 15 ( String body ) throws HL7@@ Exception { return to@@ Message ( REF_@@ I@@ 15 . class , body ) ; }
 public static boolean is@@ End@@ Variable ( @ NotNull String name ) { return name . startsWith ( END_@@ PREFIX ) ; }
 public static void main ( String [ ] args ) throws Exception { out . println ( VM . current ( ) . details ( ) ) ; PrintWriter pw = new PrintWriter ( out , true ) ; long last = VM . current ( ) . address@@ Of ( new Object ( ) ) ; for ( int l = 0 ; l < 1000 * 1000 * 1000 ; l ++ ) { long current = VM . current ( ) . address@@ Of ( new Object ( ) ) ; long distance = Math . abs ( current - last ) ; if ( distance > 16 * 1024 ) { pw . printf ( " Jump@@ ing ▁ from ▁ % x ▁ to ▁ % x ▁ ( distance ▁ = ▁ % d ▁ bytes , ▁ % d@@ K , ▁ % d@@ M ) % n " , last , current , distance , distance / 1024 , distance / 1024 / 1024 ) ; } last = current ; } pw . close ( ) ; }
 public static void main ( String [ ] args ) { Radius@@ Reader test = new Radius@@ Reader ( ) ; Radius@@ Data data = test . readData ( ) ; System . out . println ( " Ant@@ all ▁ terminal@@ er : ▁ " + data . getNum@@ Segments ( ) ) ; System . out . println ( " Nest@@ e ▁ IP : ▁ " + data . next@@ Available@@ IP ( 0 ) ) ; if ( data . getNum@@ Segments ( ) > 0 ) { } }
 public static int get@@ Fade@@ In@@ Duration ( ) { return settings . getInt ( GLOB@@ AL@@ _SETT@@ ING_@@ FA@@ DE_@@ IN_@@ DURATION , 0 ) ; }
 public static Four@@ Fragment getInstance ( ) { Four@@ Fragment fragment = new Four@@ Fragment ( ) ; Bundle args = new Bundle ( ) ; fragment . set@@ Arguments ( args ) ; return fragment ; }
 public static void main ( String [ ] args ) { System . out . println ( fi@@ bon@@ ac@@ ci ( 10 ) ) ; System . out . println ( fi@@ bon@@ ac@@ ci ( 300 ) ) ; }
 private static void run@@ Or@@ Apply@@ File@@ Template ( Project project , VirtualFile file , String template@@ Name , Properties properties , Properties conditions , boolean interactive ) throws IOException { File@@ Template@@ Manager manager = File@@ Template@@ Manager . getInstance ( ) ; File@@ Template file@@ Template = manager . getJ@@ 2@@ ee@@ Template ( template@@ Name ) ; Properties all@@ Properties = manager . getDefault@@ Properties ( ) ; if ( ! interactive ) { all@@ Properties . putAll ( properties ) ; } all@@ Properties . putAll ( conditions ) ; String text = file@@ Template . getText ( all@@ Properties ) ; Pattern pattern = Pattern . compile ( " \\ $ \\ { ( . * ) \\ } " ) ; Matcher matcher = pattern . matcher ( text ) ; StringBuffer builder = new StringBuffer ( ) ; while ( matcher . find ( ) ) { matcher . append@@ Replacement ( builder , " \\ $ " + matcher . group ( 1 ) . toUpperCase ( ) + " \\ $ " ) ; } matcher . append@@ Tail ( builder ) ; text = builder . toString ( ) ; Template@@ Impl template = ( Template@@ Impl ) Template@@ Manager . getInstance ( project ) . create@@ Template ( " " , " " , text ) ; for ( int i = 0 ; i < template . getSegment@@ sCount ( ) ; i ++ ) { if ( i == template . getEnd@@ Segment@@ Number ( ) ) continue ; String name = template . getSegment@@ Name ( i ) ; String value = " \@@ " " + properties . getProperty ( name , " " ) + " \@@ " " ; template . add@@ Variable ( name , value , value , true ) ; } if ( interactive ) { Open@@ FileDescriptor descriptor = new Open@@ FileDescriptor ( project , file ) ; Editor editor = File@@ Editor@@ Manager . getInstance ( project ) . open@@ TextEditor ( descriptor , true ) ; editor . getDocument ( ) . setText ( " " ) ; Template@@ Manager . getInstance ( project ) . start@@ Template ( editor , template ) ; } else { Vfs@@ Util . save@@ Text ( file , template . getTemplate@@ Text ( ) ) ; } }
 public static Date Add@@ Repository ( Repository@@ Node repo ) { Statement s@@ mt ; String sql ; Date last@@ Commit@@ Date = null ; try { s@@ mt = conn . createStatement ( ) ; last@@ Commit@@ Date = GetLast@@ Commit@@ Date ( repo . getName ( ) ) ; if ( last@@ Commit@@ Date == null ) { sql = " INSERT ▁ INTO ▁ TRE@@ POSI@@ TORY ( Name ) ▁ VALUES ▁ ( ' " + repo . getName ( ) + " ' ) ; " ; s@@ mt . executeUpdate ( sql ) ; s@@ mt . close ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return last@@ Commit@@ Date ; }
 public static boolean get@@ Practi@@ ce@@ Match ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getBoolean ( " practi@@ ce@@ Match@@ Pref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static boolean return@@ Present@@ Between ( @ NotNull Control@@ Flow flow , final int startOffset , final int endOffset ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { private final boolean [ ] is@@ Normal@@ Completion = new boolean [ flow . getSize ( ) + 1 ] ; My@@ Visitor ( ) { int i ; final int length = flow . getSize ( ) ; for ( i = 0 ; i < startOffset ; i ++ ) { is@@ Normal@@ Completion [ i ] = true ; } for ( i = endOffset ; i <= length ; i ++ ) { is@@ Normal@@ Completion [ i ] = true ; } } @ Override public void visit@@ Conditional@@ Throw@@ To@@ Instruction ( Conditional@@ Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; int throw@@ To@@ Offset = instruction . offset ; boolean is@@ Normal ; if ( throw@@ To@@ Offset == next@@ Offset ) { if ( throw@@ To@@ Offset <= endOffset ) { is@@ Normal = ! is@@ Leaf ( next@@ Offset ) && is@@ Normal@@ Completion [ next@@ Offset ] ; } else { return ; } } else { is@@ Normal = is@@ Leaf ( next@@ Offset ) || is@@ Normal@@ Completion [ next@@ Offset ] ; } is@@ Normal@@ Completion [ offset ] |= is@@ Normal ; } @ Override public void visit@@ Throw@@ To@@ Instruction ( Throw@@ To@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( next@@ Offset <= endOffset ) { boolean is@@ Normal = ! is@@ Leaf ( next@@ Offset ) && is@@ Normal@@ Completion [ next@@ Offset ] ; is@@ Normal@@ Completion [ offset ] |= is@@ Normal ; } } @ Override public void visit@@ Call@@ Instruction ( Call@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( next@@ Offset > endOffset && next@@ Offset != offset + 1 ) { return ; } boolean is@@ Normal = is@@ Normal@@ Completion [ next@@ Offset ] ; is@@ Normal@@ Completion [ offset ] |= is@@ Normal ; } @ Override public void visit@@ GoTo@@ Instruction ( GoTo@@ Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; boolean isRe@@ throw@@ From@@ Finally = instruction instanceof Return@@ Instruction && ( ( Return@@ Instruction ) instruction ) . isRe@@ throw@@ From@@ Finally ( ) ; boolean is@@ Normal = ! instruction . is@@ Return && is@@ Normal@@ Completion [ next@@ Offset ] && ! isRe@@ throw@@ From@@ Finally ; is@@ Normal@@ Completion [ offset ] |= is@@ Normal ; } @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( next@@ Offset > flow . getSize ( ) ) next@@ Offset = flow . getSize ( ) ; if ( offset > endOffset ) return ; final boolean is@@ Normal = is@@ Leaf ( next@@ Offset ) || is@@ Normal@@ Completion [ next@@ Offset ] ; is@@ Normal@@ Completion [ offset ] |= is@@ Normal ; } @ Override @ NotNull public Boolean getResult ( ) { return ! is@@ Normal@@ Completion [ startOffset ] ; } } final My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , startOffset , endOffset ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
 public static long rotate@@ Right ( long v , int distance ) { return ( v >@@ >> distance ) | ( v << - distance ) ; }
 @ NotNull private static Shared@@ Access@@ Blob@@ Policy policy ( EnumSet < Shared@@ Access@@ Blob@@ Permissions > permissions ) { return policy ( permissions , Instant . now ( ) . plus ( Duration . of@@ Days ( 7 ) ) ) ; }
 @ Converter public static AD@@ T_@@ A@@ 07 to@@ Ad@@ t@@ A@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 07 . class , body ) ; }
 public static void main ( String [ ] args ) { Scanner sc@@ n = new Scanner ( System . in ) ; int sum = 0 ; for ( int i = 13 ; i <= 13@@ 99 ; i = i + 1 ) { sum = sum + i ; } System . out . print ( " Sum = " + sum ) ; }
 @ Converter public static SI@@ U@@ _S@@ 19 to@@ Si@@ u@@ S@@ 19 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 19 . class , body ) ; }
 public static boolean array@@ equals ( final byte [ ] a , final byte [ ] b , final int count ) { for ( int i = 0 ; i < count ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; }
 public static Http@@ Scope refer ( String template ) { Http@@ Scope rs = new Http@@ Scope ( ) ; rs . set@@ Refer@@ id ( template ) ; return rs ; }
 public static void pause ( @ Nonnull Condition [ ] conditions , @ Nonnull Timeout timeout ) { pause ( conditions , timeout . duration ( ) ) ; }
 static public void add@@ Class@@ Public@@ Method@@ Completion ( Completion@@ ResultSet completion@@ ResultSet , Ph@@ p@@ Class php@@ Class ) { for ( Method method : getClass@@ Public@@ Method ( php@@ Class ) ) { completion@@ ResultSet . addElement ( new Ph@@ p@@ Lookup@@ Element ( method ) ) ; } }
 public static Pri@@ cing@@ Response fromJson ( String json ) { try { return new ObjectMapper ( ) . readValue ( json , Pri@@ cing@@ Response . class ) ; } catch ( IOException j@@ pe ) { throw new V@@ on@@ age@@ Unexpec@@ tedException ( " Failed ▁ to ▁ produce ▁ Pri@@ cing@@ Response ▁ from ▁ json . " , j@@ pe ) ; } }
 @ Converter public static SQ@@ M_S@@ 25 to@@ Sq@@ m@@ S@@ 25 ( String body ) throws HL7@@ Exception { return to@@ Message ( SQ@@ M_S@@ 25 . class , body ) ; }
 @ Converter public static QR@@ Y_@@ A@@ 19 to@@ Qry@@ A@@ 19 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ A@@ 19 . class , body ) ; }
 protected static < T > void load ( Global@@ Property < T > p ) { try { String k = p . getName ( ) ; String s = Global@@ Settings . getString ( k ) ; if ( s != null ) { T v = p . get@@ Converter ( ) . fromString ( s ) ; p . setValue ( v ) ; } } catch ( Exception e ) { Log . ex ( e ) ; } }
 public static boolean is@@ Windows ( ) { return System . getProperty ( " os . name " ) . toLowerCase ( ) . indexOf ( " windows " ) > - 1 ; }
 @ Nullable public static Array@@ Creation@@ Expression get@@ Complet@@ able@@ Array@@ Creation@@ Element ( PsiElement psiElement ) { if ( Ph@@ p@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . ARRAY_@@ KEY ) . accepts ( psiElement . getContext ( ) ) ) { PsiElement array@@ Key = psiElement . getContext ( ) ; if ( array@@ Key != null ) { PsiElement array@@ Hash@@ Element = array@@ Key . getContext ( ) ; if ( array@@ Hash@@ Element instanceof Array@@ Hash@@ Element ) { PsiElement array@@ Creation@@ Expression = array@@ Hash@@ Element . getContext ( ) ; if ( array@@ Creation@@ Expression instanceof Array@@ Creation@@ Expression ) { return ( Array@@ Creation@@ Expression ) array@@ Creation@@ Expression ; } } } } if ( Ph@@ p@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . ARRAY_@@ VALUE ) . accepts ( psiElement . getContext ( ) ) ) { PsiElement array@@ Key = psiElement . getContext ( ) ; if ( array@@ Key != null ) { PsiElement array@@ Creation@@ Expression = array@@ Key . getContext ( ) ; if ( array@@ Creation@@ Expression instanceof Array@@ Creation@@ Expression ) { return ( Array@@ Creation@@ Expression ) array@@ Creation@@ Expression ; } } } return null ; }
 private static String getComponent@@ FileName ( ) { final String sequence = String . valueOf ( COMPONENT_@@ SEQUENCE ++ ) ; return sequence + ' _ ' + sequence ; }
 @ Nullable public static File resolve@@ Maven@@ Lib ( @ NotNull File dir ) { File [ ] files = dir . listFiles ( ) ; if ( files != null ) { Pattern pattern = Pattern . compile ( " maven - \\ d + \\ . \\ d + \\ . \\ d + - u@@ ber \\ . jar " ) ; for ( File each : files ) { if ( pattern . matcher ( each . getName ( ) ) . matches ( ) ) { return each ; } } } return null ; }
 public static void invalidate@@ Subscription@@ List ( ) { s@@ Subscription@@ List = null ; }
 public static boolean is@@ Variable@@ Read@@ In@@ Finally ( @ NotNull Control@@ Flow flow , @ Nullable PsiElement startElement , @ NotNull PsiElement enclosing@@ Code@@ Fragment , @ NotNull Psi@@ Variable variable ) { for ( PsiElement element = startElement ; element != null && element != enclosing@@ Code@@ Fragment ; element = element . getParent ( ) ) { if ( element instanceof Psi@@ CodeBlock ) { final PsiElement parent = element . getParent ( ) ; if ( parent instanceof Psi@@ Try@@ Statement ) { final Psi@@ Try@@ Statement try@@ Statement = ( Psi@@ Try@@ Statement ) parent ; if ( try@@ Statement . get@@ Try@@ Block ( ) == element ) { final Psi@@ CodeBlock fin@@ ally@@ Block = try@@ Statement . get@@ Fin@@ ally@@ Block ( ) ; if ( fin@@ ally@@ Block != null ) { final List < Instruction > instructions = flow . get@@ Instructions ( ) ; final int startOffset = flow . getStartOffset ( fin@@ ally@@ Block ) ; final int endOffset = flow . getEndOffset ( fin@@ ally@@ Block ) ; LOG . assertTrue ( startOffset >= 0 , " flow ▁ start " ) ; LOG . assertTrue ( endOffset <= instructions . size ( ) , " flow ▁ end " ) ; for ( int i = startOffset ; i < endOffset ; i ++ ) { final Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Read@@ Variable@@ Instruction && ( ( Read@@ Variable@@ Instruction ) instruction ) . variable == variable ) { return true ; } } } } } } } return false ; }
 private static boolean isEmpty ( String iValue ) { return ( StringUtils . isBlank ( iValue ) ) ; }
 public static < T > void add ( Global@@ Property < T > p ) { properties . add ( p ) ; p . addListener ( ( src , old , cur ) -> store ( p ) ) ; load ( p ) ; }
 @ Converter public static PP@@ V_@@ PCA to@@ P@@ pv@@ P@@ ca ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ V_@@ PCA . class , body ) ; }
 @ Converter public static SR@@ M_S@@ 06 to@@ S@@ rm@@ S@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 06 . class , body ) ; }
 public static final void throw@@ ValidationError ( String code , String fieldName ) { throw new Client@@ Visible@@ Exception ( new Validation@@ Error@@ Impl ( code , fieldName ) ) ; }
 private static Instant ye@@ ster@@ day ( ) { return Instant . now ( ) . minus ( Duration . of@@ Days ( 1 ) ) ; }
 static void assert@@ BitSet ( Fixed@@ BitSet actual , Fixed@@ BitSet expected , Index@@ Searcher searcher ) throws IOException { if ( ! actual . equals ( expected ) ) { Description description = new String@@ Description ( ) ; description . append@@ Text ( reason ( actual , expected , searcher ) ) ; description . append@@ Text ( " \n Expected : ▁ " ) ; description . appendValue ( expected ) ; description . append@@ Text ( " \n ▁ ▁ ▁ ▁ ▁ got : ▁ " ) ; description . appendValue ( actual ) ; description . append@@ Text ( " \n " ) ; throw new java . lang . AssertionError ( description . toString ( ) ) ; } }
 @ Converter public static MD@@ M_@@ T@@ 11 to@@ M@@ dm@@ T@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 11 . class , body ) ; }
 public static void invoke@@ AndWait ( final Project p , final Modality@@ State state , final Runnable r ) { if ( is@@ No@@ Background@@ Mode ( ) ) { r . run ( ) ; } else { if ( ApplicationManager . getApplication ( ) . is@@ Dispatch@@ Thread ( ) ) { r . run ( ) ; } else { ApplicationManager . getApplication ( ) . invoke@@ AndWait ( new Runnable ( ) { public void run ( ) { if ( p . isDisposed ( ) ) return ; r . run ( ) ; } } , state ) ; } } }
 private static ImmutableSet < String > concat ( ImmutableSet < String > blobs , String element ) { return ImmutableSet . < String > builder ( ) . addAll ( blobs ) . add ( element ) . build ( ) ; }
 private static final TypeReference < List < Test@@ Result@@ Summary > > SUMMAR@@ I@@ ES_@@ REFERENCE = new TypeReference < List < Test@@ Result@@ Summary > > ( ) { }
 public static void set@@ Process@@ Runtime@@ Factory@@ Service ( Process@@ Runtime@@ Factory@@ Service provider ) { Process@@ Runtime@@ Factory . provider = provider ; }
 static public void info_@@ no_@@ stdout ( Object ... objects ) { info_@@ no_@@ stdout ( Sys . WATER , objects ) ; }
 private static int find@@ Single@@ Read@@ Offset ( @ NotNull Control@@ Flow flow , int startOffset , int endOffset , @ NotNull Psi@@ Variable variable ) { List < Instruction > instructions = flow . get@@ Instructions ( ) ; if ( startOffset < 0 || endOffset < 0 || endOffset > instructions . size ( ) ) return - 1 ; int read@@ Offset = - 1 ; for ( int i = startOffset ; i < endOffset ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Read@@ Variable@@ Instruction ) { if ( ( ( Read@@ Variable@@ Instruction ) instruction ) . variable == variable ) { if ( read@@ Offset < 0 ) { read@@ Offset = i ; } else { return - 1 ; } } } else if ( instruction instanceof Write@@ Variable@@ Instruction ) { if ( ( ( Write@@ Variable@@ Instruction ) instruction ) . variable == variable ) { return - 1 ; } } } return read@@ Offset ; }
 @ Converter public static SR@@ R@@ _S@@ 10 to@@ S@@ rr@@ S@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 10 . class , body ) ; }
 public static float [ ] get@@ Kernel ( SIG@@ MA sigma , float mu ) { return get@@ Kernel ( SIG@@ MA . getValue ( sigma ) , mu ) ; }
 public static Integer get@@ Metric@@ QueueSize ( ) { return metric@@ QueueSize ; }
 public static List < Item > fetch ( String itemName ) { Logger . add ( TAG , " : ▁ fetch : ▁ itemName = " , itemName ) ; List < Item > items@@ Search = new ArrayList < > ( ) ; HTTP@@ Result http@@ Result = Network@@ Stack . getInstance ( ) . perform@@ GetRequest ( String . format ( API_@@ URL , Uri . encode ( itemName ) ) ) ; if ( http@@ Result . statusCode == StatusCode . FOUND ) { try { JSONObject json = new JSONObject ( http@@ Result . output ) . getJSONObject ( KEY_@@ MATCH@@ ES ) ; Iterator < String > keys = json . keys ( ) ; while ( keys . hasNext ( ) ) { String itemId = keys . next ( ) ; JSONObject item@@ Json = json . getJSONObject ( itemId ) ; Item item = new Item ( ) ; item . id = itemId ; item . description = item@@ Json . getString ( KEY_@@ DESCRIPTION ) ; item . name = item@@ Json . getString ( KEY_@@ NAME ) ; item . members = TextUtils . equals ( item@@ Json . getString ( KEY_@@ MEMB@@ ERS ) , VALUE_@@ TRUE ) ; item . icon@@ Large = ICON_@@ ENDPOINT + itemId ; items@@ Search . add ( item ) ; } } catch ( JSONException e ) { Logger . add@@ Exception ( TAG , e ) ; } } return items@@ Search ; }
 public static String get@@ Security@@ Code ( ) { return get@@ Security@@ Code ( 4 , Security@@ Code@@ Level . Medium , false ) ; }
 public static void enable@@ Http@@ Socket@@ Read@@ Metric ( ) { Aws@@ Sdk@@ Metrics . http@@ Socket@@ Read@@ Metric@@ Enabled = true ; }
 @ Nullable public static String getRepository@@ From@@ Settings ( final File file ) { try { byte [ ] bytes = FileUtil . load@@ File@@ Bytes ( file ) ; return expand@@ Properties ( Maven@@ J@@ DOM@@ Util . find@@ Child@@ Value@@ ByPath ( Maven@@ J@@ DOM@@ Util . read ( bytes , null ) , " local@@ Repository " , null ) ) ; } catch ( IOException e ) { return null ; } }
 @ Nullable static public Ph@@ p@@ Class getClass ( Project project , String className ) { return getClass ( Ph@@ p@@ Index . getInstance ( project ) , className ) ; }
 public static Serializer@@ Registration register@@ Class@@ For@@ Id ( short id , Class cls , Serializer serializer ) { if ( locked ) { throw new RuntimeException ( " Serializer ▁ registry ▁ locked ▁ trying ▁ to ▁ register ▁ class : " + cls ) ; } Serializer@@ Registration reg = new Serializer@@ Registration ( serializer , cls , id ) ; id@@ Registr@@ ations . put ( id , reg ) ; class@@ Registr@@ ations . put ( cls , reg ) ; log . log ( Level . FINE , " Registered ▁ class [ " + id + " ] : { 0 } ▁ to : " + serializer , cls ) ; serializer . initialize ( cls ) ; registrations . add ( reg ) ; return reg ; }
 public static Subscription [ ] get@@ Filtered@@ Subscription@@ List ( Subscription [ ] full@@ List , int starting@@ Index , int max@@ Subscription@@ Count ) { Subscription [ ] subscription@@ Details@@ Array ; int result@@ SetSize = max@@ Subscription@@ Count ; ArrayList < Subscription > resultList = new ArrayList < Subscription > ( ) ; Collections . addAll ( resultList , full@@ List ) ; if ( ( resultList . size ( ) - starting@@ Index ) < max@@ Subscription@@ Count ) { result@@ SetSize = ( resultList . size ( ) - starting@@ Index ) ; } subscription@@ Details@@ Array = new Subscription [ result@@ SetSize ] ; int index = 0 ; int subscription@@ Details@@ Index = 0 ; for ( Subscription subscription@@ Detail : resultList ) { if ( starting@@ Index == index || starting@@ Index < index ) { Subscription subscription = new Subscription ( ) ; subscription . set@@ Subscription@@ Identifier ( subscription@@ Detail . getSub@@ scription@@ Identifier ( ) ) ; subscription . set@@ Subscri@@ bed@@ Queue@@ Or@@ Topic@@ Name ( subscription@@ Detail . get@@ Subscri@@ bed@@ Queue@@ Or@@ Topic@@ Name ( ) ) ; subscription . set@@ Subscriber@@ Queue@@ Bound@@ Exchange ( subscription@@ Detail . get@@ Subscriber@@ Queue@@ Bound@@ Exchange ( ) ) ; subscription . set@@ Subscriber@@ Queue@@ Name ( subscription@@ Detail . get@@ Subscriber@@ Queue@@ Name ( ) ) ; subscription . set@@ Subscription@@ Identifier ( subscription@@ Detail . getSub@@ scription@@ Identifier ( ) ) ; subscription . set@@ Dur@@ able ( subscription@@ Detail . get@@ Dur@@ able ( ) ) ; subscription . setActive ( subscription@@ Detail . get@@ Active ( ) ) ; subscription . set@@ NumberOf@@ Messages@@ Remaining@@ For@@ Subscriber ( subscription@@ Detail . getNumberOf@@ Messages@@ Remaining@@ For@@ Subscriber ( ) ) ; subscription . set@@ Connected@@ Node@@ Address ( subscription@@ Detail . get@@ Connected@@ Node@@ Address ( ) ) ; subscription . set@@ Destination ( subscription@@ Detail . get@@ Destination ( ) ) ; subscription . set@@ Protocol@@ Type ( subscription@@ Detail . getProtocol@@ Type ( ) ) ; subscription . set@@ Destination@@ Type ( subscription@@ Detail . get@@ Destination@@ Type ( ) ) ; subscription . set@@ Origin@@ HostAddress ( subscription@@ Detail . get@@ Origin@@ HostAddress ( ) ) ; subscription@@ Details@@ Array [ subscription@@ Details@@ Index ] = subscription ; subscription@@ Details@@ Index ++ ; if ( subscription@@ Details@@ Index == max@@ Subscription@@ Count ) { break ; } } index ++ ; } return subscription@@ Details@@ Array ; }
 private static boolean check@@ Reference@@ Expression@@ Scope ( @ NotNull PsiReferenceExpression ref , @ NotNull PsiElement target@@ Class@@ Member ) { final Java@@ ResolveResult resolve@@ Result = ref . advanced@@ Resolve ( false ) ; final PsiElement def = resolve@@ Result . getElement ( ) ; if ( def != null ) { PsiElement parent = def . getParent ( ) ; PsiElement common@@ Parent = parent == null ? null : PsiTreeUtil . find@@ Common@@ Parent ( parent , target@@ Class@@ Member ) ; if ( common@@ Parent == null ) { parent = resolve@@ Result . getCurrent@@ File@@ Resolve@@ Scope ( ) ; } if ( parent instanceof PsiClass ) { final PsiClass cl@@ ss = ( PsiClass ) parent ; if ( PsiTreeUtil . is@@ Ancestor ( target@@ Class@@ Member , cl@@ ss , false ) ) return false ; PsiClass containingClass = PsiTreeUtil . getParent@@ OfType ( ref , PsiClass . class ) ; while ( containingClass != null ) { if ( containingClass . isIn@@ her@@ itor ( cl@@ ss , true ) && PsiTreeUtil . is@@ Ancestor ( target@@ Class@@ Member , containingClass , false ) ) { return false ; } containingClass = containingClass . getContain@@ ingClass ( ) ; } } } return true ; }
 public static Long getLong ( String string , long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return valueOf ( defaultValue ) ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return valueOf ( defaultValue ) ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return valueOf ( defaultValue ) ; } }
 @ Converter public static SR@@ R@@ _S@@ 11 to@@ S@@ rr@@ S@@ 11 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 11 . class , body ) ; }
 @ Converter public static PP@@ R_@@ PC@@ 2 to@@ P@@ pr@@ P@@ c2 ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ R_@@ PC@@ 2 . class , body ) ; }
 public static String join ( String connector , String [ ] arr ) { StringBuffer s@@ Buffer = new StringBuffer ( ) ; for ( Object object : arr ) { s@@ Buffer . append ( object ) . append ( connector ) ; } if ( s@@ Buffer . length ( ) > 0 ) { s@@ Buffer . delete ( s@@ Buffer . length ( ) - connector . length ( ) , s@@ Buffer . length ( ) ) ; } return s@@ Buffer . toString ( ) ; }
 @ Converter public static AD@@ T_@@ A@@ 51 to@@ Ad@@ t@@ A@@ 51 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 51 . class , body ) ; }
 public static boolean is@@ No@@ Background@@ Mode ( ) { return ( ApplicationManager . getApplication ( ) . is@@ UnitTest@@ Mode ( ) || ApplicationManager . getApplication ( ) . is@@ Head@@ less@@ Environment ( ) ) ; }
 public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . common . protobuf . Register@@ Bulk@@ Key@@ Noti@@ f@@ Response@@ Protocol . internal_static_@@ com_@@ al@@ ach@@ is@@ of@@ t_@@ ta@@ yz@@ grid_@@ common_@@ proto@@ buf_@@ Register@@ Bulk@@ Key@@ Noti@@ f@@ Respon@@ se_@@ descriptor ; }
 public static List < List < Object > > getSub@@ scription@@ s@@ For ( final Context context , final String new@@ Category ) { if ( s@@ Subscription@@ List == null ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final boolean query@@ Empty = TextUtils . isEmpty ( new@@ Category ) ; s@@ Subscription@@ List = new ArrayList < > ( subscriptions . size ( ) ) ; int i = 0 ; for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { final String category = subscriptions . get ( title ) . get ( 0 ) ; if ( query@@ Empty || new@@ Category . equals ( category ) ) { if ( query@@ Empty ) { s@@ Subscription@@ List . add ( Arrays . < Object > asList ( title , category ) ) ; } else { s@@ Subscription@@ List . add ( Arrays . < Object > asList ( title , category , i ) ) ; } } i ++ ; } } return s@@ Subscription@@ List ; }
 public static String [ ] split ( String val , String de@@ collator ) { if ( ! isEmpty ( val ) ) { return val . split ( de@@ collator ) ; } return null ; }
 @ NotNull public static List < Psi@@ Variable > get@@ SS@@ A@@ Variables ( @ NotNull Control@@ Flow flow ) { return get@@ SS@@ A@@ Variables ( flow , 0 , flow . getSize ( ) , false ) ; }
 public static boolean is@@ External@@ Storage@@ Writable ( ) { return Environment . MEDIA_@@ MOUN@@ TED . equals ( Environment . getExternal@@ Storage@@ State ( ) ) ; }
 public static void setReadOnly ( boolean b ) { locked = b ; }
 @ Converter public static R@@ Q@@ C_@@ I@@ 05 to@@ R@@ q@@ c@@ I@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ C_@@ I@@ 05 . class , body ) ; }
 public static boolean is@@ Single@@ Metric@@ Namespace ( ) { return single@@ Metric@@ Namespace ; }
 public static String get ( String key , String defValue ) { if ( TextUtils . isEmpty ( key ) ) { return defValue ; } String value = get@@ With@@ Ref@@ lect ( key , null ) ; if ( TextUtils . isEmpty ( value ) ) { value = get@@ With@@ Cmd ( key , null ) ; } if ( TextUtils . isEmpty ( value ) ) { value = defValue ; } return value ; }
 static Char@@ Matcher pre@@ compute@@ Char@@ Matcher ( Char@@ Matcher matcher ) { return matcher . pre@@ computed@@ Internal ( ) ; }
 public static List < String > getSub@@ scription@@ Title@@ s@@ For ( final Context context , final List < Integer > positions ) { final List < String > titles = new ArrayList < > ( getSub@@ scriptions ( context ) . asMap ( ) . keySet ( ) ) ; final List < String > result = new ArrayList < > ( positions . size ( ) ) ; for ( final int position : positions ) { result . add ( titles . get ( position ) ) ; } return result ; }
 private static boolean type@@ Var@@ Accep@@ ts@@ Both@@ Class@@ And@@ Instance@@ Types ( @ NotNull Py@@ Generic@@ Type type@@ Var ) { return ! type@@ Var . is@@ Definition ( ) && type@@ Var . get@@ Bound ( ) == null ; }
 @ Nullable public static Py@@ Type substitute ( @ Nullable Py@@ Type type , @ NotNull Map < Py@@ Generic@@ Type , Py@@ Type > substitutions , @ NotNull Type@@ Eval@@ Context context ) { if ( has@@ Generics ( type , context ) ) { if ( type instanceof Py@@ Generic@@ Type ) { final Py@@ Generic@@ Type type@@ Var = ( Py@@ Generic@@ Type ) type ; Py@@ Type substitution = substitutions . get ( type@@ Var ) ; if ( substitution == null ) { if ( ! type@@ Var . is@@ Definition ( ) ) { final Py@@ Instanti@@ able@@ Type < ? > classType = as ( substitutions . get ( type@@ Var . to@@ Class ( ) ) , Py@@ Instanti@@ able@@ Type . class ) ; if ( classType != null ) { substitution = classType . to@@ Instance ( ) ; } } else { final Py@@ Instanti@@ able@@ Type < ? > instance@@ Type = as ( substitutions . get ( type@@ Var . to@@ Instance ( ) ) , Py@@ Instanti@@ able@@ Type . class ) ; if ( instance@@ Type != null ) { substitution = instance@@ Type . to@@ Class ( ) ; } } } if ( substitution instanceof Py@@ Generic@@ Type && ! type@@ Var . equals ( substitution ) && substitutions . containsKey ( substitution ) ) { return substitute ( substitution , substitutions , context ) ; } return substitution ; } else if ( type instanceof Py@@ Union@@ Type ) { final Py@@ Union@@ Type union = ( Py@@ Union@@ Type ) type ; final List < Py@@ Type > results = new ArrayList < > ( ) ; for ( Py@@ Type t : union . get@@ Members ( ) ) { final Py@@ Type subst = substitute ( t , substitutions , context ) ; results . add ( subst ) ; } return Py@@ Union@@ Type . union ( results ) ; } else if ( type instanceof Py@@ Collection@@ TypeImpl ) { final Py@@ Collection@@ TypeImpl collection = ( Py@@ Collection@@ TypeImpl ) type ; final List < Py@@ Type > element@@ Types = collection . getElement@@ Types ( ) ; final List < Py@@ Type > substitu@@ tes = new ArrayList < > ( ) ; for ( Py@@ Type elementType : element@@ Types ) { substitu@@ tes . add ( substitute ( elementType , substitutions , context ) ) ; } return new Py@@ Collection@@ TypeImpl ( collection . get@@ Py@@ Class ( ) , collection . is@@ Definition ( ) , substitu@@ tes ) ; } else if ( type instanceof Py@@ TupleType ) { final Py@@ TupleType tuple@@ Type = ( Py@@ TupleType ) type ; final Py@@ Class tuple@@ Class = tuple@@ Type . get@@ Py@@ Class ( ) ; final List < Py@@ Type > old@@ ElementTypes = tuple@@ Type . is@@ Ho@@ mo@@ gene@@ ous ( ) ? Collections . singletonList ( tuple@@ Type . get@@ Iter@@ ated@@ ItemType ( ) ) : tuple@@ Type . getElement@@ Types ( ) ; final List < Py@@ Type > new@@ ElementTypes = ContainerUtil . map ( old@@ ElementTypes , elementType -> substitute ( elementType , substitutions , context ) ) ; return new Py@@ TupleType ( tuple@@ Class , new@@ ElementTypes , tuple@@ Type . is@@ Ho@@ mo@@ gene@@ ous ( ) ) ; } else if ( type instanceof Py@@ Callable@@ Type ) { final Py@@ Callable@@ Type callable = ( Py@@ Callable@@ Type ) type ; List < Py@@ Callable@@ Parameter > subst@@ Params = null ; final List < Py@@ Callable@@ Parameter > parameters = callable . getParameters ( context ) ; if ( parameters != null ) { subst@@ Params = new ArrayList < > ( ) ; for ( Py@@ Callable@@ Parameter parameter : parameters ) { final Py@@ Type subst@@ Type = substitute ( parameter . getType ( context ) , substitutions , context ) ; final Py@@ Parameter psi = parameter . getParameter ( ) ; final Py@@ Callable@@ Parameter subst = psi != null ? Py@@ Callable@@ Parameter@@ Impl . psi ( psi , subst@@ Type ) : Py@@ Callable@@ Parameter@@ Impl . non@@ P@@ si ( parameter . getName ( ) , subst@@ Type , parameter . getDefault@@ Value ( ) ) ; subst@@ Params . add ( subst ) ; } } final Py@@ Type subst@@ Result = substitute ( callable . getReturnType ( context ) , substitutions , context ) ; return new Py@@ Callable@@ TypeImpl ( subst@@ Params , subst@@ Result ) ; } } return type ; }
 @ NotNull public static Map < PsiElement , Psi@@ Variable > getWrite@@ sBefore@@ Reads ( @ NotNull Control@@ Flow flow , @ NotNull Set < Psi@@ Variable > write@@ Vars , @ NotNull Set < Psi@@ Variable > read@@ Vars , final int stop@@ Point ) { Map < PsiElement , Psi@@ Variable > writes = new HashMap < > ( ) ; List < Instruction > instructions = flow . get@@ Instructions ( ) ; for ( int i = 0 ; i < instructions . size ( ) ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( ! ( instruction instanceof Write@@ Variable@@ Instruction ) ) continue ; Psi@@ Variable written@@ Var = ( ( Write@@ Variable@@ Instruction ) instruction ) . variable ; if ( ! write@@ Vars . contains ( written@@ Var ) ) continue ; if ( read@@ Before@@ Stop@@ Point ( flow , read@@ Vars , i , stop@@ Point ) ) writes . put ( flow . getElement ( i ) , written@@ Var ) ; } return writes ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Three ( ) { double a = 1. / 65@@ 00000000@@ 0l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 34@@ l * a ) , ( float ) ( 55@@ 9@@ l * a ) , ( float ) ( 59@@ 16@@ l * a ) , ( float ) ( 45@@ 255@@ l * a ) , ( float ) ( 266@@ 32@@ 2l * a ) , ( float ) ( 125@@ 27@@ 13@@ l * a ) , ( float ) ( 48@@ 29@@ 088@@ l * a ) , ( float ) ( 15@@ 512@@ 77@@ 2l * a ) , ( float ) ( 4@@ 197@@ 02@@ 80@@ l * a ) , ( float ) ( 96@@ 16@@ 06@@ 36@@ l * a ) , ( float ) ( 18@@ 65@@ 748@@ 64@@ l * a ) , ( float ) ( 304@@ 25@@ 39@@ 64@@ l * a ) , ( float ) ( 408@@ 239@@ 49@@ 6@@ l * a ) , ( float ) ( 426@@ 39@@ 57@@ 00@@ l * a ) , ( float ) ( 286@@ 09@@ 77@@ 60@@ l * a ) , ( float ) ( - 316@@ 35@@ 8@@ 10@@ l * a ) , ( float ) ( - 45@@ 0@@ 345@@ 06@@ 0l * a ) , ( float ) ( - 811@@ 98@@ 57@@ 90@@ l * a ) , ( float ) ( - 9@@ 55@@ 27@@ 74@@ 00@@ l * a ) , ( float ) ( - 811@@ 98@@ 57@@ 90@@ l * a ) , ( float ) ( - 45@@ 0@@ 345@@ 06@@ 0l * a ) , ( float ) ( - 316@@ 35@@ 8@@ 10@@ l * a ) , ( float ) ( 286@@ 09@@ 77@@ 60@@ l * a ) , ( float ) ( 426@@ 39@@ 57@@ 00@@ l * a ) , ( float ) ( 408@@ 239@@ 49@@ 6@@ l * a ) , ( float ) ( 304@@ 25@@ 39@@ 64@@ l * a ) , ( float ) ( 18@@ 65@@ 748@@ 64@@ l * a ) , ( float ) ( 96@@ 16@@ 06@@ 36@@ l * a ) , ( float ) ( 4@@ 197@@ 02@@ 80@@ l * a ) , ( float ) ( 15@@ 512@@ 77@@ 2l * a ) , ( float ) ( 48@@ 29@@ 088@@ l * a ) , ( float ) ( 125@@ 27@@ 13@@ l * a ) , ( float ) ( 266@@ 32@@ 2l * a ) , ( float ) ( 45@@ 255@@ l * a ) , ( float ) ( 59@@ 16@@ l * a ) , ( float ) ( 55@@ 9@@ l * a ) , ( float ) ( 34@@ l * a ) , ( float ) ( 1l * a ) } ; }
 public static Filter@@ Template new@@ Search@@ Filter ( final String filter@@ Query , final String ... params ) { final var filter = new Filter@@ Template ( ) ; filter . setFilter ( filter@@ Query ) ; if ( params != null ) { for ( var i = 0 ; i < params . length ; i ++ ) { if ( filter . get@@ Filter ( ) . contains ( " { " + i + " } " ) ) { filter . setParameter ( i , params [ i ] ) ; } else { filter . setParameter ( " user " , params [ i ] ) ; } } } LOGGER . debug ( " Construc@@ ted ▁ LDAP ▁ search ▁ filter ▁ [ { } ] " , filter . format ( ) ) ; return filter ; }
 @ NotNull public static File resolve@@ Local@@ Repository ( @ Nullable String overri@@ den@@ Local@@ Repository , @ Nullable String overri@@ den@@ Maven@@ Home , @ Nullable String overri@@ dden@@ User@@ Settings@@ File ) { File result = null ; if ( ! isEmpty@@ Or@@ Spaces ( overri@@ den@@ Local@@ Repository ) ) result = new File ( overri@@ den@@ Local@@ Repository ) ; if ( result == null ) { result = do@@ Resolve@@ Local@@ Repository ( resolve@@ User@@ Settings@@ File ( overri@@ dden@@ User@@ Settings@@ File ) , resolve@@ Global@@ Settings@@ File ( overri@@ den@@ Maven@@ Home ) ) ; } try { return result . getCanonical@@ File ( ) ; } catch ( IOException e ) { return result ; } }
 @ Converter public static PR@@ R_@@ PC@@ 5 to@@ Pr@@ r@@ P@@ c5 ( String body ) throws HL7@@ Exception { return to@@ Message ( PR@@ R_@@ PC@@ 5 . class , body ) ; }
 @ Nullable static public String getArray@@ Value@@ String ( Array@@ Creation@@ Expression array@@ Creation@@ Expression , String name ) { Ph@@ p@@ PsiElement php@@ PsiElement = getArray@@ Value ( array@@ Creation@@ Expression , name ) ; if ( php@@ PsiElement == null ) { return null ; } if ( php@@ PsiElement instanceof StringLiteral@@ Expression ) { return ( ( StringLiteral@@ Expression ) php@@ PsiElement ) . getContents ( ) ; } return null ; }
 @ Converter public static RD@@ R_@@ RD@@ R to@@ R@@ dr@@ R@@ dr ( String body ) throws HL7@@ Exception { return to@@ Message ( RD@@ R_@@ RD@@ R . class , body ) ; }
 public static byte [ ] swap_@@ bytes ( byte [ ] bits ) { return swap_@@ bytes ( bits , 8 ) ; }
 static public PsiElement [ ] get@@ PsiElement@@ sBy@@ Signature ( Project project , @ Nullable String signature ) { if ( signature == null ) { return new PsiElement [ 0 ] ; } Collection < ? extends Ph@@ p@@ Named@@ Element > php@@ Named@@ Element@@ Collections = Ph@@ p@@ Index . getInstance ( project ) . getBy@@ Signature ( signature , null , 0 ) ; return php@@ Named@@ Element@@ Collections . toArray ( new PsiElement [ php@@ Named@@ Element@@ Collections . size ( ) ] ) ; }
 public static void run@@ Dumb@@ Aware ( final Project project , final Runnable r ) { if ( Dumb@@ Service . is@@ Dumb@@ Aware ( r ) ) { r . run ( ) ; } else { Dumb@@ Service . getInstance ( project ) . run@@ When@@ Smart ( new Runnable ( ) { public void run ( ) { if ( project . isDisposed ( ) ) return ; r . run ( ) ; } } ) ; } }
 private static Psi@@ Statement find@@ Statement ( @ NotNull Control@@ Flow flow , int offset ) { PsiElement element = flow . getElement ( offset ) ; return PsiTreeUtil . getParent@@ OfType ( element , Psi@@ Statement . class , false ) ; }
 @ Converter public static VX@@ U_@@ V@@ 04 to@@ V@@ x@@ u@@ V@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( VX@@ U_@@ V@@ 04 . class , body ) ; }
 private static void setLog@@ 4j@@ Properties ( String log@@ Dir@@ Parent , java . util . Properties p ) { LOG_@@ DIR = log@@ Dir@@ Parent + File . separator + " h2@@ o@@ logs " ; String log@@ Path@@ FileName = getLog@@ Path@@ FileName@@ Ste@@ m ( ) ; p . setProperty ( " log4j . root@@ Logger " , " TRACE , ▁ R1 , ▁ R2 , ▁ R3 , ▁ R4 , ▁ R@@ 5 , ▁ R@@ 6" ) ; p . setProperty ( " log4j . appender . R@@ 1" , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . R1 . Threshold " , " TRACE " ) ; p . setProperty ( " log4j . appender . R1 . File " , log@@ Path@@ FileName + " - 1 - trace . log " ) ; p . setProperty ( " log4j . appender . R1 . Max@@ FileSize " , "1@@ MB " ) ; p . setProperty ( " log4j . appender . R1 . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . R1 . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . R1 . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R@@ 2" , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . R2 . Threshold " , " DEBUG " ) ; p . setProperty ( " log4j . appender . R2 . File " , log@@ Path@@ FileName + " - 2 - debug . log " ) ; p . setProperty ( " log4j . appender . R2 . Max@@ FileSize " , "3@@ MB " ) ; p . setProperty ( " log4j . appender . R2 . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . R2 . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . R2 . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R@@ 3" , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . R3 . Threshold " , " INFO " ) ; p . setProperty ( " log4j . appender . R3 . File " , log@@ Path@@ FileName + " - 3 - info . log " ) ; p . setProperty ( " log4j . appender . R3 . Max@@ FileSize " , "2@@ MB " ) ; p . setProperty ( " log4j . appender . R3 . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . R3 . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . R3 . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R@@ 4" , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . R4 . Threshold " , " WARN " ) ; p . setProperty ( " log4j . appender . R4 . File " , log@@ Path@@ FileName + " - 4 - warn . log " ) ; p . setProperty ( " log4j . appender . R4 . Max@@ FileSize " , "@@ 256@@ KB " ) ; p . setProperty ( " log4j . appender . R4 . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . R4 . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . R4 . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R@@ 5" , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . R@@ 5 . Threshold " , " ERROR " ) ; p . setProperty ( " log4j . appender . R@@ 5 . File " , log@@ Path@@ FileName + " - 5 - error . log " ) ; p . setProperty ( " log4j . appender . R@@ 5 . Max@@ FileSize " , "@@ 256@@ KB " ) ; p . setProperty ( " log4j . appender . R@@ 5 . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . R@@ 5 . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . R@@ 5 . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R@@ 6" , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . R@@ 6 . Threshold " , " FATAL " ) ; p . setProperty ( " log4j . appender . R@@ 6 . File " , log@@ Path@@ FileName + " - 6 - fatal . log " ) ; p . setProperty ( " log4j . appender . R@@ 6 . Max@@ FileSize " , "@@ 256@@ KB " ) ; p . setProperty ( " log4j . appender . R@@ 6 . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . R@@ 6 . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . R@@ 6 . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . logger . water . api . Request@@ Server " , " TRACE , ▁ HTTP@@ D " ) ; p . setProperty ( " log4j . addi@@ tivity . water . api . Request@@ Server " , " false " ) ; p . setProperty ( " log4j . appender . HTTP@@ D " , " org . apache . log4j . Rolling@@ File@@ Appender " ) ; p . setProperty ( " log4j . appender . HTTP@@ D . Threshold " , " TRACE " ) ; p . setProperty ( " log4j . appender . HTTP@@ D . File " , log@@ Path@@ FileName + " - httpd . log " ) ; p . setProperty ( " log4j . appender . HTTP@@ D . Max@@ FileSize " , "1@@ MB " ) ; p . setProperty ( " log4j . appender . HTTP@@ D . Max@@ Backup@@ Index " , "3" ) ; p . setProperty ( " log4j . appender . HTTP@@ D . layout " , " org . apache . log4j . Pattern@@ Layout " ) ; p . setProperty ( " log4j . appender . HTTP@@ D . layout . Conversion@@ Pattern " , " % m % n " ) ; p . setProperty ( " log4j . logger . org . apache . http " , " WARN " ) ; p . setProperty ( " log4j . logger . com . amazonaws " , " WARN " ) ; p . setProperty ( " log4j . logger . org . apache . hadoop " , " WARN " ) ; p . setProperty ( " log4j . logger . org . jet@@ s3@@ t . service " , " WARN " ) ; }
 public static ImageLoader getInstance ( ) { synchronized ( ImageLoader . class ) { if ( instance == null ) { instance = new ImageLoader ( ) ; } } return instance ; }
 static void run@@ In@@ Channel ( Channel channel , final Http2@@ Runnable runnable ) { channel . event@@ Loop ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Http2@@ Exception e ) { throw new RuntimeException ( e ) ; } } } ) ; }
 public static void remove ( String key ) { MD@@ C . remove ( key ) ; }
 public static Duration new@@ Duration ( final long length ) { return Duration . of@@ Seconds ( length ) ; }
 public static Describe@@ Audit@@ Stream@@ Configuration@@ Result@@ JsonUnmarshaller getInstance ( ) { if ( instance == null ) instance = new Describe@@ Audit@@ Stream@@ Configuration@@ Result@@ JsonUnmarshaller ( ) ; return instance ; }
 public static byte [ ] int@@ _to_@@ bin ( int number ) { return int@@ _to_@@ bin ( number , 32 ) ; }
 public static int size ( Collection c ) { return c != null ? c . size ( ) : 0 ; }
 public static void set@@ Jvm@@ Metric@@ Name ( String jvm@@ Metric@@ Name ) { Aws@@ Sdk@@ Metrics . jvm@@ Metric@@ Name = jvm@@ Metric@@ Name ; }
 public static String sign ( String secret , Map < String , String > oauth@@ Parameters , String algorithm , String method , String url ) { StringBuilder signature@@ Base = new StringBuilder ( OAuth@@ Utils . percent@@ Encode ( method ) ) ; signature@@ Base . append ( " & " ) ; signature@@ Base . append ( OAuth@@ Utils . percent@@ Encode ( url ) ) ; signature@@ Base . append ( " & " ) ; Map < String , String > tree@@ Map = new TreeMap < String , String > ( oauth@@ Parameters ) ; tree@@ Map . remove ( " oauth _ signature " ) ; tree@@ Map . remove ( " realm " ) ; boolean first = true ; for ( Map . Entry < String , String > entry : tree@@ Map . entrySet ( ) ) { if ( ! first ) signature@@ Base . append ( OAuth@@ Utils . percent@@ Encode ( " & " ) ) ; else first = false ; signature@@ Base . append ( OAuth@@ Utils . percent@@ Encode ( entry . getKey ( ) + " = " + entry . getValue ( ) ) ) ; } Mac mac = null ; try { Secret@@ KeySpec secret@@ KeySpec = new Secret@@ KeySpec ( ( OAuth@@ Utils . percent@@ Encode ( secret ) + " & " ) . getBytes ( ) , algorithm ) ; mac = Mac . getInstance ( secret@@ KeySpec . get@@ Algorithm ( ) ) ; mac . init ( secret@@ KeySpec ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( " signature@@ BaseString : ▁ " + signature@@ Base . toString ( ) ) ; } byte [ ] bytes = mac . do@@ Final ( signature@@ Base . toString ( ) . getBytes ( ) ) ; byte [ ] encoded@@ Mac@@ Bytes = Base64 . encode@@ Base64 ( bytes ) ; return new String ( encoded@@ Mac@@ Bytes ) ; }
 public static Su@@ do@@ ku@@ Board import@@ From@@ CSV ( String inputFile ) throws Import@@ Exception { try ( CSV@@ Reader reader = new CSV@@ Reader ( new FileReader ( inputFile ) ) ) { String [ ] nextLine ; int count@@ Lines = 0 ; if ( ( nextLine = reader . read@@ Next ( ) ) == null ) { throw new Import@@ Exception ( " Please ▁ check ▁ that ▁ the ▁ file ▁ is ▁ not ▁ empty . " ) ; } int tst = ( int ) Math . sqrt ( nextLine . length ) ; if ( tst * tst != nextLine . length ) { throw new Import@@ Exception ( " Please ▁ check ▁ the ▁ number ▁ of ▁ columns . \n " + " It ▁ should ▁ be ▁ a ▁ perfect ▁ square . " ) ; } Su@@ do@@ ku@@ Board sb = new Su@@ do@@ ku@@ Board ( nextLine . length ) ; do { if ( nextLine . length != sb . SIZE ) { throw new Import@@ Exception ( " Please ▁ check ▁ each ▁ row ▁ has ▁ " + sb . SIZE + " ▁ columns . ▁ ( Same ▁ as ▁ first ▁ row ) " ) ; } for ( int j = 0 ; j < nextLine . length ; j ++ ) { sb . set ( Integer . parseInt ( nextLine [ j ] . trim ( ) ) , count@@ Lines , j ) ; } count@@ Lines ++ ; } while ( ( nextLine = reader . read@@ Next ( ) ) != null && count@@ Lines < sb . SIZE ) ; if ( count@@ Lines < sb . SIZE || nextLine != null ) { throw new Import@@ Exception ( " Please ▁ check ▁ the ▁ input ▁ CSV ▁ file ▁ has ▁ " + sb . SIZE + " ▁ rows . ▁ ( To ▁ match ▁ the ▁ number ▁ of ▁ columns ) " ) ; } return sb ; } catch ( FileNotFoundException e ) { String errorMsg = " The ▁ file ▁ you ▁ specified ▁ was ▁ not ▁ found . " ; throw new Import@@ Exception ( errorMsg ) ; } catch ( NumberFormatException e ) { String errorMsg = " Please ▁ check ▁ all ▁ values ▁ are ▁ integer . " ; throw new Import@@ Exception ( errorMsg ) ; } catch ( IOException e ) { throw new Import@@ Exception ( e . toString ( ) ) ; } }
 @ Converter public static PP@@ P_@@ PC@@ B to@@ P@@ pp@@ P@@ cb ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ P_@@ PC@@ B . class , body ) ; }
 public static void set@@ Connectivity@@ Component@@ s@@ State@@ Enabled ( Context context , boolean enabled ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . N ) { Component@@ Util . setState ( context , enabled , Mobile@@ Messaging@@ Connectivity@@ Receiver . class ) ; } else { Component@@ Util . setState ( context , enabled , Mobile@@ Messaging@@ Job@@ Service . class ) ; } }
 public static void pause ( @ Nonnull Condition condition , long timeout ) { checkNotNull ( condition ) ; Timeout@@ Watch watch = start@@ Watch@@ With@@ Timeout@@ Of ( timeout ) ; while ( ! condition . test ( ) ) { if ( watch . is@@ TimeOut ( ) && ! condition . test ( ) ) { condition . done ( ) ; throw new Wait@@ Timed@@ Out@@ Error ( String . format ( " Timed ▁ out ▁ waiting ▁ for ▁ % s " , condition . toString ( ) ) ) ; } pause ( SLE@@ EP_@@ INTERVAL ) ; } condition . done ( ) ; }
 private static String current@@ Version ( final F@@ ed@@ ora@@ Session session , final F@@ ed@@ ora@@ Resource resource ) throws RepositoryException { return getJ@@ cr@@ Session ( session ) . get@@ Workspace ( ) . getVersion@@ Manager ( ) . getBase@@ Version ( getJ@@ cr@@ Node ( resource ) . getPath ( ) ) . get@@ Frozen@@ Node ( ) . getIdentifier ( ) ; }
 public static void main ( String [ ] args ) { scan ( " while ▁ do " ) ; scan ( " while ▁ while ▁ do " ) ; scan ( " whi@@ le@@ do ▁ done " ) ; }
 private static void log@@ To@@ KV ( final String date , final String thr , final Kind kind , final Sys sys , final String msg ) { if ( LOG_@@ KEY == null ) if ( ! Pa@@ x@@ os . _@@ cloud@@ Locked ) return ; synchronized ( Log . class ) { if ( LOG_@@ KEY == null ) LOG_@@ KEY = Key . make ( " Log " , ( byte ) 0 , Key . BUIL@@ T_@@ IN_@@ KEY ) ; } final long pid = PID ; final H2@@ O@@ Node h2o = H2@@ O . SELF ; new TA@@ tom@@ ic < Log@@ Str > ( ) { @ Override public Log@@ Str atomic ( Log@@ Str l ) { return new Log@@ Str ( l , date , h2o , pid , thr , kind , sys , msg ) ; } } . fork ( LOG_@@ KEY ) ; }
 public static SearchRequest new@@ SearchRequest ( final String base@@ Dn , final Filter@@ Template filter ) { final var sr = new SearchRequest ( base@@ Dn , filter ) ; sr . set@@ Return@@ Attributes ( Return@@ Attributes . ALL_@@ USER . value ( ) ) ; sr . set@@ SearchScope ( SearchScope . SUB@@ TREE ) ; return sr ; }
 public static int [ ] read@@ Bio@@ Data ( byte [ ] deco@@ bb@@ ed ) { int [ ] bio@@ Bytes = new int [ 2 ] ; if ( deco@@ bb@@ ed . length > 1 ) { bio@@ Bytes [ 0 ] = deco@@ bb@@ ed [ 0 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ; bio@@ Bytes [ 0 ] = bio@@ Bytes [ 0 ] | ( ( deco@@ bb@@ ed [ 1 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 8 ) ; if ( deco@@ bb@@ ed . length > 3 ) { bio@@ Bytes [ 1 ] = deco@@ bb@@ ed [ 2 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ; bio@@ Bytes [ 1 ] = ( deco@@ bb@@ ed [ 3 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 8 ; } } return bio@@ Bytes ; }
 private static long parse ( String string , int offset , int radix , boolean negative ) { long max = Long . MIN_VALUE / radix ; long result = 0 , length = string . length ( ) ; while ( offset < length ) { int digit = Character . digit ( string . charAt ( offset ++ ) , radix ) ; if ( digit == - 1 ) { throw new NumberFormatException ( string ) ; } if ( max > result ) { throw new NumberFormatException ( string ) ; } long next = result * radix - digit ; if ( next > result ) { throw new NumberFormatException ( string ) ; } result = next ; } if ( ! negative ) { result = - result ; if ( result < 0 ) { throw new NumberFormatException ( string ) ; } } return result ; }
 private static void check ( InetAddress address , int prefix@@ Length ) { if ( address . is@@ Loop@@ back@@ Address ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } if ( address instanceof Inet@@ 4@@ Address ) { if ( prefix@@ Length < 0 || prefix@@ Length > 32 ) { throw new IllegalArgumentException ( " Bad ▁ prefix@@ Length " ) ; } } else if ( address instanceof Inet@@ 6@@ Address ) { if ( prefix@@ Length < 0 || prefix@@ Length > 128 ) { throw new IllegalArgumentException ( " Bad ▁ prefix@@ Length " ) ; } } else { throw new IllegalArgumentException ( " Unsupported ▁ family " ) ; } }
 private static final String getH@@ our@@ Minute@@ Sec@@ end ( long l ) { long sec@@ end = l / 1000 ; long hour = sec@@ end / 3600 ; long minute = ( sec@@ end - ( 3600 * hour ) ) / 60 ; sec@@ end = sec@@ end - ( hour * 60 * 60 ) - ( minute * 60 ) ; return " [ ▁ " + hour + " ▁ hour , ▁ " + minute + " ▁ minute , ▁ " + sec@@ end + " ▁ sec@@ end ▁ ] " ; }
 public static String getLast@@ Replicated@@ State@@ From@@ Parameters ( Map < String , String > m ) { if ( ( m != null ) && ( m . containsKey ( KEY . CUR@@ R_@@ STATE_@@ ID . toString ( ) ) ) ) { return m . get ( KEY . CUR@@ R_@@ STATE_@@ ID . toString ( ) ) ; } return null ; }
 public static void set@@ Queue@@ Poll@@ Timeout@@ Mil@@ li ( Long timeout@@ Mil@@ li ) { queue@@ Poll@@ Timeout@@ Mil@@ li = timeout@@ Mil@@ li ; }
 public static Paint@@ Extension get ( ) { return _instance ; }
 public static boolean get@@ Dont@@ Prompt ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getBoolean ( " doNot@@ Ask@@ URL " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static void set@@ DB@@ Type ( String db@@ Type ) { context@@ Holder . set ( db@@ Type ) ; }
 static public < T extends Throwable > T err ( String msg , T exception ) { return err ( Sys . WATER , msg , exception ) ; }
 public static < T extends KeyValue > Map < String , T > getKey@@ Value@@ Collection@@ As@@ LookupTable ( List < T > collection ) { Map < String , T > map = new HashMap < String , T > ( collection . size ( ) ) ; for ( T kv : collection ) { map . put ( kv . getKey ( ) , kv ) ; } return map ; }
 public static X@@ Bridge@@ Fragment get@@ Fragment ( Bundle bundle ) { X@@ Bridge@@ Fragment fragment = new X@@ Bridge@@ Fragment ( ) ; fragment . set@@ Arguments ( bundle ) ; return fragment ; }
 @ Converter public static R@@ AS_@@ O@@ 02 to@@ R@@ as@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ AS_@@ O@@ 02 . class , body ) ; }
 public static Internal@@ Process@@ Runtime new@@ Process@@ Runtime ( Stateful@@ Knowledge@@ Session@@ Impl working@@ Memory ) { return provider == null ? null : provider . new@@ Process@@ Runtime ( working@@ Memory ) ; }
 public static String get@@ Metric@@ NameSpace ( ) { return metric@@ NameSpace ; }
 @ Converter public static QR@@ Y_@@ Q@@ 01 to@@ Qry@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ Q@@ 01 . class , body ) ; }
 public static void main ( String [ ] args ) { new Fl@@ x@@ Desktop@@ Application ( new com . your@@ name . fli@@ x@@ el@@ game . examples . blo@@ om . Fl@@ x@@ Blo@@ om ( ) , 640 , 480 ) ; }
 public static void finish@@ All ( ) { for ( Activity activity : activities ) { if ( ! activity . is@@ Finish@@ ing ( ) ) { activity . finish ( ) ; } } }
 private static String get@@ Chunk ( final CharSequence s , final int s@@ length , int marker ) { final StringBuilder chunk = new StringBuilder ( ) ; char c = s . charAt ( marker ) ; chunk . append ( c ) ; marker ++ ; if ( is@@ Digit ( c ) ) { while ( marker < s@@ length ) { c = s . charAt ( marker ) ; if ( ! is@@ Digit ( c ) ) { break ; } chunk . append ( c ) ; marker ++ ; } } else { while ( marker < s@@ length ) { c = s . charAt ( marker ) ; if ( is@@ Digit ( c ) ) { break ; } chunk . append ( c ) ; marker ++ ; } } return chunk . toString ( ) ; }
 @ Converter public static SR@@ R@@ _S@@ 04 to@@ S@@ rr@@ S@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ R@@ _S@@ 04 . class , body ) ; }
 public static final String mapTo@@ Java ( String name ) { String algorithm = algorithms . get ( name ) ; if ( algorithm == null ) { throw new UnsupportedOperationException ( " Signature ▁ algorithm ▁ of ▁ " + name + " ▁ is ▁ unsupported . " ) ; } return algorithm ; }
 public static Map < String , Commit > Un@@ serialize ( String _re@@ pository ) throws SQLException { Map < String , Commit > resultSet = new HashMap < String , Commit > ( ) ; String sql ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; sql = " SELECT ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ AS ▁ UserName , ▁ T@@ c . message , ▁ T@@ File . newName ▁ AS ▁ FileName , ▁ " + " T@@ Class . name ▁ AS ▁ ClassName , ▁ T@@ Function . name ▁ AS ▁ Func@@ Name ▁ " + " FROM ▁ T@@ Commit ▁ TC ▁ " + " INNER ▁ JOIN ▁ T@@ Repository ▁ TR ▁ ON ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ " + " INNER ▁ JOIN ▁ T@@ User ▁ TU ▁ ON ▁ TC . userid ▁ = ▁ TU . id ▁ " + " LEFT ▁ JOIN ▁ T@@ File ▁ ON ▁ T@@ File . comm@@ iti@@ d ▁ = ▁ TC . id ▁ " + " LEFT ▁ JOIN ▁ T@@ Class ▁ on ▁ T@@ Class . file@@ id ▁ = ▁ T@@ File . id ▁ " + " LEFT ▁ JOIN ▁ T@@ Function ▁ ON ▁ T@@ Function . classi@@ d ▁ = ▁ T@@ Class . id ▁ " + " WHERE ▁ TR . Name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " + " ORDER ▁ BY ▁ TC . date ; ▁ " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { Commit current@@ Commit = resultSet . get ( rs . getString ( " HashCode " ) ) ; if ( current@@ Commit == null ) { current@@ Commit = new Commit ( rs . getString ( " HashCode " ) , rs . getString ( " UserName " ) ) ; try { current@@ Commit . date = sdf . parse ( rs . getString ( " date " ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } resultSet . put ( current@@ Commit . hash , current@@ Commit ) ; } String _@@ fileName = rs . getString ( " FileName " ) ; if ( _@@ fileName != null ) { File@@ Arch current@@ File = current@@ Commit . files . get ( _@@ fileName ) ; if ( current@@ File == null ) { current@@ File = new File@@ Arch ( _@@ fileName ) ; current@@ Commit . files . put ( current@@ File . filename , current@@ File ) ; String _@@ className = rs . getString ( " ClassName " ) ; if ( _@@ className != null ) { File@@ Class current@@ Class = current@@ File . classes . get ( _@@ className ) ; if ( current@@ Class == null ) { current@@ Class = new File@@ Class ( _@@ className ) ; current@@ File . classes . put ( current@@ Class . className , current@@ Class ) ; } String _@@ funcName = rs . getString ( " Func@@ Name " ) ; if ( _@@ funcName != null ) { current@@ Class . functions . add ( _@@ funcName ) ; } } } } } rs . close ( ) ; s@@ mt . close ( ) ; return resultSet ; }
 public static String getString ( Map < String , Object > map , String key ) { if ( map == null || ! map . containsKey ( key ) ) { return null ; } return toString ( map . get ( key ) ) ; }
 static < T extends Message > T to@@ Message ( Class < T > message@@ Class , String hl7@@ String ) { try { T generic@@ Message = DEFAULT_@@ CONTEXT . new@@ Message ( message@@ Class ) ; generic@@ Message . parse ( hl7@@ String ) ; return generic@@ Message ; } catch ( HL7@@ Exception conversion@@ Ex ) { throw new Type@@ Conversion@@ Exception ( hl7@@ String , String . class , conversion@@ Ex ) ; } }
 public static Locale getDefault@@ Language ( ) { return ( Locale ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ DEFAULT_@@ LANGUAGE , key -> { try { String default@@ Language@@ s@@ Str = properties . get ( key ) ; Assert . has@@ Text ( default@@ Language@@ s@@ Str , Web@@ Config@@ Key . WEB_@@ DEFAULT_@@ LANGUAGE + " ▁ can ▁ not ▁ be ▁ empty " ) ; return Common@@ Utils . parse@@ Locale ( default@@ Language@@ s@@ Str ) ; } catch ( Property@@ NotFoundException e ) { return Web@@ Config@@ Default . WEB_@@ DEFAULT_@@ LANGUAGE ; } } ) ; }
 private static ArrayList < Method > get@@ Imp@@ lemented@@ Methods ( @ Nullable Ph@@ p@@ Class php@@ Class , @ NotNull Method method , ArrayList < Method > imp@@ lemented@@ Methods ) { if ( php@@ Class == null ) { return imp@@ lemented@@ Methods ; } Method [ ] methods = php@@ Class . getOwn@@ Methods ( ) ; for ( Method own@@ Method : methods ) { if ( Ph@@ p@@ Lang@@ Util . equals@@ Method@@ Names ( own@@ Method . getName ( ) , method . getName ( ) ) ) { imp@@ lemented@@ Methods . add ( own@@ Method ) ; } } for ( Ph@@ p@@ Class interface@@ Class : php@@ Class . get@@ Imp@@ lemented@@ Interfaces ( ) ) { get@@ Imp@@ lemented@@ Methods ( interface@@ Class , method , imp@@ lemented@@ Methods ) ; } get@@ Imp@@ lemented@@ Methods ( php@@ Class . getSuper@@ Class ( ) , method , imp@@ lemented@@ Methods ) ; return imp@@ lemented@@ Methods ; }
 private static Builder create ( ) { Builder builder = new Builder ( ) ; builder . result = new com . al@@ ach@@ iso@@ ft . ta@@ yz@@ grid . common . protobuf . Register@@ Bulk@@ Key@@ Noti@@ f@@ Response@@ Protocol . Register@@ Bulk@@ Key@@ Noti@@ f@@ Response ( ) ; return builder ; }
 public static B@@ 70@@ Parse@@ Binder create ( Fixture fixture , String name ) throws RuntimeException { B@@ 70@@ Parse@@ Binder result ; if ( name . startsWith ( ASSIGN@@ MENT_@@ STRING ) ) { result = new B@@ 70@@ Parse@@ Binder . Rec@@ all@@ Binding ( name . substring ( 1 ) ) ; } else if ( regex@@ Method@@ Pattern . matcher ( name ) . matches ( ) || method@@ Pattern . matcher ( name ) . matches ( ) ) { final TypeAdapter adapter = make@@ Adapter ( fixture , name ) ; result = new B@@ 70@@ Parse@@ Binder . Query@@ Binding ( adapter ) ; } else { result = new B@@ 70@@ Parse@@ Binder . Default@@ Building ( name ) ; } return result ; }
 private static Extended@@ Iterator < RDF@@ Node > rejec@@ ting ( Extended@@ Iterator < RDF@@ Node > i , Set < RDF@@ Node > seen ) { return i . filter@@ Drop ( seen :: contains ) ; }
 private static void doTest ( Map < String , String > graph , final int k , String ... expected@@ Paths ) { doTest ( graph , " s " , " t " , k , expected@@ Paths ) ; }
 public static < U > Action@@ Ab@@ stra@@ it < U > getInstance ( ) { return ( Action@@ Ab@@ stra@@ it < U > ) new Action@@ Json@@ Simple@@ Comp@@ or@@ te@@ ment < > ( Object . class , null ) ; }
 public static String getStatic@@ Pages@@ RootPath ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ STATIC_@@ PAGE@@ S_@@ PATH , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result = properties . get ( key , Web@@ Config@@ Default . WEB_@@ STATIC_@@ PAGE@@ S_@@ PATH ) ; if ( ! StringUtils . has@@ Text ( result ) ) throw new RuntimeException ( key + " ▁ can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } } ) ; return ( String ) cached@@ Config ; }
 public static void show@@ Error ( Activity activity , String message ) { Simple@@ Toast . error ( activity , message ) ; }
 public static void configure@@ Batch@@ Writer ( Job job , Batch@@ Writer@@ Config writer@@ Config ) { Geo@@ Me@@ sa@@ Output@@ Format@@ $ . MODULE@@ $ . configure@@ Batch@@ Writer ( job , writer@@ Config ) ; }
 public static String getLog@@ Dir ( ) { if ( LOG_@@ DIR == null ) { return " unknown - log - dir " ; } return LOG_@@ DIR ; }
 @ Nullable static public String getArray@@ KeyValue@@ Inside@@ Signature ( Project project , String signature , String methodName , String keyName ) { PsiElement psiElement = Ph@@ p@@ Elements@@ Util . get@@ PsiElement@@ sBy@@ Signature@@ Single ( project , signature ) ; if ( psiElement == null ) { return null ; } for ( Method@@ Reference method@@ Reference : PsiTreeUtil . find@@ Children@@ OfType ( psiElement , Method@@ Reference . class ) ) { if ( Ph@@ p@@ Elements@@ Util . is@@ Equal@@ Method@@ Reference@@ Name ( method@@ Reference , methodName ) ) { PsiElement [ ] parameters = method@@ Reference . getParameters ( ) ; if ( parameters . length > 0 && parameters [ 0 ] instanceof Array@@ Creation@@ Expression ) { return Ph@@ p@@ Elements@@ Util . getArray@@ Value@@ String ( ( Array@@ Creation@@ Expression ) parameters [ 0 ] , keyName ) ; } } } return null ; }
 @ NotNull public static File resolve@@ M2@@ Dir ( ) { return new File ( System . getProperty ( PROP_@@ USER_@@ HOME ) , DOT_@@ M@@ 2_@@ DIR ) ; }
 public static < T > T cast ( Object o , Class < T > t@@ Class , String expected ) { if ( o == null ) { return null ; } else if ( t@@ Class . isInstance ( o ) ) { return t@@ Class . cast ( o ) ; } else { throw new Dispatch@@ able@@ Error ( Error@@ Messages . ERROR_INVALID_@@ TYPE , o . getClass ( ) . getSimpleName ( ) , expected ) ; } }
 public static String get@@ Geo@@ Names@@ Username ( ) { return Plugin@@ Options . getOption ( Selection@@ Action@@ Geo@@ Names . GE@@ ON@@ AME@@ S_@@ USERNAME ) ; }
 static Event make ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages ) { return make@@ 0 ( sys , kind , ouch , messages , null ) ; }
 public static void main ( String [ ] args ) { Ful@@ fill@@ ment@@ Client client = new Ful@@ fill@@ ment@@ Client ( ) ; client . rec@@ ieve@@ Messages ( ) ; }
 public static JMX@@ Connector@@ Server new@@ JMX@@ Connector@@ Server ( JMX@@ Service@@ URL service@@ URL , Map < String , ? > environment , MBeanServer mbeanServer ) throws IOException { Map < String , Object > env@@ copy ; if ( environment == null ) env@@ copy = new HashMap < String , Object > ( ) ; else { Env@@ Help . check@@ Attributes ( environment ) ; env@@ copy = new HashMap < String , Object > ( environment ) ; } final Class < JMX@@ Connector@@ Server@@ Provider > target@@ Interface = JMX@@ Connector@@ Server@@ Provider . class ; final ClassLoader loader = JMX@@ Connector@@ Factory . resolve@@ ClassLoader ( env@@ copy ) ; final String protocol = service@@ URL . getProtocol ( ) ; final String provider@@ ClassName = " Server@@ Provider " ; JMX@@ Connector@@ Server@@ Provider provider = JMX@@ Connector@@ Factory . getProvider ( service@@ URL , env@@ copy , provider@@ ClassName , target@@ Interface , loader ) ; IOException exception = null ; if ( provider == null ) { if ( loader != null ) { try { JMX@@ Connector@@ Server connection = get@@ Connector@@ Server@@ As@@ Service ( loader , service@@ URL , env@@ copy , mbeanServer ) ; if ( connection != null ) return connection ; } catch ( JMX@@ Provider@@ Exception e ) { throw e ; } catch ( IOException e ) { exception = e ; } } provider = JMX@@ Connector@@ Factory . getProvider ( protocol , PROTOCOL_@@ PROVIDER_@@ DEFAULT_@@ PACKAGE , JMX@@ Connector@@ Factory . class . getClassLoader ( ) , provider@@ ClassName , target@@ Interface ) ; } if ( provider == null ) { MalformedURLException e = new MalformedURLException ( " Unsupported ▁ protocol : ▁ " + protocol ) ; if ( exception == null ) { throw e ; } else { throw Env@@ Help . initCause ( e , exception ) ; } } env@@ copy = Collections . unmodifiableMap ( env@@ copy ) ; return provider . new@@ JMX@@ Connector@@ Server ( service@@ URL , env@@ copy , mbeanServer ) ; }
 private static void write@@ Dir@@ Entry ( Jar@@ OutputStream jar@@ OutputStream , String name ) throws IOException { jar@@ OutputStream . put@@ Next@@ Entry ( new Jar@@ Entry ( name ) ) ; jar@@ OutputStream . close@@ Entry ( ) ; }
 public static Sensor@@ Db@@ Helper getInstance ( ) { return db@@ Helper ; }
 public static void main ( String [ ] args ) { try { final String custom@@ Validator@@ Class = System . getProperty ( " pose@@ id@@ on . validator . block . custom " ) ; Custom@@ Blocks@@ Validator custom@@ Validator = null ; if ( StringUtils . isNotEmpty ( custom@@ Validator@@ Class ) ) { try { final Class < ? > aClass = Class . forName ( custom@@ Validator@@ Class ) ; final Object construc@@ ted@@ Instance = aClass . newInstance ( ) ; if ( construc@@ ted@@ Instance instanceof Custom@@ Blocks@@ Validator ) { custom@@ Validator = ( Custom@@ Blocks@@ Validator ) construc@@ ted@@ Instance ; } else { throw new IllegalArgumentException ( " Wrong ▁ class ▁ supplied " ) ; } } catch ( Exception e ) { logger . error ( " Wrong ▁ Custom@@ Block@@ Validator ▁ passed " , e ) ; System . exit ( - 1 ) ; } } Set < ClassPath . ClassInfo > class@@ Infos = ClassPath@@ Helper . getPackage@@ Classes ( Thread . currentThread ( ) . getContext@@ ClassLoader ( ) , Arrays . asList ( args ) ) ; System . out . println ( " Classes ▁ in ▁ ClassLoader : ▁ " + class@@ Infos . size ( ) ) ; Map < String , List < String > > errors = new HashMap < > ( ) ; for ( ClassPath . ClassInfo class@@ Info : class@@ Infos ) { Class < ? extends DataSource < ? > > clazz = ( Class < ? extends DataSource < ? > > ) Class . forName ( class@@ Info . getName ( ) ) ; if ( Modifier . is@@ Abstract ( clazz . getModifiers ( ) ) ) { continue ; } final List < String > class@@ Errors = new ArrayList < > ( ) ; if ( DataSource . class . isAssignableFrom ( clazz ) ) { class@@ Errors . addAll ( Annotation@@ Validator . validate@@ DataSource ( clazz ) ) ; class@@ Errors . addAll ( Datasour@@ ce@@ Validator . validate ( clazz ) ) ; if ( custom@@ Validator != null ) { class@@ Errors . addAll ( custom@@ Validator . validate@@ Datasour@@ ce ( clazz ) ) ; } } if ( ! class@@ Errors . isEmpty ( ) ) { errors . put ( clazz . getName ( ) , class@@ Errors ) ; } } if ( ! errors . isEmpty ( ) ) { logger . error ( Validator@@ Utils . get@@ Formatted@@ Error@@ Messages ( errors ) ) ; System . exit ( - 1 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
 @ Converter public static CR@@ M_@@ C@@ 05 to@@ C@@ rm@@ C@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 05 . class , body ) ; }
 public static String getCurrent@@ Feed@@ Url ( final Context context ) { return getSub@@ scription@@ Url@@ At ( context , getCurrent@@ Feed@@ Position ( context ) ) ; }
 public static String replace@@ By@@ Map ( String tpl , Map < String , Object > map ) { if ( tpl != null && map != null && map . size ( ) > 0 ) { for ( String key : map . keySet ( ) ) { tpl = tpl . replace ( " { " + key + " } " , String . valueOf ( map . get ( key ) ) ) ; } } return tpl ; }
 private static boolean get@@ Aux@@ Resources ( Node i@@ Node , Seq@@ Activity io@@ Act ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " get@@ Aux@@ Resources " ) ; } boolean ok = true ; String temp@@ Val = null ; List < AD@@ L@@ Auxiliary@@ Resource > aux@@ Res = new ArrayList < AD@@ L@@ Auxiliary@@ Resource > ( ) ; NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " auxili@@ ary@@ Resource " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < auxili@@ ary@@ Resource > ▁ " + " element " ) ; } AD@@ L@@ Auxiliary@@ Resource res = new AD@@ L@@ Auxiliary@@ Resource ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " purpose " ) ; if ( temp@@ Val != null ) { res . mType = temp@@ Val ; } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " auxili@@ ary@@ Resource@@ ID " ) ; if ( temp@@ Val != null ) { res . m@@ Resource@@ ID = temp@@ Val ; } aux@@ Res . add ( res ) ; } } } io@@ Act . set@@ Aux@@ Resources ( aux@@ Res ) ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " get@@ Aux@@ Resources " ) ; } return ok ; }
 @ JsonCreator public static Application@@ Gateway@@ Tier fromString ( String name ) { return fromString ( name , Application@@ Gateway@@ Tier . class ) ; }
 public static String to@@ Binary@@ String ( long v ) { return Integr@@ al@@ ToString . long@@ To@@ Binary@@ String ( v ) ; }
 public static void clear ( ) { MD@@ C . clear ( ) ; }
 public static void set@@ Region ( String region ) { Aws@@ Sdk@@ Metrics . region = Region@@ Utils . getRegion ( region ) ; }
 private static void collect@@ Generics ( @ Nullable Py@@ Type type , @ NotNull Type@@ Eval@@ Context context , @ NotNull Set < Py@@ Generic@@ Type > collected , @ NotNull Set < Py@@ Type > visited ) { if ( visited . contains ( type ) ) { return ; } visited . add ( type ) ; if ( type instanceof Py@@ Generic@@ Type ) { collected . add ( ( Py@@ Generic@@ Type ) type ) ; } else if ( type instanceof Py@@ Union@@ Type ) { final Py@@ Union@@ Type union = ( Py@@ Union@@ Type ) type ; for ( Py@@ Type t : union . get@@ Members ( ) ) { collect@@ Generics ( t , context , collected , visited ) ; } } else if ( type instanceof Py@@ TupleType ) { final Py@@ TupleType tuple = ( Py@@ TupleType ) type ; final int n = tuple . is@@ Ho@@ mo@@ gene@@ ous ( ) ? 1 : tuple . getElement@@ Count ( ) ; for ( int i = 0 ; i < n ; i ++ ) { collect@@ Generics ( tuple . getElementType ( i ) , context , collected , visited ) ; } } else if ( type instanceof Py@@ Collection@@ Type ) { final Py@@ Collection@@ Type collection = ( Py@@ Collection@@ Type ) type ; for ( Py@@ Type elementType : collection . getElement@@ Types ( ) ) { collect@@ Generics ( elementType , context , collected , visited ) ; } } else if ( type instanceof Py@@ Callable@@ Type ) { final Py@@ Callable@@ Type callable = ( Py@@ Callable@@ Type ) type ; final List < Py@@ Callable@@ Parameter > parameters = callable . getParameters ( context ) ; if ( parameters != null ) { for ( Py@@ Callable@@ Parameter parameter : parameters ) { if ( parameter != null ) { collect@@ Generics ( parameter . getType ( context ) , context , collected , visited ) ; } } } collect@@ Generics ( callable . getReturnType ( context ) , context , collected , visited ) ; } }
 public static void set@@ Synchronization@@ Receiver@@ State@@ Enabled ( Context context , Mobile@@ Messaging@@ Synchronization@@ Receiver sync@@ Receiver , boolean enabled ) { if ( enabled ) { Local@@ Broadcast@@ Manager . getInstance ( context ) . register@@ Receiver ( sync@@ Receiver , new IntentFilter ( Local@@ Event . APPLICATION_@@ FOREG@@ ROUND . getKey ( ) ) ) ; } else { Local@@ Broadcast@@ Manager . getInstance ( context ) . unregister@@ Receiver ( sync@@ Receiver ) ; } }
 private static boolean get@@ Objec@@ tives ( Node i@@ Node , Seq@@ Activity io@@ Act ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " get@@ Objec@@ tives " ) ; } boolean ok = true ; String temp@@ Val = null ; List < Seq@@ Objective > objec@@ tives = new ArrayList < Seq@@ Objective > ( ) ; NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " primary@@ Objective " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < primary@@ Objective > ▁ " + " element " ) ; } Seq@@ Objective obj = new Seq@@ Objective ( ) ; obj . m@@ Cont@@ ribute@@ sTo@@ Roll@@ up = true ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " objec@@ tive@@ ID " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { obj . m@@ Obj@@ ID = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " satis@@ fied@@ By@@ Measure " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { obj . m@@ S@@ atis@@ fied@@ By@@ Measure = ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ; } } temp@@ Val = getElement@@ Text ( curNode , " min@@ Normalized@@ Measure " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { obj . mMin@@ Measure = ( new Double ( temp@@ Val ) ) . doubleValue ( ) ; } } List < Seq@@ Objective@@ Map > maps = get@@ Objective@@ Maps ( curNode ) ; if ( maps != null ) { obj . m@@ Maps = maps ; } obj . m@@ Cont@@ ribute@@ sTo@@ Roll@@ up = true ; objec@@ tives . add ( obj ) ; } else if ( curNode . getLocalName ( ) . equals ( " objective " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < objective > ▁ " + " element " ) ; } Seq@@ Objective obj = new Seq@@ Objective ( ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " objec@@ tive@@ ID " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { obj . m@@ Obj@@ ID = temp@@ Val ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " satis@@ fied@@ By@@ Measure " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { obj . m@@ S@@ atis@@ fied@@ By@@ Measure = ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ; } } temp@@ Val = getElement@@ Text ( curNode , " min@@ Normalized@@ Measure " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { obj . mMin@@ Measure = ( new Double ( temp@@ Val ) ) . doubleValue ( ) ; } } List < Seq@@ Objective@@ Map > maps = get@@ Objective@@ Maps ( curNode ) ; if ( maps != null ) { obj . m@@ Maps = maps ; } objec@@ tives . add ( obj ) ; } } } io@@ Act . set@@ Objec@@ tives ( objec@@ tives ) ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " get@@ Objec@@ tives " ) ; } return ok ; }
 public static String getHost@@ Metric@@ Name ( ) { return host@@ Metric@@ Name ; }
 public static List < Command > parse ( Component component ) { List < Command > component@@ Cm@@ ds = new ArrayList < Command > ( ) ; Map < String , Map < String , Object > > map = component . getDescription ( ) . get@@ Commands ( ) ; if ( map == null ) { return component@@ Cm@@ ds ; } for ( Entry < String , Map < String , Object > > entry : map . entrySet ( ) ) { if ( entry . getKey ( ) . contains ( " : " ) ) { Span@@ na . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ command ▁ " + entry . getKey ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; continue ; } Command new@@ Cmd = new Component@@ Command ( entry . getKey ( ) , component ) ; Object description = entry . getValue ( ) . get ( " description " ) ; Object usage = entry . getValue ( ) . get ( " usage " ) ; Object aliases = entry . getValue ( ) . get ( " aliases " ) ; Object permission = entry . getValue ( ) . get ( " permission " ) ; Object permission@@ Message = entry . getValue ( ) . get ( " permission - message " ) ; if ( description != null ) { new@@ Cmd . setDescription ( description . toString ( ) ) ; } if ( usage != null ) { new@@ Cmd . set@@ Usage ( usage . toString ( ) ) ; } if ( aliases != null ) { List < String > ali@@ asList = new ArrayList < String > ( ) ; if ( aliases instanceof List ) { for ( Object o : ( List < ? > ) aliases ) { if ( o . toString ( ) . contains ( " : " ) ) { Span@@ na . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ alias ▁ " + o . toString ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; continue ; } ali@@ asList . add ( o . toString ( ) ) ; } } else { if ( aliases . toString ( ) . contains ( " : " ) ) { Span@@ na . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ alias ▁ " + aliases . toString ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; } else { ali@@ asList . add ( aliases . toString ( ) ) ; } } new@@ Cmd . set@@ Aliases ( ali@@ asList ) ; } if ( permission != null ) { new@@ Cmd . set@@ Permission ( permission . toString ( ) ) ; } if ( permission@@ Message != null ) { new@@ Cmd . set@@ Permission@@ Message ( permission@@ Message . toString ( ) ) ; } component@@ Cm@@ ds . add ( new@@ Cmd ) ; } return component@@ Cm@@ ds ; }
 @ Converter public static SI@@ U@@ _S@@ 15 to@@ Si@@ u@@ S@@ 15 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 15 . class , body ) ; }
 @ Nullable private static Custom@@ Folding@@ Builder getCustom@@ Folding@@ Builder ( Folding@@ Builder builder , Folding@@ Descriptor descriptor ) { if ( builder instanceof Custom@@ Folding@@ Builder ) return ( Custom@@ Folding@@ Builder ) builder ; Folding@@ Builder original@@ Builder = descriptor . getElement ( ) . getUser@@ Data ( Composite@@ Folding@@ Builder . FO@@ LD@@ ING_@@ BUIL@@ DER ) ; if ( original@@ Builder instanceof Custom@@ Folding@@ Builder ) return ( Custom@@ Folding@@ Builder ) original@@ Builder ; return null ; }
 @ Converter public static SR@@ M_S@@ 03 to@@ S@@ rm@@ S@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( SR@@ M_S@@ 03 . class , body ) ; }
 private static int getIndex ( final String well , final int rows , final int cols ) { final int row = Character . toLowerCase ( well . charAt ( 0 ) ) - ' a ' ; final int col = Integer . parseInt ( well . substring ( 1 ) ) - 1 ; final int well@@ Index = row < 0 || row >= rows || col < 0 || col >= cols ? - 1 : row * cols + col ; return well@@ Index ; }
 public static void main ( String [ ] args ) { Log . info ( " hi " ) ; Log . info ( " h " , " i " ) ; unwrap ( System . out , " hi " ) ; unwrap ( System . err , " hi " ) ; Log . info ( " ho ▁ " , new Object ( ) { int i ; public String toString ( ) { if ( i ++ == 0 ) throw new OutOf@@ MemoryError ( ) ; else return super . toString ( ) ; } } ) ; Log . info ( " ha ▁ " , new Object ( ) { int i ; public String toString ( ) { if ( i ++ == 0 ) throw new OutOf@@ MemoryError ( ) ; else return super . toString ( ) ; } } ) ; Log . info ( " hi " ) ; Log . info ( " hi " ) ; Log . info ( " hi " ) ; }
 public static void show@@ Info ( Activity activity , String message ) { Simple@@ Toast . info ( activity , message ) ; }
 public static < T , U > List < U > collect@@ Seconds ( List < Pair < T , U > > pairs ) { List < U > result = new ArrayList < U > ( pairs . size ( ) ) ; for ( Pair < T , U > each : pairs ) { result . add ( each . second ) ; } return result ; }
 @ Converter public static QR@@ Y_@@ T@@ 12 to@@ Qry@@ T@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( QR@@ Y_@@ T@@ 12 . class , body ) ; }
 @ Converter public static SI@@ U@@ _S@@ 23 to@@ Si@@ u@@ S@@ 23 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 23 . class , body ) ; }
 @ Nullable public static File resolve@@ Maven@@ Home@@ Directory ( @ Nullable String override@@ Maven@@ Home ) { if ( ! isEmpty@@ Or@@ Spaces ( override@@ Maven@@ Home ) ) { return new File ( override@@ Maven@@ Home ) ; } String m2@@ home = System . getenv ( ENV_@@ M@@ 2_@@ HOME ) ; if ( ! isEmpty@@ Or@@ Spaces ( m2@@ home ) ) { final File home@@ From@@ Env = new File ( m2@@ home ) ; if ( isValid@@ Maven@@ Home ( home@@ From@@ Env ) ) { return home@@ From@@ Env ; } } String user@@ Home = System . getProperty ( PROP_@@ USER_@@ HOME ) ; if ( ! isEmpty@@ Or@@ Spaces ( user@@ Home ) ) { final File under@@ User@@ Home = new File ( user@@ Home , M@@ 2_@@ DIR ) ; if ( isValid@@ Maven@@ Home ( under@@ User@@ Home ) ) { return under@@ User@@ Home ; } } return null ; }
 @ Converter public static BAR_@@ P@@ 02 to@@ Bar@@ P@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( BAR_@@ P@@ 02 . class , body ) ; }
 public static boolean is@@ Variable@@ Used ( @ NotNull Control@@ Flow flow , int start , int end , @ NotNull Psi@@ Variable variable ) { List < Instruction > instructions = flow . get@@ Instructions ( ) ; LOG . assertTrue ( start >= 0 , " flow ▁ start " ) ; LOG . assertTrue ( end <= instructions . size ( ) , " flow ▁ end " ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Read@@ Variable@@ Instruction ) { if ( ( ( Read@@ Variable@@ Instruction ) instruction ) . variable == variable ) { return true ; } } else if ( instruction instanceof Write@@ Variable@@ Instruction ) { if ( ( ( Write@@ Variable@@ Instruction ) instruction ) . variable == variable ) { return true ; } } } return false ; }
 @ Converter public static AD@@ T_@@ A@@ 29 to@@ Ad@@ t@@ A@@ 29 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 29 . class , body ) ; }
 @ NotNull public static CopyOnWrite@@ List add ( @ Nullable CopyOnWrite@@ List list , @ NotNull Variable@@ Info value ) { return list == null ? new CopyOnWrite@@ List ( value ) : list . add ( value ) ; }
 private static HttpServletRequest create@@ Mock@@ Request ( String handler , boolean task@@ Queue@@ Request , boolean ajax@@ Request ) { HttpServletRequest request = createMock ( HttpServletRequest . class ) ; if ( task@@ Queue@@ Request ) { expect ( request . getHeader ( " X - App@@ Engine - Queue@@ Name " ) ) . andReturn ( " default " ) . anyTimes ( ) ; } else { expect ( request . getHeader ( " X - App@@ Engine - Queue@@ Name " ) ) . andReturn ( null ) . anyTimes ( ) ; } if ( ajax@@ Request ) { expect ( request . getHeader ( " X - Requested - With " ) ) . andReturn ( " XML@@ HttpRequest " ) . anyTimes ( ) ; } else { expect ( request . getHeader ( " X - Requested - With " ) ) . andReturn ( null ) . anyTimes ( ) ; } expect ( request . getPath@@ Info ( ) ) . andReturn ( " / " + handler ) . anyTimes ( ) ; return request ; }
 public static final Builder builder ( ) { return new Auto@@ Par@@ cel_@@ Object@@ Ref . Builder ( ) ; }
 private static void rotate@@ Facing ( TileEntity tile@@ Entity ) { I@@ BlockState state = tile@@ Entity . get@@ World ( ) . getBlock@@ State ( tile@@ Entity . getPos ( ) ) ; Enum@@ Facing orientation = Base@@ Block . get@@ Front@@ Direction ( Mod@@ Blocks . grid@@ Block . get@@ Rotation@@ Type ( ) , state ) ; switch ( orientation ) { case NORTH : Gl@@ StateManager . rotate ( 180 , 0 , 1 , 0 ) ; break ; case SOUTH : break ; case WEST : Gl@@ StateManager . rotate ( 270 , 0 , 1 , 0 ) ; break ; case EAST : Gl@@ StateManager . rotate ( 90 , 0 , 1 , 0 ) ; break ; case DOWN : case UP : break ; } }
 public static void scan ( String text ) { Char@@ Stream stream = Char@@ Streams . fromString ( text ) ; Lexer lexer = new Example ( stream ) ; for ( Token token : lexer . getAll@@ Tokens ( ) ) { System . out . print ( token . toString ( ) + " ▁ " ) ; } System . out . println ( ) ; }
 private static boolean is@@ Digit ( final char ch ) { return ( ch >= '0' ) && ( ch <= '9' ) ; }
 public static void run ( Project project , String title , final Maven@@ Task task ) throws Maven@@ Process@@ Canceled@@ Exception { final Exception [ ] can@@ ce@@ led@@ Ex = new Exception [ 1 ] ; final RuntimeException [ ] runtime@@ Ex = new RuntimeException [ 1 ] ; final Error [ ] error@@ Ex = new Error [ 1 ] ; Progress@@ Manager . getInstance ( ) . run ( new Task . Modal ( project , title , true ) { public void run ( @ NotNull ProgressIndicator i ) { try { task . run ( new Maven@@ ProgressIndicator ( i ) ) ; } catch ( Maven@@ Process@@ Canceled@@ Exception e ) { can@@ ce@@ led@@ Ex [ 0 ] = e ; } catch ( Process@@ Canceled@@ Exception e ) { can@@ ce@@ led@@ Ex [ 0 ] = e ; } catch ( RuntimeException e ) { runtime@@ Ex [ 0 ] = e ; } catch ( Error e ) { error@@ Ex [ 0 ] = e ; } } } ) ; if ( can@@ ce@@ led@@ Ex [ 0 ] instanceof Maven@@ Process@@ Canceled@@ Exception ) throw ( Maven@@ Process@@ Canceled@@ Exception ) can@@ ce@@ led@@ Ex [ 0 ] ; if ( can@@ ce@@ led@@ Ex [ 0 ] instanceof Process@@ Canceled@@ Exception ) throw new Maven@@ Process@@ Canceled@@ Exception ( ) ; if ( runtime@@ Ex [ 0 ] != null ) throw runtime@@ Ex [ 0 ] ; if ( error@@ Ex [ 0 ] != null ) throw error@@ Ex [ 0 ] ; }
 public static void set@@ Host@@ Metric@@ Name ( String host@@ Metric@@ Name ) { Aws@@ Sdk@@ Metrics . host@@ Metric@@ Name = host@@ Metric@@ Name ; }
 public static String getDevice@@ Name ( Context context , String defaultValue ) { try { return PreferenceManager . getDefault@@ SharedPreferences ( context ) . getString ( " deviceName " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
 public static boolean isNew@@ Expression@@ Ph@@ p@@ Class@@ With@@ Instance ( @ NotNull New@@ Expression new@@ Expression , @ NotNull String instance ) { return getNew@@ Expression@@ Ph@@ p@@ Class@@ With@@ Instance ( new@@ Expression , instance ) != null ; }
 public static void remove@@ Activity ( Activity activity ) { activities . remove ( activity ) ; }
 @ Converter public static MF@@ K_@@ M@@ 02 to@@ M@@ fk@@ M@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ K_@@ M@@ 02 . class , body ) ; }
 public static void main ( String [ ] args ) throws Exception { load@@ Form@@ File ( ) ; load@@ Form@@ Str ( ) ; Value value = new Value ( " 三@@ 个@@ 和@@ 尚 " , " 三@@ 个 " , " m " , " 和@@ 尚 " , " n " ) ; Library . insert@@ Word ( User@@ Define@@ Library . ambigu@@ ity@@ Fore@@ st , value ) ; Library . remove@@ Word ( User@@ Define@@ Library . ambigu@@ ity@@ Fore@@ st , " 三@@ 个@@ 和@@ 尚 " ) ; }
 public static Image@@ Exchange@@ ApplicationContext getSingleton ( ) { if ( singleton == null ) { log . error ( " Image@@ Exchange@@ ApplicationContext ▁ was ▁ not ▁ initialized ▁ when ▁ getSingleton ( ) ▁ was ▁ called . " ) ; throw new Image@@ Exchange@@ ApplicationContext@@ Initialization@@ Error ( " Image@@ Exchange@@ ApplicationContext ▁ was ▁ not ▁ initialized ▁ when ▁ getSingleton ( ) ▁ was ▁ called . " ) ; } return singleton ; }
 public static void test_@@ local@@ DateTime ( ) { System . out . println ( " Test ▁ LocalDateTime " ) ; LocalDateTime ld@@ t1 = LocalDateTime . now ( ) ; java . sql . Timestamp ts = to@@ SQL@@ Timestamp ( ld@@ t1 ) ; LocalDateTime ld@@ t2 = to@@ LocalDateTime ( ts ) ; System . out . println ( " LocalDateTime ▁ 1 ▁ = ▁ " + ld@@ t1 ) ; System . out . println ( " Timestamp ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + ts ) ; System . out . println ( " LocalDateTime ▁ 2 ▁ = ▁ " + ld@@ t2 ) ; if ( ! ld@@ t2 . equals ( ld@@ t1 ) ) { throw new IllegalStateException ( ) ; } }
 @ Converter public static REF_@@ I@@ 13 to@@ Ref@@ I@@ 13 ( String body ) throws HL7@@ Exception { return to@@ Message ( REF_@@ I@@ 13 . class , body ) ; }
 public static int numberOf@@ Trailing@@ Zeros ( long v ) { int low = ( int ) v ; return low != 0 ? Integer . numberOf@@ Trailing@@ Zeros ( low ) : 32 + Integer . numberOf@@ Trailing@@ Zeros ( ( int ) ( v >@@ >> 32 ) ) ; }
 private static boolean are@@ Instruction@@ s@@ Reach@@ able@@ With@@ Calls ( @ NotNull final Control@@ Flow flow , @ NotNull final int [ ] instruction@@ Offsets , final int startOffset ) { ControlFlow@@ Graph graph = new ControlFlow@@ Graph ( flow . getSize ( ) ) { @ Override boolean is@@ Complete ( int offset , int next@@ Offset ) { return ArrayUtil . indexOf ( instruction@@ Offsets , next@@ Offset ) >= 0 ; } } ; graph . build@@ From ( flow ) ; return graph . depth@@ First@@ Search ( startOffset ) ; }
 public static void update@@ Subscription@@ Id@@ At ( final Context context , final String id , final int position ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final String title = getSub@@ scription@@ Title@@ At ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; values . set ( 1 , id ) ; subscriptions . replace@@ Values ( title , values ) ; save@@ Sub@@ scriptions ( context , subscriptions ) ; }
 public static Collection < Serializer@@ Registration > get@@ Serializer@@ Registr@@ ations ( ) { return registrations ; }
 public static void generate@@ Doc@@ Template ( String path , Document@@ Generator . Doc@@ Mode mode ) { Document@@ Generator rg = Groovy@@ Utils . newInstance ( " scripts / Rest@@ Documentation@@ Generator . groovy " ) ; rg . generate@@ Doc@@ Templates ( path , mode ) ; }
 private static TreeNode generate ( ) { TreeNode t6 = new TreeNode ( 6 ) ; TreeNode t@@ 9 = new TreeNode ( 9 ) ; TreeNode t@@ 8 = new TreeNode ( 8 ) ; t@@ 8 . left = t6 ; t@@ 8 . right = t@@ 9 ; TreeNode t@@ 13 = new TreeNode ( 13 ) ; TreeNode t@@ 11 = new TreeNode ( 11 ) ; t@@ 11 . right = t@@ 13 ; TreeNode root = new TreeNode ( 10 ) ; root . left = t@@ 8 ; root . right = t@@ 11 ; return root ; }
 public static int get@@ Store@@ Local@@ B@@ io ( byte [ ] bytes ) { if ( bytes . length > 7 ) { return ( ( ( bytes [ 0 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) | ( ( bytes [ 1 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 8 ) ) | ( ( bytes [ 2 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 16 ) ) | ( ( bytes [ 3 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) << 24 ) ; } return 0 ; }
 private static PsiType reduce ( List < Mixin > mix@@ ins ) { List < PsiType > types = mix@@ ins . stream ( ) . filter ( it -> ! it . my@@ Neg@@ ated ) . map ( it -> it . my@@ Type ) . collect ( toList ( ) ) ; return types . isEmpty ( ) ? null : Psi@@ Intersection@@ Type . create@@ Intersection ( types ) ; }
 public static void increment@@ Count ( ) { sCount ++ ; }
 @ NotNull private static List < PsiReferenceExpression > getRead@@ Before@@ Write ( @ NotNull Control@@ Flow flow , int startOffset ) { if ( startOffset < 0 || startOffset >= flow . getSize ( ) ) { return Collections . emptyList ( ) ; } final Read@@ Before@@ Write@@ Client@@ Visitor visitor = new Read@@ Before@@ Write@@ Client@@ Visitor ( flow , false ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( startOffset ) ; }
 private static boolean verify@@ B@@ ST@@ Post@@ Order ( int [ ] nums ) { if ( nums == null || nums . length == 0 ) { return false ; } if ( nums . length == 1 ) { return true ; } return process ( nums , 0 , nums . length - 1 ) ; }
 private static final Set < Character > LEG@@ AL_@@ NUMBER_@@ CHAR = new HashSet < Character > ( ) { { add ( '0' ) ; add ( '1' ) ; add ( '2' ) ; add ( '3' ) ; add ( '4' ) ; add ( '5' ) ; add ( '6' ) ; add ( '7' ) ; add ( '8' ) ; add ( '9' ) ; add ( ' . ' ) ; } }
 static public < T extends Throwable > T warn ( Sys t , String msg , T exception ) { Event e = Event . make ( t , Kind . WARN , exception , msg ) ; write ( e , true , true ) ; return exception ; }
 protected static String getApi@@ Name@@ AsString ( Class < ? extends Api@@ Method > api@@ Method ) { return getApi@@ Name ( api@@ Method ) . getName ( ) ; }
 protected static Map < Integer , String > to@@ Privilege@@ sMap ( ResultSet resultSet ) throws SQLException { Map < Integer , String > result = new HashMap < Integer , String > ( ) ; while ( resultSet . next ( ) ) { result . put ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; } return result ; }
 static public void info_@@ no_@@ stdout ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , false , true ) ; }
 public static void verify@@ Manifest@@ Component@@ sFor@@ Push ( Context context ) { verify@@ Manifest@@ Service ( context , Mobile@@ Messaging@@ Cloud@@ Service . class ) ; verify@@ Manifest@@ Service ( context , Mobile@@ Messaging@@ Fire@@ base@@ Service . class ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { verify@@ Manifest@@ Service ( context , Mobile@@ Messaging@@ Job@@ Service . class ) ; } else { verify@@ Manifest@@ Receiver ( context , Mobile@@ Messaging@@ Connectivity@@ Receiver . class ) ; } }
 public static OC@@ SP@@ Response getInstance ( ASN1@@ Tagged@@ Object obj , boolean explicit ) { return getInstance ( ASN1@@ Sequence . getInstance ( obj , explicit ) ) ; }
 public static String [ ] Available@@ Projects ( ) throws SQLException { List < String > repos = new ArrayList < String > ( ) ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ Name ▁ FROM ▁ TRE@@ POSI@@ TORY ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { repos . add ( rs . getString ( " name " ) ) ; } rs . close ( ) ; s@@ mt . close ( ) ; return ( String [ ] ) repos . toArray ( new String [ 0 ] ) ; }
 public static String toString ( LocalTime lt ) { String s = ( lt == null ? null : lt . toString ( ) ) ; return s ; }
 static public HashMap < String , String > getArray@@ KeyValue@@ Map ( Array@@ Creation@@ Expression array@@ Creation@@ Expression ) { HashMap < String , String > keys = new HashMap < String , String > ( ) ; for ( Array@@ Hash@@ Element array@@ Hash@@ Element : array@@ Creation@@ Expression . get@@ Hash@@ Elements ( ) ) { Ph@@ p@@ PsiElement child = array@@ Hash@@ Element . getKey ( ) ; if ( child != null && ( ( child instanceof StringLiteral@@ Expression ) || Ph@@ p@@ Patterns . psiElement ( Ph@@ p@@ ElementTypes . NUMBER ) . accepts ( child ) ) ) { String key ; if ( child instanceof StringLiteral@@ Expression ) { key = ( ( StringLiteral@@ Expression ) child ) . getContents ( ) ; } else { key = child . getText ( ) ; } String value = null ; if ( array@@ Hash@@ Element . getValue ( ) instanceof StringLiteral@@ Expression ) { value = ( ( StringLiteral@@ Expression ) array@@ Hash@@ Element . getValue ( ) ) . getContents ( ) ; } keys . put ( key , value ) ; } } return keys ; }
 public static float [ ] get@@ Kernel ( float sigma , float mu , int n@@ Points ) { float normalization = ( float ) ( Math . pow ( sigma , 5 ) * Math . sqrt ( 2.@@ f * Math . PI ) ) ; if ( sigma < 1 ) { int power = Misc@@ Math . find@@ PowerOf@@ 10 ( sigma * sigma ) ; normalization *= ( 1. / ( sigma * sigma ) ) * Math . pow ( 10 , - 1 * power ) ; } int half@@ Width@@ In@@ Pixels = n@@ Points >> 1 ; int start = ( int ) ( mu - half@@ Width@@ In@@ Pixels ) ; int stop@@ Ex@@ cl = ( int ) mu + half@@ Width@@ In@@ Pixels + 1 ; float d , ds@@ q ; int count = 0 ; float [ ] y@@ Points = new float [ n@@ Points ] ; for ( int i = start ; i < stop@@ Ex@@ cl ; i ++ ) { if ( count >= n@@ Points ) { break ; } float x = i ; d = ( x - mu ) ; ds@@ q = d * d ; float y = ( ds@@ q - sigma * sigma ) * ( float ) ( Math . exp ( - 1.@@ f * ds@@ q / ( 2.@@ f * sigma * sigma ) ) ) ; y@@ Points [ count ] = y / normalization ; count ++ ; } return y@@ Points ; }
 @ Converter public static MF@@ N_@@ M@@ 01 to@@ M@@ fn@@ M@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 01 . class , body ) ; }
 public static void main ( String [ ] args ) { Lit@@ m@@ us@@ Frame represent@@ s@@ P@@ d = new Lit@@ m@@ us@@ Frame ( ) ; }
 public static Change@@ Batch@@ StaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new Change@@ Batch@@ StaxUnmarshaller ( ) ; return instance ; }
 public static boolean collect@@ Outer@@ Locals ( @ NotNull List < ? super Psi@@ Variable > array , @ NotNull PsiElement scope , @ NotNull PsiElement member , @ NotNull PsiElement target@@ Class@@ Member ) { if ( scope instanceof Psi@@ MethodCallExpression ) { final Psi@@ MethodCallExpression call = ( Psi@@ MethodCallExpression ) scope ; if ( ! check@@ Reference@@ Expression@@ Scope ( call . getMethod@@ Expression ( ) , target@@ Class@@ Member ) ) { return false ; } } else if ( scope instanceof PsiReferenceExpression ) { if ( ! check@@ Reference@@ Expression@@ Scope ( ( PsiReferenceExpression ) scope , target@@ Class@@ Member ) ) { return false ; } } if ( scope instanceof PsiJava@@ Code@@ ReferenceElement ) { final PsiJava@@ Code@@ ReferenceElement ref = ( PsiJava@@ Code@@ ReferenceElement ) scope ; final Java@@ ResolveResult result = ref . advanced@@ Resolve ( false ) ; final PsiElement ref@@ Element = result . getElement ( ) ; if ( ref@@ Element != null ) { PsiElement parent = ref@@ Element . getParent ( ) ; parent = parent != null ? PsiTreeUtil . find@@ Common@@ Parent ( parent , member ) : null ; if ( parent == null ) { parent = result . getCurrent@@ File@@ Resolve@@ Scope ( ) ; } if ( parent != null && ! member . equals ( parent ) ) { parent = PsiTreeUtil . find@@ Common@@ Parent ( parent , target@@ Class@@ Member ) ; if ( target@@ Class@@ Member . equals ( parent ) ) { if ( ref@@ Element instanceof Psi@@ Variable ) { if ( scope instanceof PsiReferenceExpression && PsiUtil . is@@ Acces@@ sed@@ For@@ Writing ( ( PsiReferenceExpression ) scope ) ) { return false ; } Psi@@ Variable variable = ( Psi@@ Variable ) ref@@ Element ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } else { return false ; } } } } } else if ( scope instanceof Psi@@ This@@ Expression ) { PsiJava@@ Code@@ ReferenceElement qualifier = ( ( Psi@@ This@@ Expression ) scope ) . getQualifier ( ) ; if ( qualifier == null ) { return false ; } } else if ( scope instanceof Psi@@ Super@@ Expression ) { if ( ( ( Psi@@ Super@@ Expression ) scope ) . getQualifier ( ) == null ) { return false ; } } for ( PsiElement child = scope . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( ! collect@@ Outer@@ Locals ( array , child , member , target@@ Class@@ Member ) ) return false ; } return true ; }
 @ Suppress@@ Lint ( " Inlin@@ ed@@ Api " ) @ TargetApi ( 16 ) private static void test@@ Conversion@@ To@@ Framework@@ Media@@ Format@@ V@@ 16 ( Format in ) { Media@@ Format out = in . get@@ Framework@@ Media@@ Format@@ V@@ 16 ( ) ; assertThat ( out . getString ( Media@@ Format . KEY_@@ MIME ) ) . isEqualTo ( in . sample@@ MimeType ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY_@@ LANGUAGE , in . language ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY_@@ MAX_@@ INPUT_@@ SIZE , in . max@@ Input@@ Size ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY_@@ WIDTH , in . width ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY_@@ HEIGHT , in . height ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY_@@ CHANNEL_@@ COUNT , in . channel@@ Count ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY@@ _SAMPLE_@@ RATE , in . sampleRate ) ; assert@@ Optional@@ V@@ 16 ( out , Media@@ Format . KEY_@@ FRAME_@@ RATE , in . frame@@ Rate ) ; for ( int i = 0 ; i < in . initializ@@ ation@@ Data . size ( ) ; i ++ ) { byte [ ] original@@ Data = in . initializ@@ ation@@ Data . get ( i ) ; ByteBuffer framework@@ Buffer = out . get@@ ByteBuffer ( " csd - " + i ) ; byte [ ] framework@@ Data = Arrays . copyOf ( framework@@ Buffer . array ( ) , framework@@ Buffer . limit ( ) ) ; assertThat ( framework@@ Data ) . isEqualTo ( original@@ Data ) ; } }
 @ Converter public static VX@@ X_@@ V@@ 02 to@@ V@@ xx@@ V@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( VX@@ X_@@ V@@ 02 . class , body ) ; }
 public static String byteArray@@ To@@ HexString ( byte [ ] raw , int line@@ size ) { if ( raw == null ) return null ; final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; hex . append ( ' \n ' ) ; int i = 0 ; for ( final byte b : raw ) { hex . append ( HEX@@ ES [ ( b >> 4 ) & 0xF ] ) . append ( HEX@@ ES [ ( b ) & 0xF ] ) ; i ++ ; hex . append ( ' ▁ ' ) ; if ( i == line@@ size ) { hex . append ( ' \n ' ) ; i = 0 ; } } hex . append ( ' \n ' ) ; return hex . toString ( ) ; }
 public static Temp@@ FileSystem getInstance ( ) { return ApplicationManager . getApplication ( ) . getComponent ( Temp@@ FileSystem . class ) ; }
 public static < Stream@@ MessageType > void contains@@ In@@ Any@@ Order ( Map < Integer , List < Stream@@ MessageType > > expected , InMemory@@ Output@@ Descriptor < Stream@@ MessageType > output@@ Descriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( output@@ Descriptor ) ; Map < Integer , List < Stream@@ MessageType > > actual = TestRunner . consume@@ Stream ( output@@ Descriptor , timeout ) ; for ( Integer par@@ ition@@ Id : expected . keySet ( ) ) { assertThat ( actual . get ( par@@ ition@@ Id ) , Is@@ Iterable@@ Containing@@ In@@ Any@@ Order . contains@@ In@@ Any@@ Order ( expected . get ( par@@ ition@@ Id ) . toArray ( ) ) ) ; } }
 public static boolean is@@ Data@@ Present ( Arena@@ Data data ) { if ( data . getLocation ( " lob@@ by " ) . isPresent ( ) && data . getLocation ( " circ@@ lec@@ enter " ) . isPresent ( ) && data . getLocation ( " circle@@ edge " ) . isPresent ( ) && data . getVariable ( " dedicated " , Boolean . class ) . isPresent ( ) ) { return ! data . getVariable ( " dedicated " , Boolean . class ) . get ( ) ? data . getLocation ( " join@@ sign " ) . isPresent ( ) : true ; } else { return false ; } }
 public static Serializer@@ Registration register@@ Class ( Class cls , Serializer serializer ) { Serializer@@ Registration existing@@ Reg = get@@ Exact@@ Serializer@@ Registration ( cls ) ; short id ; if ( existing@@ Reg != null ) { id = existing@@ Reg . getId ( ) ; } else { id = next@@ Id ( ) ; } return register@@ Class@@ For@@ Id ( id , cls , serializer ) ; }
 public static Properties getSystem@@ Properties ( ) { Properties result = ( Properties ) System . getProperties ( ) . clone ( ) ; for ( String each : new TH@@ ash@@ Set < String > ( ( Set ) result . keySet ( ) ) ) { if ( each . startsWith ( " idea . " ) ) { result . remove ( each ) ; } } return result ; }
 public static Locale [ ] getSupport@@ Languages ( ) { return ( Locale [ ] ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB@@ _SUP@@ PORT_@@ LANGU@@ AGES , key -> { try { String support@@ Language@@ s@@ Str = properties . get ( key ) ; String [ ] support@@ Language@@ s@@ Str@@ Array = support@@ Language@@ s@@ Str . split ( " , " ) ; Locale [ ] ret = new Locale [ support@@ Language@@ s@@ Str@@ Array . length ] ; for ( int i = 0 ; i < support@@ Language@@ s@@ Str@@ Array . length ; i ++ ) { ret [ i ] = Common@@ Utils . parse@@ Locale ( support@@ Language@@ s@@ Str@@ Array [ i ] ) ; ; } return ret ; } catch ( Property@@ NotFoundException e ) { return Web@@ Config@@ Default . WEB@@ _SUP@@ PORT_@@ LANGU@@ AGES ; } } ) ; }
 private static I@@ Connectivity@@ Manager getService ( ) { return I@@ Connectivity@@ Manager . Stub . as@@ Interface ( ServiceManager . getService ( Context . CONNEC@@ TI@@ VI@@ TY@@ _SERVICE ) ) ; }
 private static void assert@@ Write@@ Access@@ Not@@ Gran@@ ted ( Segment@@ Node@@ Store@@ Persistence persistence ) { try { assert@@ Write@@ Access@@ Gran@@ ted ( persistence ) ; fail ( " Write ▁ access ▁ should ▁ not ▁ be ▁ granted , ▁ but ▁ writing ▁ to ▁ the ▁ storage ▁ succeeded . " ) ; } catch ( Exception e ) { } }
 static Metric@@ Collector getInternal@@ Metric@@ Collector ( ) { return mc ; }
 @ NotNull private static Optional < Boolean > match ( @ NotNull Py@@ TupleType expected , @ NotNull Py@@ Union@@ Type actual , @ NotNull Match@@ Context context ) { final int elementCount = expected . getElement@@ Count ( ) ; if ( ! expected . is@@ Ho@@ mo@@ gene@@ ous ( ) && consist@@ sOf@@ Same@@ Element@@ Number@@ Tuples ( actual , elementCount ) ) { return Optional . of ( substitu@@ te@@ Expected@@ Element@@ sWith@@ Uni@@ ons ( expected , elementCount , actual , context ) ) ; } return Optional . empty ( ) ; }
 static Fixed@@ Bit@@ Set@@ Filter wrap@@ With@@ Fixed@@ Bit@@ Set@@ Filter ( Filter filter ) { return SearchContext . current ( ) . fixed@@ Bit@@ Set@@ Filter@@ Cache ( ) . get@@ Fixed@@ Bit@@ Set@@ Filter ( filter ) ; }
 @ Nullable static public Method getClass@@ Method ( Project project , String php@@ ClassName , String methodName ) { for ( Ph@@ p@@ Class php@@ Class : Ph@@ p@@ Index . getInstance ( project ) . get@@ Classes@@ By@@ FQ@@ N ( php@@ ClassName ) ) { Method method = getClass@@ Method ( php@@ Class , methodName ) ; if ( method != null ) { return method ; } } return null ; }
 private static < T > Extended@@ Iterator < T > recording ( Clo@@ sable@@ Iterator < T > i , Set < T > seen ) { return new N@@ ice@@ Iterator < T > ( ) { @ Override public void remove ( ) { i . remove ( ) ; } @ Override public boolean hasNext ( ) { return i . hasNext ( ) ; } @ Override public T next ( ) { T x = i . next ( ) ; seen . add ( x ) ; return x ; } @ Override public void close ( ) { i . close ( ) ; } } ; }
 private static String get@@ With@@ Cmd ( String key , String defValue ) { String value = defValue ; try { Process process = Runtime . getRuntime ( ) . exec ( CMD_@@ GET_@@ PROP + " ▁ " + key ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; StringBuilder builder = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { builder . append ( line ) ; } String readValue = builder . toString ( ) ; if ( ! TextUtils . isEmpty ( readValue ) ) { value = readValue ; } } catch ( IOException e ) { } finally { if ( reader != null ) { reader . close ( ) ; } } process . destroy ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } return value ; }
 @ Before@@ All @ After@@ All public static void clean@@ Up ( ) { Helper . remove@@ Dir ( new File ( DIR ) ) ; }
 @ Nullable static File resolve@@ Dir@@ Or@@ Create ( @ NonNull String path ) throws SecurityException { File file = new File ( path ) ; if ( ! file . exists ( ) && ! file . mkdirs ( ) ) { return null ; } if ( ! file . isDirectory ( ) ) { return null ; } if ( ! file . can@@ Read ( ) || ! file . can@@ Write ( ) ) { return null ; } return file ; }
 @ Converter public static P@@ GL_@@ PC@@ 8 to@@ P@@ gl@@ P@@ c8 ( String body ) throws HL7@@ Exception { return to@@ Message ( P@@ GL_@@ PC@@ 8 . class , body ) ; }
 public static byte [ ] swap_@@ bytes ( byte [ ] bits , int byte@@ size ) { final int L = bits . length ; byte [ ] output = new byte [ L ] ; int j = L - byte@@ size ; for ( int i = 0 ; i < L ; i ++ , j ++ ) { if ( j == L ) { j = 0 ; } output [ j ] = bits [ i ] ; } return output ; }
 @ Converter public static UD@@ M_@@ Q@@ 05 to@@ U@@ dm@@ Q@@ 05 ( String body ) throws HL7@@ Exception { return to@@ Message ( UD@@ M_@@ Q@@ 05 . class , body ) ; }
 private static Collection < Value@@ Function < File , ? > > produ@@ ce@@ File@@ Converters ( ) { ArrayList < Value@@ Function < File , ? > > converters = new ArrayList < > ( ) ; converters . add ( new Value@@ Function@@ Impl < > ( File . class , File . class , Functions . < File > identity ( ) ) ) ; converters . add ( new Value@@ Function@@ Impl < > ( File . class , DataSource . class , new FileTo@@ DataSource@@ Function ( ) ) ) ; converters . add ( new Value@@ Function@@ Impl < > ( File . class , byte [ ] . class , new FileTo@@ ByteArray@@ Function ( ) ) ) ; converters . add ( new Value@@ Function@@ Impl < > ( File . class , InputStream . class , new FileTo@@ InputStream@@ Function ( ) ) ) ; return converters ; }
 public static Extended@@ Iterator < RDF@@ Node > distinct ( Extended@@ Iterator < RDF@@ Node > base ) { Set < RDF@@ Node > seen = new HashSet < > ( ) ; return recording ( rejec@@ ting ( base , seen ) , seen ) ; }
 public static boolean is@@ Equal@@ ClassName ( @ NotNull Ph@@ p@@ Class php@@ Class , @ NotNull Ph@@ p@@ Class compare@@ ClassName ) { return is@@ Equal@@ ClassName ( php@@ Class , compare@@ ClassName . get@@ Presentable@@ FQ@@ N ( ) ) ; }
 public static String getFirst@@ Node@@ Text ( Elements elements ) { return elements . get ( 0 ) . text ( ) ; }
 public static < Stream@@ MessageType > void contains@@ In@@ Any@@ Order ( List < Stream@@ MessageType > expected , InMemory@@ Output@@ Descriptor < Stream@@ MessageType > output@@ Descriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( output@@ Descriptor ) ; assertThat ( TestRunner . consume@@ Stream ( output@@ Descriptor , timeout ) . entrySet ( ) . stream ( ) . flatMap ( entry -> entry . getValue ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) , Is@@ Iterable@@ Containing@@ In@@ Any@@ Order . contains@@ In@@ Any@@ Order ( expected . toArray ( ) ) ) ; }
 @ Converter public static AD@@ T_@@ A@@ 40 to@@ Ad@@ t@@ A@@ 40 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 40 . class , body ) ; }
 @ Bean public static Property@@ Sources@@ Placeholder@@ Configurer property@@ Sources@@ Placeholder@@ Configurer ( ) { return new Property@@ Sources@@ Placeholder@@ Configurer ( ) ; }
 public static An@@ des@@ Manager@@ Service@@ Stub get@@ An@@ des@@ Manager@@ Service@@ Stub ( Servlet@@ Config config , HttpSession session ) throws AxisFault { String backend@@ Server@@ URL = Carbon@@ UIUtil . getServer@@ URL ( config . get@@ ServletContext ( ) , session ) ; String service@@ URL = backend@@ Server@@ URL + AN@@ DES_@@ MANAG@@ ER@@ _SERVICE_@@ NAME ; Configuration@@ Context config@@ Context = ( Configuration@@ Context ) config . get@@ ServletContext ( ) . getAttribute ( Carbon@@ Constants . CONFIGURATION_@@ CONTEXT ) ; An@@ des@@ Manager@@ Service@@ Stub stub = new An@@ des@@ Manager@@ Service@@ Stub ( config@@ Context , service@@ URL ) ; String cookie = ( String ) session . getAttribute ( Server@@ Constants . AD@@ MIN@@ _SERVICE_@@ COOKIE ) ; if ( cookie != null ) { Options option = stub . _get@@ ServiceClient ( ) . getOptions ( ) ; option . set@@ Manage@@ Session ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTP@@ Constants . COOKIE_@@ STRING , cookie ) ; } return stub ; }
 @ Converter public static PIN_@@ I@@ 07 to@@ Pin@@ I@@ 07 ( String body ) throws HL7@@ Exception { return to@@ Message ( PIN_@@ I@@ 07 . class , body ) ; }
 @ Nullable private static PsiElement getUn@@ reachable@@ Statement@@ Parent ( @ NotNull PsiElement statement ) { final PsiElement parent = statement . getParent ( ) ; if ( parent instanceof Psi@@ For@@ Statement && ( ( Psi@@ For@@ Statement ) parent ) . get@@ Initialization ( ) == statement ) { return parent ; } return null ; }
 @ NotNull protected static Promise < String > getText@@ To@@ Evaluate ( DataContext dataContext , X@@ Debug@@ Session session ) { final Editor editor = CommonData@@ Keys . EDITOR . getData ( dataContext ) ; if ( editor == null ) { return Pro@@ mises . resolved@@ Promise ( null ) ; } String text = editor . get@@ SelectionModel ( ) . getSelected@@ Text ( ) ; if ( text != null ) { return Pro@@ mises . resolved@@ Promise ( StringUtil . nul@@ lize ( text , true ) ) ; } X@@ Debugger@@ Evaluator evaluator = session . getDebug@@ Process ( ) . get@@ Evaluator ( ) ; if ( evaluator != null ) { return X@@ Debugger@@ Evaluate@@ ActionHandler . get@@ Expression@@ Text ( evaluator , editor . getProject ( ) , editor ) . then ( s -> StringUtil . nul@@ lize ( s , true ) ) ; } return Pro@@ mises . resolved@@ Promise ( null ) ; }
 @ NotNull public static Collection < PsiElement > collect@@ Method@@ Element@@ sWith@@ Parents ( final @ NotNull Method method , @ NotNull final Processor < PsiElement > processor ) { Collection < PsiElement > elements = new HashSet < PsiElement > ( ) ; collect@@ Method@@ Element@@ sWith@@ Parents ( method , 3 , elements , processor ) ; return elements ; }
 public static < T > T cast@@ NotNull ( Object o , Class < T > t@@ Class , String expected ) { if ( o == null ) { throw new Dispatch@@ able@@ Error ( Error@@ Messages . ERROR_INVALID_@@ TYPE , " null " , expected ) ; } else { return cast ( o , t@@ Class , expected ) ; } }
 @ Converter public static OR@@ R_@@ O@@ 02 to@@ Or@@ r@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( OR@@ R_@@ O@@ 02 . class , body ) ; }
 @ Converter public static AD@@ T_@@ A@@ 46 to@@ Ad@@ t@@ A@@ 46 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 46 . class , body ) ; }
 public static String get@@ Security@@ Code ( int length , Security@@ Code@@ Level level , boolean is@@ Can@@ Repeat ) { int len = length ; char [ ] codes = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , ' i ' , ' j ' , ' k ' , ' m ' , ' n ' , ' p ' , ' q ' , ' r ' , ' s ' , ' t ' , ' u ' , ' v ' , ' w ' , ' x ' , ' y ' , ' z ' , ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' , ' G ' , ' H ' , ' I ' , ' J ' , ' K ' , ' L ' , ' M ' , ' N ' , ' P ' , ' Q ' , ' R ' , ' S ' , ' T ' , ' U ' , ' V ' , ' W ' , ' X ' , ' Y ' , ' Z ' } ; if ( level == Security@@ Code@@ Level . Simple ) { codes = Arrays . copy@@ Of@@ Range ( codes , 0 , 9 ) ; } else if ( level == Security@@ Code@@ Level . Medium ) { codes = Arrays . copy@@ Of@@ Range ( codes , 0 , 33 ) ; } int n = codes . length ; if ( len > n && is@@ Can@@ Repeat == false ) { throw new RuntimeException ( String . format ( " 调@@ 用@@ Security@@ Code . get@@ Security@@ Code ( %1 $ s , %2 $ s , %@@ 3 $ s ) 出@@ 现@@ 异@@ 常 ， " + " 当@@ is@@ Can@@ Repeat@@ 为 % 3 $ s@@ 时 ， 传@@ 入@@ 参@@ 数 % 1 $ s@@ 不@@ 能@@ 大@@ 于 % 4 $ s " , len , level , is@@ Can@@ Repeat , n ) ) ; } char [ ] result = new char [ len ] ; if ( is@@ Can@@ Repeat ) { for ( int i = 0 ; i < result . length ; i ++ ) { int r = ( int ) ( Math . random ( ) * n ) ; result [ i ] = codes [ r ] ; } } else { for ( int i = 0 ; i < result . length ; i ++ ) { int r = ( int ) ( Math . random ( ) * n ) ; result [ i ] = codes [ r ] ; codes [ r ] = codes [ -- n ] ; } } return String . valueOf ( result ) ; }
 public static void init ( Context context ) { settings = context . get@@ SharedPreferences ( GLOB@@ AL@@ _SETT@@ INGS_@@ NAME , 0 ) ; }
 @ Converter public static MF@@ N_@@ M@@ 08 to@@ M@@ fn@@ M@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 08 . class , body ) ; }
 private static final ThreadPoolExecutor EXEC@@ UT@@ OR = new ThreadPoolExecutor ( 0 , Integer . MAX_VALUE , 1 , TimeUnit . SECONDS , new LinkedBlockingQueue < > ( ) , new ThreadFactory ( ) { private final AtomicInteger num = new AtomicInteger ( ) ; @ NotNull @ Override public Thread new@@ Thread ( @ NotNull Runnable r ) { return new Thread ( r , " M@@ aven ▁ Artifact ▁ Downloader ▁ " + num . getAnd@@ Increment ( ) ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 33 to@@ Ad@@ t@@ A@@ 33 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 33 . class , body ) ; }
 public static Maven@@ Task@@ Handler run@@ In@@ Background ( final Project project , final String title , final boolean cancell@@ able , final Maven@@ Task task ) { final Maven@@ ProgressIndicator indicator = new Maven@@ ProgressIndicator ( ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { try { task . run ( indicator ) ; } catch ( Maven@@ Process@@ Canceled@@ Exception ignore ) { indicator . cancel ( ) ; } catch ( Process@@ Canceled@@ Exception ignore ) { indicator . cancel ( ) ; } } } ; if ( is@@ No@@ Background@@ Mode ( ) ) { runnable . run ( ) ; return new Maven@@ Task@@ Handler ( ) { public void waitFor ( ) { } } ; } else { final Future < ? > future = ApplicationManager . getApplication ( ) . execute@@ On@@ Pooled@@ Thread ( runnable ) ; final Maven@@ Task@@ Handler handler = new Maven@@ Task@@ Handler ( ) { public void waitFor ( ) { try { future . get ( ) ; } catch ( InterruptedException e ) { Maven@@ Log . LOG . error ( e ) ; } catch ( ExecutionException e ) { Maven@@ Log . LOG . error ( e ) ; } } } ; invokeLater ( project , new Runnable ( ) { public void run ( ) { if ( future . isDone ( ) ) return ; new Task . Background@@ able ( project , title , cancell@@ able ) { public void run ( @ NotNull ProgressIndicator i ) { indicator . set@@ Indicator ( i ) ; handler . waitFor ( ) ; } } . queue ( ) ; } } ) ; return handler ; } }
 static < T extends Message > T to@@ Message ( Class < T > message@@ Class , byte [ ] hl7@@ Bytes , Exchange exchange ) { try { T generic@@ Message = DEFAULT_@@ CONTEXT . new@@ Message ( message@@ Class ) ; generic@@ Message . parse ( IO@@ Converter . toString ( hl7@@ Bytes , exchange ) ) ; return generic@@ Message ; } catch ( HL7@@ Exception | IOException conversion@@ Ex ) { throw new Type@@ Conversion@@ Exception ( hl7@@ Bytes , byte [ ] . class , conversion@@ Ex ) ; } }
 public static void main ( String [ ] args ) throws Exception { test@@ Server ( ) ; }
 public static void log ( File file , PrintStream stream ) throws Exception { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) break ; stream . println ( line ) ; } } finally { reader . close ( ) ; } }
 @ NotNull private static Collection < Folding@@ Descriptor > getCustom@@ Folding@@ Descriptors ( @ NotNull Editor editor , @ NotNull Project project ) { Set < Folding@@ Descriptor > fol@@ ding@@ Descriptors = new HashSet < > ( ) ; final Document document = editor . getDocument ( ) ; Psi@@ DocumentManager document@@ Manager = Psi@@ DocumentManager . getInstance ( project ) ; PsiFile file = document@@ Manager != null ? document@@ Manager . get@@ PsiFile ( document ) : null ; if ( file != null ) { final File@@ View@@ Provider view@@ Provider = file . getView@@ Provider ( ) ; for ( final Language language : view@@ Provider . get@@ Languages ( ) ) { final PsiFile psi = view@@ Provider . getP@@ si ( language ) ; final Folding@@ Builder fol@@ ding@@ Builder = Language@@ Fol@@ ding . INSTANCE . for@@ Language ( language ) ; if ( psi != null ) { for ( Folding@@ Descriptor descriptor : Language@@ Fol@@ ding . build@@ Folding@@ Descriptors ( fol@@ ding@@ Builder , psi , document , false ) ) { Custom@@ Folding@@ Builder custom@@ Folding@@ Builder = getCustom@@ Folding@@ Builder ( fol@@ ding@@ Builder , descriptor ) ; if ( custom@@ Folding@@ Builder != null ) { if ( custom@@ Folding@@ Builder . is@@ Custom@@ Region@@ Start ( descriptor . getElement ( ) ) ) { fol@@ ding@@ Descriptors . add ( descriptor ) ; } } } } } } return fol@@ ding@@ Descriptors ; }
 public static boolean is@@ Instruction@@ Reachable ( @ NotNull final Control@@ Flow flow , final int instruction@@ Offset , final int startOffset ) { return are@@ Instruction@@ s@@ Reachable ( flow , new int [ ] { instruction@@ Offset } , startOffset ) ; }
 @ Converter public static RR@@ G_@@ O@@ 02 to@@ R@@ rg@@ O@@ 02 ( String body ) throws HL7@@ Exception { return to@@ Message ( RR@@ G_@@ O@@ 02 . class , body ) ; }
 @ NotNull public static List < Psi@@ Variable > getInput@@ Variables ( @ NotNull Control@@ Flow flow , int start , int end ) { List < Psi@@ Variable > used@@ Variables = get@@ Used@@ Variables ( flow , start , end ) ; List < Psi@@ Variable > array = new ArrayList < > ( used@@ Variables . size ( ) ) ; for ( Psi@@ Variable variable : used@@ Variables ) { if ( need@@ Variable@@ Value@@ At ( variable , flow , start ) ) { array . add ( variable ) ; } } return array ; }
 public static boolean is@@ Metrics@@ Enabled ( ) { Metric@@ Collector mc = Aws@@ Sdk@@ Metrics . mc ; return mc != null && mc . isEnabled ( ) ; }
 public static String getDefault@@ Theme ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ DEFAULT_@@ THE@@ ME , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . WEB_@@ DEFAULT_@@ THE@@ ME , Web@@ Config@@ Default . WEB_@@ DEFAULT_@@ THE@@ ME ) ; } } ) ; return ( String ) cached@@ Config ; }
 private static PsiReferenceExpression get@@ Enclosing@@ ReferenceExpression ( @ NotNull PsiElement element , @ NotNull Psi@@ Variable variable ) { final PsiReferenceExpression reference = find@@ Reference@@ To ( element , variable ) ; if ( reference != null ) return reference ; while ( element != null ) { if ( element instanceof PsiReferenceExpression ) { return ( PsiReferenceExpression ) element ; } if ( element instanceof PsiMethod || element instanceof PsiClass ) { return null ; } element = element . getParent ( ) ; } return null ; }
 public static byte [ ] random@@ Bytes ( ) { return random@@ Bytes ( 100 ) ; }
 public static void die ( String s ) { System . err . println ( s ) ; if ( ! _d@@ ont@@ Die ) H2@@ O . exit ( - 1 ) ; }
 private static boolean read@@ Before@@ Stop@@ Point ( @ NotNull final Control@@ Flow flow , @ NotNull Set < Psi@@ Variable > read@@ Vars , final int startOffset , final int stop@@ Point ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { private boolean reachable = false ; @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { if ( offset == stop@@ Point || is@@ WriteTo@@ Read@@ Var ( instruction ) ) { reachable = false ; return ; } boolean found@@ Read = instruction instanceof Read@@ Variable@@ Instruction && read@@ Vars . contains ( ( ( Read@@ Variable@@ Instruction ) instruction ) . variable ) ; reachable |= found@@ Read ; } private boolean is@@ WriteTo@@ Read@@ Var ( Instruction instruction ) { return instruction instanceof Write@@ Variable@@ Instruction && read@@ Vars . contains ( ( ( Write@@ Variable@@ Instruction ) instruction ) . variable ) ; } @ Override public Boolean getResult ( ) { return reachable ; } } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , startOffset , flow . getSize ( ) ) ; return visitor . getResult ( ) ; }
 @ Converter public static OM@@ D_@@ O@@ 01 to@@ O@@ md@@ O@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( OM@@ D_@@ O@@ 01 . class , body ) ; }
 public static String getRoot@@ Context@@ Config@@ ClassName ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ ROOT_@@ CONTEXT_@@ CONFIG_@@ CLASS , key -> { return properties . get ( key , Web@@ Config@@ Default . CORE_@@ ROOT_@@ CONTEXT_@@ CONFIG_@@ CLASS ) ; } ) ; return ( String ) cached@@ Config ; }
 private static void process@@ Text@@ Content ( List < Object > contents , StringBuilder sb , boolean add@@ Space ) { for ( Object o : contents ) { if ( o instanceof P ) { P p = ( P ) o ; process@@ Text@@ Content ( p . getContent ( ) , sb , true ) ; sb . append ( ' \n ' ) ; } else if ( o instanceof Italic ) { Italic i = ( Italic ) o ; process@@ Text@@ Content ( i . getContent ( ) , sb , true ) ; } else if ( o instanceof Bold ) { Bold b = ( Bold ) o ; process@@ Text@@ Content ( b . getContent ( ) , sb , true ) ; } else if ( o instanceof Mono@@ space ) { Mono@@ space m = ( Mono@@ space ) o ; process@@ Text@@ Content ( m . getContent ( ) , sb , true ) ; } else if ( o instanceof S@@ up ) { S@@ up s = ( S@@ up ) o ; process@@ Text@@ Content ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Sub ) { Sub s = ( Sub ) o ; process@@ Text@@ Content ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof S@@ c ) { S@@ c s = ( S@@ c ) o ; process@@ Text@@ Content ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof X@@ ref ) { } else if ( o instanceof String ) { sb . append ( o ) ; if ( add@@ Space ) sb . append ( ' ▁ ' ) ; } else { } } }
 public static Force@@ TypeOf@@ HttpRequest get@@ Force@@ TypeOf@@ Http@@ Requests ( ) { return force@@ TypeOf@@ Http@@ Requests ; }
 private static Cloud@@ Blob@@ Container getContainer@@ From ( Segment@@ Node@@ Store@@ Persistence persistence ) throws Exception { return ( ( Azure@@ Persistence ) persistence ) . getSegment@@ store@@ Directory ( ) . getContainer ( ) ; }
 public static Temporal@@ Query < ZoneId > zone ( ) { return Temporal@@ Queries . ZONE ; }
 @ Converter public static CR@@ M_@@ C@@ 08 to@@ C@@ rm@@ C@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( CR@@ M_@@ C@@ 08 . class , body ) ; }
 public static String replace@@ By@@ KV ( String tpl , Object ... vals ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < vals . length ; i += 2 ) { if ( i + 1 < vals . length ) { map . put ( String . valueOf ( vals [ i ] ) , vals [ i + 1 ] ) ; } } return replace@@ By@@ Map ( tpl , map ) ; }
 private static String getUserName ( SharedPreferences settings ) { return settings . getString ( Preference@@ Keys . KEY_@@ USERNAME , null ) ; }
 public static boolean has@@ Observable@@ Throw@@ Exit@@ Points ( @ NotNull final Control@@ Flow flow , final int flow@@ Start , final int flow@@ End , @ NotNull PsiElement [ ] elements , @ NotNull PsiElement enclosing@@ Code@@ Fragment ) { final List < Instruction > instructions = flow . get@@ Instructions ( ) ; class Worker { @ NotNull private Map < Psi@@ Variable , Int@@ ArrayList > getWrite@@ s@@ Offsets ( ) { final Map < Psi@@ Variable , Int@@ ArrayList > write@@ Offsets = new TH@@ ash@@ Map < > ( ) ; for ( int i = flow@@ Start ; i < flow@@ End ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Write@@ Variable@@ Instruction ) { final Psi@@ Variable variable = ( ( Write@@ Variable@@ Instruction ) instruction ) . variable ; if ( variable instanceof Psi@@ Local@@ Variable || variable instanceof Psi@@ Parameter ) { Int@@ ArrayList offsets = write@@ Offsets . get ( variable ) ; if ( offsets == null ) write@@ Offsets . put ( variable , offsets = new Int@@ ArrayList ( ) ) ; offsets . add ( i ) ; } } } LOG . debug ( " write@@ Offsets : " , write@@ Offsets ) ; return write@@ Offsets ; } @ NotNull private Map < Psi@@ Variable , Int@@ ArrayList > get@@ Visible@@ Read@@ s@@ Offsets ( @ NotNull Map < Psi@@ Variable , Int@@ ArrayList > write@@ Offsets , @ NotNull Psi@@ CodeBlock try@@ Block ) { final Map < Psi@@ Variable , Int@@ ArrayList > visible@@ Read@@ Offsets = new TH@@ ash@@ Map < > ( ) ; for ( Psi@@ Variable variable : write@@ Offsets . keySet ( ) ) { if ( ! PsiTreeUtil . is@@ Ancestor ( try@@ Block , variable , true ) ) { visible@@ Read@@ Offsets . put ( variable , new Int@@ ArrayList ( ) ) ; } } if ( visible@@ Read@@ Offsets . isEmpty ( ) ) return visible@@ Read@@ Offsets ; for ( int i = 0 ; i < instructions . size ( ) ; i ++ ) { final Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof Read@@ Variable@@ Instruction ) { final Psi@@ Variable variable = ( ( Read@@ Variable@@ Instruction ) instruction ) . variable ; final Int@@ ArrayList read@@ Offsets = visible@@ Read@@ Offsets . get ( variable ) ; if ( read@@ Offsets != null ) { read@@ Offsets . add ( i ) ; } } } LOG . debug ( " visible@@ Read@@ Offsets : " , visible@@ Read@@ Offsets ) ; return visible@@ Read@@ Offsets ; } @ NotNull private Map < Psi@@ Variable , Set < PsiElement > > getRe@@ ach@@ able@@ After@@ Write ( @ NotNull Map < Psi@@ Variable , Int@@ ArrayList > write@@ Offsets , @ NotNull Map < Psi@@ Variable , Int@@ ArrayList > visible@@ Read@@ Offsets ) { final Map < Psi@@ Variable , Set < PsiElement > > after@@ Write = new TH@@ ash@@ Map < > ( ) ; for ( Psi@@ Variable variable : visible@@ Read@@ Offsets . keySet ( ) ) { final Function < Integer , BitSet > calculator = getRe@@ ach@@ able@@ Instruction@@ s@@ Calculator ( ) ; final BitSet collec@@ ted@@ Offsets = new BitSet ( flow@@ End ) ; for ( final int write@@ Offset : write@@ Offsets . get ( variable ) . toArray ( ) ) { LOG . assertTrue ( write@@ Offset >= flow@@ Start , " write@@ Offset " ) ; final BitSet reachable@@ Offsets = calculator . fun ( write@@ Offset ) ; collec@@ ted@@ Offsets . or ( reachable@@ Offsets ) ; } Set < PsiElement > throw@@ Sources = after@@ Write . get ( variable ) ; if ( throw@@ Sources == null ) after@@ Write . put ( variable , throw@@ Sources = new TH@@ ash@@ Set < > ( ) ) ; for ( int i = flow@@ Start ; i < flow@@ End ; i ++ ) { if ( collec@@ ted@@ Offsets . get ( i ) ) { throw@@ Sources . add ( flow . getElement ( i ) ) ; } } final List < PsiElement > sub@@ ordin@@ ates = new ArrayList < > ( ) ; for ( PsiElement element : throw@@ Sources ) { if ( throw@@ Sources . contains ( element . getParent ( ) ) ) { sub@@ ordin@@ ates . add ( element ) ; } } throw@@ Sources . removeAll ( sub@@ ordin@@ ates ) ; } LOG . debug ( " after@@ Write : " , after@@ Write ) ; return after@@ Write ; } @ NotNull private Int@@ ArrayList getC@@ atch@@ Or@@ Fin@@ ally@@ Offsets ( @ NotNull List < ? extends Psi@@ Try@@ Statement > try@@ Statements , @ NotNull List < ? extends PsiClassType > throw@@ n@@ Exceptions ) { final Int@@ ArrayList catch@@ Or@@ Fin@@ ally@@ Offsets = new Int@@ ArrayList ( ) ; for ( Psi@@ Try@@ Statement try@@ Statement : try@@ Statements ) { final Psi@@ CodeBlock fin@@ ally@@ Block = try@@ Statement . get@@ Fin@@ ally@@ Block ( ) ; if ( fin@@ ally@@ Block != null ) { int offset = flow . getStartOffset ( fin@@ ally@@ Block ) ; if ( offset >= 0 ) { catch@@ Or@@ Fin@@ ally@@ Offsets . add ( offset - 2 ) ; } } for ( Psi@@ Catch@@ Section catch@@ Section : try@@ Statement . getC@@ atch@@ Sections ( ) ) { final Psi@@ CodeBlock catch@@ Block = catch@@ Section . getC@@ atch@@ Block ( ) ; final Psi@@ Parameter parameter = catch@@ Section . getParameter ( ) ; if ( catch@@ Block != null && parameter != null ) { for ( PsiClassType throw@@ Type : throw@@ n@@ Exceptions ) { if ( is@@ Cau@@ ght@@ Exception@@ Type ( throw@@ Type , parameter . getType ( ) ) ) { int offset = flow . getStartOffset ( catch@@ Block ) ; if ( offset >= 0 ) { catch@@ Or@@ Fin@@ ally@@ Offsets . add ( offset - 1 ) ; } } } } } } return catch@@ Or@@ Fin@@ ally@@ Offsets ; } private boolean is@@ Any@@ Read@@ Offset@@ Reach@@ able@@ From ( @ Nullable Int@@ ArrayList read@@ Offsets , @ NotNull Int@@ ArrayList from@@ Offsets ) { if ( read@@ Offsets != null && ! read@@ Offsets . isEmpty ( ) ) { final int [ ] read@@ Offset@@ sArray = read@@ Offsets . toArray ( ) ; for ( int j = 0 ; j < from@@ Offsets . size ( ) ; j ++ ) { int from@@ Offset = from@@ Offsets . get ( j ) ; if ( are@@ Instruction@@ s@@ Reachable ( flow , read@@ Offset@@ sArray , from@@ Offset ) ) { LOG . debug ( " reachable@@ From@@ Offset : " , from@@ Offset ) ; return true ; } } } return false ; } @ NotNull private Function < Integer , BitSet > getRe@@ ach@@ able@@ Instruction@@ s@@ Calculator ( ) { final ControlFlow@@ Graph graph = new ControlFlow@@ Graph ( flow . getSize ( ) ) { @ Override void add@@ Arc ( int offset , int next@@ Offset ) { next@@ Offset = promo@@ te@@ Through@@ Goto@@ Chain ( flow , next@@ Offset ) ; if ( next@@ Offset >= flow@@ Start && next@@ Offset < flow@@ End ) { super . add@@ Arc ( offset , next@@ Offset ) ; } } } ; graph . build@@ From ( flow ) ; return startOffset -> { BitSet visited@@ Offsets = new BitSet ( flow@@ End ) ; graph . depth@@ First@@ Search ( startOffset , visited@@ Offsets ) ; return visited@@ Offsets ; } ; } } final Worker worker = new Worker ( ) ; final Map < Psi@@ Variable , Int@@ ArrayList > write@@ Offsets = worker . getWrite@@ s@@ Offsets ( ) ; if ( write@@ Offsets . isEmpty ( ) ) return false ; final PsiElement common@@ Parent = elements . length != 1 ? PsiTreeUtil . find@@ Common@@ Parent ( elements ) : elements [ 0 ] . getParent ( ) ; final List < Psi@@ Try@@ Statement > try@@ Statements = collect@@ Try@@ Statement@@ Stack ( common@@ Parent , enclosing@@ Code@@ Fragment ) ; if ( try@@ Statements . isEmpty ( ) ) return false ; final Psi@@ CodeBlock try@@ Block = try@@ Statements . get ( 0 ) . get@@ Try@@ Block ( ) ; if ( try@@ Block == null ) return false ; final Map < Psi@@ Variable , Int@@ ArrayList > visible@@ Read@@ Offsets = worker . get@@ Visible@@ Read@@ s@@ Offsets ( write@@ Offsets , try@@ Block ) ; if ( visible@@ Read@@ Offsets . isEmpty ( ) ) return false ; final Map < Psi@@ Variable , Set < PsiElement > > after@@ Write = worker . getRe@@ ach@@ able@@ After@@ Write ( write@@ Offsets , visible@@ Read@@ Offsets ) ; if ( after@@ Write . isEmpty ( ) ) return false ; for ( Map . Entry < Psi@@ Variable , Set < PsiElement > > entry : after@@ Write . entrySet ( ) ) { final Psi@@ Variable variable = entry . getKey ( ) ; final PsiElement [ ] psi@@ Elements = entry . getValue ( ) . toArray ( PsiElement . EMPTY_ARRAY ) ; final List < PsiClassType > throw@@ n@@ Exceptions = Exception@@ Util . get@@ Throw@@ n@@ Exceptions ( psi@@ Elements ) ; if ( ! throw@@ n@@ Exceptions . isEmpty ( ) ) { final Int@@ ArrayList catch@@ Or@@ Fin@@ ally@@ Offsets = worker . getC@@ atch@@ Or@@ Fin@@ ally@@ Offsets ( try@@ Statements , throw@@ n@@ Exceptions ) ; if ( worker . is@@ Any@@ Read@@ Offset@@ Reach@@ able@@ From ( visible@@ Read@@ Offsets . get ( variable ) , catch@@ Or@@ Fin@@ ally@@ Offsets ) ) { return true ; } } } return false ; }
 @ Converter public static AD@@ T_@@ A@@ 42 to@@ Ad@@ t@@ A@@ 42 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 42 . class , body ) ; }
 private static String strip@@ Enum@@ Suffix ( String className ) { if ( className . endsWith ( " Enum " ) ) { return className . substring ( 0 , className . length ( ) - 4 ) ; } return className ; }
 public static void main ( String [ ] args ) { try { A@@ Box@@ Materializ@@ er@@ Example example = new A@@ Box@@ Materializ@@ er@@ Example ( ) ; example . generate@@ Trip@@ les ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
 public static Serializer get@@ Exact@@ Serializer ( Class cls ) { return class@@ Registr@@ ations . get ( cls ) . get@@ Serializer ( ) ; }
 private static void write@@ Manifest ( Jar@@ OutputStream jar@@ OutputStream , String name ) throws Exception { write@@ Dir@@ Entry ( jar@@ OutputStream , " META - INF / " ) ; Manifest manifest = new Manifest ( ) ; manifest . getMain@@ Attributes ( ) . putValue ( " Built - By " , name ) ; manifest . getMain@@ Attributes ( ) . put ( Attributes . Name . MANIF@@ EST_@@ VERSION , "1.0" ) ; jar@@ OutputStream . put@@ Next@@ Entry ( new ZipEntry ( " META - INF / MANIF@@ EST . MF " ) ) ; manifest . write ( jar@@ OutputStream ) ; jar@@ OutputStream . close@@ Entry ( ) ; }
 protected static float [ ] get@@ Bin@@ omi@@ al@@ Kernel@@ Sig@@ ma@@ Two@@ SQ@@ RT@@ 2 ( ) { double a = 1. / 41@@ 00000000@@ l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 30@@ l * a ) , ( float ) ( 433@@ l * a ) , ( float ) ( 400@@ 0l * a ) , ( float ) ( 265@@ 36@@ l * a ) , ( float ) ( 13@@ 44@@ 16@@ l * a ) , ( float ) ( 539@@ 400@@ l * a ) , ( float ) ( 175@@ 48@@ 48@@ l * a ) , ( float ) ( 469@@ 27@@ 80@@ l * a ) , ( float ) ( 10@@ 37@@ 805@@ 6@@ l * a ) , ( float ) ( 189@@ 329@@ 40@@ l * a ) , ( float ) ( 28@@ 04@@ 88@@ 00@@ l * a ) , ( float ) ( 32@@ 256@@ 12@@ 0l * a ) , ( float ) ( 24@@ 812@@ 400@@ l * a ) , ( float ) ( 24@@ 812@@ 40@@ l * a ) , ( float ) ( - 29@@ 77@@ 488@@ 0l * a ) , ( float ) ( - 589@@ 29@@ 45@@ 0l * a ) , ( float ) ( - 707@@ 15@@ 34@@ 0l * a ) , ( float ) ( - 589@@ 29@@ 45@@ 0l * a ) , ( float ) ( - 29@@ 77@@ 488@@ 0l * a ) , ( float ) ( 24@@ 812@@ 40@@ l * a ) , ( float ) ( 24@@ 812@@ 400@@ l * a ) , ( float ) ( 32@@ 256@@ 12@@ 0l * a ) , ( float ) ( 28@@ 04@@ 88@@ 00@@ l * a ) , ( float ) ( 189@@ 329@@ 40@@ l * a ) , ( float ) ( 10@@ 37@@ 805@@ 6@@ l * a ) , ( float ) ( 469@@ 27@@ 80@@ l * a ) , ( float ) ( 175@@ 48@@ 48@@ l * a ) , ( float ) ( 539@@ 400@@ l * a ) , ( float ) ( 13@@ 44@@ 16@@ l * a ) , ( float ) ( 265@@ 36@@ l * a ) , ( float ) ( 400@@ 0l * a ) , ( float ) ( 433@@ l * a ) , ( float ) ( 30@@ l * a ) , ( float ) ( 1l * a ) } ; }
 private static Method find@@ Method ( Fixture fixture , String simple@@ Name ) { Method [ ] methods = getTarget@@ Class ( fixture ) . get@@ Methods ( ) ; Method method = null ; Method [ ] var@@ 4 = methods ; int var@@ 5 = methods . length ; for ( int var@@ 6 = 0 ; var@@ 6 < var@@ 5 ; ++ var@@ 6 ) { Method possible@@ Method = var@@ 4 [ var@@ 6 ] ; if ( simple@@ Name . equalsIgnoreCase ( possible@@ Method . getName ( ) ) ) { method = possible@@ Method ; break ; } } return method ; }
 @ Converter public static REF_@@ I@@ 12 to@@ Ref@@ I@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( REF_@@ I@@ 12 . class , body ) ; }
 @ Converter public static MF@@ N_@@ M@@ 10 to@@ M@@ fn@@ M@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 10 . class , body ) ; }
 protected static Map < Integer , Bar@@ code > to@@ Barcode@@ Map ( ResultSet resultSet ) throws SQLException { Map < Integer , Bar@@ code > result = new HashMap < Integer , Bar@@ code > ( ) ; while ( resultSet . next ( ) ) { Bar@@ code barcode = new Bar@@ code ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; result . put ( resultSet . getInt ( 1 ) , barcode ) ; } return result ; }
 public static Search@@ Operation new@@ Search@@ Operation ( final String base@@ Dn , final String filter@@ Query , final String ... params ) { final var operation = new Search@@ Operation ( ) ; operation . set@@ Request ( SearchRequest . builder ( ) . dn ( base@@ Dn ) . filter ( new@@ Search@@ Filter ( filter@@ Query , params ) ) . return@@ Attributes ( Return@@ Attributes . ALL . value ( ) ) . scope ( SearchScope . SUB@@ TREE ) . build ( ) ) ; return operation ; }
 @ Converter public static VX@@ R_@@ V@@ 03 to@@ V@@ x@@ r@@ V@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( VX@@ R_@@ V@@ 03 . class , body ) ; }
 @ Converter public static PP@@ R_@@ PC@@ 3 to@@ P@@ pr@@ P@@ c3 ( String body ) throws HL7@@ Exception { return to@@ Message ( PP@@ R_@@ PC@@ 3 . class , body ) ; }
 public static void draw_@@ String_@@ Value ( int row@@ Y , Image img , int x_@@ img , int num , int x_@@ num , int maxNum@@ Length , Graphics g ) { g . drawImage ( img , x_@@ img , row@@ Y , null ) ; Number@@ Renderer . draw@@ Number ( num , x_@@ num , row@@ Y , maxNum@@ Length , g ) ; }
 public static void setN@@ ail ( Buil@@ dr@@ N@@ ail _n@@ ail ) { n@@ ail = _n@@ ail ; }
 public static Search@@ Results getSearch@@ Results@@ For ( final Context context , final String query , final int position ) { final List < Integer > positions = new ArrayList < > ( ) ; final List < LinkedHashMap < Integer , Integer > > indices = new ArrayList < > ( ) ; int i = 0 ; for ( final String title : getSub@@ scriptions ( context ) . asMap ( ) . keySet ( ) ) { if ( StringUtils . contains@@ IgnoreCase ( title , query ) ) { indices . add ( Search@@ Utils . get@@ Indices@@ For@@ Query ( title , query ) ) ; positions . add ( i ) ; } i ++ ; } return new Search@@ Results ( position , positions , indices ) ; }
 public static Map < String , String > decode@@ Authorization ( String authorization ) { Map < String , String > oauth@@ Parameters = new HashMap < String , String > ( ) ; if ( authorization != null ) { Matcher m = AUTHORIZ@@ ATION_@@ PATTERN . matcher ( authorization ) ; if ( m . matches ( ) ) { if ( " oauth " . equalsIgnoreCase ( m . group ( 1 ) ) ) { for ( String key@@ ValuePair : m . group ( 2 ) . split ( " \\ s * , \\ s * " ) ) { m = KEY@@ VALUE@@ PA@@ IR_@@ PATTERN . matcher ( key@@ ValuePair ) ; if ( m . matches ( ) ) { String key = OAuth@@ Utils . decode@@ Percent ( m . group ( 1 ) ) ; String value = OAuth@@ Utils . decode@@ Percent ( m . group ( 2 ) ) ; oauth@@ Parameters . put ( key , value ) ; } } } } } return oauth@@ Parameters ; }
 public static int read@@ I@@ ll@@ umin@@ ance@@ Value ( byte [ ] bytes ) { if ( bytes . length < 2 ) { return 0 ; } return de@@ compress_@@ light ( bytes [ 1 ] & Motion@@ Event@@ Compat . ACTION_@@ MASK ) ; }
 @ Converter public static R@@ Q@@ I_@@ I@@ 01 to@@ R@@ qi@@ I@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ I_@@ I@@ 01 . class , body ) ; }
 public static JB@@ Color getRoot@@ BackgroundColor ( @ NotNull VirtualFile root , @ NotNull Vcs@@ Log@@ Color@@ Manager color@@ Manager ) { return Vcs@@ Log@@ Color@@ ManagerImpl . get@@ BackgroundColor ( color@@ Manager . getRoot@@ Color ( root ) ) ; }
 @ NotNull private static Optional < Boolean > match ( @ Nullable Py@@ Type expected , @ Nullable Py@@ Type actual , @ NotNull Match@@ Context context ) { final Pair < Py@@ Type , Py@@ Type > types = Pair . create ( expected , actual ) ; if ( context . matching . contains ( types ) ) return Optional . of ( true ) ; context . matching . add ( types ) ; final Optional < Boolean > result = match@@ Impl ( expected , actual , context ) ; context . matching . remove ( types ) ; return result ; }
 public static void invokeLater ( final Project p , final Modality@@ State state , final Runnable r ) { if ( is@@ No@@ Background@@ Mode ( ) ) { r . run ( ) ; } else { ApplicationManager . getApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { if ( p . isDisposed ( ) ) return ; r . run ( ) ; } } , state ) ; } }
 public static synchronized Image@@ Exchange@@ ApplicationContext getSingleton ( String [ ] contexts ) { if ( singleton == null && contexts == null ) throw new Image@@ Exchange@@ ApplicationContext@@ Initialization@@ Error ( " Image@@ Exchange@@ ApplicationContext ▁ may ▁ not ▁ be ▁ explicitly ▁ initialized ▁ with ▁ a ▁ null ▁ context . " ) ; if ( singleton != null ) { if ( contexts . length != effective@@ ApplicationContext . length ) throw new Image@@ Exchange@@ ApplicationContext@@ Initialization@@ Error ( " Image@@ Exchange@@ ApplicationContext ▁ may ▁ not ▁ be ▁ re - initialized ▁ with ▁ a ▁ different ▁ context . " ) ; for ( int index = 0 ; index < contexts . length ; ++ index ) if ( ! contexts [ index ] . equalsIgnoreCase ( effective@@ ApplicationContext [ index ] ) ) throw new Image@@ Exchange@@ ApplicationContext@@ Initialization@@ Error ( " Image@@ Exchange@@ ApplicationContext ▁ may ▁ not ▁ be ▁ re - initialized ▁ with ▁ a ▁ different ▁ context . " ) ; log . warn ( " Image@@ Exchange@@ ApplicationContext . getSingleton ▁ was ▁ called ▁ twice ▁ with ▁ the ▁ same ▁ context . " ) ; } if ( singleton == null ) { effective@@ ApplicationContext = contexts ; singleton = new Image@@ Exchange@@ ApplicationContext ( ) ; } return singleton ; }
 @ NotNull static public Map < String , PsiElement > getArray@@ Values@@ As@@ Map ( @ NotNull Array@@ Creation@@ Expression array@@ Creation@@ Expression ) { List < PsiElement > array@@ Values = Ph@@ p@@ PsiUtil . getChildren ( array@@ Creation@@ Expression , new Condition < PsiElement > ( ) { @ Override public boolean value ( PsiElement psiElement ) { return psiElement . getNode ( ) . getElementType ( ) == Ph@@ p@@ ElementTypes . ARRAY_@@ VALUE ; } } ) ; if ( array@@ Values == null ) { return Collections . emptyMap ( ) ; } Map < String , PsiElement > keys = new HashMap < String , PsiElement > ( ) ; for ( PsiElement child : array@@ Values ) { String stringValue = Ph@@ p@@ Elements@@ Util . getStringValue ( child . getFirstChild ( ) ) ; if ( stringValue != null && StringUtils . isNotBlank ( stringValue ) ) { keys . put ( stringValue , child ) ; } } return keys ; }
 @ NotNull public static Psi@@ Variable [ ] getOutput@@ Variables ( @ NotNull Control@@ Flow flow , int start , int end , @ NotNull int [ ] exit@@ Points ) { Collection < Psi@@ Variable > written@@ Variables = get@@ Written@@ Variables ( flow , start , end , false ) ; List < Psi@@ Variable > array = new ArrayList < > ( ) ; for ( Psi@@ Variable variable : written@@ Variables ) { for ( int exit@@ Point : exit@@ Points ) { if ( need@@ Variable@@ Value@@ At ( variable , flow , exit@@ Point ) ) { array . add ( variable ) ; } } } Psi@@ Variable [ ] output@@ Variables = array . toArray ( new Psi@@ Variable [ 0 ] ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " output ▁ variables : " ) ; for ( Psi@@ Variable variable : output@@ Variables ) { LOG . debug ( " ▁ ▁ " + variable ) ; } } return output@@ Variables ; }
 public static void main ( String [ ] args ) { ArrayList < Co@@ ffe@@ e > coffe@@ es = new ArrayList < Co@@ ffe@@ e > ( ) ; for ( Co@@ ffe@@ e c : new Co@@ ffe@@ e@@ Generator ( 10 ) ) coffe@@ es . add ( c ) ; System . out . println ( coffe@@ es ) ; }
 public static List@@ Tag@@ sFor@@ Resource@@ Result@@ JsonUnmarshaller getInstance ( ) { if ( instance == null ) instance = new List@@ Tag@@ sFor@@ Resource@@ Result@@ JsonUnmarshaller ( ) ; return instance ; }
 private static Seq@@ Activity build@@ Activity@@ Node ( Node i@@ Node , Node i@@ Coll ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " build@@ Activity@@ Node " ) ; } Seq@@ Activity act = new Seq@@ Activity ( ) ; boolean error = false ; String temp@@ Val = null ; act . set@@ ID ( AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " identifier " ) ) ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " identifier@@ ref " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { act . set@@ Resource@@ ID ( temp@@ Val ) ; } } temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( i@@ Node , " is@@ visible " ) ; if ( temp@@ Val != null ) { if ( ! isEmpty ( temp@@ Val ) ) { act . setIs@@ Visible ( ( Boolean . valueOf ( temp@@ Val ) ) . booleanValue ( ) ) ; } } NodeList children = i@@ Node . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " item " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ an ▁ < item > ▁ element " ) ; } Seq@@ Activity nested@@ Act = AD@@ L@@ Seq@@ Utilities . build@@ Activity@@ Node ( curNode , i@@ Coll ) ; if ( nested@@ Act != null ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Adding ▁ child " ) ; } act . addChild ( nested@@ Act ) ; } else { error = true ; } } else if ( curNode . getLocalName ( ) . equals ( " title " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < title > ▁ element " ) ; } act . setTitle ( AD@@ L@@ Seq@@ Utilities . getElement@@ Text ( curNode , null ) ) ; } else if ( curNode . getLocalName ( ) . equals ( " sequ@@ enc@@ ing " ) ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < sequ@@ enc@@ ing > ▁ element " ) ; } Node seq@@ Info = curNode ; temp@@ Val = AD@@ L@@ Seq@@ Utilities . getAttribute ( curNode , " ID@@ Ref " ) ; if ( temp@@ Val != null ) { String search = " im@@ ss@@ s : sequ@@ enc@@ ing [ @ ID = ' " + temp@@ Val + " ' ] " ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Look@@ ing ▁ for ▁ X@@ PATH ▁ - - > ▁ " + search ) ; } Node seq@@ Global = null ; XPath@@ Factory path@@ Factory = XPath@@ Factory . newInstance ( ) ; XPath path = path@@ Factory . new@@ XPath ( ) ; try { seq@@ Global = ( Node ) path . evaluate ( search , i@@ Coll , XPath@@ Constants . NODE ) ; } catch ( Exception e ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ In ▁ transform " ) ; e . printStackTrace ( ) ; } } if ( seq@@ Global != null ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ FOUND " ) ; } } else { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR : ▁ Not ▁ Found " ) ; } seq@@ Info = null ; error = true ; } if ( ! error ) { seq@@ Info = seq@@ Global . clone@@ Node ( true ) ; NodeList seq@@ Children = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < seq@@ Children . getLength ( ) ; j ++ ) { Node cur@@ Child = seq@@ Children . item ( j ) ; if ( cur@@ Child . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Local ▁ definition " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ ▁ " + j ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ < " + cur@@ Child . getLocalName ( ) + " > " ) ; } try { seq@@ Info . appendChild ( cur@@ Child ) ; } catch ( org . w3c . dom . DOMException e ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR : ▁ " ) ; e . printStackTrace ( ) ; } error = true ; seq@@ Info = null ; } } } } } if ( seq@@ Info != null ) { error = ! AD@@ L@@ Seq@@ Utilities . extract@@ Seq@@ Info ( seq@@ Info , act ) ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Extr@@ acted ▁ Sequ@@ enc@@ ing ▁ Info " ) ; } } } } } if ( act . getResource@@ ID ( ) == null && ! act . has@@ Children ( true ) ) { error = true ; } if ( error ) { act = null ; } if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ error ▁ = = ▁ " + error ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " build@@ Activity@@ Node " ) ; } return act ; }
 private static int LC@@ Sub@@ Str@@ _@@ DP ( char X [ ] , char Y [ ] ) { int m = X . length ; int n = Y . length ; int LC@@ Stuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { LC@@ Stuff [ i ] [ j ] = 1 + LC@@ Stuff [ i - 1 ] [ j - 1 ] ; result = Integer . max ( result , LC@@ Stuff [ i ] [ j ] ) ; } else { LC@@ Stuff [ i ] [ j ] = 0 ; } } } return result ; }
 public static Collection < String > find@@ In@@ Base@@ Directory ( @ Nullable VirtualFile baseDir ) { List < String > candidates = new ArrayList < > ( ) ; if ( baseDir != null ) { baseDir . refresh ( true , false ) ; VirtualFile [ ] su@@ spec@@ ts = baseDir . getChildren ( ) ; for ( VirtualFile child : su@@ spec@@ ts ) { candidates . addAll ( find@@ In@@ Root@@ Directory ( child ) ) ; } } return candidates ; }
 public static String getApi@@ RootPath ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . WEB_@@ API_@@ ROOT_@@ PATH , key -> { String result = properties . get ( key , Web@@ Config@@ Default . WEB_@@ API_@@ ROOT_@@ PATH ) ; if ( ! StringUtils . has@@ Text ( result ) ) throw new RuntimeException ( key + " can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = Common@@ Utils . convert@@ Dir@@ To@@ Unix@@ Format ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } ) ; return ( String ) cached@@ Config ; }
 public static Long to@@ Nano@@ Second ( LocalTime lt ) { Long i = ( lt == null ? null : new Long ( lt . to@@ Nano@@ OfDay ( ) ) ) ; return i ; }
 static public < T extends Throwable > T err ( Sys t , String msg , T exception ) { Event e = Event . make ( t , Kind . ERR@@ R , exception , msg ) ; write ( e , true , false ) ; return exception ; }
 @ TargetApi ( 16 ) private static void assert@@ Optional@@ V@@ 16 ( Media@@ Format format , String key , String value ) { if ( value == null ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getString ( key ) ) . isEqualTo ( value ) ; } }
 @ TargetApi ( 16 ) private static void assert@@ Optional@@ V@@ 16 ( Media@@ Format format , String key , int value ) { if ( value == Format . NO_@@ VALUE ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getInteger ( key ) ) . isEqualTo ( value ) ; } }
 private static void validate@@ Sql@@ Firewall@@ Rule@@ NotFound ( ) { Assert . assertNull ( sql@@ Server@@ Manager . sql@@ Servers ( ) . getBy@@ Resource@@ Group ( R@@ G_@@ NAME , SQL@@ _SERVER_@@ NAME ) . fire@@ wall@@ Rules ( ) . get ( SQL_@@ FIRE@@ WAL@@ L@@ RULE_@@ NAME ) ) ; }
 public static Metric < Double > gen@@ Gauge@@ Def ( ) { return ( Metric < Double > ) gen@@ Def ( Metric@@ Type . G@@ AU@@ GE ) ; }
 private static final byte [ ] get@@ Byte@@ Key ( Serializable sessionId ) { String keys = Constants@@ Sh@@ iro . SHI@@ RO_@@ CACHE_@@ SESSION + " : " + sessionId . toString ( ) ; return keys . getBytes ( ) ; }
 private static void create@@ HBase@@ Table@@ 1 ( ) throws IOException { TableName tableName = TableName . valueOf ( TEST_@@ TABLE_@@ 1 ) ; createTable ( tableName , F@@ AM@@ ILI@@ ES , SP@@ LIT_@@ KEYS ) ; Table table = open@@ Table ( tableName ) ; List < Put > puts = new ArrayList < > ( ) ; puts . add ( put@@ Row ( 1 , 10 , " Hello - 1" , 100L , 1.@@ 01 , false , " W@@ elt - 1" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 18 ▁ 19@@ :00:00@@ " ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 18" ) , Time . valueOf ( "19@@ :00:00@@ " ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 0001@@ " ) ) ) ; puts . add ( put@@ Row ( 2 , 20 , " Hello - 2" , 200@@ L , 2.@@ 02 , true , " W@@ elt - 2" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 18 ▁ 19:@@ 01@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 18" ) , Time . valueOf ( "19@@ :@@ 01@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 02" ) ) ) ; puts . add ( put@@ Row ( 3 , 30 , " Hello - 3" , 300@@ L , 3.@@ 03 , false , " W@@ elt - 3" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 18 ▁ 19:@@ 02@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 18" ) , Time . valueOf ( "19@@ :@@ 02@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 03" ) ) ) ; puts . add ( put@@ Row ( 4 , 40 , null , 400@@ L , 4.@@ 04 , true , " W@@ elt - 4" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 18 ▁ 19:@@ 03@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 18" ) , Time . valueOf ( "19@@ :@@ 03@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 04" ) ) ) ; puts . add ( put@@ Row ( 5 , 50 , " Hello - 5" , 500@@ L , 5.@@ 05 , false , " W@@ elt - 5" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 19 ▁ 19:@@ 10@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 19@@ " ) , Time . valueOf ( "19@@ :@@ 10@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 05" ) ) ) ; puts . add ( put@@ Row ( 6 , 60 , " Hello - 6" , 600@@ L , 6.@@ 06 , true , " W@@ elt - 6" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 19 ▁ 19:@@ 20@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 19@@ " ) , Time . valueOf ( "19@@ :@@ 20@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 06@@ " ) ) ) ; puts . add ( put@@ Row ( 7 , 70 , " Hello - 7" , 700@@ L , 7.@@ 07 , false , " W@@ elt - 7" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 19 ▁ 19:@@ 30@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 19@@ " ) , Time . valueOf ( "19@@ :@@ 30@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 07" ) ) ) ; puts . add ( put@@ Row ( 8 , 80 , null , 800@@ L , 8.@@ 08 , true , " W@@ elt - 8" , Timestamp . valueOf ( "201@@ 9-@@ 08-@@ 19 ▁ 19:@@ 40@@ :00" ) , Date . valueOf ( "201@@ 9-@@ 08-@@ 19@@ " ) , Time . valueOf ( "19@@ :@@ 40@@ :00" ) , new BigDecimal ( "12@@ 34567@@ 8.@@ 00@@ 08" ) ) ) ; table . put ( puts ) ; table . close ( ) ; }
 public static void add@@ Remove@@ Set ( int i , HashSet < Integer > set ) { if ( set . contains ( i ) ) { set . remove ( i ) ; } else { set . add ( i ) ; } }
 public static int from@@ Base64 ( char c ) { int result = BASE@@ 64_@@ DECODE_@@ MAP [ c ] ; assert ( result != - 1 ) : " invalid ▁ char " ; return BASE@@ 64_@@ DECODE_@@ MAP [ c ] ; }
 public static String getRe@@ dis@@ Host ( ) { return ( String ) CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . RE@@ DI@@ S_@@ HOST , key -> properties . get ( key , Web@@ Config@@ Default . RE@@ DI@@ S_@@ HOST ) ) ; }
 private static Field getField ( Class < ? > clazz , String fieldName ) throws NoSuch@@ FieldException { try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuch@@ FieldException var@@ 4 ) { Class < ? > superClass = clazz . getSuper@@ class ( ) ; if ( superClass == null ) { throw var@@ 4 ; } else { return getField ( superClass , fieldName ) ; } } }
 @ Converter public static MD@@ M_@@ T@@ 09 to@@ M@@ dm@@ T@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 09 . class , body ) ; }
 @ Query@@ Delegate ( Delegate@@ Test . User . class ) public static String@@ Path getName ( Q@@ Delegate@@ Test_@@ User user ) { return user . name ; }
 public static boolean set@@ Course@@ Status ( String i@@ Course@@ ID , String i@@ Lear@@ ner@@ ID , String i@@ Satisfied , String i@@ Measure , String i@@ Completed ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " set@@ Course@@ Status " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Course@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Lear@@ ner@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Satisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Measure ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + i@@ Completed ) ; } boolean success = true ; if ( ! ( i@@ Satisfied . equals ( " unknown " ) || i@@ Satisfied . equals ( " satisfied " ) || i@@ Satisfied . equals ( " not@@ Satisfied " ) ) ) { success = false ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + i@@ Satisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " set@@ Course@@ Status " ) ; } return success ; } if ( ! ( i@@ Completed . equals ( " unknown " ) || i@@ Completed . equals ( " completed " ) || i@@ Completed . equals ( " incomplete " ) ) ) { success = false ; if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + i@@ Completed ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " set@@ Course@@ Status " ) ; } return success ; } try { double measure = Double . parseDouble ( i@@ Measure ) ; if ( measure < - 1.0 || measure > 1.0 ) { success = false ; } } catch ( Exception e ) { success = false ; } if ( ! success ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + i@@ Measure ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " set@@ Course@@ Status " ) ; } return success ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ AD@@ L@@ Seq@@ Uti@@ lies : set@@ Course@@ Status " ) ; return success ; }
 public static void update@@ Subscription@@ Url ( final Context context , final String feed@@ Url ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final int position = getCurrent@@ Feed@@ Position ( context ) ; final String title = getSub@@ scription@@ Title@@ At ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; values . set ( 2 , feed@@ Url ) ; subscriptions . replace@@ Values ( title , values ) ; save@@ Sub@@ scriptions ( context , subscriptions ) ; }
 @ Converter public static C@@ SU@@ _C@@ 12 to@@ C@@ su@@ C@@ 12 ( String body ) throws HL7@@ Exception { return to@@ Message ( C@@ SU@@ _C@@ 12 . class , body ) ; }
 public static void pause ( @ Nonnull Condition condition ) { pause ( condition , DEFAULT_@@ DELAY ) ; }
 public static void Update@@ Repo@@ To@@ Last@@ Commit ( Repository@@ Node repo@@ Node ) { Statement s@@ mt ; String sql ; try { s@@ mt = conn . createStatement ( ) ; sql = " UPDATE ▁ TRE@@ POSI@@ TORY ▁ SET ▁ Last@@ Commit@@ Id ▁ = ▁ " + " ( SELECT ▁ distinct ( id ) ▁ FROM ▁ T@@ COMMIT ▁ where ▁ date ▁ = ▁ ( select ▁ max ( date ) ▁ from ▁ T@@ COMMIT ) ) " + " WHERE ▁ Name ▁ = ▁ ' " + repo@@ Node . getName ( ) + " ' ; " ; s@@ mt . executeUpdate ( sql ) ; s@@ mt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
 public static Category@@ Fragment newInstance ( int index ) { Bundle bundle = new Bundle ( ) ; bundle . putInt ( Cont@@ ants . INDEX , index ) ; Category@@ Fragment fragment = new Category@@ Fragment ( ) ; fragment . set@@ Arguments ( bundle ) ; return fragment ; }
 @ Converter public static MF@@ N_@@ M@@ 09 to@@ M@@ fn@@ M@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 09 . class , body ) ; }
 public static boolean is@@ Do@@ minator ( Control@@ Flow flow , int maybe@@ Do@@ minator , int target ) { class My@@ Visitor extends Instruction@@ Client@@ Visitor < Boolean > { final BitSet my@@ Reached@@ Without@@ Do@@ minator = new BitSet ( ) ; @ Override public void visit@@ Instruction ( Instruction instruction , int offset , int next@@ Offset ) { super . visit@@ Instruction ( instruction , offset , next@@ Offset ) ; if ( next@@ Offset != maybe@@ Do@@ minator && ( target == next@@ Offset || my@@ Reached@@ Without@@ Do@@ minator . get ( next@@ Offset ) ) ) { my@@ Reached@@ Without@@ Do@@ minator . set ( offset ) ; } } @ Override public Boolean getResult ( ) { return my@@ Reached@@ Without@@ Do@@ minator . get ( 0 ) ; } } My@@ Visitor visitor = new My@@ Visitor ( ) ; depth@@ First@@ Search ( flow , visitor , 0 , target ) ; return ! visitor . getResult ( ) ; }
 @ Converter public static S@@ UR_@@ P@@ 09 to@@ Sur@@ P@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( S@@ UR_@@ P@@ 09 . class , body ) ; }
 public static synchronized Test@@ Net@@ 3@@ Params get ( ) { if ( instance == null ) { instance = new Test@@ Net@@ 3@@ Params ( ) ; } return instance ; }
 public static Instruction get ( String name ) { return instruction@@ Map . get ( name ) ; }
 @ Parameters public static Object [ ] [ ] parameters ( ) { Iterator@@ Test@@ Input input = get@@ Iterator@@ Input ( ) ; Iterator@@ Test@@ Output output = get@@ Iterator@@ Output ( ) ; List < Iterator@@ TestCase > tests = Iterator@@ TestCase@@ Finder . findAll@@ TestCases ( ) ; return Base@@ JUnit4@@ Iterator@@ Test . create@@ Parameters ( input , output , tests ) ; }
 static public PsiElement@@ Pattern . Capture < StringLiteral@@ Expression > getMethod@@ Return@@ Pattern ( ) { return Platform@@ Patterns . psiElement ( StringLiteral@@ Expression . class ) . with@@ Parent ( Platform@@ Patterns . psiElement ( Ph@@ p@@ Return . class ) . inside ( Method . class ) ) . with@@ Language ( Ph@@ p@@ Language . INSTANCE ) ; }
 public static byte [ ] encode@@ _bin ( byte [ ] data ) { byte [ ] out = new byte [ 8 * data . length ] ; for ( int i = 0 ; i < data . length ; i ++ ) { int ch = ( int ) data [ i ] ; if ( ch < 0 ) ch = 256 + ch ; byte [ ] conv = _char@@ _to_@@ bin [ ch ] ; System . arraycopy ( conv , 0 , out , i * 8 , 8 ) ; } return out ; }
 public static _Fields findByThrift@@ Id ( int fieldId ) { switch ( fieldId ) { case 1 : return class_@@ NAME ; case 2 : return ST ; case 3 : return INTER@@ PRE@@ TER_@@ CONTEXT ; default : return null ; } }
 public static void verify@@ Manifest@@ Service ( Context context , Class < ? extends Service > cls ) { try { context . getPackage@@ Manager ( ) . getService@@ Info ( new ComponentName ( context , cls ) , PackageManager . GET_@@ DISAB@@ LED_@@ COMPONE@@ N@@ TS ) ; } catch ( Exception ignored ) { report@@ Missing@@ Component ( context , cls ) ; } }
 private static Simple@@ Bind@@ Authentication@@ Handler getP@@ oo@@ led@@ Bind@@ Authentication@@ Handler ( final Ldap@@ Authentication@@ Properties l ) { final var handler = new Simple@@ Bind@@ Authentication@@ Handler ( new@@ Pooled@@ ConnectionFactory ( l ) ) ; handler . set@@ Authentication@@ Controls ( new Password@@ Policy@@ Control ( ) ) ; return handler ; }
 public static PsiElement getUn@@ reachable@@ Statement ( @ NotNull Control@@ Flow flow ) { final Instruction@@ Client@@ Visitor < PsiElement > visitor = new Un@@ reachable@@ Statement@@ Client@@ Visitor ( flow ) ; depth@@ First@@ Search ( flow , visitor ) ; return visitor . getResult ( ) ; }
 @ Converter public static AD@@ T_@@ A@@ 27 to@@ Ad@@ t@@ A@@ 27 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 27 . class , body ) ; }
 public static List < Variable > getVariable@@ References@@ InScope ( final Variable variable , final boolean include@@ Self ) { final List < Variable > variables = new ArrayList < Variable > ( ) ; Variable variable@@ Decl = null ; if ( ! variable . is@@ Declaration ( ) ) { PsiElement psiElement = variable . resolve ( ) ; if ( psiElement instanceof Variable ) { variable@@ Decl = ( Variable ) psiElement ; } } else { variable@@ Decl = variable ; } if ( variable@@ Decl == null ) { return variables ; } Method method = PsiTreeUtil . getParent@@ OfType ( variable , Method . class ) ; Ph@@ p@@ PsiUtil . has@@ References@@ In@@ SearchScope ( method . getUse@@ Scope ( ) , variable@@ Decl , new Common@@ Processors . Find@@ Processor < PsiReference > ( ) { @ Override protected boolean accept ( PsiReference psi@@ Reference ) { PsiElement variable@@ Ref = psi@@ Reference . getElement ( ) ; if ( variable@@ Ref instanceof Variable ) { if ( include@@ Self ) { variables . add ( ( Variable ) variable@@ Ref ) ; } else { if ( ! variable@@ Ref . equals ( variable ) ) { variables . add ( ( Variable ) variable@@ Ref ) ; } } } return false ; } } ) ; return variables ; }
 @ NotNull public static Collection < Psi@@ Variable > get@@ Written@@ Variables ( @ NotNull Control@@ Flow flow , int start , int end , final boolean ignore@@ Not@@ Reach@@ ing@@ Writes ) { Set < Psi@@ Variable > set = new HashSet < > ( ) ; get@@ Written@@ Variables ( flow , start , end , ignore@@ Not@@ Reach@@ ing@@ Writes , set ) ; return set ; }
 private static Linked@@ ListMultimap < String , String > getSub@@ scriptions ( final Context context ) { if ( s@@ Sub@@ scriptions == null ) { s@@ Sub@@ scriptions = Linked@@ ListMultimap . create ( ) ; final String subscriptions = get ( context , KEY@@ _SUB@@ SCRIP@@ TIONS , String . class ) ; if ( ! TextUtils . isEmpty ( subscriptions ) ) { try { final JSONObject JSON = new JSONObject ( subscriptions ) ; final JSONArray title@@ s@@ JSON = JSON . get@@ JSONArray ( KEY@@ _SUB@@ SCRIP@@ TION_@@ TIT@@ LES ) ; final JSONArray categ@@ ories@@ JSON = JSON . get@@ JSONArray ( KEY@@ _SUB@@ SCRIP@@ TION_@@ CATEG@@ ORI@@ ES ) ; final JSONArray ids@@ JSON = JSON . get@@ JSONArray ( KEY@@ _SUB@@ SCRIP@@ TION_@@ IDS ) ; final JSONArray url@@ s@@ JSON = JSON . get@@ JSONArray ( KEY@@ _SUB@@ SCRIP@@ TION_@@ URL@@ S ) ; for ( int i = 0 ; i < title@@ s@@ JSON . length ( ) ; i ++ ) { final String title = title@@ s@@ JSON . getString ( i ) ; s@@ Sub@@ scriptions . put ( title , categ@@ ories@@ JSON . getString ( i ) ) ; s@@ Sub@@ scriptions . put ( title , ids@@ JSON . getString ( i ) ) ; s@@ Sub@@ scriptions . put ( title , url@@ s@@ JSON . getString ( i ) ) ; } } catch ( final JSONException e ) { Log@@ Utils . logError ( e ) ; } } } return s@@ Sub@@ scriptions ; }
 private static void do@@ Dra@@ in ( final Stream@@ Connection connection , final Closeable ... additional ) { if ( ! connection . getSource@@ Channel ( ) . isOpen ( ) ) { Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; return ; } final ByteBuffer b = ByteBuffer . allocate ( 1 ) ; try { int res = connection . getSource@@ Channel ( ) . read ( b ) ; b . clear ( ) ; if ( res == 0 ) { final Xn@@ io@@ Executor . Key key = Worker@@ Utils . execute@@ After ( connection . get@@ Io@@ Thread ( ) , new Runnable ( ) { @ Override public void run ( ) { Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; } } , MAX_@@ DRA@@ IN_@@ TIME , TimeUnit . MILLISECONDS ) ; connection . getSource@@ Channel ( ) . setRead@@ Listener ( new Channel@@ Listener < Condu@@ it@@ Stream@@ Source@@ Channel > ( ) { @ Override public void handleEvent ( Condu@@ it@@ Stream@@ Source@@ Channel channel ) { try { int res = channel . read ( b ) ; if ( res != 0 ) { Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; key . remove ( ) ; } } catch ( Exception e ) { if ( e instanceof IOException ) { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( ( IOException ) e ) ; } else { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( new IOException ( e ) ) ; } Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; key . remove ( ) ; } } } ) ; connection . getSource@@ Channel ( ) . resume@@ Reads ( ) ; } else { Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; } } catch ( Throwable e ) { if ( e instanceof IOException ) { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( ( IOException ) e ) ; } else { Under@@ tow@@ Logger . REQUEST_@@ IO_@@ LOGGER . io@@ Exception ( new IOException ( e ) ) ; } Io@@ Utils . safe@@ Close ( connection ) ; Io@@ Utils . safe@@ Close ( additional ) ; } }
 public static @ Nonnull Affinity@@ Group@@ Filter@@ Options getInstance ( @ Nonnull String regex ) { Affinity@@ Group@@ Filter@@ Options options = new Affinity@@ Group@@ Filter@@ Options ( false ) ; options . regex = regex ; return options ; }
 @ Converter public static MD@@ M_@@ T@@ 03 to@@ M@@ dm@@ T@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 03 . class , body ) ; }
 public static FW@@ Log@@ Name setLog@@ Name ( FW@@ Log@@ Name name ) { FW@@ Log@@ Name curren@@ Log@@ Name = getCurrent@@ Log@@ Name ( ) ; if ( name == null ) { remove ( LOG_@@ NAME ) ; } else { MD@@ C . put ( LOG_@@ NAME , name . toString ( ) ) ; } return curren@@ Log@@ Name ; }
 @ Converter public static RP@@ A_@@ I@@ 08 to@@ R@@ pa@@ I@@ 08 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ A_@@ I@@ 08 . class , body ) ; }
 @ Converter public static R@@ RI@@ _@@ I@@ 15 to@@ R@@ ri@@ I@@ 15 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ RI@@ _@@ I@@ 15 . class , body ) ; }
 public static java . util . Date to@@ Java@@ Date ( ZonedDateTime dt ) { java . util . Date ts = ( dt == null ? null : new java . util . Date ( dt . to@@ Instant ( ) . to@@ Epoch@@ Mil@@ li ( ) ) ) ; return ts ; }
 @ Converter public static OS@@ R_@@ Q@@ 06 to@@ O@@ sr@@ Q@@ 06 ( String body ) throws HL7@@ Exception { return to@@ Message ( OS@@ R_@@ Q@@ 06 . class , body ) ; }
 @ BeforeClass public static void before@@ Class ( ) { R@@ IO@@ T . init ( ) ; }
 private static Iterator@@ Test@@ Output get@@ Iterator@@ Output ( ) { return new Iterator@@ Test@@ Output ( OUTPUT_@@ DATA ) ; }
 @ Converter public static RP@@ A_@@ I@@ 10 to@@ R@@ pa@@ I@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( RP@@ A_@@ I@@ 10 . class , body ) ; }
 public static ArrayList < Queue@@ Role@@ Permission > get@@ Filtered@@ Role@@ List ( ArrayList < Queue@@ Role@@ Permission > all@@ Permissions , int starting@@ Index , int max@@ Role@@ sCount ) { int numberOf@@ Permission@@ sTo@@ Show = max@@ Role@@ sCount ; if ( ( all@@ Permissions . size ( ) - starting@@ Index ) < max@@ Role@@ sCount ) { numberOf@@ Permission@@ sTo@@ Show = ( all@@ Permissions . size ( ) - starting@@ Index ) ; } ArrayList < Queue@@ Role@@ Permission > permission@@ List = new ArrayList < Queue@@ Role@@ Permission > ( ) ; for ( int i = starting@@ Index ; i < starting@@ Index + numberOf@@ Permission@@ sTo@@ Show ; i ++ ) { permission@@ List . add ( all@@ Permissions . get ( i ) ) ; } return permission@@ List ; }
 public static void test_@@ local@@ Time_@@ as_@@ integer ( ) { System . out . println ( " Test ▁ LocalTime ▁ as ▁ Integer " ) ; LocalTime l@@ t1 = LocalTime . now ( ) ; Long i = to@@ Nano@@ Second ( l@@ t1 ) ; LocalTime l@@ t2 = to@@ LocalTime ( i ) ; System . out . println ( " LocalTime ▁ 1 ▁ = ▁ " + l@@ t1 ) ; System . out . println ( " Integer ▁ ▁ ▁ ▁ ▁ = ▁ " + i ) ; System . out . println ( " LocalTime ▁ 2 ▁ = ▁ " + l@@ t2 ) ; if ( ! l@@ t2 . equals ( l@@ t1 ) ) { throw new IllegalStateException ( ) ; } }
 public static void create@@ Global@@ Objs ( String i@@ Lear@@ ner@@ ID , String i@@ Scope@@ ID , List < String > i@@ Obj@@ List ) { if ( _@@ Debug ) { System . out . println ( " ▁ ▁ : : ▁ AD@@ L@@ Seq@@ Utilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " create@@ Global@@ Objs " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ Lear@@ ner@@ ID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + i@@ Scope@@ ID ) ; } System . out . println ( " NOT ▁ IMPLEMENTED : ▁ AD@@ L@@ Seq@@ Utilities : create@@ Global@@ Objs " ) ; }
 public static Collection < Ph@@ p@@ Class > getClass@@ From@@ Ph@@ pType@@ Set ( Project project , Set < String > types ) { Ph@@ pType ph@@ pType = new Ph@@ pType ( ) ; ph@@ pType . add ( types ) ; List < Ph@@ p@@ Class > php@@ Classes = new ArrayList < Ph@@ p@@ Class > ( ) ; for ( String typeName : Ph@@ p@@ Index . getInstance ( project ) . complete@@ Type ( project , ph@@ pType , new HashSet < String > ( ) ) . get@@ Types ( ) ) { if ( typeName . startsWith ( " \ \@@ " ) ) { Ph@@ p@@ Class php@@ Class = Ph@@ p@@ Elements@@ Util . getClass@@ Interface ( project , typeName ) ; if ( php@@ Class != null ) { php@@ Classes . add ( php@@ Class ) ; } } } return php@@ Classes ; }
 public static void set@@ Metric@@ QueueSize ( Integer size ) { metric@@ QueueSize = size ; }
 private static List < Field > getAll@@ Declared@@ Fields ( Class < ? > clazz ) { if ( clazz . getSuper@@ class ( ) != null ) { List < Field > fields = getAll@@ Declared@@ Fields ( clazz . getSuper@@ class ( ) ) ; fields . addAll ( Arrays . asList ( clazz . getDeclared@@ Fields ( ) ) ) ; return fields ; } else { return new ArrayList ( Arrays . asList ( clazz . getDeclared@@ Fields ( ) ) ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 17 to@@ Ad@@ t@@ A@@ 17 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 17 . class , body ) ; }
 @ Converter public static C@@ SU@@ _C@@ 09 to@@ C@@ su@@ C@@ 09 ( String body ) throws HL7@@ Exception { return to@@ Message ( C@@ SU@@ _C@@ 09 . class , body ) ; }
 @ Converter public static MD@@ M_@@ T@@ 10 to@@ M@@ dm@@ T@@ 10 ( String body ) throws HL7@@ Exception { return to@@ Message ( MD@@ M_@@ T@@ 10 . class , body ) ; }
 private static void Create@@ Git@@ Min@@ er@@ Repo@@ Structure ( ) { try { Statement s@@ mt = conn . createStatement ( ) ; String sql = " CREATE ▁ TABLE ▁ TRE@@ POSI@@ TORY ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT , " + " Name ▁ STRING ▁ UNIQUE ▁ NOT ▁ NULL , " + " Last@@ Commit@@ Id ▁ INTEGER ▁ REFERENCES ▁ T@@ COMMIT ( id ) ) ; " + " CREATE ▁ TABLE ▁ T@@ USER ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT , " + " Name ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ T@@ COMMIT ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT , " + " Repo@@ Id ▁ INTEGER ▁ REFERENCES ▁ TRE@@ POSI@@ TORY ( id ) ▁ NOT ▁ NULL , " + " UserID ▁ INTEGER ▁ REFERENCES ▁ T@@ USER ( id ) ▁ NOT ▁ NULL , " + " HashCode ▁ STRING ▁ NOT ▁ NULL , " + " Date ▁ STRING ▁ NOT ▁ NULL , " + " Message ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ T@@ FILE ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT , " + " Commit@@ Id ▁ INTEGER ▁ REFERENCES ▁ T@@ COMMIT ( id ) , " + " New@@ Name ▁ STRING ▁ NOT ▁ NULL , " + " Old@@ Name ▁ STRING ▁ NOT ▁ NULL , " + " New@@ Obj@@ Id ▁ STRING ▁ NOT ▁ NULL , " + " PackageName ▁ STRING ▁ NOT ▁ NULL , " + " Change@@ Type ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ T@@ CLASS ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT , " + " File@@ Id ▁ INTEGER ▁ REFERENCES ▁ T@@ FILE ( id ) , " + " Name ▁ STRING ▁ NOT ▁ NULL , " + " Line@@ Start ▁ INT ▁ NOT ▁ NULL , " + " Line@@ End ▁ INT ▁ NOT ▁ NULL , " + " Change@@ Type ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ T@@ FUNCTION ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTO@@ INCREMENT , " + " Class@@ Id ▁ INTEGER ▁ REFERENCES ▁ T@@ CLASS ( id ) , " + " Name ▁ STRING ▁ NOT ▁ NULL , " + " Line@@ Start ▁ INT ▁ NOT ▁ NULL , " + " Line@@ End ▁ INT ▁ NOT ▁ NULL , " + " Change@@ Type ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ T@@ BUG ( " + " id ▁ STRING ▁ NOT ▁ NULL , " + " Commit@@ ID ▁ STRING ▁ NOT ▁ NULL ) ; " ; s@@ mt . executeUpdate ( sql ) ; s@@ mt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
 public static Matrix@@ 2D Extract@@ Commit@@ Artifact@@ Matrix ( Analyzer . Gra@@ in gra@@ in , String _re@@ pository , String filename ) throws SQLException { String sql ; Matrix@@ Descriptor descriptor = new Matrix@@ Descriptor ( InfoType . COMMIT , InfoType . ARTI@@ FAC@@ T ) ; Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR , ▁ T@@ FILE ▁ TF ▁ " + " WHERE ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . comm@@ iti@@ d ▁ = ▁ TC . id ▁ AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . Add@@ Row@@ Desc ( rs . getString ( " HashCode " ) ) ; } switch ( gra@@ in ) { case FILE : sql = " SELECT ▁ Distin@@ ct ( TF . New@@ Name ) ▁ FROM ▁ T@@ FILE ▁ TF , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . Commit@@ Id ▁ = ▁ TC . id ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TF . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . Add@@ Col@@ Desc ( rs . getString ( " New@@ Name " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TF@@ L . New@@ Name , ▁ TC@@ L . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ Func@@ Name ▁ " + " FROM ▁ T@@ Function ▁ TF , ▁ T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . classi@@ d ▁ = ▁ TC@@ L . id ▁ AND ▁ TC@@ L . file@@ id ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ " + " AND ▁ TF@@ L . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF@@ L . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " ) ; sql = sql . concat ( " GROUP ▁ BY ▁ TF@@ L . New@@ Name , ▁ TC@@ L . name , ▁ TF . name ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . Add@@ Col@@ Desc ( rs . getString ( " New@@ Name " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " Func@@ Name " ) ) ; rs . close ( ) ; break ; } Matrix@@ 2D mat = new Matrix@@ 2D ( descriptor ) ; switch ( gra@@ in ) { case FILE : sql = " SELECT ▁ TC . HashCode , ▁ TF . New@@ Name ▁ FROM ▁ T@@ FILE ▁ TF , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . Commit@@ Id ▁ = ▁ TC . id ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ AND ▁ TF . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TF . New@@ Name ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; int count = 0 ; while ( rs . next ( ) ) { count ++ ; mat . Set@@ Element ( rs . getString ( " HashCode " ) , rs . getString ( " New@@ Name " ) , 1 ) ; } System . out . println ( count ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ TC . hashcode , ▁ TF@@ L . New@@ Name , ▁ TC@@ L . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ Func@@ Name ▁ from ▁ T@@ Function ▁ TF , ▁ " + " T@@ CLASS ▁ TC@@ L , ▁ T@@ FILE ▁ TF@@ L , ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TF . classi@@ d ▁ = ▁ TC@@ L . id ▁ AND ▁ TC@@ L . file@@ id ▁ = ▁ TF@@ L . id ▁ AND ▁ TF@@ L . Commit@@ ID ▁ = ▁ TC . id ▁ AND ▁ " + " TF@@ L . New@@ Name ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . Repo@@ Id ▁ = ▁ TR . id ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF@@ L . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _re@@ pository + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TF@@ L . newname , ▁ TC@@ L . name , ▁ TF . name ; " ) ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . Set@@ Element ( rs . getString ( " HashCode " ) , rs . getString ( " New@@ Name " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " Func@@ Name " ) , 1 ) ; } rs . close ( ) ; break ; } s@@ mt . close ( ) ; return mat ; }
 @ Converter public static SI@@ U@@ _S@@ 22 to@@ Si@@ u@@ S@@ 22 ( String body ) throws HL7@@ Exception { return to@@ Message ( SI@@ U@@ _S@@ 22 . class , body ) ; }
 public static Level make@@ Blank@@ Level ( ) { Level l = new Level ( ) ; fill@@ Grid ( l . get@@ Grid ( ) , Grid . GRID_@@ W@@ ALL ) ; return l ; }
 public static final I@@ Function@@ Descriptor@@ Factory FACTORY = new I@@ Function@@ Descriptor@@ Factory ( ) { @ Override public I@@ Function@@ Descriptor create@@ Function@@ Descriptor ( ) { return new String@@ Position@@ Descriptor ( ) ; } @ Override public I@@ Function@@ Type@@ In@@ fe@@ rer create@@ Function@@ Type@@ In@@ fe@@ rer ( ) { return Function@@ Type@@ In@@ fe@@ re@@ rs . SET_@@ STRING_@@ OFFSET ; } }
 private static void depth@@ First@@ Search ( @ NotNull Control@@ Flow flow , @ NotNull Instruction@@ Client@@ Visitor visitor ) { depth@@ First@@ Search ( flow , visitor , 0 , flow . getSize ( ) ) ; }
 private static final byte [ ] bytes ( String value ) { return requireNonNull ( value ) . getBytes ( UTF_8 ) ; }
 public static void validate@@ Imported@@ Element ( Import@@ Rules import@@ Rules , Object subject ) throws KettleException { List < Import@@ Validation@@ Feedback > feedback = import@@ Rules . verify@@ Rules ( subject ) ; List < Import@@ Validation@@ Feedback > errors = Import@@ Validation@@ Feedback . getErrors ( feedback ) ; if ( ! errors . isEmpty ( ) ) { StringBuilder message = new StringBuilder ( BaseMessages . getString ( PKG , " Repository@@ Importer . Validation@@ Failed . Message " , subject . toString ( ) ) ) ; message . append ( Const . CR ) ; for ( Import@@ Validation@@ Feedback error : errors ) { message . append ( " ▁ - ▁ " ) ; message . append ( error . toString ( ) ) ; message . append ( Const . CR ) ; } throw new KettleException ( message . toString ( ) ) ; } }
 private static String getServer ( SharedPreferences settings , Context context ) { return settings . getString ( Preference@@ Keys . KEY@@ _SERVER_@@ URL , context . getString ( R . string . default_@@ server_url ) ) ; }
 public static String getWeb@@ Config@@ ClassName ( ) { Object cached@@ Config = CONFIG_@@ CA@@ H@@ CE . get ( Web@@ Config@@ Key . CORE_@@ WEB_@@ CONFIG_@@ CLASS , new Data@@ Getter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( Web@@ Config@@ Key . CORE_@@ WEB_@@ CONFIG_@@ CLASS , Web@@ Config@@ Default . CORE_@@ WEB_@@ CONFIG_@@ CLASS ) ; } } ) ; return ( String ) cached@@ Config ; }
 private static Date GetLast@@ Commit@@ Date ( String name ) { Date result = null ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; String sql = " SELECT ▁ TC . Date ▁ FROM ▁ T@@ COMMIT ▁ TC , ▁ TRE@@ POSI@@ TORY ▁ TR ▁ " + " WHERE ▁ TR . Last@@ Commit@@ Id ▁ = ▁ TC . id ▁ AND ▁ " + " TR . Name ▁ = ▁ ' " + name + " ' ; " ; Statement stm ; ResultSet rs ; try { stm = conn . createStatement ( ) ; rs = stm . executeQuery ( sql ) ; while ( rs . next ( ) ) { try { result = sdf . parse ( rs . getString ( " date " ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return result ; }
 public static void add@@ I@@ Fl@@ ate@@ View@@ Adapter ( I@@ Ju@@ ah@@ ya@@ Fl@@ ate@@ View@@ In@@ Flat@@ er@@ Adapter if@@ l ) { if ( null == list ) list = new ArrayList < I@@ Ju@@ ah@@ ya@@ Fl@@ ate@@ View@@ In@@ Flat@@ er@@ Adapter > ( ) ; if ( ! list . contains ( if@@ l ) ) list . add ( if@@ l ) ; }
 @ Converter public static AD@@ T_@@ A@@ 31 to@@ Ad@@ t@@ A@@ 31 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 31 . class , body ) ; }
 @ Converter public static R@@ Q@@ I_@@ I@@ 03 to@@ R@@ qi@@ I@@ 03 ( String body ) throws HL7@@ Exception { return to@@ Message ( R@@ Q@@ I_@@ I@@ 03 . class , body ) ; }
 @ Converter public static MF@@ N_@@ M@@ 04 to@@ M@@ fn@@ M@@ 04 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ N_@@ M@@ 04 . class , body ) ; }
 public static void set@@ Region ( Regions region ) { Aws@@ Sdk@@ Metrics . region = Region@@ Utils . getRegion ( region . getName ( ) ) ; }
 public static java . sql . Timestamp to@@ SQL@@ Timestamp ( LocalDateTime ld@@ t ) { java . sql . Timestamp ts = ( ld@@ t == null ? null : Timestamp . valueOf ( ld@@ t ) ) ; return ts ; }
 private static Class < ? > getTarget@@ Class ( Fixture fixture ) { return fixture . getClass ( ) ; }
 public static void setState ( Context context , boolean enabled , Class component@@ Class ) { int state = enabled ? PackageManager . COMPONENT_@@ ENABLED_@@ STATE_@@ ENABLED : PackageManager . COMPONENT_@@ ENABLED_@@ STATE_@@ DISABLED ; ComponentName componentName = new ComponentName ( context , component@@ Class ) ; try { context . getPackage@@ Manager ( ) . set@@ Component@@ Enabled@@ Setting ( componentName , state , PackageManager . DONT_@@ KILL_@@ APP ) ; } catch ( Exception e ) { throw new ConfigurationException ( ConfigurationException . Reason . MISSING_@@ REQUIRED_@@ COMPONENT , component@@ Class . getCanonicalName ( ) ) ; } }
 @ Converter public static AD@@ T_@@ A@@ 39 to@@ Ad@@ t@@ A@@ 39 ( String body ) throws HL7@@ Exception { return to@@ Message ( AD@@ T_@@ A@@ 39 . class , body ) ; }
 static List < Object > getSub@@ scription@@ sAs@@ Out@@ lines ( final Context context , final boolean retain@@ Categories ) { final Linked@@ ListMultimap < String , String > subscriptions = getSub@@ scriptions ( context ) ; final List < Object > out@@ lines = new ArrayList < > ( subscriptions . size ( ) ) ; final Linked@@ ListMultimap < String , Outline > outline@@ Groups = Linked@@ ListMultimap . create ( ) ; for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { final String category = subscriptions . get ( title ) . get ( 0 ) ; final String xml@@ Url = subscriptions . get ( title ) . get ( 2 ) ; final Outline outline = new Outline . Builder ( ) . setText ( title ) . setTitle ( title ) . set@@ Xml@@ Url ( xml@@ Url ) . build ( ) ; if ( retain@@ Categories ) { outline@@ Groups . put ( category , outline ) ; } else { out@@ lines . add ( outline ) ; } } if ( retain@@ Categories ) { for ( final String category : outline@@ Groups . asMap ( ) . keySet ( ) ) { out@@ lines . add ( new Outline@@ Group . Builder ( ) . setText ( category ) . setTitle ( category ) . addSub@@ Out@@ lines ( outline@@ Groups . get ( category ) ) . build ( ) ) ; } } return out@@ lines ; }
 public static boolean is@@ External@@ Storage@@ Readable ( ) { String state = Environment . getExternal@@ Storage@@ State ( ) ; return Environment . MEDIA_@@ MOUN@@ TED . equals ( state ) || Environment . MEDIA_@@ MOUN@@ TED_@@ READ_ONLY . equals ( state ) ; }
 public static int Num@@ Comm@@ its ( String proj@@ Name ) { int total = 0 ; try { Statement s@@ mt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ T@@ Commit . HashCode ▁ FROM ▁ T@@ COMMIT , ▁ TRE@@ POSI@@ TORY ▁ " + " WHERE ▁ T@@ COMMIT . Repo@@ Id ▁ = ▁ TRE@@ POSI@@ TORY . id ▁ AND ▁ " + " TRE@@ POSI@@ TORY . Name ▁ = ▁ ' " + proj@@ Name + " ' ; " ; rs = s@@ mt . executeQuery ( sql ) ; while ( rs . next ( ) ) { total ++ ; } rs . close ( ) ; s@@ mt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return total ; }
 @ NotNull private static Optional < Boolean > match ( @ NotNull Py@@ TupleType expected , @ NotNull Py@@ TupleType actual , @ NotNull Match@@ Context context ) { if ( ! expected . is@@ Ho@@ mo@@ gene@@ ous ( ) && ! actual . is@@ Ho@@ mo@@ gene@@ ous ( ) ) { if ( expected . getElement@@ Count ( ) != actual . getElement@@ Count ( ) ) { return Optional . of ( false ) ; } for ( int i = 0 ; i < expected . getElement@@ Count ( ) ; i ++ ) { if ( ! match ( expected . getElementType ( i ) , actual . getElementType ( i ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } return Optional . of ( true ) ; } if ( expected . is@@ Ho@@ mo@@ gene@@ ous ( ) && ! actual . is@@ Ho@@ mo@@ gene@@ ous ( ) ) { final Py@@ Type expected@@ ElementType = expected . get@@ Iter@@ ated@@ ItemType ( ) ; for ( int i = 0 ; i < actual . getElement@@ Count ( ) ; i ++ ) { if ( ! match ( expected@@ ElementType , actual . getElementType ( i ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } return Optional . of ( true ) ; } if ( ! expected . is@@ Ho@@ mo@@ gene@@ ous ( ) && actual . is@@ Ho@@ mo@@ gene@@ ous ( ) ) { return Optional . of ( false ) ; } return match ( expected . get@@ Iter@@ ated@@ ItemType ( ) , actual . get@@ Iter@@ ated@@ ItemType ( ) , context ) ; }
 @ Converter public static TB@@ R_@@ Q@@ 01 to@@ T@@ br@@ Q@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( TB@@ R_@@ Q@@ 01 . class , body ) ; }
 public static void copy@@ Last@@ Repl@@ Id ( Map < String , String > src@@ Parameter , Map < String , String > dest@@ Parameter ) { String last@@ Repl@@ Id = src@@ Parameter . get ( Replication@@ Spec . KEY . CUR@@ R_@@ STATE_@@ ID . toString ( ) ) ; if ( last@@ Repl@@ Id != null ) { dest@@ Parameter . put ( Replication@@ Spec . KEY . CUR@@ R_@@ STATE_@@ ID . toString ( ) , last@@ Repl@@ Id ) ; } }
 public static void register ( ) { Client@@ Registry . bind@@ TileEntity@@ Special@@ Renderer ( Grid@@ TE . class , new Grid@@ Renderer ( ) ) ; }
 @ Converter public static MF@@ K_@@ M@@ 01 to@@ M@@ fk@@ M@@ 01 ( String body ) throws HL7@@ Exception { return to@@ Message ( MF@@ K_@@ M@@ 01 . class , body ) ; }
 private static Graph@@ Traversal < Vertex , Long > get@@ Traversal@@ With@@ Lambda ( final Graph@@ Traversal@@ Source g ) { assume@@ That ( " This ▁ test ▁ is ▁ not ▁ enabled ▁ for ▁ this ▁ ScriptEngine : ▁ " + ENGINE_@@ TO_@@ TEST , ENGINE_@@ TO_@@ TEST , any@@ Of ( is ( " gremlin - python " ) , is ( " gremlin - j@@ ython " ) , is ( " gremlin - groovy " ) ) ) ; if ( ENGINE_@@ TO_@@ TEST . equals ( " gremlin - groovy " ) ) return g . V ( ) . out ( " created " ) . map ( Lambda . function ( " { x ▁ - > ▁ x . get ( ) . values ( ' name ' ) } " ) ) . count ( ) ; else if ( ENGINE_@@ TO_@@ TEST . equals ( " gremlin - python " ) || ENGINE_@@ TO_@@ TEST . equals ( " gremlin - j@@ ython " ) ) return g . V ( ) . out ( " created " ) . map ( Lambda . function ( " x ▁ : ▁ x . get ( ) . values ( ' name ' ) " ) ) . count ( ) ; else throw new RuntimeException ( " The ▁ " + ENGINE_@@ TO_@@ TEST + " ▁ ScriptEngine ▁ is ▁ not ▁ supported ▁ by ▁ this ▁ test " ) ; }
