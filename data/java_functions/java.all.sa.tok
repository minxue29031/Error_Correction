GlenRSmith/elasticsearch | static TokenizerFactory newFactory ( String name , Supplier < Tokenizer > supplier ) { return new TokenizerFactory ( ) { @ Override public String name ( ) { return name ; } @ Override public Tokenizer create ( ) { return supplier . get ( ) ; } } ; }
sscdotopen/giraph-compensations | public static void setGraphState ( BasicVertex vertex , GraphState graphState ) throws Exception { Class < ? extends BasicVertex > c = BasicVertex . class ; Method m = c . getDeclaredMethod ( " setGraphState " , GraphState . class ) ; m . setAccessible ( true ) ; m . invoke ( vertex , graphState ) ; }
sscdotopen/giraph-compensations | public static < I extends WritableComparable , V extends Writable , E extends Writable , M extends Writable > void assertValidVertex ( Configuration conf , GraphState < I , V , E , M > graphState , BasicVertex < I , V , E , M > actual , I expectedId , V expectedValue , Edge < I , E > ... edges ) throws Exception { BasicVertex < I , V , E , M > expected = BspUtils . createVertex ( conf ) ; setGraphState ( expected , graphState ) ; Map < I , E > edgeMap = Maps . newHashMap ( ) ; for ( Edge < I , E > edge : edges ) { edgeMap . put ( edge . getDestVertexId ( ) , edge . getEdgeValue ( ) ) ; } expected . initialize ( expectedId , expectedValue , edgeMap , null ) ; assertValid ( expected , actual ) ; }
sscdotopen/giraph-compensations | public static < I extends WritableComparable , V extends Writable , E extends Writable , M extends Writable > void assertValid ( BasicVertex < I , V , E , M > expected , BasicVertex < I , V , E , M > actual ) { assertEquals ( expected . getVertexId ( ) , actual . getVertexId ( ) ) ; assertEquals ( expected . getVertexValue ( ) , actual . getVertexValue ( ) ) ; assertEquals ( expected . getNumEdges ( ) , actual . getNumEdges ( ) ) ; List < Edge < I , E > > expectedEdges = Lists . newArrayList ( ) ; List < Edge < I , E > > actualEdges = Lists . newArrayList ( ) ; for ( I actualDestId : actual ) { actualEdges . add ( new Edge < I , E > ( actualDestId , actual . getEdgeValue ( actualDestId ) ) ) ; } for ( I expectedDestId : expected ) { expectedEdges . add ( new Edge < I , E > ( expectedDestId , expected . getEdgeValue ( expectedDestId ) ) ) ; } Collections . sort ( expectedEdges ) ; Collections . sort ( actualEdges ) ; for ( int i = 0 ; i < expectedEdges . size ( ) ; i ++ ) { assertEquals ( expectedEdges . get ( i ) , actualEdges . get ( i ) ) ; } }
podpage/J-lexa | public static Header parse ( List < String > lines ) throws IOException { Header header = new Header ( ) ; lines . forEach ( line -> { if ( header . getRequestMethod ( ) == null ) { for ( RequestMethod requestMethod : RequestMethod . values ( ) ) { if ( line . startsWith ( requestMethod . name ( ) + " ▁ " ) ) { header . setRequestURL ( line . split ( " ▁ " ) [ 1 ] ) ; header . setRequestMethod ( requestMethod ) ; break ; } } } for ( HeaderField headerField : HeaderField . values ( ) ) { if ( headerField . getType ( ) != HeaderType . RESPONSE ) { if ( line . toLowerCase ( ) . startsWith ( headerField . getName ( ) . toLowerCase ( ) + " : " ) ) { headerField . setContent ( line . substring ( line . indexOf ( " : " ) + 1 , line . length ( ) ) . trim ( ) ) ; header . addHeaderField ( headerField ) ; } } } } ) ; return header ; }
Sargul/dbeaver | private static String formatReleaseNotes ( String releaseNotes ) { while ( releaseNotes . startsWith ( " \n " ) ) { releaseNotes = releaseNotes . substring ( 1 ) ; } String [ ] rnLines = releaseNotes . split ( " \n " ) ; int leadSpacesNum = 0 ; for ( int i = 0 ; i < rnLines [ 0 ] . length ( ) ; i ++ ) { if ( rnLines [ 0 ] . charAt ( i ) == ' ▁ ' ) { leadSpacesNum ++ ; } else { break ; } } StringBuilder result = new StringBuilder ( ) ; for ( String rnLine : rnLines ) { if ( rnLine . length ( ) > leadSpacesNum ) { if ( result . length ( ) > 0 ) result . append ( " \n " ) ; result . append ( rnLine . substring ( leadSpacesNum ) ) ; } } return result . toString ( ) ; }
dagnir/aws-sdk-java | public static DeleteFlowLogsResultStaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new DeleteFlowLogsResultStaxUnmarshaller ( ) ; return instance ; }
GlenRSmith/elasticsearch | public static ParsedValueCount fromXContent ( XContentParser parser , final String name ) { ParsedValueCount sum = PARSER . apply ( parser , null ) ; sum . setName ( name ) ; return sum ; }
raviperi/storm | public static byte [ ] serialize ( Object obj ) throws IOException { try ( ByteArrayOutputStream b = new ByteArrayOutputStream ( ) ) { try ( ObjectOutputStream o = new ObjectOutputStream ( b ) ) { o . writeObject ( obj ) ; } return b . toByteArray ( ) ; } }
haikuowuya/android_system_code | public static boolean isWhitespace ( char ch ) { return ch == SP || ch == HT || ch == CR || ch == LF ; }
dydeve/web | public static InternMapStorage of ( boolean threadSafe , InternStorage . ValueConstructor valueConstructor ) { if ( threadSafe ) { return new InternMapStorage ( new ConcurrentHashMap < > ( ) , valueConstructor ) ; } return new InternMapStorage ( new HashMap < > ( ) , valueConstructor ) ; }
bbottema/java-reflection | private static Collection < ValueFunction < File , ? > > produceFileConverters ( ) { ArrayList < ValueFunction < File , ? > > converters = new ArrayList < > ( ) ; converters . add ( new ValueFunctionImpl < > ( File . class , File . class , Functions . < File > identity ( ) ) ) ; converters . add ( new ValueFunctionImpl < > ( File . class , DataSource . class , new FileToDataSourceFunction ( ) ) ) ; converters . add ( new ValueFunctionImpl < > ( File . class , byte [ ] . class , new FileToByteArrayFunction ( ) ) ) ; converters . add ( new ValueFunctionImpl < > ( File . class , InputStream . class , new FileToInputStreamFunction ( ) ) ) ; return converters ; }
pphdsny/ArithmeticTest | public static void main ( String [ ] args ) { _1052_maxSatisfied maxSatisfied = new _1052_maxSatisfied ( ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 1 , 0 , 1 , 2 , 1 , 1 , 7 , 5 } , new int [ ] { 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 } , 3 ) ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 1 } , new int [ ] { 0 } , 1 ) ) ; System . out . println ( maxSatisfied . maxSatisfied ( new int [ ] { 4 , 10 , 10 } , new int [ ] { 1 , 1 , 0 } , 2 ) ) ; }
FDevman/VIDEVOX-Beta | public static boolean preview ( String text ) throws VidevoxException { String cmd = " echo ▁ \" " + text + " \" ▁ | ▁ festival ▁ - - tts " ; logger . debug ( " command ▁ is : ▁ " + cmd ) ; ProcessBuilder builder = new ProcessBuilder ( " / bin / bash " , " - c " , cmd ) ; try { builder . start ( ) . waitFor ( ) ; } catch ( IOException | InterruptedException e ) { throw new VidevoxException ( " Text ▁ to ▁ speech ▁ preview ▁ is ▁ not ▁ working ▁ at ▁ the ▁ moment " ) ; } return true ; }
FDevman/VIDEVOX-Beta | public static boolean textToMP3 ( File destination , String speech ) throws VidevoxException { File tempWAV = ModelHelper . enforceFileExtension ( destination , " . wav " ) ; logger . debug ( " File ▁ name ▁ is ▁ actually : ▁ " + tempWAV . getAbsolutePath ( ) ) ; destination = ModelHelper . enforceFileExtension ( destination , " . mp3" ) ; String cmd = " echo ▁ ' " + speech + " ' ▁ | ▁ text2wave ▁ " + " - o ▁ " + " \" " + tempWAV . getAbsolutePath ( ) + " \" " ; logger . debug ( " textToMP3 ▁ - ▁ cmd ▁ = ▁ " + cmd ) ; ProcessBuilder builder = new ProcessBuilder ( " / bin / bash " , " - c " , cmd ) ; try { Process process = builder . start ( ) ; int returnVal = process . waitFor ( ) ; if ( returnVal != 0 ) { throw new VidevoxException ( " Wav ▁ file ▁ unable ▁ to ▁ be ▁ created : ▁ Check ▁ that ▁ festival ▁ is ▁ installed ▁ correctly " ) ; } logger . trace ( " created ▁ wav ▁ at : ▁ " + tempWAV . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new VidevoxException ( " Unknown ▁ IO ▁ Exception ▁ during ▁ WAV ▁ creation " ) ; } catch ( InterruptedException e ) { throw new VidevoxException ( " Festival ▁ thread ▁ interrupted : ▁ Unknown ▁ source " ) ; } cmd = " ffmpeg ▁ - i ▁ " + " \" " + tempWAV . getAbsolutePath ( ) + " \" " + " ▁ - y ▁ - f ▁ mp3 ▁ " + " \" " + destination . getAbsolutePath ( ) + " \" " ; logger . debug ( " cmd ▁ = ▁ " + cmd ) ; builder = new ProcessBuilder ( " / bin / bash " , " - c " , cmd ) ; try { Process process = builder . start ( ) ; int returnVal = process . waitFor ( ) ; if ( returnVal != 0 ) { throw new VidevoxException ( " Unable ▁ to ▁ convert ▁ to ▁ mp3 : ▁ Check ▁ that ▁ festival ▁ is ▁ installed ▁ correctly " ) ; } logger . debug ( " Created ▁ mp3 ▁ at : ▁ " + destination . getAbsolutePath ( ) ) ; } catch ( IOException e ) { throw new VidevoxException ( " Unknown ▁ IO ▁ Exception ▁ during ▁ mp3 ▁ conversion " ) ; } catch ( InterruptedException e ) { throw new VidevoxException ( " Festival ▁ thread ▁ interrupted : ▁ Unknown ▁ source " ) ; } logger . trace ( " Done ▁ with ▁ textToMP3" ) ; return true ; }
kkhatua/drill | public static Map < Scan , FieldList > getFieldLists ( LogicalPlan plan ) { Collection < SinkOperator > ops = plan . getGraph ( ) . getRoots ( ) ; Preconditions . checkArgument ( ops . size ( ) == 1 , " Scan ▁ Field ▁ determiner ▁ currently ▁ only ▁ works ▁ with ▁ plans ▁ that ▁ have ▁ a ▁ single ▁ root . " ) ; ScanFieldDeterminer sfd = new ScanFieldDeterminer ( ) ; ops . iterator ( ) . next ( ) . accept ( sfd , new FieldList ( ) ) ; return sfd . scanFields ; }
vpipkt/geomesa | public static void configureDataStore ( Job job , Map < String , String > dataStoreParams ) { Object m = JavaConverters . mapAsScalaMapConverter ( dataStoreParams ) . asScala ( ) ; scala . collection . immutable . Map < String , String > scalaParams = ( ( scala . collection . mutable . Map < String , String > ) m ) . toMap ( Predef . < Tuple2 < String , String > > conforms ( ) ) ; GeoMesaOutputFormat$ . MODULE$ . configureDataStore ( job , scalaParams ) ; }
vpipkt/geomesa | public static void configureBatchWriter ( Job job , BatchWriterConfig writerConfig ) { GeoMesaOutputFormat$ . MODULE$ . configureBatchWriter ( job , writerConfig ) ; }
Flibio/Ultimate-Spleef | public static Optional < UArena > createArena ( String arenaName , ArenaData data ) { if ( isDataPresent ( data ) ) { return Optional . of ( new UArena ( arenaName , data ) ) ; } else { return Optional . empty ( ) ; } }
Flibio/Ultimate-Spleef | public static boolean isDataPresent ( ArenaData data ) { if ( data . getLocation ( " lobby " ) . isPresent ( ) && data . getLocation ( " circlecenter " ) . isPresent ( ) && data . getLocation ( " circleedge " ) . isPresent ( ) && data . getVariable ( " dedicated " , Boolean . class ) . isPresent ( ) ) { return ! data . getVariable ( " dedicated " , Boolean . class ) . get ( ) ? data . getLocation ( " joinsign " ) . isPresent ( ) : true ; } else { return false ; } }
yuweijun/learning-programming | public static void main ( String [ ] args ) throws IOException { OkHttpTimeoutExample okHttpTimeoutExample = new OkHttpTimeoutExample ( ) ; okHttpTimeoutExample . run ( ) ; }
cnishina/jmeter-client | public static JMeterElement getType ( TYPE findType , List < JMeterElement > inList ) { for ( JMeterElement je : inList ) { if ( je . type == findType ) return je ; } return null ; }
cnishina/jmeter-client | public static List < JMeterElement > getListType ( TYPE findType , List < JMeterElement > inList ) { List < JMeterElement > jmeterEls = new ArrayList < JMeterElement > ( ) ; for ( JMeterElement je : inList ) { if ( je . type == findType ) jmeterEls . add ( je ) ; } return jmeterEls ; }
byrao123/clickfortech | public static MapProviderFactory getInstance ( ) { if ( mapFactory == null ) { mapFactory = new MapProviderFactory ( ) ; } return mapFactory ; }
byrao123/clickfortech | public static MapProvider getMapProviderForName ( String providerClassName ) { return getInstance ( ) . getMapProvider ( providerClassName ) ; }
danielkec/Ansible | @ org . junit . BeforeClass public static void setUp ( ) throws Exception { System . out . println ( " = = = ▁ Setting ▁ up ▁ inmemory ▁ db ▁ for ▁ Ansible ▁ DAO ▁ Test ▁ = = = " ) ; CREATE_TMP_DB_SQL = new Scanner ( new FileInputStream ( SQL_FOLDER_PATH + " recreateDb . sql " ) ) . useDelimiter ( " \\ A " ) . next ( ) ; JdbcDataSource ds = new JdbcDataSource ( ) ; ds . setURL ( JDBC_URL ) ; ds . setUser ( " sa " ) ; ds . setPassword ( " sa " ) ; Connection conn = ds . getConnection ( ) ; conn = ds . getConnection ( ) ; conn . createStatement ( ) . execute ( CREATE_TMP_DB_SQL ) ; conn . commit ( ) ; conn . close ( ) ; }
danielkec/Ansible | @ AfterClass public static void tearDown ( ) throws SQLException { System . out . println ( " = = = = ▁ Cleaning ▁ inmemory ▁ db ▁ = = = = " ) ; RunScript . execute ( JDBC_URL , " sa " , " sa " , " classpath : cz / kec / of / ansible / dao / clearDb . sql " , Charset . forName ( " UTF - 8" ) , false ) ; }
mkeijzer/push-forth | public static Instruction getInstruction ( String name ) { return instructionMap . get ( name ) ; }
mkeijzer/push-forth | public static Instruction [ ] getAllInstructions ( ) { Collection < Instruction > ins = instructionMap . values ( ) ; return ins . toArray ( new Instruction [ ins . size ( ) ] ) ; }
mkeijzer/push-forth | public static List < Instruction > getAllInstructionsButOne ( String toExclude ) { List < Instruction > ins = new ArrayList < Instruction > ( ) ; for ( Map . Entry < String , Instruction > entry : instructionMap . entrySet ( ) ) { if ( ! entry . getKey ( ) . equals ( toExclude ) ) { ins . add ( entry . getValue ( ) ) ; } } return ins ; }
mkeijzer/push-forth | public static void put ( String name , Instruction result ) { instructionMap . put ( name , result ) ; }
mkeijzer/push-forth | public static Instruction get ( String name ) { return instructionMap . get ( name ) ; }
mkeijzer/push-forth | public static Instruction safeget ( String name ) { Instruction res = instructionMap . get ( name ) ; if ( res == null ) { throw new RuntimeException ( " Instruction ▁ with ▁ name ▁ " + name + " ▁ not ▁ found " ) ; } return res ; }
mkeijzer/push-forth | public static void remove ( String name ) { instructionMap . remove ( name ) ; }
mkeijzer/push-forth | public static Instruction randomInstruction ( Random random ) { int choice = random . nextInt ( instructionMap . size ( ) ) ; for ( Instruction ins : instructionMap . values ( ) ) { if ( choice -- == 0 ) { return ins ; } } throw new RuntimeException ( " Dictionary : ▁ should ▁ not ▁ happen " ) ; }
andrewgaul/aws-sdk-java | public static ConfigurationOptionDescriptionStaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new ConfigurationOptionDescriptionStaxUnmarshaller ( ) ; return instance ; }
perezd/bazel | public static LinkOptions of ( ImmutableList < String > linkOptions , SymbolGenerator < ? > symbolGenerator ) { return new LinkOptions ( linkOptions , symbolGenerator . generate ( ) ) ; }
perezd/bazel | public static Builder builder ( ) { return new Builder ( ) ; }
perezd/bazel | public static CcLinkingContext merge ( List < CcLinkingContext > ccLinkingContexts ) { Builder mergedCcLinkingContext = CcLinkingContext . builder ( ) ; ExtraLinkTimeLibraries . Builder mergedExtraLinkTimeLibraries = ExtraLinkTimeLibraries . builder ( ) ; for ( CcLinkingContext ccLinkingContext : ccLinkingContexts ) { mergedCcLinkingContext . addTransitiveLinkerInputs ( ccLinkingContext . getLinkerInputs ( ) ) ; if ( ccLinkingContext . getExtraLinkTimeLibraries ( ) != null ) { mergedExtraLinkTimeLibraries . addTransitive ( ccLinkingContext . getExtraLinkTimeLibraries ( ) ) ; } } mergedCcLinkingContext . setExtraLinkTimeLibraries ( mergedExtraLinkTimeLibraries . build ( ) ) ; return mergedCcLinkingContext . build ( ) ; }
perezd/bazel | public static Builder builder ( ) { return new Builder ( ) ; }
sekys/ivis | public static void main ( String [ ] args ) { Dimension size = new Dimension ( 200 , 100 ) ; DrawingJPanel panel = new DrawingJPanel ( size ) ; panel . fill ( Color . WHITE . getRGB ( ) ) ; panel . repaint ( ) ; JFrame frame = new JFrame ( " " ) ; frame . add ( panel ) ; frame . setUndecorated ( true ) ; frame . setVisible ( true ) ; frame . setResizable ( false ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . pack ( ) ; }
dyu/protostuff-1.0.x | public static Bear filledBear ( ) { Bear bear = new Bear ( ) ; bear . someBearField = " bearField " ; bear . normalBodyTemperature = 20f ; bear . properName = " bear " ; return bear ; }
dyu/protostuff-1.0.x | public static Tiger filledTiger ( ) { Tiger tiger = new Tiger ( ) ; tiger . someTigerField = " tigerField " ; tiger . normalBodyTemperature = 30f ; tiger . properName = " tiger " ; return tiger ; }
dyu/protostuff-1.0.x | public static Elephant filledElephant ( ) { Elephant elephant = new Elephant ( ) ; elephant . someElephantField = " elephantField " ; elephant . normalBodyTemperature = 25f ; elephant . properName = " elephant " ; return elephant ; }
dyu/protostuff-1.0.x | public static Zoo filledZoo ( ) { Zoo zoo = new Zoo ( ) ; Elephant elephant = filledElephant ( ) ; Bear bear = filledBear ( ) ; Tiger tiger = filledTiger ( ) ; zoo . largestAnimal = elephant ; zoo . animals . add ( bear ) ; zoo . animals . add ( tiger ) ; zoo . animals . add ( elephant ) ; return zoo ; }
rohit5ram/carjoin | public static TripShareDAO getInstance ( final Context context ) { if ( singleton == null ) { singleton = new TripShareDAO ( context . getApplicationContext ( ) ) ; } return singleton ; }
hastef88/carbon-business-messaging | public static String getHtmlString ( String message ) { return message . replaceAll ( " < " , " & lt ; " ) . replaceAll ( " > " , " & gt ; " ) ; }
hastef88/carbon-business-messaging | public static AndesAdminServiceStub getAndesAdminServiceStub ( ServletConfig config , HttpSession session , HttpServletRequest request ) throws AxisFault { String backendServerURL = CarbonUIUtil . getServerURL ( config . getServletContext ( ) , session ) ; backendServerURL = backendServerURL + ANDES_ADMIN_SERVICE_NAME ; ConfigurationContext configContext = ( ConfigurationContext ) config . getServletContext ( ) . getAttribute ( CarbonConstants . CONFIGURATION_CONTEXT ) ; AndesAdminServiceStub stub = new AndesAdminServiceStub ( configContext , backendServerURL ) ; String cookie = ( String ) session . getAttribute ( ServerConstants . ADMIN_SERVICE_COOKIE ) ; if ( cookie != null ) { Options option = stub . _getServiceClient ( ) . getOptions ( ) ; option . setManageSession ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTPConstants . COOKIE_STRING , cookie ) ; } return stub ; }
hastef88/carbon-business-messaging | public static AndesManagerServiceStub getAndesManagerServiceStub ( ServletConfig config , HttpSession session ) throws AxisFault { String backendServerURL = CarbonUIUtil . getServerURL ( config . getServletContext ( ) , session ) ; String serviceURL = backendServerURL + ANDES_MANAGER_SERVICE_NAME ; ConfigurationContext configContext = ( ConfigurationContext ) config . getServletContext ( ) . getAttribute ( CarbonConstants . CONFIGURATION_CONTEXT ) ; AndesManagerServiceStub stub = new AndesManagerServiceStub ( configContext , serviceURL ) ; String cookie = ( String ) session . getAttribute ( ServerConstants . ADMIN_SERVICE_COOKIE ) ; if ( cookie != null ) { Options option = stub . _getServiceClient ( ) . getOptions ( ) ; option . setManageSession ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTPConstants . COOKIE_STRING , cookie ) ; } return stub ; }
hastef88/carbon-business-messaging | public static AndesEventAdminServiceStub getAndesEventAdminServiceStub ( ServletConfig config , HttpSession session , HttpServletRequest request ) throws AxisFault { String backendServerURL = CarbonUIUtil . getServerURL ( config . getServletContext ( ) , session ) ; backendServerURL = backendServerURL + ANDES_ADMIN_EVENT_SERVICE_NAME ; ConfigurationContext configContext = ( ConfigurationContext ) config . getServletContext ( ) . getAttribute ( CarbonConstants . CONFIGURATION_CONTEXT ) ; AndesEventAdminServiceStub stub = new AndesEventAdminServiceStub ( configContext , backendServerURL ) ; String cookie = ( String ) session . getAttribute ( ServerConstants . ADMIN_SERVICE_COOKIE ) ; if ( cookie != null ) { Options option = stub . _getServiceClient ( ) . getOptions ( ) ; option . setManageSession ( true ) ; option . setProperty ( org . apache . axis2 . transport . http . HTTPConstants . COOKIE_STRING , cookie ) ; } return stub ; }
hastef88/carbon-business-messaging | public static Queue [ ] getFilteredQueueList ( Queue [ ] fullList , int startingIndex , int maxQueueCount ) { Queue [ ] queueDetailsArray ; int resultSetSize = maxQueueCount ; ArrayList < Queue > resultList = new ArrayList < Queue > ( ) ; Collections . addAll ( resultList , fullList ) ; if ( ( resultList . size ( ) - startingIndex ) < maxQueueCount ) { resultSetSize = ( resultList . size ( ) - startingIndex ) ; } queueDetailsArray = new Queue [ resultSetSize ] ; int index = 0 ; int queueDetailsIndex = 0 ; for ( Queue queueDetail : resultList ) { if ( startingIndex == index || startingIndex < index ) { queueDetailsArray [ queueDetailsIndex ] = new Queue ( ) ; queueDetailsArray [ queueDetailsIndex ] . setQueueName ( queueDetail . getQueueName ( ) ) ; queueDetailsArray [ queueDetailsIndex ] . setMessageCount ( queueDetail . getMessageCount ( ) ) ; queueDetailsIndex ++ ; if ( queueDetailsIndex == maxQueueCount ) { break ; } } index ++ ; } return queueDetailsArray ; }
hastef88/carbon-business-messaging | public static Subscription [ ] getFilteredSubscriptionList ( Subscription [ ] fullList , int startingIndex , int maxSubscriptionCount ) { Subscription [ ] subscriptionDetailsArray ; int resultSetSize = maxSubscriptionCount ; ArrayList < Subscription > resultList = new ArrayList < Subscription > ( ) ; Collections . addAll ( resultList , fullList ) ; if ( ( resultList . size ( ) - startingIndex ) < maxSubscriptionCount ) { resultSetSize = ( resultList . size ( ) - startingIndex ) ; } subscriptionDetailsArray = new Subscription [ resultSetSize ] ; int index = 0 ; int subscriptionDetailsIndex = 0 ; for ( Subscription subscriptionDetail : resultList ) { if ( startingIndex == index || startingIndex < index ) { Subscription subscription = new Subscription ( ) ; subscription . setSubscriptionIdentifier ( subscriptionDetail . getSubscriptionIdentifier ( ) ) ; subscription . setSubscribedQueueOrTopicName ( subscriptionDetail . getSubscribedQueueOrTopicName ( ) ) ; subscription . setSubscriberQueueBoundExchange ( subscriptionDetail . getSubscriberQueueBoundExchange ( ) ) ; subscription . setSubscriberQueueName ( subscriptionDetail . getSubscriberQueueName ( ) ) ; subscription . setSubscriptionIdentifier ( subscriptionDetail . getSubscriptionIdentifier ( ) ) ; subscription . setDurable ( subscriptionDetail . getDurable ( ) ) ; subscription . setActive ( subscriptionDetail . getActive ( ) ) ; subscription . setNumberOfMessagesRemainingForSubscriber ( subscriptionDetail . getNumberOfMessagesRemainingForSubscriber ( ) ) ; subscription . setConnectedNodeAddress ( subscriptionDetail . getConnectedNodeAddress ( ) ) ; subscription . setDestination ( subscriptionDetail . getDestination ( ) ) ; subscription . setProtocolType ( subscriptionDetail . getProtocolType ( ) ) ; subscription . setDestinationType ( subscriptionDetail . getDestinationType ( ) ) ; subscription . setOriginHostAddress ( subscriptionDetail . getOriginHostAddress ( ) ) ; subscriptionDetailsArray [ subscriptionDetailsIndex ] = subscription ; subscriptionDetailsIndex ++ ; if ( subscriptionDetailsIndex == maxSubscriptionCount ) { break ; } } index ++ ; } return subscriptionDetailsArray ; }
hastef88/carbon-business-messaging | public static ArrayList < QueueRolePermission > getFilteredRoleList ( ArrayList < QueueRolePermission > allPermissions , int startingIndex , int maxRolesCount ) { int numberOfPermissionsToShow = maxRolesCount ; if ( ( allPermissions . size ( ) - startingIndex ) < maxRolesCount ) { numberOfPermissionsToShow = ( allPermissions . size ( ) - startingIndex ) ; } ArrayList < QueueRolePermission > permissionList = new ArrayList < QueueRolePermission > ( ) ; for ( int i = startingIndex ; i < startingIndex + numberOfPermissionsToShow ; i ++ ) { permissionList . add ( allPermissions . get ( i ) ) ; } return permissionList ; }
Edwin-Ran/es_source_read | static SearchContext createSearchContext ( String indexName , String parentType , String childType ) throws IOException { IndexService indexService = createIndex ( indexName ) ; MapperService mapperService = indexService . mapperService ( ) ; mapperService . merge ( childType , new CompressedString ( PutMappingRequest . buildFromSimplifiedDef ( childType , " _ parent " , " type = " + parentType ) . string ( ) ) , true ) ; return createSearchContext ( indexService ) ; }
Edwin-Ran/es_source_read | static void assertBitSet ( FixedBitSet actual , FixedBitSet expected , IndexSearcher searcher ) throws IOException { if ( ! actual . equals ( expected ) ) { Description description = new StringDescription ( ) ; description . appendText ( reason ( actual , expected , searcher ) ) ; description . appendText ( " \n Expected : ▁ " ) ; description . appendValue ( expected ) ; description . appendText ( " \n ▁ ▁ ▁ ▁ ▁ got : ▁ " ) ; description . appendValue ( actual ) ; description . appendText ( " \n " ) ; throw new java . lang . AssertionError ( description . toString ( ) ) ; } }
Edwin-Ran/es_source_read | static String reason ( FixedBitSet actual , FixedBitSet expected , IndexSearcher indexSearcher ) throws IOException { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " expected ▁ cardinality : " ) . append ( expected . cardinality ( ) ) . append ( ' \n ' ) ; DocIdSetIterator iterator = expected . iterator ( ) ; for ( int doc = iterator . nextDoc ( ) ; doc != DocIdSetIterator . NO_MORE_DOCS ; doc = iterator . nextDoc ( ) ) { builder . append ( " Expected ▁ doc [ " ) . append ( doc ) . append ( " ] ▁ with ▁ id ▁ value ▁ " ) . append ( indexSearcher . doc ( doc ) . get ( UidFieldMapper . NAME ) ) . append ( ' \n ' ) ; } builder . append ( " actual ▁ cardinality : ▁ " ) . append ( actual . cardinality ( ) ) . append ( ' \n ' ) ; iterator = actual . iterator ( ) ; for ( int doc = iterator . nextDoc ( ) ; doc != DocIdSetIterator . NO_MORE_DOCS ; doc = iterator . nextDoc ( ) ) { builder . append ( " Actual ▁ doc [ " ) . append ( doc ) . append ( " ] ▁ with ▁ id ▁ value ▁ " ) . append ( indexSearcher . doc ( doc ) . get ( UidFieldMapper . NAME ) ) . append ( ' \n ' ) ; } return builder . toString ( ) ; }
Edwin-Ran/es_source_read | static void assertTopDocs ( TopDocs actual , TopDocs expected ) { assertThat ( " actual . totalHits ▁ ! = ▁ expected . totalHits " , actual . totalHits , equalTo ( expected . totalHits ) ) ; assertThat ( " actual . getMaxScore ( ) ▁ ! = ▁ expected . getMaxScore ( ) " , actual . getMaxScore ( ) , equalTo ( expected . getMaxScore ( ) ) ) ; assertThat ( " actual . scoreDocs . length ▁ ! = ▁ expected . scoreDocs . length " , actual . scoreDocs . length , equalTo ( actual . scoreDocs . length ) ) ; for ( int i = 0 ; i < actual . scoreDocs . length ; i ++ ) { ScoreDoc actualHit = actual . scoreDocs [ i ] ; ScoreDoc expectedHit = expected . scoreDocs [ i ] ; assertThat ( " actualHit . doc ▁ ! = ▁ expectedHit . doc " , actualHit . doc , equalTo ( expectedHit . doc ) ) ; assertThat ( " actualHit . score ▁ ! = ▁ expectedHit . score " , actualHit . score , equalTo ( expectedHit . score ) ) ; } }
Edwin-Ran/es_source_read | static Filter wrap ( Filter filter ) { return SearchContext . current ( ) . filterCache ( ) . cache ( filter ) ; }
Edwin-Ran/es_source_read | static FixedBitSetFilter wrapWithFixedBitSetFilter ( Filter filter ) { return SearchContext . current ( ) . fixedBitSetFilterCache ( ) . getFixedBitSetFilter ( filter ) ; }
dcapwell/jmh-tests | public static int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | public final static int finalAdd ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | public static int add ( int i , int j ) { return i + j ; }
dcapwell/jmh-tests | public final static int finalAdd ( int i , int j ) { return i + j ; }
hernad/oo-netbeans | public static void start ( final ComponentTypePropertyEditor editor , final PolyStruct plStruct ) { NewTemplateTypesDialog templTypes = new NewTemplateTypesDialog ( editor , plStruct ) ; DialogDescriptor ddscr = new DialogDescriptor ( templTypes , NbBundle . getMessage ( ComponentWizardIterator . class , " LBL _ TemplateTypes _ Title " ) ) ; ddscr . setButtonListener ( templTypes ) ; Dialog d = DialogDisplayer . getDefault ( ) . createDialog ( ddscr ) ; d . setVisible ( true ) ; }
Lekanich/intellij-community | public static void executeOnPooledThread ( Runnable runnable ) { myAsyncTasks . add ( ApplicationManager . getApplication ( ) . executeOnPooledThread ( runnable ) ) ; }
Lekanich/intellij-community | private static void edt ( @ NotNull final ThrowableRunnable < Exception > runnable ) throws Exception { final AtomicReference < Exception > exception = new AtomicReference < Exception > ( ) ; UIUtil . invokeAndWaitIfNeeded ( new Runnable ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Exception throwable ) { exception . set ( throwable ) ; } } } ) ; if ( exception . get ( ) != null ) { throw exception . get ( ) ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String substituteConfigParameters ( String applicationId , String string ) { StrSubstitutor sub = new StrSubstitutor ( new ConfigStringLookup ( applicationId ) ) ; return sub . replace ( string ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String substituteConfigParameters ( String string ) { return SUBSTITUTOR . replace ( string ) ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String parseGroupNamespaceCode ( String namespaceAndNameCombo ) { if ( namespaceAndNameCombo == null ) { return null ; } String [ ] groupData = namespaceAndNameCombo . split ( KewApiConstants . KIM_GROUP_NAMESPACE_NAME_DELIMITER_CHARACTER ) ; if ( groupData . length == 1 ) { return KimConstants . KIM_GROUP_WORKFLOW_NAMESPACE_CODE ; } else if ( groupData . length == 2 ) { return groupData [ 0 ] . trim ( ) ; } else { return null ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static String parseGroupName ( String namespaceAndNameCombo ) { if ( namespaceAndNameCombo == null ) { return null ; } String [ ] groupData = namespaceAndNameCombo . split ( KewApiConstants . KIM_GROUP_NAMESPACE_NAME_DELIMITER_CHARACTER ) ; if ( groupData . length == 1 ) { return groupData [ 0 ] . trim ( ) ; } else if ( groupData . length == 2 ) { return groupData [ 1 ] . trim ( ) ; } else { return null ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static boolean checkDateRanges ( String fromDate , String toDate ) { try { Date parsedDate = CoreApiServiceLocator . getDateTimeService ( ) . convertToDate ( fromDate . trim ( ) ) ; Calendar fromCalendar = Calendar . getInstance ( ) ; fromCalendar . setLenient ( false ) ; fromCalendar . setTime ( parsedDate ) ; fromCalendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; fromCalendar . set ( Calendar . MINUTE , 0 ) ; fromCalendar . set ( Calendar . SECOND , 0 ) ; fromCalendar . set ( Calendar . MILLISECOND , 0 ) ; parsedDate = CoreApiServiceLocator . getDateTimeService ( ) . convertToDate ( toDate . trim ( ) ) ; Calendar toCalendar = Calendar . getInstance ( ) ; toCalendar . setLenient ( false ) ; toCalendar . setTime ( parsedDate ) ; toCalendar . set ( Calendar . HOUR_OF_DAY , 0 ) ; toCalendar . set ( Calendar . MINUTE , 0 ) ; toCalendar . set ( Calendar . SECOND , 0 ) ; toCalendar . set ( Calendar . MILLISECOND , 0 ) ; if ( fromCalendar . after ( toCalendar ) ) { return false ; } return true ; } catch ( Exception ex ) { return false ; } }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static < T extends KeyValue > Map < String , String > getKeyValueCollectionAsMap ( List < T > collection ) { Map < String , String > map = new HashMap < String , String > ( collection . size ( ) ) ; for ( KeyValue kv : collection ) { map . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } return map ; }
ua-eas/ksd-kc5.2.1-rice2.3.6-ua | public static < T extends KeyValue > Map < String , T > getKeyValueCollectionAsLookupTable ( List < T > collection ) { Map < String , T > map = new HashMap < String , T > ( collection . size ( ) ) ; for ( T kv : collection ) { map . put ( kv . getKey ( ) , kv ) ; } return map ; }
erichwang/presto | public static void main ( String [ ] args ) throws RunnerException { Options options = new OptionsBuilder ( ) . verbosity ( VerboseMode . NORMAL ) . include ( " . * " + BenchmarkPagesSort . class . getSimpleName ( ) + " . * " ) . build ( ) ; new Runner ( options ) . run ( ) ; }
Fokko/druid | static void configureSsl ( Binder binder ) { final SSLContext context ; try { context = SSLContext . getDefault ( ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } binder . bind ( SSLContext . class ) . toProvider ( Providers . of ( context ) ) . in ( LazySingleton . class ) ; }
Fokko/druid | static AsyncHttpClient createAsyncHttpClient ( String nameFormat , String timerThreadNameFormat , @ Nullable SSLContext sslContext ) { final DefaultAsyncHttpClientConfig . Builder builder = new DefaultAsyncHttpClientConfig . Builder ( ) . setThreadFactory ( Execs . makeThreadFactory ( nameFormat ) ) . setNettyTimer ( new HashedWheelTimer ( Execs . makeThreadFactory ( timerThreadNameFormat ) ) ) ; if ( sslContext != null ) { builder . setSslContext ( new JdkSslContext ( sslContext , true , ClientAuth . NONE ) ) ; } return new DefaultAsyncHttpClient ( builder . build ( ) ) ; }
Fokko/druid | public static SSLContext getEffectiveSSLContext ( HttpEmitterSSLClientConfig sslConfig , SSLContext sslContext ) { SSLContext effectiveSSLContext ; if ( sslConfig . isUseDefaultJavaContext ( ) ) { try { effectiveSSLContext = SSLContext . getDefault ( ) ; } catch ( NoSuchAlgorithmException nsae ) { throw new RuntimeException ( nsae ) ; } } else if ( sslConfig . getTrustStorePath ( ) != null ) { log . info ( " Creating ▁ SSLContext ▁ for ▁ HttpEmitter ▁ client ▁ using ▁ config ▁ [ % s ] " , sslConfig ) ; effectiveSSLContext = new TLSUtils . ClientSSLContextBuilder ( ) . setProtocol ( sslConfig . getProtocol ( ) ) . setTrustStoreType ( sslConfig . getTrustStoreType ( ) ) . setTrustStorePath ( sslConfig . getTrustStorePath ( ) ) . setTrustStoreAlgorithm ( sslConfig . getTrustStoreAlgorithm ( ) ) . setTrustStorePasswordProvider ( sslConfig . getTrustStorePasswordProvider ( ) ) . build ( ) ; } else { effectiveSSLContext = sslContext ; } return effectiveSSLContext ; }
hotchemi/wearzaim | public static Intent createIntent ( Context context , boolean login ) { Intent intent = new Intent ( context , SendLoginStatusService . class ) ; intent . putExtra ( KEY_LOGIN , String . valueOf ( login ) ) ; return intent ; }
coderkiss/ImageLoader | public static ImageLoader getInstance ( ) { synchronized ( ImageLoader . class ) { if ( instance == null ) { instance = new ImageLoader ( ) ; } } return instance ; }
shalk/TIJ4Code | public static void main ( String [ ] args ) { }
euler-form/web-form | public static int getI18nRefreshFreq ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_CACHE_I18N_REFRESH_FREQ , key -> { return properties . getIntValue ( WebConfigKey . CORE_CACHE_I18N_REFRESH_FREQ , WebConfigDefault . CORE_CACHE_I18N_REFRESH_FREQ ) ; } ) ; return ( int ) cachedConfig ; }
euler-form/web-form | public static String getWebUrl ( ) { try { String result = properties . get ( WebConfigKey . WEB_URL ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( WebConfigKey . WEB_URL + " can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " / " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } return result ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( e ) ; } }
euler-form/web-form | public static boolean isApiEnabled ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_API_ENABLED , key -> { return properties . getBooleanValue ( key , WebConfigDefault . WEB_API_ENABLED ) ; } ) ; return ( boolean ) cachedConfig ; }
euler-form/web-form | public static String getApiRootPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_API_ROOT_PATH , key -> { String result = properties . get ( key , WebConfigDefault . WEB_API_ROOT_PATH ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( key + " can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = CommonUtils . convertDirToUnixFormat ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminRootPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_ROOT_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result = properties . get ( WebConfigKey . WEB_ADMIN_ROOT_PATH , WebConfigDefault . WEB_ADMIN_ROOT_PATH ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( WebConfigKey . WEB_ADMIN_ROOT_PATH + " ▁ can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = CommonUtils . convertDirToUnixFormat ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getStaticPagesRootPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_STATIC_PAGES_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result = properties . get ( key , WebConfigDefault . WEB_STATIC_PAGES_PATH ) ; if ( ! StringUtils . hasText ( result ) ) throw new RuntimeException ( key + " ▁ can ▁ not ▁ be ▁ empty " ) ; while ( result . endsWith ( " * " ) ) { result = result . substring ( 0 , result . length ( ) - 1 ) ; } result = CommonUtils . convertDirToUnixFormat ( result , false ) ; if ( ! result . startsWith ( " / " ) ) result = " / " + result ; return result ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getJspPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_JSP_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return CommonUtils . convertDirToUnixFormat ( properties . get ( WebConfigKey . WEB_JSP_PATH , WebConfigDefault . WEB_JSP_PATH ) , true ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminJspPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_JSP_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return CommonUtils . convertDirToUnixFormat ( properties . get ( WebConfigKey . WEB_ADMIN_JSP_PATH , WebConfigDefault . WEB_ADMIN_JSP_PATH ) , true ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getRuntimePath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_RUNTIME_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String result ; try { result = properties . get ( WebConfigKey . CORE_RUNTIME_PATH ) ; } catch ( PropertyNotFoundException e ) { if ( isWindows ( ) ) { LOGGER . info ( " OS ▁ is ▁ windows " ) ; result = WebConfigDefault . CORE_RUNTIME_PATH_WIN ; } else { LOGGER . info ( " OS ▁ isn ' t ▁ windows " ) ; result = WebConfigDefault . CORE_RUNTIME_PATH_UNIX ; } LOGGER . warn ( " Couldn ' t ▁ load ▁ " + WebConfigKey . CORE_RUNTIME_PATH + " ▁ , ▁ use ▁ " + result + " ▁ for ▁ default . " ) ; } result = CommonUtils . convertDirToUnixFormat ( result , true ) ; if ( ! result . startsWith ( " / " ) && ! result . startsWith ( " file : // " ) ) { throw new RuntimeException ( WebConfigKey . CORE_RUNTIME_PATH + " ▁ must ▁ bengin ▁ with ▁ file : // ▁ or ▁ / " ) ; } else { if ( result . startsWith ( " file : // " ) ) { result = result . substring ( " file : // " . length ( ) ) ; } } if ( isWindows ( ) && result . startsWith ( " / " ) ) { result = " C : " + result ; } return CommonUtils . convertDirToUnixFormat ( result , false ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static long getRamCacheCleanFreq ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_CAHCE_RAMCACHE_POOL_CLEAN_FREQ , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . getLongValue ( WebConfigKey . CORE_CAHCE_RAMCACHE_POOL_CLEAN_FREQ , WebConfigDefault . CORE_CAHCE_RAMCACHE_POOL_CLEAN_FREQ ) ; } } ) ; return ( long ) cachedConfig ; }
euler-form/web-form | public static MultiPartConfig getMultiPartConfig ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_MULITPART , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { String location = properties . get ( WebConfigKey . WEB_MULITPART_LOCATION , WebConfigDefault . WEB_MULITPART_LOCATION ) ; long maxFileSize = properties . getLongValue ( WebConfigKey . WEB_MULITPART_MAX_FILE_SIZE , WebConfigDefault . WEB_MULITPART_MAX_FILE_SIZE ) ; long maxRequestSize = properties . getLongValue ( WebConfigKey . WEB_MULITPART_MAX_REQUEST_SIZE , WebConfigDefault . WEB_MULITPART_MAX_REQUEST_SIZE ) ; int fileSizeThreshold = properties . getIntValue ( WebConfigKey . WEB_MULITPART_FILE_SIZE_THRESHOLD , WebConfigDefault . WEB_MULITPART_FILE_SIZE_THRESHOLD ) ; MultiPartConfig result = new MultiPartConfig ( location , maxFileSize , maxRequestSize , fileSizeThreshold ) ; return result ; } } ) ; return ( MultiPartConfig ) cachedConfig ; }
euler-form/web-form | public static ProjectMode getProjectMode ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_MODE , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . getEnumValue ( WebConfigKey . PROJECT_MODE , WebConfigDefault . PROJECT_MODE , true ) ; } } ) ; return ( ProjectMode ) cachedConfig ; }
euler-form/web-form | public static String getProjectVersion ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_VERSION , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { try { return properties . get ( WebConfigKey . PROJECT_VERSION ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( " Couldn ' t ▁ load ▁ " + WebConfigKey . PROJECT_VERSION ) ; } } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getProjectBuildtime ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_BUILDTIME , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { try { return properties . get ( WebConfigKey . PROJECT_BUILDTIME ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( " Couldn ' t ▁ load ▁ " + WebConfigKey . PROJECT_BUILDTIME ) ; } } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getCopyrightHolder ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . PROJECT_COPYRIGHT_HOLDER , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . PROJECT_COPYRIGHT_HOLDER , WebConfigDefault . PROJECT_COPYRIGHT_HOLDER ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getSitename ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_SITENAME , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_SITENAME , WebConfigDefault . WEB_SITENAME ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAssetsPath ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ASSETS_PATH , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_ASSETS_PATH , WebConfigDefault . WEB_ASSETS_PATH ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static boolean isDebugMode ( ) { return getProjectMode ( ) . equals ( ProjectMode . DEVELOP ) || getProjectMode ( ) . equals ( ProjectMode . DEBUG ) ; }
euler-form/web-form | public static String getDefaultTheme ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_DEFAULT_THEME , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_DEFAULT_THEME , WebConfigDefault . WEB_DEFAULT_THEME ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminDashboardBrandIcon ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_ICON , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_ICON , WebConfigDefault . WEB_ADMIN_DASHBOARD_BRAND_ICON ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminDashboardBrandText ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_TEXT , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . WEB_ADMIN_DASHBOARD_BRAND_TEXT , WebConfigDefault . WEB_ADMIN_DASHBOARD_BRAND_TEXT ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getRootContextConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_ROOT_CONTEXT_CONFIG_CLASS , key -> { return properties . get ( key , WebConfigDefault . CORE_ROOT_CONTEXT_CONFIG_CLASS ) ; } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getWebConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_WEB_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_WEB_CONFIG_CLASS , WebConfigDefault . CORE_WEB_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAjaxConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_AJAX_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_AJAX_CONFIG_CLASS , WebConfigDefault . CORE_AJAX_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminWebConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_ADMIN_WEB_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_ADMIN_WEB_CONFIG_CLASS , WebConfigDefault . CORE_ADMIN_WEB_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getAdminAjaxConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_ADMIN_AJAX_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_ADMIN_AJAX_CONFIG_CLASS , WebConfigDefault . CORE_ADMIN_AJAX_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static String getApiConfigClassName ( ) { Object cachedConfig = CONFIG_CAHCE . get ( WebConfigKey . CORE_API_CONFIG_CLASS , new DataGetter < String , Object > ( ) { @ Override public Object getData ( String key ) { return properties . get ( WebConfigKey . CORE_API_CONFIG_CLASS , WebConfigDefault . CORE_API_CONFIG_CLASS ) ; } } ) ; return ( String ) cachedConfig ; }
euler-form/web-form | public static Locale getDefaultLanguage ( ) { return ( Locale ) CONFIG_CAHCE . get ( WebConfigKey . WEB_DEFAULT_LANGUAGE , key -> { try { String defaultLanguagesStr = properties . get ( key ) ; Assert . hasText ( defaultLanguagesStr , WebConfigKey . WEB_DEFAULT_LANGUAGE + " ▁ can ▁ not ▁ be ▁ empty " ) ; return CommonUtils . parseLocale ( defaultLanguagesStr ) ; } catch ( PropertyNotFoundException e ) { return WebConfigDefault . WEB_DEFAULT_LANGUAGE ; } } ) ; }
euler-form/web-form | public static Locale [ ] getSupportLanguages ( ) { return ( Locale [ ] ) CONFIG_CAHCE . get ( WebConfigKey . WEB_SUPPORT_LANGUAGES , key -> { try { String supportLanguagesStr = properties . get ( key ) ; String [ ] supportLanguagesStrArray = supportLanguagesStr . split ( " , " ) ; Locale [ ] ret = new Locale [ supportLanguagesStrArray . length ] ; for ( int i = 0 ; i < supportLanguagesStrArray . length ; i ++ ) { ret [ i ] = CommonUtils . parseLocale ( supportLanguagesStrArray [ i ] ) ; ; } return ret ; } catch ( PropertyNotFoundException e ) { return WebConfigDefault . WEB_SUPPORT_LANGUAGES ; } } ) ; }
euler-form/web-form | public static String getConfigPath ( ) { return getRuntimePath ( ) + " / conf / config . properties " ; }
euler-form/web-form | public static boolean isWindows ( ) { return System . getProperty ( " os . name " ) . toLowerCase ( ) . indexOf ( " windows " ) > - 1 ; }
euler-form/web-form | public static String getSmtp ( ) { return ( String ) CONFIG_CAHCE . get ( WebConfigKey . MAIL_SMTP , key -> { try { return properties . get ( key ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( e ) ; } } ) ; }
euler-form/web-form | public static RedisType getRedisType ( ) { return ( RedisType ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_TYPE , key -> properties . getEnumValue ( key , WebConfigDefault . REDIS_TYPE , true ) ) ; }
euler-form/web-form | public static String getRedisHost ( ) { return ( String ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_HOST , key -> properties . get ( key , WebConfigDefault . REDIS_HOST ) ) ; }
euler-form/web-form | public static String getRedisPassword ( ) { return ( String ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_PASSWORD , key -> properties . get ( key , WebConfigDefault . REDIS_PASSWORD ) ) ; }
euler-form/web-form | public static int getRedisPort ( ) { return ( int ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_PORT , key -> properties . getIntValue ( key , WebConfigDefault . REDIS_PORT ) ) ; }
euler-form/web-form | public static String [ ] getRedisSentinels ( ) { String str = ( String ) CONFIG_CAHCE . get ( WebConfigKey . REDIS_SENTINELS , key -> { try { return properties . get ( key ) ; } catch ( PropertyNotFoundException e ) { throw new RuntimeException ( e ) ; } } ) ; Assert . hasText ( str , ( ) -> WebConfigKey . REDIS_SENTINELS + " can ▁ not ▁ be ▁ empty " ) ; return str . split ( " , " ) ; }
sajavadi/pinot | public static SegmentPruner getSegmentPruner ( String prunerClassName , Configuration segmentPrunerConfig ) { try { Class < ? extends SegmentPruner > cls = PRUNER_MAP . get ( prunerClassName . toLowerCase ( ) ) ; if ( cls != null ) { SegmentPruner segmentPruner = cls . newInstance ( ) ; segmentPruner . init ( segmentPrunerConfig ) ; return segmentPruner ; } } catch ( Exception ex ) { throw new RuntimeException ( " Not ▁ support ▁ SegmentPruner ▁ type ▁ with ▁ - ▁ " + prunerClassName , ex ) ; } throw new UnsupportedOperationException ( " No ▁ SegmentPruner ▁ type ▁ with ▁ - ▁ " + prunerClassName ) ; }
jgaupp/arx | private static int checkStyle ( int style ) { if ( ( style & SWT . BORDER ) != 0 ) style |= SWT . SHADOW_IN ; int mask = SWT . SHADOW_IN | SWT . SHADOW_OUT | SWT . SHADOW_NONE | SWT . LEFT_TO_RIGHT | SWT . RIGHT_TO_LEFT ; style = style & mask ; return style |= SWT . NO_FOCUS | SWT . DOUBLE_BUFFERED ; }
SDRC-India/collect | public static void setWebCredentialsFromPreferences ( Context context ) { final SharedPreferences settings = PreferenceManager . getDefaultSharedPreferences ( context ) ; String username = getUserName ( settings ) ; String password = getPassword ( settings ) ; if ( username == null || username . isEmpty ( ) ) return ; String host = Uri . parse ( getServer ( settings , context ) ) . getHost ( ) ; WebUtils . addCredentials ( username , password , host ) ; }
SDRC-India/collect | private static String getServer ( SharedPreferences settings , Context context ) { return settings . getString ( PreferenceKeys . KEY_SERVER_URL , context . getString ( R . string . default_server_url ) ) ; }
SDRC-India/collect | private static String getPassword ( SharedPreferences settings ) { return settings . getString ( PreferenceKeys . KEY_PASSWORD , null ) ; }
SDRC-India/collect | private static String getUserName ( SharedPreferences settings ) { return settings . getString ( PreferenceKeys . KEY_USERNAME , null ) ; }
lj3lj3/XBridge | public static XBridgeFragment getFragment ( Bundle bundle ) { XBridgeFragment fragment = new XBridgeFragment ( ) ; fragment . setArguments ( bundle ) ; return fragment ; }
baiyubin/javatemplates | public static void main ( String [ ] args ) { IterativeTwo i2 = new IterativeTwo ( ) ; System . out . println ( i2 . solutionSteps ( 3 ) ) ; }
google/fest | public static void pause ( @ Nonnull Condition condition ) { pause ( condition , DEFAULT_DELAY ) ; }
google/fest | public static void pause ( @ Nonnull Condition condition , @ Nonnull Timeout timeout ) { checkNotNull ( timeout ) ; pause ( condition , timeout . duration ( ) ) ; }
google/fest | public static void pause ( @ Nonnull Condition condition , long timeout ) { checkNotNull ( condition ) ; TimeoutWatch watch = startWatchWithTimeoutOf ( timeout ) ; while ( ! condition . test ( ) ) { if ( watch . isTimeOut ( ) && ! condition . test ( ) ) { condition . done ( ) ; throw new WaitTimedOutError ( String . format ( " Timed ▁ out ▁ waiting ▁ for ▁ % s " , condition . toString ( ) ) ) ; } pause ( SLEEP_INTERVAL ) ; } condition . done ( ) ; }
google/fest | public static void pause ( @ Nonnull Condition [ ] conditions ) { pause ( conditions , DEFAULT_DELAY ) ; }
google/fest | public static void pause ( @ Nonnull Condition [ ] conditions , @ Nonnull Timeout timeout ) { pause ( conditions , timeout . duration ( ) ) ; }
google/fest | public static void pause ( @ Nonnull Condition [ ] conditions , long timeout ) { checkNotNullOrEmpty ( conditions ) ; TimeoutWatch watch = startWatchWithTimeoutOf ( timeout ) ; while ( ! areSatisfied ( conditions ) ) { if ( watch . isTimeOut ( ) ) { for ( Condition condition : conditions ) { condition . done ( ) ; } throw new WaitTimedOutError ( String . format ( " Timed ▁ out ▁ waiting ▁ for ▁ % s " , format ( conditions ) ) ) ; } pause ( SLEEP_INTERVAL ) ; } for ( Condition condition : conditions ) { condition . done ( ) ; } }
google/fest | private static boolean areSatisfied ( @ Nonnull Condition [ ] conditions ) { for ( Condition condition : conditions ) { checkNotNull ( condition ) ; if ( ! condition . test ( ) ) { return false ; } } return true ; }
google/fest | public static void pause ( long timeout , @ Nonnull TimeUnit unit ) { checkNotNull ( unit ) ; pause ( unit . toMillis ( timeout ) ) ; }
google/fest | public static void pause ( long ms ) { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; } }
google/fest | public static void pause ( ) { pause ( SLEEP_INTERVAL ) ; }
apache/activemq-openwire | static private void add ( DataStreamMarshaller dsm ) { marshaller [ dsm . getDataStructureType ( ) ] = dsm ; }
apache/activemq-openwire | static public DataStreamMarshaller [ ] createMarshallerMap ( OpenWireFormat wireFormat ) { return marshaller ; }
cfieber/orca | private static Map < String , Object > findBuildInfoInUpstreamStage ( Stage currentStage , List < Pattern > packageFilePatterns ) { Stage upstreamStage = currentStage . ancestors ( ) . stream ( ) . filter ( it -> { Map < String , Object > buildInfo = ( Map < String , Object > ) it . getOutputs ( ) . get ( " buildInfo " ) ; return buildInfo != null && artifactMatch ( ( List < Map < String , String > > ) buildInfo . get ( " artifacts " ) , packageFilePatterns ) ; } ) . findFirst ( ) . orElse ( null ) ; return upstreamStage != null ? ( Map < String , Object > ) upstreamStage . getOutputs ( ) . get ( " buildInfo " ) : emptyMap ( ) ; }
cfieber/orca | private static boolean artifactMatch ( List < Map < String , String > > artifacts , List < Pattern > patterns ) { return artifacts != null && artifacts . stream ( ) . anyMatch ( ( Map artifact ) -> patterns . stream ( ) . anyMatch ( p -> p . matcher ( String . valueOf ( artifact . get ( " fileName " ) ) ) . matches ( ) ) ) ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( ) { return new AffinityGroupFilterOptions ( false ) ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( boolean matchesAny ) { return new AffinityGroupFilterOptions ( matchesAny ) ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( @ Nonnull String regex ) { AffinityGroupFilterOptions options = new AffinityGroupFilterOptions ( false ) ; options . regex = regex ; return options ; }
JanewzhWang/dasein-cloud-core | public static @ Nonnull AffinityGroupFilterOptions getInstance ( boolean matchesAny , @ Nonnull String regex ) { AffinityGroupFilterOptions options = new AffinityGroupFilterOptions ( matchesAny ) ; options . regex = regex ; return options ; }
272029252/Metamorphosis | public static AddMsgLocation decode ( final ByteBuffer buf ) { if ( ! buf . hasRemaining ( ) ) { return null ; } final long offset = buf . getLong ( ) ; final int length = buf . getInt ( ) ; final int checksum = buf . getInt ( ) ; final int descLen = buf . getInt ( ) ; final byte [ ] descBytes = new byte [ descLen ] ; buf . get ( descBytes ) ; final String desc = ByteUtils . getString ( descBytes ) ; return new AddMsgLocation ( offset , length , checksum , desc ) ; }
GunoH/intellij-community | public static < A , B > List < B > map ( Function < A , B > fn , List < A > as ) { return null ; }
GunoH/intellij-community | public static < A , B > B foldLeft ( BiFunction < B , A , B > fn , B b , List < A > as ) { return null ; }
GunoH/intellij-community | public static void main ( String [ ] args ) { List < CoProduct2 < String , Integer > > criteria = emptyList ( ) ; foldLeft ( ( r , t ) -> t . into ( ( s , i ) -> null ) , new Tuple2 < List < Object > , List < Object > > ( new ArrayList < > ( ) , new ArrayList < > ( ) ) , map ( CoProduct2 :: project , criteria ) ) ; }
GunoH/intellij-community | private static < Am , Bm > List < Bm > map ( Function < Am , Bm > fn , List < Am > as ) { return null ; }
GunoH/intellij-community | private static < Al > void foldLeft ( Consumer < Al > fn , List < Al > as ) { }
GunoH/intellij-community | public static void foo ( final List < CoProduct2 < String > > criteria ) { foldLeft ( ( t ) -> t . into ( ) , map ( CoProduct2 :: project , criteria ) ) ; }
wintersandroid/lego-display-sequencer | @ NonNull public static SequenceThread parseSnapshot ( @ NonNull DataSnapshot snapshot ) { Log . d ( TAG , " parseSnapshot ▁ " + snapshot . toString ( ) ) ; SequenceThread sequenceThread = snapshot . getValue ( SequenceThread . class ) ; sequenceThread . setKey ( snapshot . getKey ( ) ) ; return sequenceThread ; }
don-philipe/graphhopper | private static GraphHopperServerConfiguration createConfig ( ) { GraphHopperServerConfiguration config = new GraphHopperServerTestConfiguration ( ) ; config . getGraphHopperConfiguration ( ) . putObject ( " graph . flag _ encoders " , " car | turn _ costs = true " ) . putObject ( " routing . ch . disabling _ allowed " , true ) . putObject ( " prepare . min _ network _ size " , 0 ) . putObject ( " datareader . file " , " . . / core / files / moscow . osm . gz " ) . putObject ( " graph . encoded _ values " , " road _ class , surface , road _ environment , max _ speed " ) . putObject ( " graph . location " , DIR ) . setProfiles ( Arrays . asList ( new Profile ( " my _ car _ turn _ costs " ) . setVehicle ( " car " ) . setWeighting ( " fastest " ) . setTurnCosts ( true ) , new Profile ( " my _ car _ no _ turn _ costs " ) . setVehicle ( " car " ) . setWeighting ( " fastest " ) . setTurnCosts ( false ) ) ) . setCHProfiles ( Arrays . asList ( new CHProfile ( " my _ car _ turn _ costs " ) , new CHProfile ( " my _ car _ no _ turn _ costs " ) ) ) . setLMProfiles ( Arrays . asList ( new LMProfile ( " my _ car _ no _ turn _ costs " ) , new LMProfile ( " my _ car _ turn _ costs " ) . setPreparationProfile ( " my _ car _ no _ turn _ costs " ) ) ) ; return config ; }
don-philipe/graphhopper | @ BeforeAll @ AfterAll public static void cleanUp ( ) { Helper . removeDir ( new File ( DIR ) ) ; }
clemus90/competitive-programming | static Scanner newInput ( ) throws IOException { if ( System . getProperty ( " JUDGE " ) != null ) { return new Scanner ( new File ( " chairs . in " ) ) ; } else { return new Scanner ( System . in ) ; } }
clemus90/competitive-programming | static PrintWriter newOutput ( ) throws IOException { if ( System . getProperty ( " JUDGE " ) != null ) { return new PrintWriter ( " chairs . out " ) ; } else { return new PrintWriter ( System . out ) ; } }
clemus90/competitive-programming | public static void main ( String [ ] args ) throws IOException { try ( Scanner in = newInput ( ) ; PrintWriter out = newOutput ( ) ) { double [ ] sides = new double [ 3 ] ; double avg = 0 ; for ( int i = 0 ; i < 3 ; i ++ ) { sides [ i ] = ( in . nextDouble ( ) ) / 2.0 ; avg += sides [ i ] ; } avg /= 3 ; NumberFormat f = new DecimalFormat ( " # 0.0000000" ) ; out . println ( f . format ( avg ) ) ; } }
arthurthouzeau/SudokuSolverGUI | public static SudokuBoard importFromCSV ( String inputFile ) throws ImportException { try ( CSVReader reader = new CSVReader ( new FileReader ( inputFile ) ) ) { String [ ] nextLine ; int countLines = 0 ; if ( ( nextLine = reader . readNext ( ) ) == null ) { throw new ImportException ( " Please ▁ check ▁ that ▁ the ▁ file ▁ is ▁ not ▁ empty . " ) ; } int tst = ( int ) Math . sqrt ( nextLine . length ) ; if ( tst * tst != nextLine . length ) { throw new ImportException ( " Please ▁ check ▁ the ▁ number ▁ of ▁ columns . \n " + " It ▁ should ▁ be ▁ a ▁ perfect ▁ square . " ) ; } SudokuBoard sb = new SudokuBoard ( nextLine . length ) ; do { if ( nextLine . length != sb . SIZE ) { throw new ImportException ( " Please ▁ check ▁ each ▁ row ▁ has ▁ " + sb . SIZE + " ▁ columns . ▁ ( Same ▁ as ▁ first ▁ row ) " ) ; } for ( int j = 0 ; j < nextLine . length ; j ++ ) { sb . set ( Integer . parseInt ( nextLine [ j ] . trim ( ) ) , countLines , j ) ; } countLines ++ ; } while ( ( nextLine = reader . readNext ( ) ) != null && countLines < sb . SIZE ) ; if ( countLines < sb . SIZE || nextLine != null ) { throw new ImportException ( " Please ▁ check ▁ the ▁ input ▁ CSV ▁ file ▁ has ▁ " + sb . SIZE + " ▁ rows . ▁ ( To ▁ match ▁ the ▁ number ▁ of ▁ columns ) " ) ; } return sb ; } catch ( FileNotFoundException e ) { String errorMsg = " The ▁ file ▁ you ▁ specified ▁ was ▁ not ▁ found . " ; throw new ImportException ( errorMsg ) ; } catch ( NumberFormatException e ) { String errorMsg = " Please ▁ check ▁ all ▁ values ▁ are ▁ integer . " ; throw new ImportException ( errorMsg ) ; } catch ( IOException e ) { throw new ImportException ( e . toString ( ) ) ; } }
xitrum-framework/scalive | public static void agentmain ( String agentArgs , Instrumentation inst ) throws IOException { final String [ ] args = agentArgs . split ( " ▁ " ) ; final String [ ] jarSearchDirs = args [ 0 ] . split ( File . pathSeparator ) ; final int port = Integer . parseInt ( args [ 1 ] ) ; final ServerSocket serverSocket = Server . open ( port ) ; new Thread ( Agent . class . getName ( ) + " - Server " ) { @ Override public void run ( ) { try { Server . run ( serverSocket , jarSearchDirs ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } } . start ( ) ; }
gems-uff/dominoes | public static void Open ( ) { File f = new File ( database_file ) ; boolean createStructure = false ; if ( ! f . exists ( ) ) createStructure = true ; try { Class . forName ( " org . sqlite . JDBC " ) ; conn = DriverManager . getConnection ( " jdbc : sqlite : " + database_file ) ; if ( createStructure ) CreateGitMinerRepoStructure ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static void Close ( ) { try { conn . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static Map < String , Commit > Unserialize ( String _repository ) throws SQLException { Map < String , Commit > resultSet = new HashMap < String , Commit > ( ) ; String sql ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; sql = " SELECT ▁ TC . date , ▁ TC . hashcode , ▁ TU . name ▁ AS ▁ UserName , ▁ Tc . message , ▁ TFile . newName ▁ AS ▁ FileName , ▁ " + " TClass . name ▁ AS ▁ ClassName , ▁ TFunction . name ▁ AS ▁ FuncName ▁ " + " FROM ▁ TCommit ▁ TC ▁ " + " INNER ▁ JOIN ▁ TRepository ▁ TR ▁ ON ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " INNER ▁ JOIN ▁ TUser ▁ TU ▁ ON ▁ TC . userid ▁ = ▁ TU . id ▁ " + " LEFT ▁ JOIN ▁ TFile ▁ ON ▁ TFile . commitid ▁ = ▁ TC . id ▁ " + " LEFT ▁ JOIN ▁ TClass ▁ on ▁ TClass . fileid ▁ = ▁ TFile . id ▁ " + " LEFT ▁ JOIN ▁ TFunction ▁ ON ▁ TFunction . classid ▁ = ▁ TClass . id ▁ " + " WHERE ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . date ; ▁ " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { Commit currentCommit = resultSet . get ( rs . getString ( " HashCode " ) ) ; if ( currentCommit == null ) { currentCommit = new Commit ( rs . getString ( " HashCode " ) , rs . getString ( " UserName " ) ) ; try { currentCommit . date = sdf . parse ( rs . getString ( " date " ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } resultSet . put ( currentCommit . hash , currentCommit ) ; } String _fileName = rs . getString ( " FileName " ) ; if ( _fileName != null ) { FileArch currentFile = currentCommit . files . get ( _fileName ) ; if ( currentFile == null ) { currentFile = new FileArch ( _fileName ) ; currentCommit . files . put ( currentFile . filename , currentFile ) ; String _className = rs . getString ( " ClassName " ) ; if ( _className != null ) { FileClass currentClass = currentFile . classes . get ( _className ) ; if ( currentClass == null ) { currentClass = new FileClass ( _className ) ; currentFile . classes . put ( currentClass . className , currentClass ) ; } String _funcName = rs . getString ( " FuncName " ) ; if ( _funcName != null ) { currentClass . functions . add ( _funcName ) ; } } } } } rs . close ( ) ; smt . close ( ) ; return resultSet ; }
gems-uff/dominoes | public static Date AddRepository ( RepositoryNode repo ) { Statement smt ; String sql ; Date lastCommitDate = null ; try { smt = conn . createStatement ( ) ; lastCommitDate = GetLastCommitDate ( repo . getName ( ) ) ; if ( lastCommitDate == null ) { sql = " INSERT ▁ INTO ▁ TREPOSITORY ( Name ) ▁ VALUES ▁ ( ' " + repo . getName ( ) + " ' ) ; " ; smt . executeUpdate ( sql ) ; smt . close ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } return lastCommitDate ; }
gems-uff/dominoes | public static void Serialize ( RepositoryNode repo ) { Statement smt ; String sql ; try { smt = conn . createStatement ( ) ; Date lastCommitDate = AddRepository ( repo ) ; InsertUsers ( ) ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; List < CommitNode > commits = repo . getCommits ( ) ; for ( CommitNode commit : commits ) { if ( lastCommitDate == null || ( lastCommitDate != null && commit . getDate ( ) . after ( lastCommitDate ) ) ) { sql = " INSERT ▁ INTO ▁ TCOMMIT ▁ ( RepoId , ▁ UserId , ▁ HashCode , ▁ Date , ▁ Message ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TREPOSITORY ▁ TR ▁ WHERE ▁ TR . Name ▁ = ▁ ' " + repo . getName ( ) + " ' ) , " + " ( SELECT ▁ id ▁ FROM ▁ TUSER ▁ TU ▁ WHERE ▁ TU . Name ▁ = ▁ ' " + commit . getUser ( ) . getName ( ) + " ' ) , " + " ' " + commit . getId ( ) + " ' , " + " ' " + sdf . format ( commit . getDate ( ) ) + " ' , " + " ' " + commit . getLogMessage ( ) . replaceAll ( " ' " , " ' ' " ) + " ' ) ; " ; for ( FileNode fileNode : commit . getFiles ( ) ) { sql += " INSERT ▁ INTO ▁ TFILE ▁ ( CommitId , ▁ NewName , ▁ OldName , ▁ NewObjId , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TCOMMIT ▁ TC ▁ WHERE ▁ TC . HashCode ▁ = ▁ ' " + commit . getId ( ) + " ' ) , " + " ' " + fileNode . newName + " ' , " + " ' " + fileNode . oldName + " ' , " + " ' " + fileNode . newObjId + " ' , " + " ' " + fileNode . changeType + " ' ) ; " ; for ( ClassNode classNode : fileNode . getClasses ( ) ) { sql += " INSERT ▁ INTO ▁ TCLASS ▁ ( FileId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TFILE ▁ TF ▁ WHERE ▁ TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ) , " + " ' " + classNode . getName ( ) + " ' , " + classNode . getLineStart ( ) + " , " + classNode . getLineEnd ( ) + " , " + " ' " + classNode . getChangeType ( ) + " ' ) ; " ; for ( FunctionNode functionNode : classNode . getFunctions ( ) ) { sql += " INSERT ▁ INTO ▁ TFUNCTION ▁ ( ClassId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCLASS ▁ TC , ▁ TFILE ▁ TF ▁ WHERE ▁ TC . Name ▁ = ▁ ' " + classNode . getName ( ) + " ' ▁ AND ▁ " + " TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ▁ AND ▁ TC . FileId ▁ = ▁ TF . id ) , " + " ' " + functionNode . getName ( ) + " ' , " + functionNode . getLineStart ( ) + " , " + functionNode . getLineEnd ( ) + " , " + " ' " + functionNode . getChangeType ( ) + " ' ) ; " ; } } } sql += " UPDATE ▁ TREPOSITORY ▁ SET ▁ LastCommitId ▁ = ▁ " + " ( SELECT ▁ distinct ( id ) ▁ FROM ▁ TCOMMIT ▁ where ▁ date ▁ = ▁ ( select ▁ max ( date ) ▁ from ▁ TCOMMIT ) ) " + " WHERE ▁ Name ▁ = ▁ ' " + repo . getName ( ) + " ' ; " ; smt . executeUpdate ( sql ) ; } } smt . close ( ) ; } catch ( SQLException e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | private static Date GetLastCommitDate ( String name ) { Date result = null ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; String sql = " SELECT ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TR . LastCommitId ▁ = ▁ TC . id ▁ AND ▁ " + " TR . Name ▁ = ▁ ' " + name + " ' ; " ; Statement stm ; ResultSet rs ; try { stm = conn . createStatement ( ) ; rs = stm . executeQuery ( sql ) ; while ( rs . next ( ) ) { try { result = sdf . parse ( rs . getString ( " date " ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } } } catch ( SQLException e ) { e . printStackTrace ( ) ; } return result ; }
gems-uff/dominoes | private static void InsertUsers ( ) throws SQLException { Map < String , UserNode > users = UserNode . getUsers ( ) ; Statement smt = conn . createStatement ( ) ; for ( UserNode user : users . values ( ) ) { String sql = " SELECT ▁ * ▁ FROM ▁ TUSER ▁ WHERE ▁ name ▁ = ▁ ' " + user . getName ( ) + " ' ; " ; ResultSet rs = smt . executeQuery ( sql ) ; if ( ! rs . next ( ) ) { sql = " INSERT ▁ INTO ▁ TUSER ▁ ( Name ) ▁ VALUES ▁ ( ' " + user . getName ( ) + " ' ) ; " ; smt . executeUpdate ( sql ) ; } rs . close ( ) ; } smt . close ( ) ; }
gems-uff/dominoes | public static int getUserId ( String name ) { name = name . replaceAll ( " ' " , " ' ' " ) ; try { Statement smt = conn . createStatement ( ) ; String sql = " SELECT ▁ * ▁ FROM ▁ TUSER ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ; ResultSet rs = smt . executeQuery ( sql ) ; if ( ! rs . next ( ) ) { sql = " INSERT ▁ INTO ▁ TUSER ▁ ( Name ) ▁ VALUES ▁ ( ' " + name + " ' ) ; " ; smt . executeUpdate ( sql ) ; } else { return rs . getInt ( " id " ) ; } sql = " SELECT ▁ * ▁ FROM ▁ TUSER ▁ WHERE ▁ name ▁ = ▁ ' " + name + " ' ; " ; rs = smt . executeQuery ( sql ) ; if ( rs . next ( ) ) return rs . getInt ( " id " ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return - 1 ; }
gems-uff/dominoes | private static void CreateGitMinerRepoStructure ( ) { try { Statement smt = conn . createStatement ( ) ; String sql = " CREATE ▁ TABLE ▁ TREPOSITORY ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " Name ▁ STRING ▁ UNIQUE ▁ NOT ▁ NULL , " + " LastCommitId ▁ INTEGER ▁ REFERENCES ▁ TCOMMIT ( id ) ) ; " + " CREATE ▁ TABLE ▁ TUSER ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " Name ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TCOMMIT ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " RepoId ▁ INTEGER ▁ REFERENCES ▁ TREPOSITORY ( id ) ▁ NOT ▁ NULL , " + " UserID ▁ INTEGER ▁ REFERENCES ▁ TUSER ( id ) ▁ NOT ▁ NULL , " + " HashCode ▁ STRING ▁ NOT ▁ NULL , " + " Date ▁ STRING ▁ NOT ▁ NULL , " + " Message ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TFILE ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " CommitId ▁ INTEGER ▁ REFERENCES ▁ TCOMMIT ( id ) , " + " NewName ▁ STRING ▁ NOT ▁ NULL , " + " OldName ▁ STRING ▁ NOT ▁ NULL , " + " NewObjId ▁ STRING ▁ NOT ▁ NULL , " + " PackageName ▁ STRING ▁ NOT ▁ NULL , " + " ChangeType ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TCLASS ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " FileId ▁ INTEGER ▁ REFERENCES ▁ TFILE ( id ) , " + " Name ▁ STRING ▁ NOT ▁ NULL , " + " LineStart ▁ INT ▁ NOT ▁ NULL , " + " LineEnd ▁ INT ▁ NOT ▁ NULL , " + " ChangeType ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TFUNCTION ( " + " id ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT , " + " ClassId ▁ INTEGER ▁ REFERENCES ▁ TCLASS ( id ) , " + " Name ▁ STRING ▁ NOT ▁ NULL , " + " LineStart ▁ INT ▁ NOT ▁ NULL , " + " LineEnd ▁ INT ▁ NOT ▁ NULL , " + " ChangeType ▁ STRING ▁ NOT ▁ NULL ) ; " + " CREATE ▁ TABLE ▁ TBUG ( " + " id ▁ STRING ▁ NOT ▁ NULL , " + " CommitID ▁ STRING ▁ NOT ▁ NULL ) ; " ; smt . executeUpdate ( sql ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static Matrix2D ExtractCommitArtifactMatrix ( Analyzer . Grain grain , String _repository , String filename ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . COMMIT , InfoType . ARTIFACT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR , ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . commitid ▁ = ▁ TC . id ▁ AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddRowDesc ( rs . getString ( " HashCode " ) ) ; } switch ( grain ) { case FILE : sql = " SELECT ▁ Distinct ( TF . NewName ) ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TF . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " NewName " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TFL . NewName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TFL . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; sql = sql . concat ( " GROUP ▁ BY ▁ TFL . NewName , ▁ TCL . name , ▁ TF . name ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddColDesc ( rs . getString ( " NewName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; rs . close ( ) ; break ; } Matrix2D mat = new Matrix2D ( descriptor ) ; switch ( grain ) { case FILE : sql = " SELECT ▁ TC . HashCode , ▁ TF . NewName ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TF . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TF . NewName ; " ) ; rs = smt . executeQuery ( sql ) ; int count = 0 ; while ( rs . next ( ) ) { count ++ ; mat . SetElement ( rs . getString ( " HashCode " ) , rs . getString ( " NewName " ) , 1 ) ; } System . out . println ( count ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ TC . hashcode , ▁ TFL . NewName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ from ▁ TFunction ▁ TF , ▁ " + " TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ " + " TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TFL . newName ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TFL . newname , ▁ TCL . name , ▁ TF . name ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " HashCode " ) , rs . getString ( " NewName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; } rs . close ( ) ; break ; } smt . close ( ) ; return mat ; }
gems-uff/dominoes | public static Matrix2D ExtractFileClassMethodComposition ( String _repository ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . ARTIFACT , InfoType . ARTIFACT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ DISTINCT ▁ TFL . NewName ▁ AS ▁ FileName ▁ " + " FROM ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TCL . fileId ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . NewName , ▁ TCL . name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddRowDesc ( rs . getString ( " FileName " ) ) ; } sql = " SELECT ▁ DISTINCT ▁ TFL . NewName ▁ AS ▁ FileName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . NewName , ▁ TCL . name , ▁ TF . Name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddColDesc ( rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; } Matrix2D result = new Matrix2D ( descriptor ) ; sql = " SELECT ▁ DISTINCT ▁ TFL . NewName ▁ AS ▁ FileName , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TFL . NewName ▁ NOT ▁ LIKE ▁ ' null ' ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ " + " AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . NewName , ▁ TCL . Name , ▁ TF . Name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) result . SetElement ( rs . getString ( " FileName " ) , rs . getString ( " FileName " ) + " $ " + rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , 1 ) ; return result ; }
gems-uff/dominoes | public static Matrix2D ExtractDeveloperCommitMatrix ( String _repository , String filename ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . USER , InfoType . COMMIT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR , ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . commitid ▁ = ▁ TC . id ▁ AND ▁ TF . newname ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddColDesc ( rs . getString ( " HashCode " ) ) ; } sql = " SELECT ▁ Distinct ( TU . name ) ▁ FROM ▁ TUser ▁ TU , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . userID ▁ = ▁ TU . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddRowDesc ( rs . getString ( " name " ) ) ; } Matrix2D mat = new Matrix2D ( descriptor ) ; sql = " SELECT ▁ TU . name , ▁ TC . HashCode ▁ FROM ▁ TUser ▁ TU , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR , ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TC . userID ▁ = ▁ TU . id ▁ AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " ; if ( filename != null ) sql = sql . concat ( " AND ▁ TF . commitid ▁ = ▁ TC . id ▁ AND ▁ TF . newname ▁ = ▁ ' " + filename + " ' ▁ " ) ; sql = sql . concat ( " ORDER ▁ BY ▁ TC . Date , ▁ TC . HashCode ; " ) ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " name " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; smt . close ( ) ; return mat ; }
gems-uff/dominoes | public static String [ ] AvailableProjects ( ) throws SQLException { List < String > repos = new ArrayList < String > ( ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ Name ▁ FROM ▁ TREPOSITORY ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { repos . add ( rs . getString ( " name " ) ) ; } rs . close ( ) ; smt . close ( ) ; return ( String [ ] ) repos . toArray ( new String [ 0 ] ) ; }
gems-uff/dominoes | public static int NumCommits ( String projName ) { int total = 0 ; try { Statement smt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ TCommit . HashCode ▁ FROM ▁ TCOMMIT , ▁ TREPOSITORY ▁ " + " WHERE ▁ TCOMMIT . RepoId ▁ = ▁ TREPOSITORY . id ▁ AND ▁ " + " TREPOSITORY . Name ▁ = ▁ ' " + projName + " ' ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { total ++ ; } rs . close ( ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return total ; }
gems-uff/dominoes | public static Map < String , Integer > Commits_Month ( String projName ) { Map < String , Integer > res = new LinkedHashMap < String , Integer > ( ) ; try { Statement smt = conn . createStatement ( ) ; ResultSet rs ; String sql = " SELECT ▁ strftime ( ' % m - % Y ' , ▁ TCommit . Date ) ▁ as ▁ ' month - year ' , ▁ " + " COUNT ( TCommit . Date ) ▁ AS ▁ TotalMonth ▁ FROM ▁ TCOMMIT , ▁ TREPOSITORY , ▁ TFILE ▁ " + " WHERE ▁ TCOMMIT . RepoId ▁ = ▁ TREPOSITORY . id ▁ AND ▁ " + " TFILE . commitId ▁ = ▁ TCOMMIT . id ▁ AND ▁ TFile . newname ▁ like ▁ ' java / engine / org / apache / derby / impl / jdbc / EmbedConnection . java ' ▁ AND ▁ " + " TREPOSITORY . Name ▁ = ▁ ' " + projName + " ' ▁ " + " GROUP ▁ BY ▁ strftime ( ' % m - % Y ' , ▁ Date ) ▁ ORDER ▁ BY ▁ TotalMonth ▁ desc ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { res . put ( rs . getString ( " month - year " ) , rs . getInt ( " TotalMonth " ) ) ; } rs . close ( ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return res ; }
gems-uff/dominoes | public static void UpdateRepoToLastCommit ( RepositoryNode repoNode ) { Statement smt ; String sql ; try { smt = conn . createStatement ( ) ; sql = " UPDATE ▁ TREPOSITORY ▁ SET ▁ LastCommitId ▁ = ▁ " + " ( SELECT ▁ distinct ( id ) ▁ FROM ▁ TCOMMIT ▁ where ▁ date ▁ = ▁ ( select ▁ max ( date ) ▁ from ▁ TCOMMIT ) ) " + " WHERE ▁ Name ▁ = ▁ ' " + repoNode . getName ( ) + " ' ; " ; smt . executeUpdate ( sql ) ; smt . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static void AddCommit ( CommitNode commit , RepositoryNode repoNode ) { Statement smt ; String sql ; SimpleDateFormat sdf = new SimpleDateFormat ( " yyyy - MM - dd ▁ HH : mm : ss " ) ; try { smt = conn . createStatement ( ) ; sql = " INSERT ▁ INTO ▁ TCOMMIT ▁ ( RepoId , ▁ UserId , ▁ HashCode , ▁ Date , ▁ Message ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TREPOSITORY ▁ TR ▁ WHERE ▁ TR . Name ▁ = ▁ ' " + repoNode . getName ( ) + " ' ) , " + Integer . toString ( getUserId ( commit . getUser ( ) . getName ( ) ) ) + " , " + " ' " + commit . getId ( ) + " ' , " + " ' " + sdf . format ( commit . getDate ( ) ) + " ' , " + " ' " + commit . getLogMessage ( ) . replaceAll ( " ' " , " ' ' " ) + " ' ) ; " ; for ( FileNode fileNode : commit . getFiles ( ) ) { sql += " INSERT ▁ INTO ▁ TFILE ▁ ( CommitId , ▁ NewName , ▁ OldName , ▁ NewObjId , ▁ PackageName , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TCOMMIT ▁ TC ▁ WHERE ▁ TC . HashCode ▁ = ▁ ' " + commit . getId ( ) + " ' ) , " + " ' " + fileNode . newName + " ' , " + " ' " + fileNode . oldName + " ' , " + " ' " + fileNode . newObjId + " ' , " + " ' " + fileNode . packageName + " ' , " + " ' " + fileNode . changeType + " ' ) ; " ; for ( ClassNode classNode : fileNode . getClasses ( ) ) { sql += " INSERT ▁ INTO ▁ TCLASS ▁ ( FileId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ id ▁ FROM ▁ TFILE ▁ TF ▁ WHERE ▁ TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ) , " + " ' " + classNode . getName ( ) + " ' , " + classNode . getLineStart ( ) + " , " + classNode . getLineEnd ( ) + " , " + " ' " + classNode . getChangeType ( ) + " ' ) ; " ; for ( FunctionNode functionNode : classNode . getFunctions ( ) ) { sql += " INSERT ▁ INTO ▁ TFUNCTION ▁ ( ClassId , ▁ Name , ▁ LineStart , ▁ LineEnd , ▁ ChangeType ) " + " ▁ VALUES ▁ ( " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCLASS ▁ TC , ▁ TFILE ▁ TF ▁ WHERE ▁ TC . Name ▁ = ▁ ' " + classNode . getName ( ) + " ' ▁ AND ▁ " + " TF . NewObjId ▁ = ▁ ' " + fileNode . newObjId + " ' ▁ AND ▁ TC . FileId ▁ = ▁ TF . id ) , " + " ' " + functionNode . getName ( ) + " ' , " + functionNode . getLineStart ( ) + " , " + functionNode . getLineEnd ( ) + " , " + " ' " + functionNode . getChangeType ( ) + " ' ) ; " ; } } } smt . executeUpdate ( sql ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
gems-uff/dominoes | public static void MineBugs ( String bugMatch , RepositoryNode repository ) throws SQLException { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . USER , InfoType . COMMIT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Message ▁ FROM ▁ TCommit ▁ TC , ▁ TRepository ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + repository . getName ( ) + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date ; " ; rs = smt . executeQuery ( sql ) ; List < Entry < String , String > > bugCommit = new ArrayList < Map . Entry < String , String > > ( ) ; while ( rs . next ( ) ) { String hashCode = rs . getString ( " HashCode " ) ; String message = rs . getString ( " Message " ) ; String bugId = extractBugId ( message , bugMatch ) ; if ( bugId != null ) { Map . Entry < String , String > pair = new AbstractMap . SimpleEntry ( bugId , hashCode ) ; bugCommit . add ( pair ) ; } } for ( Entry < String , String > record : bugCommit ) { sql = " INSERT ▁ INTO ▁ TBUG ▁ ( id , ▁ commitId ) " + " ▁ VALUES ▁ ( ' " + record . getKey ( ) + " ' , ▁ ' " + record . getValue ( ) + " ' ) ; " ; smt . executeUpdate ( sql ) ; } rs . close ( ) ; smt . close ( ) ; }
gems-uff/dominoes | private static String extractBugId ( String text , String match ) { String idBug = " derby - " ; String res = idBug ; int start = text . toLowerCase ( ) . indexOf ( idBug ) ; for ( int i = start + idBug . length ( ) ; i < text . length ( ) ; i ++ ) { if ( ! Character . isDigit ( text . charAt ( i ) ) ) { break ; } res += text . charAt ( i ) ; } if ( idBug . equals ( res ) ) return null ; return res ; }
gems-uff/dominoes | public static Matrix2D ExtractCommitSubMatrix ( Grain grain , String _repository , int offset , int size ) { try { String sql ; MatrixDescriptor descriptor = new MatrixDescriptor ( InfoType . ARTIFACT , InfoType . COMMIT ) ; Statement smt = conn . createStatement ( ) ; ResultSet rs ; sql = " SELECT ▁ TC . HashCode , ▁ TC . Date ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . Name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date ▁ ASC ▁ " + " LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { descriptor . AddColDesc ( rs . getString ( " HashCode " ) ) ; } switch ( grain ) { case FILE : sql = " SELECT ▁ Distinct ( TF . NewName ) ▁ FROM ▁ TFILE ▁ TF ▁ " + " WHERE ▁ TF . CommitId ▁ IN ▁ " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' " + " ORDER ▁ BY ▁ TC . date ▁ ASC ▁ LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ) " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddRowDesc ( rs . getString ( " NewName " ) ) ; rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ DISTINCT ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ " + " FROM ▁ TFunction ▁ TF , ▁ TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ " + " AND ▁ TC . RepoId ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " GROUP ▁ BY ▁ TCL . name , ▁ TF . name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) descriptor . AddRowDesc ( rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) ) ; rs . close ( ) ; break ; } Matrix2D mat = new Matrix2D ( descriptor ) ; switch ( grain ) { case FILE : sql = " SELECT ▁ TC . HashCode , ▁ TF . NewName ▁ FROM ▁ TFILE ▁ TF , ▁ TCOMMIT ▁ TC ▁ " + " WHERE ▁ TF . CommitId ▁ = ▁ TC . id ▁ AND ▁ TC . id ▁ IN ▁ " + " ( SELECT ▁ TC . id ▁ FROM ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TC . RepoId ▁ = ▁ TR . id ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' " + " ORDER ▁ BY ▁ TC . date ▁ ASC ▁ LIMIT ▁ " + size + " ▁ OFFSET ▁ " + offset + " ) " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " NewName " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; break ; case METHOD : sql = " SELECT ▁ TC . hashcode , ▁ TCL . name ▁ as ▁ ClassName , ▁ TF . name ▁ as ▁ FuncName ▁ from ▁ TFunction ▁ TF , ▁ " + " TCLASS ▁ TCL , ▁ TFILE ▁ TFL , ▁ TCOMMIT ▁ TC , ▁ TREPOSITORY ▁ TR ▁ " + " WHERE ▁ TF . classid ▁ = ▁ TCL . id ▁ AND ▁ TCL . fileid ▁ = ▁ TFL . id ▁ AND ▁ TFL . CommitID ▁ = ▁ TC . id ▁ AND ▁ " + " TC . RepoId ▁ = ▁ TR . id ▁ ▁ AND ▁ TR . name ▁ = ▁ ' " + _repository + " ' ▁ " + " ORDER ▁ BY ▁ TC . Date , ▁ TFL . newname , ▁ TCL . name , ▁ TF . name ; " ; rs = smt . executeQuery ( sql ) ; while ( rs . next ( ) ) { mat . SetElement ( rs . getString ( " ClassName " ) + " . " + rs . getString ( " FuncName " ) , rs . getString ( " HashCode " ) , 1 ) ; } rs . close ( ) ; break ; } smt . close ( ) ; return mat ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
AlexaGh/JavaMainRepo | public static void main ( String [ ] args ) throws Exception { String [ ] species = { Constants . Species . Aquatics , Constants . Species . Mammals , Constants . Species . Birds , Constants . Species . Insects , Constants . Species . Reptiles } ; String [ ] [ ] animals = { { Constants . Animals . Aquatics . SeaTurtle , Constants . Animals . Aquatics . SeaHorse , Constants . Animals . Aquatics . MoonJellyfish } , { Constants . Animals . Mammals . Tiger , Constants . Animals . Mammals . Cow , Constants . Animals . Mammals . Monkey } , { Constants . Animals . Birds . Dove , Constants . Animals . Birds . Woodpecker , Constants . Animals . Birds . Nightingale } , { Constants . Animals . Insects . Butterfly , Constants . Animals . Insects . LadyBug , Constants . Animals . Insects . Spider } , { Constants . Animals . Reptiles . Crocodile , Constants . Animals . Reptiles . Dragon , Constants . Animals . Reptiles . Turtule } } ; AnimalFactory abstractFactory = new AnimalFactory ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { SpeciesFactory speciesFactory1 = abstractFactory . getSpeciesFactory ( species [ i ] ) ; Animal a1 = speciesFactory1 . getAnimal ( animals [ i ] [ j ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ animal ▁ with ▁ % d ▁ legs ▁ whose ▁ name ▁ is ▁ % s ! \n " , a1 . getNrOfLegs ( ) , a1 . getName ( ) ) ; } } int i = 0 ; while ( i <= 50 || i == 0 ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory2 = abstractFactory . getSpeciesFactory ( species [ chooseSpecies ] ) ; Animal a2 = speciesFactory2 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; System . out . printf ( " We ▁ have ▁ an ▁ animal ▁ with ▁ % d ▁ legs ▁ whose ▁ name ▁ is ▁ % s ! \n " , a2 . getNrOfLegs ( ) , a2 . getName ( ) ) ; i ++ ; } AnimalFactory abstractFactory2 = new AnimalFactory ( ) ; Animal [ ] allAnimals = new Animal [ 15 ] ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory3 = abstractFactory2 . getSpeciesFactory ( species [ chooseSpecies ] ) ; allAnimals [ k ] = speciesFactory3 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; } CareTakerFactory abstractTakers = new CareTakerFactory ( ) ; Employee employee = abstractTakers . getEmployeeFactory ( Constants . Employees . Caretaker ) ; employee . setDead ( false ) ; employee . setName ( " Jack " ) ; Employee [ ] caretakers = new CareTaker [ 15 ] ; for ( int x = 0 ; x < 15 ; x ++ ) { caretakers [ x ] = abstractTakers . getEmployeeFactory ( Constants . Employees . Caretaker ) ; caretakers [ x ] . setDead ( false ) ; } boolean isTakenCareOf = false ; for ( int x = 0 ; x < caretakers . length ; x ++ ) { for ( int k = 0 ; k < allAnimals . length ; k ++ ) { if ( ! caretakers [ k ] . isDead ( ) && ! allAnimals [ k ] . isTakenCareOf ( ) ) { String result = ( ( CareTaker ) caretakers [ x ] ) . takeCareOf ( allAnimals [ k ] ) ; if ( result . equals ( Constants . Employees . Caretakers . TCO_KILLED ) ) { System . out . println ( " caretaker " + k + " ▁ killed ▁ by ▁ " + allAnimals [ k ] . getName ( ) ) ; caretakers [ k ] . setDead ( true ) ; } else if ( result . equals ( Constants . Employees . Caretakers . TCO_NO_TIME ) ) { continue ; } else { allAnimals [ k ] . setTakenCareOf ( true ) ; } } if ( allAnimals [ k ] . isTakenCareOf ( ) ) { isTakenCareOf = true ; } else { isTakenCareOf = false ; } } } PrintWriter writer = new PrintWriter ( " output . txt " , " UTF - 8" ) ; if ( isTakenCareOf ) { System . out . println ( " All ▁ animals ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; writer . println ( " All ▁ animals ▁ have ▁ been ▁ taken ▁ care ▁ of ! " ) ; } else { System . out . println ( " There ▁ are ▁ animals ▁ that ▁ still ▁ need ▁ to ▁ be ▁ cared ▁ of ! " ) ; writer . println ( " There ▁ are ▁ animals ▁ that ▁ still ▁ need ▁ to ▁ be ▁ cared ▁ of ! " ) ; } for ( int l = 0 ; l < allAnimals . length ; l ++ ) { if ( ! isTakenCareOf ) { System . out . println ( allAnimals [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; writer . println ( allAnimals [ l ] . getName ( ) + " ▁ still ▁ needs ▁ to ▁ be ▁ taken ▁ care ▁ of ! " ) ; } } AnimalFactory abstractFactory3 = new AnimalFactory ( ) ; AnimalRepository ar = new AnimalRepository ( ) ; ArrayList < Animal > animalsList = new ArrayList < > ( ) ; ArrayList < Animal > animalsListToDisplay = new ArrayList < > ( ) ; for ( int k = 0 ; k < 15 ; k ++ ) { Random rand = new Random ( ) ; int chooseSpecies = rand . nextInt ( 5 ) ; int chooseAnimal = rand . nextInt ( 3 ) ; SpeciesFactory speciesFactory3 = abstractFactory3 . getSpeciesFactory ( species [ chooseSpecies ] ) ; Animal allAnimalsAsAList = speciesFactory3 . getAnimal ( animals [ chooseSpecies ] [ chooseAnimal ] ) ; animalsList . add ( allAnimalsAsAList ) ; } ar . save ( animalsList ) ; animalsListToDisplay = ar . load ( ) ; System . out . println ( ) ; System . out . println ( " saved ▁ list : " ) ; writer . println ( ) ; writer . println ( " saved ▁ list : " ) ; for ( Animal ani2 : animalsList ) { System . out . println ( ani2 . getName ( ) ) ; writer . println ( ani2 . getName ( ) ) ; } System . out . println ( ) ; System . out . println ( " loaded ▁ list : " ) ; writer . println ( ) ; writer . println ( " loaded ▁ list : " ) ; for ( Animal ani : animalsListToDisplay ) { System . out . println ( ani . getName ( ) ) ; writer . println ( ani . getName ( ) ) ; } ArrayList < Employee > employeesList = new ArrayList < > ( ) ; ArrayList < Employee > employeesListToDisplay = new ArrayList < > ( ) ; CareTakerFactory abstractTakers2 = new CareTakerFactory ( ) ; EmployeeRepository er = new EmployeeRepository ( ) ; for ( int k = 0 ; k < 10 ; k ++ ) { Employee employee2 = abstractTakers2 . getEmployeeFactory ( Constants . Employees . Caretaker ) ; employeesList . add ( employee2 ) ; } er . save ( employeesList ) ; employeesListToDisplay = er . load ( ) ; for ( int k = 0 ; k < employeesList . size ( ) ; k ++ ) { System . out . println ( String . valueOf ( employeesListToDisplay . get ( k ) . getName ( ) ) ) ; } writer . close ( ) ; }
eminn/jet-word-count | public static void main ( String [ ] args ) throws Exception { DAG dag = new DAG ( ) ; Vertex source = dag . newVertex ( " source " , Sources . readMap ( " lines " ) ) ; Pattern delimiter = Pattern . compile ( " \\ W + " ) ; Vertex tokenize = dag . newVertex ( " tokenize " , Processors . flatMap ( ( Entry < Integer , String > e ) -> Traversers . traverseArray ( delimiter . split ( e . getValue ( ) . toLowerCase ( ) ) ) . filter ( word -> ! word . isEmpty ( ) ) ) ) ; Vertex accumulate = dag . newVertex ( " accumulate " , Processors . accumulateByKey ( DistributedFunctions . wholeItem ( ) , AggregateOperations . counting ( ) ) ) ; Vertex combine = dag . newVertex ( " combine " , Processors . combineByKey ( AggregateOperations . counting ( ) ) ) ; Vertex sink = dag . newVertex ( " sink " , Sinks . writeMap ( " counts " ) ) ; dag . edge ( between ( source , tokenize ) ) . edge ( between ( tokenize , accumulate ) . partitioned ( DistributedFunctions . wholeItem ( ) , Partitioner . HASH_CODE ) ) . edge ( between ( accumulate , combine ) . distributed ( ) . partitioned ( DistributedFunctions . entryKey ( ) ) ) . edge ( between ( combine , sink ) ) ; JetInstance jet = JetBootstrap . getInstance ( ) ; IMap < Integer , String > map = jet . getMap ( " lines " ) ; map . put ( 0 , " It ▁ was ▁ the ▁ best ▁ of ▁ times , " ) ; map . put ( 1 , " it ▁ was ▁ the ▁ worst ▁ of ▁ times , " ) ; map . put ( 2 , " it ▁ was ▁ the ▁ age ▁ of ▁ wisdom , " ) ; map . put ( 3 , " it ▁ was ▁ the ▁ age ▁ of ▁ foolishness , " ) ; map . put ( 4 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ belief , " ) ; map . put ( 5 , " it ▁ was ▁ the ▁ epoch ▁ of ▁ incredulity , " ) ; map . put ( 6 , " it ▁ was ▁ the ▁ season ▁ of ▁ Light , " ) ; map . put ( 7 , " it ▁ was ▁ the ▁ season ▁ of ▁ Darkness " ) ; map . put ( 8 , " it ▁ was ▁ the ▁ spring ▁ of ▁ hope , " ) ; map . put ( 9 , " it ▁ was ▁ the ▁ winter ▁ of ▁ despair , " ) ; map . put ( 10 , " we ▁ had ▁ everything ▁ before ▁ us , " ) ; map . put ( 11 , " we ▁ had ▁ nothing ▁ before ▁ us , " ) ; map . put ( 12 , " we ▁ were ▁ all ▁ going ▁ direct ▁ to ▁ Heaven , " ) ; map . put ( 13 , " we ▁ were ▁ all ▁ going ▁ direct ▁ the ▁ other ▁ way ▁ - - " ) ; map . put ( 14 , " in ▁ short , ▁ the ▁ period ▁ was ▁ so ▁ far ▁ like ▁ the ▁ present ▁ period , ▁ that ▁ some ▁ of ▁ " + " its ▁ noisiest ▁ authorities ▁ insisted ▁ on ▁ its ▁ being ▁ received , ▁ for ▁ good ▁ or ▁ for ▁ " + " evil , ▁ in ▁ the ▁ superlative ▁ degree ▁ of ▁ comparison ▁ only . " ) ; Job job = jet . newJob ( dag ) ; Future < Void > future = job . execute ( ) ; future . get ( ) ; System . out . println ( jet . getMap ( " counts " ) . entrySet ( ) ) ; }
lamberthu/hrpc | public static void testServer ( ) throws Exception { RpcContext context = new RpcContext ( ) ; RpcServer rpcServer = new RpcServer ( context ) ; rpcServer . addService ( new HelloServiceImpl ( ) ) ; rpcServer . start ( ) ; }
lamberthu/hrpc | public static void main ( String [ ] args ) throws Exception { testServer ( ) ; }
bedward70/bedward70-fitnesse-io | public static B70ParseBinder create ( Fixture fixture , String name ) throws RuntimeException { B70ParseBinder result ; if ( name . startsWith ( ASSIGNMENT_STRING ) ) { result = new B70ParseBinder . RecallBinding ( name . substring ( 1 ) ) ; } else if ( regexMethodPattern . matcher ( name ) . matches ( ) || methodPattern . matcher ( name ) . matches ( ) ) { final TypeAdapter adapter = makeAdapter ( fixture , name ) ; result = new B70ParseBinder . QueryBinding ( adapter ) ; } else { result = new B70ParseBinder . DefaultBuilding ( name ) ; } return result ; }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapter ( Fixture fixture , String name ) throws RuntimeException { Matcher regexMatcher = regexMethodPattern . matcher ( name ) ; if ( regexMatcher . find ( ) ) { return makeAdapterForRegexMethod ( name , fixture , regexMatcher ) ; } else { Matcher methodMatcher = methodPattern . matcher ( name ) ; return methodMatcher . find ( ) ? makeAdapterForMethod ( name , fixture , methodMatcher ) : makeAdapterForField ( name , fixture ) ; } }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForMethod ( String name , Fixture fixture , Matcher matcher ) { return makeAdapterForMethod ( name , fixture , matcher , false ) ; }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForRegexMethod ( String name , Fixture fixture , Matcher matcher ) { return makeAdapterForMethod ( name , fixture , matcher , true ) ; }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForMethod ( String name , Fixture fixture , Matcher matcher , boolean isRegex ) { Method method = getMethod ( name , fixture , matcher ) ; if ( method == null ) { throw new NoSuchMethodFitFailureException ( name ) ; } else { return TypeAdapter . on ( fixture , method , isRegex ) ; } }
bedward70/bedward70-fitnesse-io | private static TypeAdapter makeAdapterForField ( String name , Fixture fixture ) { Field field = null ; if ( GracefulNamer . isGracefulName ( name ) ) { String simpleName = GracefulNamer . disgrace ( name ) . toLowerCase ( ) ; field = findField ( fixture , simpleName ) ; } else { Matcher matcher = fieldPattern . matcher ( name ) ; matcher . find ( ) ; String fieldName = matcher . group ( 1 ) ; Class clazz = getTargetClass ( fixture ) ; try { field = clazz . getField ( fieldName ) ; } catch ( NoSuchFieldException var9 ) { try { field = getField ( clazz , fieldName ) ; } catch ( NoSuchFieldException var8 ) { ; } } } if ( field == null ) { throw new NoSuchFieldFitFailureException ( name ) ; } else { return TypeAdapter . on ( fixture , field ) ; } }
bedward70/bedward70-fitnesse-io | private static Class < ? > getTargetClass ( Fixture fixture ) { return fixture . getClass ( ) ; }
bedward70/bedward70-fitnesse-io | private static Field getField ( Class < ? > clazz , String fieldName ) throws NoSuchFieldException { try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException var4 ) { Class < ? > superClass = clazz . getSuperclass ( ) ; if ( superClass == null ) { throw var4 ; } else { return getField ( superClass , fieldName ) ; } } }
bedward70/bedward70-fitnesse-io | private static Method getMethod ( String name , Fixture fixture , Matcher matcher ) { Method method = null ; String methodName ; if ( GracefulNamer . isGracefulName ( name ) ) { methodName = GracefulNamer . disgrace ( name ) . toLowerCase ( ) ; method = findMethod ( fixture , methodName ) ; } else { try { methodName = matcher . group ( 1 ) ; Class < ? > targetClass = getTargetClass ( fixture ) ; method = targetClass . getMethod ( methodName , new Class [ 0 ] ) ; } catch ( NoSuchMethodException var6 ) { ; } } return method ; }
bedward70/bedward70-fitnesse-io | private static Field findField ( Fixture fixture , String simpleName ) { List < Field > fields = getAllDeclaredFields ( getTargetClass ( fixture ) ) ; Field field = null ; Iterator var4 = fields . iterator ( ) ; while ( var4 . hasNext ( ) ) { Field possibleField = ( Field ) var4 . next ( ) ; if ( simpleName . equalsIgnoreCase ( possibleField . getName ( ) ) ) { field = possibleField ; break ; } } return field ; }
bedward70/bedward70-fitnesse-io | private static List < Field > getAllDeclaredFields ( Class < ? > clazz ) { if ( clazz . getSuperclass ( ) != null ) { List < Field > fields = getAllDeclaredFields ( clazz . getSuperclass ( ) ) ; fields . addAll ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; return fields ; } else { return new ArrayList ( Arrays . asList ( clazz . getDeclaredFields ( ) ) ) ; } }
bedward70/bedward70-fitnesse-io | private static Method findMethod ( Fixture fixture , String simpleName ) { Method [ ] methods = getTargetClass ( fixture ) . getMethods ( ) ; Method method = null ; Method [ ] var4 = methods ; int var5 = methods . length ; for ( int var6 = 0 ; var6 < var5 ; ++ var6 ) { Method possibleMethod = var4 [ var6 ] ; if ( simpleName . equalsIgnoreCase ( possibleMethod . getName ( ) ) ) { method = possibleMethod ; break ; } } return method ; }
Battsooj/gocd | public static void setNail ( BuildrNail _nail ) { nail = _nail ; }
Battsooj/gocd | public static void nailMain ( NGContext ctx ) { nail . main ( ctx ) ; }
thombergs/wicked-charts | public static List < ConstLabel > of ( String ... texts ) { List < ConstLabel > resultList = new ArrayList < ConstLabel > ( ) ; for ( String text : texts ) { resultList . add ( new ConstLabel ( text ) ) ; } return resultList ; }
thombergs/wicked-charts | public static List < ConstLabel > of ( List < String > textList ) { List < ConstLabel > resultList = new ArrayList < ConstLabel > ( ) ; for ( String text : textList ) { resultList . add ( new ConstLabel ( text ) ) ; } return resultList ; }
Nzen/PD-Litmus | public static void main ( String [ ] args ) { LitmusFrame representsPd = new LitmusFrame ( ) ; }
freeVM/freeVM | public static void main ( String [ ] args ) { junit . textui . TestRunner . run ( XGraphics2DRTest . class ) ; }
Bragaman/atom | public static void main ( String [ ] args ) throws Exception { out . println ( VM . current ( ) . details ( ) ) ; PrintWriter pw = new PrintWriter ( out , true ) ; long last = VM . current ( ) . addressOf ( new Object ( ) ) ; for ( int l = 0 ; l < 1000 * 1000 * 1000 ; l ++ ) { long current = VM . current ( ) . addressOf ( new Object ( ) ) ; long distance = Math . abs ( current - last ) ; if ( distance > 16 * 1024 ) { pw . printf ( " Jumping ▁ from ▁ % x ▁ to ▁ % x ▁ ( distance ▁ = ▁ % d ▁ bytes , ▁ % dK , ▁ % dM ) % n " , last , current , distance , distance / 1024 , distance / 1024 / 1024 ) ; } last = current ; } pw . close ( ) ; }
allotria/intellij-community | public static VirtualEnvSdkFlavor getInstance ( ) { return PythonSdkFlavor . EP_NAME . findExtension ( VirtualEnvSdkFlavor . class ) ; }
allotria/intellij-community | @ Nullable public static VirtualFile getPyEnvDefaultLocations ( ) { final String path = System . getenv ( ) . get ( " PYENV _ ROOT " ) ; if ( ! StringUtil . isEmpty ( path ) ) { final VirtualFile pyEnvRoot = LocalFileSystem . getInstance ( ) . findFileByPath ( FileUtil . expandUserHome ( path ) . replace ( ' \ \' , ' / ' ) ) ; if ( pyEnvRoot != null ) { return pyEnvRoot . findFileByRelativePath ( " versions " ) ; } } final VirtualFile userHome = LocalFileSystem . getInstance ( ) . findFileByPath ( SystemProperties . getUserHome ( ) . replace ( ' \ \' , ' / ' ) ) ; if ( userHome != null ) { return userHome . findFileByRelativePath ( " . pyenv / versions " ) ; } return null ; }
allotria/intellij-community | public static VirtualFile getDefaultLocation ( ) { final String path = System . getenv ( ) . get ( " WORKON _ HOME " ) ; if ( ! StringUtil . isEmpty ( path ) ) { return LocalFileSystem . getInstance ( ) . findFileByPath ( FileUtil . expandUserHome ( path ) . replace ( ' \ \' , ' / ' ) ) ; } final VirtualFile userHome = LocalFileSystem . getInstance ( ) . findFileByPath ( SystemProperties . getUserHome ( ) . replace ( ' \ \' , ' / ' ) ) ; if ( userHome != null ) { final VirtualFile predefinedFolder = userHome . findChild ( " . virtualenvs " ) ; if ( predefinedFolder == null ) return userHome ; return predefinedFolder ; } return null ; }
allotria/intellij-community | public static Collection < String > findInBaseDirectory ( @ Nullable VirtualFile baseDir ) { List < String > candidates = new ArrayList < > ( ) ; if ( baseDir != null ) { baseDir . refresh ( true , false ) ; VirtualFile [ ] suspects = baseDir . getChildren ( ) ; for ( VirtualFile child : suspects ) { candidates . addAll ( findInRootDirectory ( child ) ) ; } } return candidates ; }
allotria/intellij-community | @ NotNull public static Collection < String > findInRootDirectory ( @ Nullable VirtualFile rootDir ) { final List < String > candidates = new ArrayList < > ( ) ; if ( rootDir != null && rootDir . isDirectory ( ) ) { final VirtualFile bin = rootDir . findChild ( " bin " ) ; final VirtualFile scripts = rootDir . findChild ( " Scripts " ) ; if ( bin != null ) { final String interpreter = findInterpreter ( bin ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } if ( scripts != null ) { final String interpreter = findInterpreter ( scripts ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } if ( candidates . isEmpty ( ) ) { final String interpreter = findInterpreter ( rootDir ) ; if ( interpreter != null ) candidates . add ( interpreter ) ; } } return candidates ; }
allotria/intellij-community | @ Nullable private static String findInterpreter ( VirtualFile dir ) { for ( VirtualFile child : dir . getChildren ( ) ) { if ( ! child . isDirectory ( ) ) { final String childName = StringUtil . toLowerCase ( child . getName ( ) ) ; for ( String name : NAMES ) { if ( SystemInfo . isWindows ) { if ( childName . equals ( name ) ) { return FileUtil . toSystemDependentName ( child . getPath ( ) ) ; } } else { if ( childName . startsWith ( name ) || PYTHON_RE . matcher ( childName ) . matches ( ) ) { if ( ! childName . endsWith ( " - config " ) ) { return child . getPath ( ) ; } } } } } } return null ; }
cstudioteam/csFrame | public static FWLogName setLogName ( FWLogName name ) { FWLogName currenLogName = getCurrentLogName ( ) ; if ( name == null ) { remove ( LOG_NAME ) ; } else { MDC . put ( LOG_NAME , name . toString ( ) ) ; } return currenLogName ; }
cstudioteam/csFrame | public static FWLogName getCurrentLogName ( ) { String logName = MDC . get ( LOG_NAME ) ; FWLogName retName = null ; if ( logName != null ) { retName = FWLogName . valueOf ( logName ) ; } return retName ; }
cstudioteam/csFrame | public static void clear ( ) { MDC . clear ( ) ; }
cstudioteam/csFrame | public static void put ( String key , String value ) { MDC . put ( key , value ) ; }
cstudioteam/csFrame | public static void remove ( String key ) { MDC . remove ( key ) ; }
TopQuadrant/shacl | public static ExtendedIterator < RDFNode > distinct ( ExtendedIterator < RDFNode > base ) { Set < RDFNode > seen = new HashSet < > ( ) ; return recording ( rejecting ( base , seen ) , seen ) ; }
TopQuadrant/shacl | private static < T > ExtendedIterator < T > recording ( ClosableIterator < T > i , Set < T > seen ) { return new NiceIterator < T > ( ) { @ Override public void remove ( ) { i . remove ( ) ; } @ Override public boolean hasNext ( ) { return i . hasNext ( ) ; } @ Override public T next ( ) { T x = i . next ( ) ; seen . add ( x ) ; return x ; } @ Override public void close ( ) { i . close ( ) ; } } ; }
TopQuadrant/shacl | private static ExtendedIterator < RDFNode > rejecting ( ExtendedIterator < RDFNode > i , Set < RDFNode > seen ) { return i . filterDrop ( seen :: contains ) ; }
uvasoftware/scanii-java | public static < T > T load ( String js , Class < T > valueType ) { try { return mapper . readValue ( js , valueType ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
uvasoftware/scanii-java | public static JsonNode load ( String js ) { try { return mapper . readTree ( js ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
AsciiBunny/Bunny-Control-System | public static void main ( String [ ] args ) throws IOException { BunnyServer server ; if ( args . length > 0 ) server = new BunnyServer ( Integer . parseInt ( args [ 0 ] ) , Integer . parseInt ( args [ 1 ] ) , args [ 2 ] ) ; else server = new BunnyServer ( ) ; Thread t = new Thread ( server ) ; t . start ( ) ; }
Syncleus/AetherMUD | private static String getItem ( String fullCommand ) { if ( ! StringUtils . containsIgnoreCase ( fullCommand , ON_KEYWORD ) ) { return fullCommand ; } List < String > parts = Arrays . asList ( fullCommand . split ( " ( ? i ) " + ON_KEYWORD , 2 ) ) ; String item = parts . get ( 0 ) ; return item . trim ( ) ; }
Syncleus/AetherMUD | private static Optional < String > getItemTarget ( String fullCommand ) { if ( ! StringUtils . containsIgnoreCase ( fullCommand , ON_KEYWORD ) ) { return Optional . empty ( ) ; } List < String > parts = Arrays . asList ( fullCommand . split ( " ( ? i ) " + ON_KEYWORD , 2 ) ) ; if ( parts . size ( ) > 1 ) { String item = parts . get ( 1 ) ; return Optional . of ( item . trim ( ) ) ; } return Optional . empty ( ) ; }
miniway/presto | public static Builder builder ( ColumnMetadata ... columns ) { return builder ( ImmutableList . copyOf ( columns ) ) ; }
miniway/presto | public static Builder builder ( List < ColumnMetadata > columns ) { ImmutableList . Builder < String > names = ImmutableList . builder ( ) ; ImmutableList . Builder < Type > types = ImmutableList . builder ( ) ; for ( ColumnMetadata column : columns ) { names . add ( column . getName ( ) ) ; types . add ( column . getType ( ) ) ; } return new Builder ( names . build ( ) , types . build ( ) ) ; }
flyzsd/java-code-snippets | private static JMXConnectorServer getConnectorServerAsService ( ClassLoader loader , JMXServiceURL url , Map < String , ? > map , MBeanServer mbs ) throws IOException { Iterator < JMXConnectorServerProvider > providers = JMXConnectorFactory . getProviderIterator ( JMXConnectorServerProvider . class , loader ) ; IOException exception = null ; while ( providers . hasNext ( ) ) { try { return providers . next ( ) . newJMXConnectorServer ( url , map , mbs ) ; } catch ( JMXProviderException e ) { throw e ; } catch ( Exception e ) { if ( logger . traceOn ( ) ) logger . trace ( " getConnectorAsService " , " URL [ " + url + " ] ▁ Service ▁ provider ▁ exception : ▁ " + e ) ; if ( ! ( e instanceof MalformedURLException ) ) { if ( exception == null ) { if ( e instanceof IOException ) { exception = ( IOException ) e ; } else { exception = EnvHelp . initCause ( new IOException ( e . getMessage ( ) ) , e ) ; } } } continue ; } } if ( exception == null ) return null ; else throw exception ; }
flyzsd/java-code-snippets | public static JMXConnectorServer newJMXConnectorServer ( JMXServiceURL serviceURL , Map < String , ? > environment , MBeanServer mbeanServer ) throws IOException { Map < String , Object > envcopy ; if ( environment == null ) envcopy = new HashMap < String , Object > ( ) ; else { EnvHelp . checkAttributes ( environment ) ; envcopy = new HashMap < String , Object > ( environment ) ; } final Class < JMXConnectorServerProvider > targetInterface = JMXConnectorServerProvider . class ; final ClassLoader loader = JMXConnectorFactory . resolveClassLoader ( envcopy ) ; final String protocol = serviceURL . getProtocol ( ) ; final String providerClassName = " ServerProvider " ; JMXConnectorServerProvider provider = JMXConnectorFactory . getProvider ( serviceURL , envcopy , providerClassName , targetInterface , loader ) ; IOException exception = null ; if ( provider == null ) { if ( loader != null ) { try { JMXConnectorServer connection = getConnectorServerAsService ( loader , serviceURL , envcopy , mbeanServer ) ; if ( connection != null ) return connection ; } catch ( JMXProviderException e ) { throw e ; } catch ( IOException e ) { exception = e ; } } provider = JMXConnectorFactory . getProvider ( protocol , PROTOCOL_PROVIDER_DEFAULT_PACKAGE , JMXConnectorFactory . class . getClassLoader ( ) , providerClassName , targetInterface ) ; } if ( provider == null ) { MalformedURLException e = new MalformedURLException ( " Unsupported ▁ protocol : ▁ " + protocol ) ; if ( exception == null ) { throw e ; } else { throw EnvHelp . initCause ( e , exception ) ; } } envcopy = Collections . unmodifiableMap ( envcopy ) ; return provider . newJMXConnectorServer ( serviceURL , envcopy , mbeanServer ) ; }
gosu-lang/old-gosu-repo | public static CompilerSettings getInstance ( ) { return ServiceManager . getService ( CompilerSettings . class ) ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Barcode > toBarcodeMap ( ResultSet resultSet ) throws SQLException { Map < Integer , Barcode > result = new HashMap < Integer , Barcode > ( ) ; while ( resultSet . next ( ) ) { Barcode barcode = new Barcode ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; result . put ( resultSet . getInt ( 1 ) , barcode ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Company > toCompanyMap ( ResultSet resultSet ) throws SQLException { Map < Integer , Company > result = new HashMap < Integer , Company > ( ) ; while ( resultSet . next ( ) ) { Company company = new Company ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getString ( 3 ) , resultSet . getString ( 4 ) , resultSet . getString ( 5 ) ) ; result . put ( resultSet . getInt ( 1 ) , company ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Item > toItemMap ( ResultSet resultSet , Map < Integer , Barcode > barcodeMap , Map < Integer , Company > companyMap ) throws SQLException { Map < Integer , Item > result = new HashMap < Integer , Item > ( ) ; while ( resultSet . next ( ) ) { Item item = new Item ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , companyMap . get ( resultSet . getInt ( 3 ) ) , barcodeMap . get ( resultSet . getInt ( 4 ) ) , resultSet . getString ( 5 ) ) ; result . put ( resultSet . getInt ( 1 ) , item ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , String > toItemTypeMap ( ResultSet resultSet ) throws SQLException { Map < Integer , String > result = new HashMap < Integer , String > ( ) ; while ( resultSet . next ( ) ) { result . put ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Location > toLocationMap ( ResultSet resultSet ) throws SQLException { Map < Integer , Location > result = new HashMap < Integer , Location > ( ) ; while ( resultSet . next ( ) ) { Location location = new Location ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getInt ( 3 ) , resultSet . getInt ( 4 ) ) ; result . put ( resultSet . getInt ( 1 ) , location ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , String > toPrivilegesMap ( ResultSet resultSet ) throws SQLException { Map < Integer , String > result = new HashMap < Integer , String > ( ) ; while ( resultSet . next ( ) ) { result . put ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , User > toUserMap ( ResultSet resultSet ) throws SQLException { Map < Integer , User > result = new HashMap < Integer , User > ( ) ; while ( resultSet . next ( ) ) { User user = new User ( resultSet . getInt ( 1 ) , resultSet . getString ( 2 ) , resultSet . getString ( 4 ) , resultSet . getInt ( 5 ) ) ; user . setHash ( resultSet . getString ( 3 ) ) ; result . put ( resultSet . getInt ( 1 ) , user ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | protected static Map < Integer , Inventory > toInventoryMap ( ResultSet resultSet , Map < Integer , Item > itemMap , Map < Integer , Company > companyMap , Map < Integer , Location > locationMap , Map < Integer , Barcode > barcodeMap ) throws SQLException { Map < Integer , Inventory > result = new HashMap < Integer , Inventory > ( ) ; while ( resultSet . next ( ) ) { Inventory inventory = new Inventory ( resultSet . getInt ( 1 ) , itemMap . get ( resultSet . getInt ( 2 ) ) , resultSet . getInt ( 3 ) , companyMap . get ( resultSet . getInt ( 4 ) ) , resultSet . getInt ( 5 ) , resultSet . getInt ( 6 ) , resultSet . getDate ( 7 ) , resultSet . getDate ( 8 ) , locationMap . get ( resultSet . getInt ( 9 ) ) , barcodeMap . get ( resultSet . getInt ( 10 ) ) ) ; result . put ( resultSet . getInt ( 1 ) , inventory ) ; } return result ; }
Rowan-SoftwareDevelopment-Team2/Warehouse-Inventory | public static int getMaxResult ( ResultSet resultSet ) throws SQLException { resultSet . next ( ) ; return resultSet . getInt ( 1 ) ; }
apacheignite/ignite | public static C1 < IgniteCheckedException , IgniteException > getExceptionConverter ( Class < ? extends IgniteCheckedException > clazz ) { return exceptionConverters . get ( clazz ) ; }
apacheignite/ignite | private static Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , IgniteException > > exceptionConverters ( ) { Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , IgniteException > > m = new HashMap < > ( ) ; m . put ( IgniteInterruptedCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteInterruptedException ( e . getMessage ( ) , ( InterruptedException ) e . getCause ( ) ) ; } } ) ; m . put ( IgniteFutureCancelledCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteFutureCancelledException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteFutureTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteFutureTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ClusterGroupEmptyCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ClusterGroupEmptyException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ClusterTopologyCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { ClusterTopologyException topEx = new ClusterTopologyException ( e . getMessage ( ) , e ) ; ClusterTopologyCheckedException checked = ( ClusterTopologyCheckedException ) e ; if ( checked . retryReadyFuture ( ) != null ) topEx . retryReadyFuture ( new IgniteFutureImpl < > ( checked . retryReadyFuture ( ) ) ) ; return topEx ; } } ) ; m . put ( IgniteDeploymentCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteDeploymentException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ComputeTaskTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ComputeTaskTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ComputeTaskCancelledCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ComputeTaskCancelledException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxRollbackCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionRollbackException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxHeuristicCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionHeuristicException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxOptimisticCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionOptimisticException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteClientDisconnectedCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteClientDisconnectedException ( ( ( IgniteClientDisconnectedCheckedException ) e ) . reconnectFuture ( ) , e . getMessage ( ) , e ) ; } } ) ; return m ; }
apacheignite/ignite | public static List < PluginProvider > allPluginProviders ( ) { return AccessController . doPrivileged ( new PrivilegedAction < List < PluginProvider > > ( ) { @ Override public List < PluginProvider > run ( ) { List < PluginProvider > providers = new ArrayList < > ( ) ; ServiceLoader < PluginProvider > ldr = ServiceLoader . load ( PluginProvider . class ) ; for ( PluginProvider provider : ldr ) providers . add ( provider ) ; return providers ; } } ) ; }
apacheignite/ignite | public static Exception convertExceptionNoWrap ( IgniteCheckedException e ) { C1 < IgniteCheckedException , IgniteException > converter = exceptionConverters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof IgniteException ) return ( Exception ) e . getCause ( ) ; return e ; }
apacheignite/ignite | public static IgniteException convertException ( IgniteCheckedException e ) { IgniteClientDisconnectedException e0 = e . getCause ( IgniteClientDisconnectedException . class ) ; if ( e0 != null ) { assert e0 . reconnectFuture ( ) != null : e0 ; throw e0 ; } IgniteClientDisconnectedCheckedException disconnectedErr = e . getCause ( IgniteClientDisconnectedCheckedException . class ) ; if ( disconnectedErr != null ) { assert disconnectedErr . reconnectFuture ( ) != null : disconnectedErr ; e = disconnectedErr ; } C1 < IgniteCheckedException , IgniteException > converter = exceptionConverters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof IgniteException ) return ( IgniteException ) e . getCause ( ) ; return new IgniteException ( e . getMessage ( ) , e ) ; }
apacheignite/ignite | public static long currentTimeMillis ( ) { return curTimeMillis ; }
apacheignite/ignite | public static long microTime ( ) { return System . nanoTime ( ) / 1000 ; }
apacheignite/ignite | public static int ceilPow2 ( int v ) { return Integer . highestOneBit ( v - 1 ) << 1 ; }
apacheignite/ignite | public static boolean isPow2 ( int i ) { return i > 0 && ( i & ( i - 1 ) ) == 0 ; }
apacheignite/ignite | @ Nullable public static Method ctorFactory ( ) { return CTOR_FACTORY ; }
apacheignite/ignite | public static Constructor objectConstructor ( ) { return OBJECT_CTOR ; }
apacheignite/ignite | @ Nullable public static Object sunReflectionFactory ( ) { return SUN_REFLECT_FACTORY ; }
apacheignite/ignite | public static String gridEventName ( int type ) { String name = GRID_EVT_NAMES . get ( type ) ; return name != null ? name : Integer . toString ( type ) ; }
apacheignite/ignite | public static int [ ] gridEvents ( final int ... excl ) { if ( F . isEmpty ( excl ) ) return GRID_EVTS ; List < Integer > evts = toIntList ( GRID_EVTS , new P1 < Integer > ( ) { @ Override public boolean apply ( Integer i ) { return ! containsIntArray ( excl , i ) ; } } ) ; return toIntArray ( evts ) ; }
apacheignite/ignite | public static boolean discoOrdered ( DiscoverySpi discoSpi ) { DiscoverySpiOrderSupport ann = U . getAnnotation ( discoSpi . getClass ( ) , DiscoverySpiOrderSupport . class ) ; return ann != null && ann . value ( ) ; }
apacheignite/ignite | public static boolean relaxDiscoveryOrdered ( ) { return " true " . equalsIgnoreCase ( System . getProperty ( IGNITE_NO_DISCO_ORDER ) ) ; }
apacheignite/ignite | @ Deprecated public static void debug ( Object msg ) { X . error ( debugPrefix ( ) + msg ) ; }
apacheignite/ignite | @ Deprecated public static void debugx ( String msg ) { X . printerrln ( debugPrefix ( ) + msg ) ; }
apacheignite/ignite | @ Deprecated public static void debug ( IgniteLogger log , String msg ) { log . info ( msg ) ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( ) { dumpStack ( " Dumping ▁ stack . " ) ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( String msg ) { new Exception ( debugPrefix ( ) + msg ) . printStackTrace ( System . out ) ; }
apacheignite/ignite | public static void dumpStack ( @ Nullable IgniteLogger log , String msg ) { U . error ( log , " Dumping ▁ stack . " , new Exception ( msg ) ) ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( String msg , PrintStream out ) { new Exception ( msg ) . printStackTrace ( out ) ; }
apacheignite/ignite | @ Deprecated public static void debugStack ( IgniteLogger log , String msg ) { log . error ( msg , new Exception ( debugPrefix ( ) + msg ) ) ; }
apacheignite/ignite | private static String debugPrefix ( ) { return ' < ' + DEBUG_DATE_FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + ' > ' + ' ▁ ' ; }
apacheignite/ignite | public static void debugHeapUsage ( ) { System . gc ( ) ; Runtime runtime = Runtime . getRuntime ( ) ; X . println ( ' < ' + DEBUG_DATE_FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + " > ▁ Heap ▁ stats ▁ [ free = " + runtime . freeMemory ( ) / ( 1024 * 1024 ) + " M , ▁ total = " + runtime . totalMemory ( ) / ( 1024 * 1024 ) + " M ] " ) ; }
apacheignite/ignite | public static double heapSize ( ClusterNode node , int precision ) { return heapSize ( Collections . singleton ( node ) , precision ) ; }
apacheignite/ignite | public static double heapSize ( Iterable < ClusterNode > nodes , int precision ) { double heap = 0.0 ; for ( ClusterNode n : nodesPerJvm ( nodes ) ) { ClusterMetrics m = n . metrics ( ) ; heap += Math . max ( m . getHeapMemoryInitialized ( ) , m . getHeapMemoryMaximum ( ) ) ; } return roundedHeapSize ( heap , precision ) ; }
apacheignite/ignite | private static Iterable < ClusterNode > nodesPerJvm ( Iterable < ClusterNode > nodes ) { Map < String , ClusterNode > grpMap = new HashMap < > ( ) ; for ( ClusterNode node : nodes ) { String grpId = node . attribute ( ATTR_MACS ) + " | " + node . attribute ( ATTR_JVM_PID ) ; if ( ! grpMap . containsKey ( grpId ) ) grpMap . put ( grpId , node ) ; } return grpMap . values ( ) ; }
apacheignite/ignite | public static double heapSize ( int precision ) { return roundedHeapSize ( Runtime . getRuntime ( ) . maxMemory ( ) , precision ) ; }
apacheignite/ignite | private static double roundedHeapSize ( double heap , int precision ) { double rounded = new BigDecimal ( heap / ( 1024 * 1024 * 1024d ) ) . round ( new MathContext ( precision ) ) . doubleValue ( ) ; return rounded < 0.1 ? 0.1 : rounded ; }
apacheignite/ignite | public static void dumpThreads ( @ Nullable IgniteLogger log ) { ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; final Set < Long > deadlockedThreadsIds = getDeadlockedThreadIds ( mxBean ) ; if ( deadlockedThreadsIds . size ( ) == 0 ) warn ( log , " No ▁ deadlocked ▁ threads ▁ detected . " ) ; else warn ( log , " Deadlocked ▁ threads ▁ detected ▁ ( see ▁ thread ▁ dump ▁ below ) ▁ " + " [ deadlockedThreadsCnt = " + deadlockedThreadsIds . size ( ) + ' ] ' ) ; ThreadInfo [ ] threadInfos = mxBean . dumpAllThreads ( mxBean . isObjectMonitorUsageSupported ( ) , mxBean . isSynchronizerUsageSupported ( ) ) ; GridStringBuilder sb = new GridStringBuilder ( " Thread ▁ dump ▁ at ▁ " ) . a ( new SimpleDateFormat ( " yyyy / MM / dd ▁ HH : mm : ss ▁ z " ) . format ( new Date ( U . currentTimeMillis ( ) ) ) ) . a ( NL ) ; for ( ThreadInfo info : threadInfos ) { printThreadInfo ( info , sb , deadlockedThreadsIds ) ; sb . a ( NL ) ; if ( info . getLockedSynchronizers ( ) != null && info . getLockedSynchronizers ( ) . length > 0 ) { printSynchronizersInfo ( info . getLockedSynchronizers ( ) , sb ) ; sb . a ( NL ) ; } } sb . a ( NL ) ; warn ( log , sb . toString ( ) ) ; }
apacheignite/ignite | private static Set < Long > getDeadlockedThreadIds ( ThreadMXBean mxBean ) { final long [ ] deadlockedIds = mxBean . findDeadlockedThreads ( ) ; final Set < Long > deadlockedThreadsIds ; if ( ! F . isEmpty ( deadlockedIds ) ) { Set < Long > set = new HashSet < > ( ) ; for ( long id : deadlockedIds ) set . add ( id ) ; deadlockedThreadsIds = Collections . unmodifiableSet ( set ) ; } else deadlockedThreadsIds = Collections . emptySet ( ) ; return deadlockedThreadsIds ; }
apacheignite/ignite | private static void printThreadInfo ( ThreadInfo threadInfo , GridStringBuilder sb , Set < Long > deadlockedIdSet ) { final long id = threadInfo . getThreadId ( ) ; if ( deadlockedIdSet . contains ( id ) ) sb . a ( " # # # # # ▁ DEADLOCKED ▁ " ) ; sb . a ( " Thread ▁ [ name = \" " ) . a ( threadInfo . getThreadName ( ) ) . a ( " \" , ▁ id = " ) . a ( threadInfo . getThreadId ( ) ) . a ( " , ▁ state = " ) . a ( threadInfo . getThreadState ( ) ) . a ( " , ▁ blockCnt = " ) . a ( threadInfo . getBlockedCount ( ) ) . a ( " , ▁ waitCnt = " ) . a ( threadInfo . getWaitedCount ( ) ) . a ( " ] " ) . a ( NL ) ; LockInfo lockInfo = threadInfo . getLockInfo ( ) ; if ( lockInfo != null ) { sb . a ( " ▁ ▁ ▁ ▁ Lock ▁ [ object = " ) . a ( lockInfo ) . a ( " , ▁ ownerName = " ) . a ( threadInfo . getLockOwnerName ( ) ) . a ( " , ▁ ownerId = " ) . a ( threadInfo . getLockOwnerId ( ) ) . a ( " ] " ) . a ( NL ) ; } MonitorInfo [ ] monitors = threadInfo . getLockedMonitors ( ) ; StackTraceElement [ ] elements = threadInfo . getStackTrace ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { StackTraceElement e = elements [ i ] ; sb . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ at ▁ " ) . a ( e . toString ( ) ) ; for ( MonitorInfo monitor : monitors ) { if ( monitor . getLockedStackDepth ( ) == i ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ locked ▁ " ) . a ( monitor ) ; } sb . a ( NL ) ; } }
apacheignite/ignite | private static void printSynchronizersInfo ( LockInfo [ ] syncs , GridStringBuilder sb ) { sb . a ( " ▁ ▁ ▁ ▁ Locked ▁ synchronizers : " ) ; for ( LockInfo info : syncs ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) . a ( info ) ; }
apacheignite/ignite | @ Nullable public static Constructor < ? > forceEmptyConstructor ( Class < ? > cls ) throws IgniteCheckedException { Constructor < ? > ctor = null ; try { return cls . getDeclaredConstructor ( ) ; } catch ( Exception ignore ) { Method ctorFac = U . ctorFactory ( ) ; Object sunRefFac = U . sunReflectionFactory ( ) ; if ( ctorFac != null && sunRefFac != null ) try { ctor = ( Constructor ) ctorFac . invoke ( sunRefFac , cls , U . objectConstructor ( ) ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ object ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } } return ctor ; }
apacheignite/ignite | @ Nullable public static Class < ? > classForName ( String cls , @ Nullable Class < ? > dflt ) { try { return cls == null ? dflt : Class . forName ( cls ) ; } catch ( ClassNotFoundException ignore ) { return dflt ; } }
apacheignite/ignite | @ Nullable public static < T > T newInstance ( String cls ) throws IgniteCheckedException { Class < ? > cls0 ; try { cls0 = Class . forName ( cls ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } return ( T ) newInstance ( cls0 ) ; }
apacheignite/ignite | @ Nullable public static < T > T newInstance ( Class < T > cls ) throws IgniteCheckedException { boolean set = false ; Constructor < T > ctor = null ; try { ctor = cls . getDeclaredConstructor ( ) ; if ( ctor == null ) return null ; if ( ! ctor . isAccessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ctor . newInstance ( ) ; } catch ( NoSuchMethodException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ find ▁ empty ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( ctor != null && set ) ctor . setAccessible ( false ) ; } }
apacheignite/ignite | ) @ Nullable public static < T > T forceNewInstance ( Class < ? > cls ) throws IgniteCheckedException { Constructor ctor = forceEmptyConstructor ( cls ) ; if ( ctor == null ) return null ; boolean set = false ; try { if ( ! ctor . isAccessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ( T ) ctor . newInstance ( ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( set ) ctor . setAccessible ( false ) ; } }
apacheignite/ignite | public static String formatMins ( long mins ) { assert mins >= 0 ; if ( mins == 0 ) return " < ▁ 1 ▁ min " ; SB sb = new SB ( ) ; long dd = mins / 1440 ; if ( dd > 0 ) sb . a ( dd ) . a ( dd == 1 ? " ▁ day ▁ " : " ▁ days ▁ " ) ; mins %= 1440 ; long hh = mins / 60 ; if ( hh > 0 ) sb . a ( hh ) . a ( hh == 1 ? " ▁ hour ▁ " : " ▁ hours ▁ " ) ; mins %= 60 ; if ( mins > 0 ) sb . a ( mins ) . a ( mins == 1 ? " ▁ min ▁ " : " ▁ mins ▁ " ) ; return sb . toString ( ) . trim ( ) ; }
apacheignite/ignite | public static String id8 ( UUID id ) { return id . toString ( ) . substring ( 0 , 8 ) ; }
apacheignite/ignite | public static String id8 ( IgniteUuid id ) { String s = id . toString ( ) ; return s . substring ( 0 , 4 ) + s . substring ( s . length ( ) - 4 ) ; }
apacheignite/ignite | public static String filler ( int len , char ch ) { char [ ] a = new char [ len ] ; Arrays . fill ( a , ch ) ; return new String ( a ) ; }
apacheignite/ignite | public static < T > void writeArray ( ObjectOutput out , T [ ] arr ) throws IOException { int len = arr == null ? 0 : arr . length ; out . writeInt ( len ) ; if ( arr != null && arr . length > 0 ) for ( T t : arr ) out . writeObject ( t ) ; }
apacheignite/ignite | public static void writeCollection ( ObjectOutput out , Collection < ? > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Object o : col ) out . writeObject ( o ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static void writeIntCollection ( DataOutput out , Collection < Integer > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Integer i : col ) out . writeInt ( i ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | @ Nullable public static Collection < Integer > readIntCollection ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Collection < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
apacheignite/ignite | public static < K , V > Map < K , V > copyMap ( Map < K , V > m ) { return new HashMap < > ( m ) ; }
apacheignite/ignite | public static < K , V > Map < K , V > sealMap ( Map < K , V > m ) { assert m != null ; return Collections . unmodifiableMap ( new HashMap < > ( m ) ) ; }
apacheignite/ignite | public static < E > List < E > sealList ( Collection < E > c ) { return Collections . unmodifiableList ( new ArrayList < > ( c ) ) ; }
apacheignite/ignite | public static < E > List < E > sealList ( E ... a ) { return Collections . unmodifiableList ( Arrays . asList ( a ) ) ; }
apacheignite/ignite | @ Nullable public static String getNetworkInterfaceName ( String addr ) { assert addr != null ; try { InetAddress inetAddr = InetAddress . getByName ( addr ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) for ( InetAddress itfAddr : asIterable ( itf . getInetAddresses ( ) ) ) if ( itfAddr . equals ( inetAddr ) ) return itf . getDisplayName ( ) ; } catch ( UnknownHostException ignore ) { return null ; } catch ( SocketException ignore ) { return null ; } return null ; }
apacheignite/ignite | public static InetAddress resolveLocalHost ( @ Nullable String hostName ) throws IOException { return F . isEmpty ( hostName ) ? new InetSocketAddress ( 0 ) . getAddress ( ) : InetAddress . getByName ( hostName ) ; }
apacheignite/ignite | public static synchronized boolean isLocalHostChanged ( ) throws IOException { InetAddress locHost0 = locHost ; return locHost0 != null && ! resetLocalHost ( ) . equals ( locHost0 ) ; }
apacheignite/ignite | public static List < InetAddress > filterReachable ( List < InetAddress > addrs ) { final int reachTimeout = 2000 ; if ( addrs . isEmpty ( ) ) return Collections . emptyList ( ) ; if ( addrs . size ( ) == 1 ) { InetAddress addr = addrs . get ( 0 ) ; if ( reachable ( addr , reachTimeout ) ) return Collections . singletonList ( addr ) ; return Collections . emptyList ( ) ; } final List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Collection < Future < ? > > futs = new ArrayList < > ( addrs . size ( ) ) ; ExecutorService executor = Executors . newFixedThreadPool ( Math . min ( 10 , addrs . size ( ) ) ) ; for ( final InetAddress addr : addrs ) { futs . add ( executor . submit ( new Runnable ( ) { @ Override public void run ( ) { if ( reachable ( addr , reachTimeout ) ) { synchronized ( res ) { res . add ( addr ) ; } } } } ) ) ; } for ( Future < ? > fut : futs ) { try { fut . get ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteException ( " Thread ▁ has ▁ been ▁ interrupted . " , e ) ; } catch ( ExecutionException e ) { throw new IgniteException ( e ) ; } } executor . shutdown ( ) ; return res ; }
apacheignite/ignite | private static void addresses ( InetAddress addr , Collection < String > addrs , Collection < String > hostNames ) { String hostName = addr . getHostName ( ) ; String ipAddr = addr . getHostAddress ( ) ; addrs . add ( ipAddr ) ; if ( ! F . isEmpty ( hostName ) && ! addr . isLoopbackAddress ( ) ) hostNames . add ( hostName ) ; }
apacheignite/ignite | public static synchronized InetAddress getLocalHost ( ) throws IOException { if ( locHost == null ) resetLocalHost ( ) ; return locHost ; }
apacheignite/ignite | private static synchronized InetAddress resetLocalHost ( ) throws IOException { locHost = null ; String sysLocHost = IgniteSystemProperties . getString ( IGNITE_LOCAL_HOST ) ; if ( sysLocHost != null ) sysLocHost = sysLocHost . trim ( ) ; if ( ! F . isEmpty ( sysLocHost ) ) locHost = InetAddress . getByName ( sysLocHost ) ; else { List < NetworkInterface > itfs = new ArrayList < > ( ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) itfs . add ( itf ) ; Collections . sort ( itfs , new Comparator < NetworkInterface > ( ) { @ Override public int compare ( NetworkInterface itf1 , NetworkInterface itf2 ) { return itf1 . getName ( ) . compareTo ( itf2 . getName ( ) ) ; } } ) ; int reachTimeout = 2000 ; for ( NetworkInterface itf : itfs ) { boolean found = false ; for ( InetAddress addr : asIterable ( itf . getInetAddresses ( ) ) ) { if ( ! addr . isLoopbackAddress ( ) && ! addr . isLinkLocalAddress ( ) && reachable ( itf , addr , reachTimeout ) ) { locHost = addr ; found = true ; break ; } } if ( found ) break ; } } if ( locHost == null ) locHost = InetAddress . getLocalHost ( ) ; return locHost ; }
apacheignite/ignite | public static boolean reachable ( NetworkInterface itf , InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( itf , 0 , reachTimeout ) ; } catch ( IOException ignore ) { return false ; } }
apacheignite/ignite | public static boolean reachable ( InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( reachTimeout ) ; } catch ( IOException ignore ) { return false ; } }
apacheignite/ignite | public static boolean sameMacs ( ClusterNode loc , ClusterNode rmt ) { assert loc != null ; assert rmt != null ; String locMacs = loc . attribute ( IgniteNodeAttributes . ATTR_MACS ) ; String rmtMacs = rmt . attribute ( IgniteNodeAttributes . ATTR_MACS ) ; return locMacs != null && locMacs . equals ( rmtMacs ) ; }
apacheignite/ignite | public static synchronized Collection < String > allLocalIps ( ) { List < String > ips = new ArrayList < > ( 4 ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { if ( ! itf . isLoopback ( ) ) { Enumeration < InetAddress > addrs = itf . getInetAddresses ( ) ; for ( InetAddress addr : asIterable ( addrs ) ) { String hostAddr = addr . getHostAddress ( ) ; if ( ! addr . isLoopbackAddress ( ) && ! ips . contains ( hostAddr ) ) ips . add ( hostAddr ) ; } } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( ips ) ; return ips ; }
apacheignite/ignite | public static synchronized Collection < String > allLocalMACs ( ) { List < String > macs = new ArrayList < > ( 3 ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { byte [ ] hwAddr = itf . getHardwareAddress ( ) ; if ( hwAddr != null && hwAddr . length > 0 ) { String mac = byteArray2HexString ( hwAddr ) ; if ( ! macs . contains ( mac ) ) macs . add ( mac ) ; } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( macs ) ; return macs ; }
apacheignite/ignite | public static File downloadUrl ( URL url , File file ) throws IOException { assert url != null ; assert file != null ; InputStream in = null ; OutputStream out = null ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpsURLConnection ) { HttpsURLConnection https = ( HttpsURLConnection ) conn ; https . setHostnameVerifier ( new DeploymentHostnameVerifier ( ) ) ; SSLContext ctx = SSLContext . getInstance ( HTTPS_PROTOCOL ) ; ctx . init ( null , getTrustManagers ( ) , null ) ; https . setSSLSocketFactory ( ctx . getSocketFactory ( ) ) ; } in = conn . getInputStream ( ) ; if ( in == null ) throw new IOException ( " Failed ▁ to ▁ open ▁ connection : ▁ " + url . toString ( ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; copy ( in , out ) ; } catch ( NoSuchAlgorithmException | KeyManagementException e ) { throw new IOException ( " Failed ▁ to ▁ open ▁ HTTPs ▁ connection ▁ [ url = " + url . toString ( ) + " , ▁ msg = " + e + ' ] ' , e ) ; } finally { close ( in , null ) ; close ( out , null ) ; } return file ; }
apacheignite/ignite | private static TrustManager [ ] getTrustManagers ( ) { return new TrustManager [ ] { new X509TrustManager ( ) { @ Nullable @ Override public X509Certificate [ ] getAcceptedIssuers ( ) { return null ; } @ Override public void checkClientTrusted ( X509Certificate [ ] certs , String authType ) { } @ Override public void checkServerTrusted ( X509Certificate [ ] certs , String authType ) { } } } ; }
apacheignite/ignite | @ Nullable public static String hidePassword ( @ Nullable String uri ) { if ( uri == null ) return null ; if ( Pattern . matches ( " . * : // ( . * : . * ) @ . * " , uri ) ) { int userInfoLastIdx = uri . indexOf ( ' @ ' ) ; assert userInfoLastIdx != - 1 ; String str = uri . substring ( 0 , userInfoLastIdx ) ; int userInfoStartIdx = str . lastIndexOf ( ' / ' ) ; str = str . substring ( userInfoStartIdx + 1 ) ; String [ ] params = str . split ( " ; " ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < params . length ; i ++ ) { int idx ; if ( ( idx = params [ i ] . indexOf ( ' : ' ) ) != - 1 ) params [ i ] = params [ i ] . substring ( 0 , idx + 1 ) + ' * ' ; builder . append ( params [ i ] ) ; if ( i != params . length - 1 ) builder . append ( ' ; ' ) ; } return new StringBuilder ( uri ) . replace ( userInfoStartIdx + 1 , userInfoLastIdx , builder . toString ( ) ) . toString ( ) ; } return uri ; }
apacheignite/ignite | public static ClassLoader gridClassLoader ( ) { return gridClassLoader ; }
apacheignite/ignite | public static boolean hasParent ( @ Nullable ClassLoader parent , ClassLoader ldr ) { if ( parent != null ) { for ( ; ldr != null ; ldr = ldr . getParent ( ) ) { if ( ldr . equals ( parent ) ) return true ; } return false ; } return true ; }
apacheignite/ignite | public static void writeBytesCollection ( DataOutput out , Collection < byte [ ] > bytes ) throws IOException { if ( bytes != null ) { out . writeInt ( bytes . size ( ) ) ; for ( byte [ ] b : bytes ) writeByteArray ( out , b ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static List < byte [ ] > readBytesList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size < 0 ) return null ; List < byte [ ] > res = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) res . add ( readByteArray ( in ) ) ; return res ; }
apacheignite/ignite | public static void writeByteArray ( DataOutput out , @ Nullable byte [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; out . write ( arr ) ; } }
apacheignite/ignite | public static void writeByteArray ( DataOutput out , @ Nullable byte [ ] arr , int maxLen ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { int len = Math . min ( arr . length , maxLen ) ; out . writeInt ( len ) ; out . write ( arr , 0 , len ) ; } }
apacheignite/ignite | @ Nullable public static byte [ ] readByteArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; byte [ ] res = new byte [ len ] ; in . readFully ( res ) ; return res ; }
apacheignite/ignite | public static byte [ ] readByteArray ( ByteBuffer ... bufs ) { assert ! F . isEmpty ( bufs ) ; int size = 0 ; for ( ByteBuffer buf : bufs ) size += buf . remaining ( ) ; byte [ ] res = new byte [ size ] ; int off = 0 ; for ( ByteBuffer buf : bufs ) { int len = buf . remaining ( ) ; if ( len != 0 ) { buf . get ( res , off , len ) ; off += len ; } } assert off == res . length ; return res ; }
apacheignite/ignite | public static void writeByteCollection ( DataOutput out , Collection < Byte > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Byte i : col ) out . writeByte ( i ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | @ Nullable public static List < Byte > readByteList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Byte > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readByte ( ) ) ; return col ; }
apacheignite/ignite | public static byte [ ] join ( byte [ ] ... bufs ) { int size = 0 ; for ( byte [ ] buf : bufs ) { size += buf . length ; } byte [ ] res = new byte [ size ] ; int position = 0 ; for ( byte [ ] buf : bufs ) { arrayCopy ( buf , 0 , res , position , buf . length ) ; position += buf . length ; } return res ; }
apacheignite/ignite | public static String byteArray2String ( byte [ ] arr , String hdrFmt , String bodyFmt ) { assert arr != null ; assert hdrFmt != null ; assert bodyFmt != null ; SB sb = new SB ( ) ; sb . a ( ' { ' ) ; boolean first = true ; for ( byte b : arr ) if ( first ) { sb . a ( String . format ( hdrFmt , b ) ) ; first = false ; } else sb . a ( String . format ( bodyFmt , b ) ) ; sb . a ( ' } ' ) ; return sb . toString ( ) ; }
apacheignite/ignite | public static byte [ ] hexString2ByteArray ( String hex ) throws IllegalArgumentException { if ( hex . length ( ) % 2 != 0 ) hex = '0' + hex ; char [ ] chars = hex . toCharArray ( ) ; byte [ ] bytes = new byte [ chars . length / 2 ] ; int byteCnt = 0 ; for ( int i = 0 ; i < chars . length ; i += 2 ) { int newByte = 0 ; newByte |= hexCharToByte ( chars [ i ] ) ; newByte <<= 4 ; newByte |= hexCharToByte ( chars [ i + 1 ] ) ; bytes [ byteCnt ] = ( byte ) newByte ; byteCnt ++ ; } return bytes ; }
apacheignite/ignite | ) private static byte hexCharToByte ( char ch ) throws IllegalArgumentException { switch ( ch ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : return ( byte ) ( ch - '0' ) ; case ' a ' : case ' A ' : return 0xa ; case ' b ' : case ' B ' : return 0xb ; case ' c ' : case ' C ' : return 0xc ; case ' d ' : case ' D ' : return 0xd ; case ' e ' : case ' E ' : return 0xe ; case ' f ' : case ' F ' : return 0xf ; default : throw new IllegalArgumentException ( " Hex ▁ decoding ▁ wrong ▁ input ▁ character ▁ [ character = " + ch + ' ] ' ) ; } }
apacheignite/ignite | public static byte [ ] doubleToBytes ( double d ) { return longToBytes ( Double . doubleToLongBits ( d ) ) ; }
apacheignite/ignite | public static int doubleToBytes ( double d , byte [ ] bytes , int off ) { return longToBytes ( Double . doubleToLongBits ( d ) , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] floatToBytes ( float f ) { return intToBytes ( Float . floatToIntBits ( f ) ) ; }
apacheignite/ignite | public static int floatToBytes ( float f , byte [ ] bytes , int off ) { return intToBytes ( Float . floatToIntBits ( f ) , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] longToBytes ( long l ) { return GridClientByteUtils . longToBytes ( l ) ; }
apacheignite/ignite | public static int longToBytes ( long l , byte [ ] bytes , int off ) { return off + GridClientByteUtils . longToBytes ( l , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] intToBytes ( int i ) { return GridClientByteUtils . intToBytes ( i ) ; }
apacheignite/ignite | public static int intToBytes ( int i , byte [ ] bytes , int off ) { return off + GridClientByteUtils . intToBytes ( i , bytes , off ) ; }
apacheignite/ignite | public static byte [ ] shortToBytes ( short s ) { return GridClientByteUtils . shortToBytes ( s ) ; }
apacheignite/ignite | public static int shortToBytes ( short s , byte [ ] bytes , int off ) { return off + GridClientByteUtils . shortToBytes ( s , bytes , off ) ; }
apacheignite/ignite | public static int uuidToBytes ( @ Nullable UUID uuid , byte [ ] arr , int off ) { return off + GridClientByteUtils . uuidToBytes ( uuid , arr , off ) ; }
apacheignite/ignite | public static byte [ ] uuidToBytes ( @ Nullable UUID uuid ) { return GridClientByteUtils . uuidToBytes ( uuid ) ; }
apacheignite/ignite | public static short bytesToShort ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Short . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; short res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
apacheignite/ignite | public static int bytesToInt ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Integer . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; int res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
apacheignite/ignite | public static long bytesToLong ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Long . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; long res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
apacheignite/ignite | public static UUID bytesToUuid ( byte [ ] bytes , int off ) { return GridClientByteUtils . bytesToUuid ( bytes , off ) ; }
apacheignite/ignite | public static double bytesToDouble ( byte [ ] bytes , int off ) { return Double . longBitsToDouble ( bytesToLong ( bytes , off ) ) ; }
apacheignite/ignite | public static float bytesToFloat ( byte [ ] bytes , int off ) { return Float . intBitsToFloat ( bytesToInt ( bytes , off ) ) ; }
apacheignite/ignite | public static boolean bytesEqual ( byte [ ] a , int aOff , byte [ ] b , int bOff , int len ) { if ( aOff + len > a . length || bOff + len > b . length ) return false ; else { for ( int i = 0 ; i < len ; i ++ ) if ( a [ aOff + i ] != b [ bOff + i ] ) return false ; return true ; } }
apacheignite/ignite | public static byte [ ] decodeHex ( char [ ] data ) throws IgniteCheckedException { int len = data . length ; if ( ( len & 0x01 ) != 0 ) throw new IgniteCheckedException ( " Odd ▁ number ▁ of ▁ characters . " ) ; byte [ ] out = new byte [ len >> 1 ] ; for ( int i = 0 , j = 0 ; j < len ; i ++ ) { int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f |= toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; }
apacheignite/ignite | public static String dash ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' - ' ) ; dash [ 0 ] = dash [ len - 1 ] = ' + ' ; return new String ( dash ) ; }
apacheignite/ignite | public static String pad ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' ▁ ' ) ; return new String ( dash ) ; }
apacheignite/ignite | public static String format ( long sysTime ) { return LONG_DATE_FMT . format ( new java . util . Date ( sysTime ) ) ; }
apacheignite/ignite | public static < T > Iterable < T > randomIterable ( Collection < T > col ) { List < T > list = new ArrayList < > ( col ) ; Collections . shuffle ( list ) ; return list ; }
apacheignite/ignite | public static < T > Iterable < T > asIterable ( final Enumeration < T > e ) { return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { @ Override public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } @ SuppressWarnings ( { " IteratorNextCanNotThrowNoSuchElementException " } ) @ Override public T next ( ) { return e . nextElement ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; }
apacheignite/ignite | public static void copy ( File src , File dest , boolean overwrite ) throws IOException { assert src != null ; assert dest != null ; if ( ! src . exists ( ) ) throw new FileNotFoundException ( " Source ▁ can ' t ▁ be ▁ found : ▁ " + src ) ; if ( src . getAbsoluteFile ( ) . equals ( dest . getAbsoluteFile ( ) ) ) throw new IOException ( " Source ▁ and ▁ destination ▁ are ▁ the ▁ same ▁ [ src = " + src + " , ▁ dest = " + dest + ' ] ' ) ; if ( dest . exists ( ) ) { if ( ! dest . isDirectory ( ) && ! overwrite ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + dest ) ; if ( ! dest . canWrite ( ) ) throw new IOException ( " Destination ▁ is ▁ not ▁ writable : " + dest ) ; } else { File parent = dest . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) parent . mkdirs ( ) ; if ( src . isDirectory ( ) ) dest . mkdir ( ) ; } if ( src . isDirectory ( ) ) { File [ ] files = src . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { File dir = new File ( dest , file . getName ( ) ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) throw new IOException ( " Can ' t ▁ create ▁ directory : ▁ " + dir ) ; copy ( file , dir , overwrite ) ; } else copy ( file , dest , overwrite ) ; } } else { File file = dest . exists ( ) && dest . isDirectory ( ) ? new File ( dest , src . getName ( ) ) : dest ; if ( ! overwrite && file . exists ( ) ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + file ) ; FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( file ) ; copy ( in , out ) ; } finally { if ( in != null ) in . close ( ) ; if ( out != null ) { out . getFD ( ) . sync ( ) ; out . close ( ) ; } } } }
apacheignite/ignite | public static void onGridStart ( ) { synchronized ( mux ) { if ( gridCnt == 0 ) { assert timer == null ; timer = new Thread ( new Runnable ( ) { @ SuppressWarnings ( { " BusyWait " , " InfiniteLoopStatement " } ) @ Override public void run ( ) { while ( true ) { curTimeMillis = System . currentTimeMillis ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignored ) { break ; } } } } , " ignite - clock " ) ; timer . setDaemon ( true ) ; timer . setPriority ( 10 ) ; timer . start ( ) ; } ++ gridCnt ; } }
apacheignite/ignite | public static void onGridStop ( ) throws InterruptedException { synchronized ( mux ) { if ( gridCnt == 0 ) return ; -- gridCnt ; Thread timer0 = timer ; if ( gridCnt == 0 && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }
apacheignite/ignite | public static int copy ( InputStream in , OutputStream out ) throws IOException { assert in != null ; assert out != null ; byte [ ] buf = new byte [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
apacheignite/ignite | public static int copy ( Reader in , Writer out ) throws IOException { assert in != null ; assert out != null ; char [ ] buf = new char [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
apacheignite/ignite | public static void writeStringToFile ( File file , String s ) throws IOException { writeStringToFile ( file , s , Charset . defaultCharset ( ) . toString ( ) , false ) ; }
apacheignite/ignite | public static void writeStringToFile ( File file , String s , String charset ) throws IOException { writeStringToFile ( file , s , charset , false ) ; }
apacheignite/ignite | public static String readFileToString ( String fileName , String charset ) throws IOException { Reader input = new InputStreamReader ( new FileInputStream ( fileName ) , charset ) ; StringWriter output = new StringWriter ( ) ; char [ ] buf = new char [ 4096 ] ; int n ; while ( ( n = input . read ( buf ) ) != - 1 ) output . write ( buf , 0 , n ) ; return output . toString ( ) ; }
apacheignite/ignite | public static void writeStringToFile ( File file , String s , String charset , boolean append ) throws IOException { if ( s == null ) return ; try ( OutputStream out = new FileOutputStream ( file , append ) ) { out . write ( s . getBytes ( charset ) ) ; } }
apacheignite/ignite | public static < E extends Throwable > E withCause ( E e , @ Nullable Throwable cause ) { assert e != null ; if ( cause != null ) e . initCause ( cause ) ; return e ; }
apacheignite/ignite | public static boolean delete ( @ Nullable File file ) { if ( file == null ) return false ; boolean res = true ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files != null && files . length > 0 ) for ( File file1 : files ) if ( file1 . isDirectory ( ) ) res &= delete ( file1 ) ; else if ( file1 . getName ( ) . endsWith ( " jar " ) ) try { new JarFile ( file1 , false ) . close ( ) ; res &= file1 . delete ( ) ; } catch ( IOException ignore ) { } else res &= file1 . delete ( ) ; res &= file . delete ( ) ; } else res = file . delete ( ) ; return res ; }
apacheignite/ignite | public static boolean mkdirs ( File dir ) { assert dir != null ; return dir . mkdirs ( ) || dir . exists ( ) ; }
apacheignite/ignite | @ Nullable private static String resolveProjectHome ( ) { assert Thread . holdsLock ( IgniteUtils . class ) ; String ggHome0 = IgniteSystemProperties . getString ( IGNITE_HOME ) ; if ( ! F . isEmpty ( ggHome0 ) ) return ggHome0 ; String appWorkDir = System . getProperty ( " user . dir " ) ; if ( appWorkDir != null ) { ggHome0 = findProjectHome ( new File ( appWorkDir ) ) ; if ( ggHome0 != null ) return ggHome0 ; } URI classesUri ; Class < IgniteUtils > cls = IgniteUtils . class ; try { ProtectionDomain domain = cls . getProtectionDomain ( ) ; if ( domain == null || domain . getCodeSource ( ) == null || domain . getCodeSource ( ) . getLocation ( ) == null ) { logResolveFailed ( cls , null ) ; return null ; } classesUri = domain . getCodeSource ( ) . getLocation ( ) . toURI ( ) ; if ( isWindows ( ) && classesUri . getAuthority ( ) != null ) classesUri = new URI ( classesUri . toString ( ) . replace ( " file : // " , " file : / " ) ) ; } catch ( URISyntaxException | SecurityException e ) { logResolveFailed ( cls , e ) ; return null ; } File classesFile ; try { classesFile = new File ( classesUri ) ; } catch ( IllegalArgumentException e ) { logResolveFailed ( cls , e ) ; return null ; } return findProjectHome ( classesFile ) ; }
apacheignite/ignite | private static String findProjectHome ( File startDir ) { for ( File cur = startDir . getAbsoluteFile ( ) ; cur != null ; cur = cur . getParentFile ( ) ) { if ( ! new File ( cur , " bin " ) . isDirectory ( ) || ! new File ( cur , " config " ) . isDirectory ( ) ) continue ; return cur . getPath ( ) ; } return null ; }
apacheignite/ignite | private static void logResolveFailed ( Class cls , Exception e ) { warn ( null , " Failed ▁ to ▁ resolve ▁ IGNITE _ HOME ▁ automatically ▁ for ▁ class ▁ codebase ▁ " + " [ class = " + cls + ( e == null ? " " : " , ▁ e = " + e . getMessage ( ) ) + ' ] ' ) ; }
apacheignite/ignite | @ Nullable public static String getIgniteHome ( ) { GridTuple < String > ggHomeTup = ggHome ; String ggHome0 ; if ( ggHomeTup == null ) { synchronized ( IgniteUtils . class ) { ggHomeTup = ggHome ; if ( ggHomeTup == null ) { ggHome = F . t ( ggHome0 = resolveProjectHome ( ) ) ; if ( ggHome0 != null ) System . setProperty ( IGNITE_HOME , ggHome0 ) ; } else ggHome0 = ggHomeTup . get ( ) ; } } else ggHome0 = ggHomeTup . get ( ) ; return ggHome0 ; }
apacheignite/ignite | public static void setIgniteHome ( @ Nullable String path ) { GridTuple < String > ggHomeTup = ggHome ; String ggHome0 ; if ( ggHomeTup == null ) { synchronized ( IgniteUtils . class ) { ggHomeTup = ggHome ; if ( ggHomeTup == null ) { if ( F . isEmpty ( path ) ) System . clearProperty ( IGNITE_HOME ) ; else System . setProperty ( IGNITE_HOME , path ) ; ggHome = F . t ( path ) ; return ; } else ggHome0 = ggHomeTup . get ( ) ; } } else ggHome0 = ggHomeTup . get ( ) ; if ( ggHome0 != null && ! ggHome0 . equals ( path ) ) throw new IgniteException ( " Failed ▁ to ▁ set ▁ IGNITE _ HOME ▁ after ▁ it ▁ has ▁ been ▁ already ▁ resolved ▁ " + " [ igniteHome = " + ggHome0 + " , ▁ newIgniteHome = " + path + ' ] ' ) ; }
apacheignite/ignite | @ Nullable public static File resolveIgnitePath ( String path ) { assert path != null ; String home = getIgniteHome ( ) ; if ( home != null ) { File file = new File ( home , path ) ; if ( file . exists ( ) ) return file ; } File file = new File ( path ) ; if ( file . exists ( ) ) return file ; return null ; }
apacheignite/ignite | @ Nullable public static URL resolveIgniteUrl ( String path ) { return resolveIgniteUrl ( path , true ) ; }
apacheignite/ignite | public static URL resolveSpringUrl ( String springCfgPath ) throws IgniteCheckedException { A . notNull ( springCfgPath , " springCfgPath " ) ; URL url ; try { url = new URL ( springCfgPath ) ; } catch ( MalformedURLException e ) { url = U . resolveIgniteUrl ( springCfgPath ) ; if ( url == null ) url = resolveInClasspath ( springCfgPath ) ; if ( url == null ) throw new IgniteCheckedException ( " Spring ▁ XML ▁ configuration ▁ path ▁ is ▁ invalid : ▁ " + springCfgPath + " . ▁ Note ▁ that ▁ this ▁ path ▁ should ▁ be ▁ either ▁ absolute ▁ or ▁ a ▁ relative ▁ local ▁ file ▁ system ▁ path , ▁ " + " relative ▁ to ▁ META - INF ▁ in ▁ classpath ▁ or ▁ valid ▁ URL ▁ to ▁ IGNITE _ HOME . " , e ) ; } return url ; }
apacheignite/ignite | @ Nullable private static URL resolveInClasspath ( String path ) { ClassLoader clsLdr = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( clsLdr == null ) return null ; return clsLdr . getResource ( path . replaceAll ( " \\ \ \" , " / " ) ) ; }
apacheignite/ignite | ) @ Nullable public static URL resolveIgniteUrl ( String path , boolean metaInf ) { File f = resolveIgnitePath ( path ) ; if ( f != null ) { try { return f . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { } } ClassLoader clsLdr = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( clsLdr != null ) { String locPath = ( metaInf ? " META - INF / " : " " ) + path . replaceAll ( " \\ \ \" , " / " ) ; return clsLdr . getResource ( locPath ) ; } else return null ; }
apacheignite/ignite | public static String byteArray2HexString ( byte [ ] arr ) { SB sb = new SB ( arr . length << 1 ) ; for ( byte b : arr ) sb . a ( Integer . toHexString ( MASK & b >>> 4 ) ) . a ( Integer . toHexString ( MASK & b ) ) ; return sb . toString ( ) . toUpperCase ( ) ; }
apacheignite/ignite | public static boolean containsObjectArray ( @ Nullable Object [ ] arr , Object val , @ Nullable Object ... vals ) { if ( arr == null || arr . length == 0 ) return false ; for ( Object o : arr ) { if ( F . eq ( o , val ) ) return true ; if ( vals != null && vals . length > 0 ) for ( Object v : vals ) if ( F . eq ( o , v ) ) return true ; } return false ; }
apacheignite/ignite | public static boolean containsObjectArray ( @ Nullable Object [ ] arr , @ Nullable Collection < Object > c ) { if ( arr == null || arr . length == 0 || c == null || c . isEmpty ( ) ) return false ; for ( Object o : arr ) { if ( c . contains ( o ) ) return true ; } return false ; }
apacheignite/ignite | public static boolean containsIntArray ( int [ ] arr , int val ) { assert arr != null ; if ( arr . length == 0 ) return false ; for ( int i : arr ) if ( i == val ) return true ; return false ; }
apacheignite/ignite | public static boolean containsStringArray ( String [ ] arr , @ Nullable String val , boolean ignoreCase ) { assert arr != null ; for ( String s : arr ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignoreCase ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
apacheignite/ignite | public static boolean containsStringCollection ( Iterable < String > c , @ Nullable String val , boolean ignoreCase ) { assert c != null ; for ( String s : c ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignoreCase ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
apacheignite/ignite | public static void close ( @ Nullable AutoCloseable rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void closeQuiet ( @ Nullable AutoCloseable rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception ignored ) { } }
apacheignite/ignite | public static void close ( @ Nullable SelectionKey rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) close ( rsrc . channel ( ) , log ) ; }
apacheignite/ignite | public static void closeQuiet ( @ Nullable SelectionKey rsrc ) { if ( rsrc != null ) closeQuiet ( rsrc . channel ( ) ) ; }
apacheignite/ignite | public static void close ( @ Nullable DatagramSocket rsrc ) { if ( rsrc != null ) rsrc . close ( ) ; }
apacheignite/ignite | public static void close ( @ Nullable Selector rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void closeQuiet ( @ Nullable Selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException ignored ) { } }
apacheignite/ignite | public static void close ( @ Nullable Context rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void closeQuiet ( @ Nullable Context rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException ignored ) { } }
apacheignite/ignite | public static void close ( @ Nullable URLClassLoader clsLdr , @ Nullable IgniteLogger log ) { if ( clsLdr != null ) try { URLClassPath path = SharedSecrets . getJavaNetAccess ( ) . getURLClassPath ( clsLdr ) ; Field ldrFld = path . getClass ( ) . getDeclaredField ( " loaders " ) ; ldrFld . setAccessible ( true ) ; Iterable ldrs = ( Iterable ) ldrFld . get ( path ) ; for ( Object ldr : ldrs ) if ( ldr . getClass ( ) . getName ( ) . endsWith ( " JarLoader " ) ) try { Field jarFld = ldr . getClass ( ) . getDeclaredField ( " jar " ) ; jarFld . setAccessible ( true ) ; ZipFile jar = ( ZipFile ) jarFld . get ( ldr ) ; jar . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void releaseQuiet ( @ Nullable FileLock lock ) { if ( lock != null ) try { lock . release ( ) ; } catch ( Exception ignored ) { } }
apacheignite/ignite | public static void rollbackConnection ( @ Nullable Connection rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException e ) { warn ( log , " Failed ▁ to ▁ rollback ▁ JDBC ▁ connection : ▁ " + e . getMessage ( ) ) ; } }
apacheignite/ignite | public static void courtesy ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; courtesy ( log , s , s ) ; }
apacheignite/ignite | public static void courtesy ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) log . getLogger ( IgniteConfiguration . COURTESY_LOGGER_NAME ) . warning ( compact ( longMsg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( courtesy ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; }
apacheignite/ignite | public static void warn ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; warn ( log , s , s ) ; }
apacheignite/ignite | public static void quietAndWarn ( IgniteLogger log , Object msg ) { quietAndWarn ( log , msg , msg ) ; }
apacheignite/ignite | public static void quietAndWarn ( IgniteLogger log , Object msg , Object shortMsg ) { warn ( log , msg ) ; if ( log . isQuiet ( ) ) quiet ( false , shortMsg ) ; }
apacheignite/ignite | public static void error ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; if ( msg instanceof Throwable ) { Throwable t = ( Throwable ) msg ; error ( log , t . getMessage ( ) , t ) ; } else { String s = msg . toString ( ) ; error ( log , s , s , null ) ; } }
apacheignite/ignite | public static void warn ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) log . warning ( compact ( longMsg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( wrn ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; }
apacheignite/ignite | public static void log ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) { if ( log . isInfoEnabled ( ) ) log . info ( compact ( longMsg . toString ( ) ) ) ; } else quiet ( false , shortMsg ) ; }
apacheignite/ignite | public static void log ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; log ( log , s , s ) ; }
apacheignite/ignite | public static void error ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg , @ Nullable Throwable e ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) { if ( e == null ) log . error ( compact ( longMsg . toString ( ) ) ) ; else log . error ( compact ( longMsg . toString ( ) ) , e ) ; } else { X . printerr ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( err ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; if ( e != null ) e . printStackTrace ( System . err ) ; else X . printerrln ( ) ; } }
apacheignite/ignite | public static void error ( @ Nullable IgniteLogger log , Object shortMsg , @ Nullable Throwable e ) { assert shortMsg != null ; String s = shortMsg . toString ( ) ; error ( log , s , s , e ) ; }
apacheignite/ignite | public static void quiet ( boolean err , Object ... objs ) { assert objs != null ; String time = SHORT_DATE_FMT . format ( new java . util . Date ( ) ) ; SB sb = new SB ( ) ; for ( Object obj : objs ) sb . a ( ' [ ' ) . a ( time ) . a ( " ] ▁ " ) . a ( obj . toString ( ) ) . a ( NL ) ; PrintStream ps = err ? System . err : System . out ; ps . print ( compact ( sb . toString ( ) ) ) ; }
apacheignite/ignite | public static void quietAndInfo ( IgniteLogger log , String msg ) { if ( log . isQuiet ( ) ) U . quiet ( false , msg ) ; if ( log . isInfoEnabled ( ) ) log . info ( msg ) ; }
apacheignite/ignite | public static void rollbackConnectionQuiet ( @ Nullable Connection rsrc ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException ignored ) { } }
apacheignite/ignite | public static ObjectName makeMBeanName ( @ Nullable String gridName , @ Nullable String grp , String name ) throws MalformedObjectNameException { SB sb = new SB ( JMX_DOMAIN + ' : ' ) ; appendClassLoaderHash ( sb ) ; appendJvmId ( sb ) ; if ( gridName != null && ! gridName . isEmpty ( ) ) sb . a ( " grid = " ) . a ( gridName ) . a ( ' , ' ) ; if ( grp != null ) sb . a ( " group = " ) . a ( grp ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
apacheignite/ignite | private static void appendClassLoaderHash ( SB sb ) { if ( getBoolean ( IGNITE_MBEAN_APPEND_class_LOADER_ID , true ) ) { String clsLdrHash = Integer . toHexString ( Ignite . class . getClassLoader ( ) . hashCode ( ) ) ; sb . a ( " clsLdr = " ) . a ( clsLdrHash ) . a ( ' , ' ) ; } }
apacheignite/ignite | private static void appendJvmId ( SB sb ) { if ( getBoolean ( IGNITE_MBEAN_APPEND_JVM_ID ) ) { String jvmId = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; sb . a ( " jvmId = " ) . a ( jvmId ) . a ( ' , ' ) ; } }
apacheignite/ignite | public static String maskName ( @ Nullable String cacheName ) { return cacheName == null ? " default " : cacheName ; }
apacheignite/ignite | public static ObjectName makeCacheMBeanName ( @ Nullable String gridName , @ Nullable String cacheName , String name ) throws MalformedObjectNameException { SB sb = new SB ( JMX_DOMAIN + ' : ' ) ; appendClassLoaderHash ( sb ) ; appendJvmId ( sb ) ; if ( gridName != null && ! gridName . isEmpty ( ) ) sb . a ( " grid = " ) . a ( gridName ) . a ( ' , ' ) ; cacheName = maskName ( cacheName ) ; sb . a ( " group = " ) . a ( cacheName ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
apacheignite/ignite | public static < T > ObjectName registerMBean ( MBeanServer mbeanSrv , @ Nullable String gridName , @ Nullable String grp , String name , T impl , @ Nullable Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , makeMBeanName ( gridName , grp , name ) ) . getObjectName ( ) ; }
apacheignite/ignite | public static < T > ObjectName registerMBean ( MBeanServer mbeanSrv , ObjectName name , T impl , Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , name ) . getObjectName ( ) ; }
apacheignite/ignite | public static < T > ObjectName registerCacheMBean ( MBeanServer mbeanSrv , @ Nullable String gridName , @ Nullable String cacheName , String name , T impl , Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , makeCacheMBeanName ( gridName , cacheName , name ) ) . getObjectName ( ) ; }
apacheignite/ignite | public static void interrupt ( @ Nullable Thread t ) { if ( t != null ) t . interrupt ( ) ; }
apacheignite/ignite | public static void interrupt ( Iterable < ? extends Thread > workers ) { if ( workers != null ) for ( Thread worker : workers ) worker . interrupt ( ) ; }
apacheignite/ignite | public static boolean join ( @ Nullable Thread t , @ Nullable IgniteLogger log ) { if ( t != null ) try { t . join ( ) ; return true ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ a ▁ thread : ▁ " + t ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
apacheignite/ignite | public static boolean joinThreads ( Iterable < ? extends Thread > workers , @ Nullable IgniteLogger log ) { boolean retval = true ; if ( workers != null ) for ( Thread worker : workers ) if ( ! join ( worker , log ) ) retval = false ; return retval ; }
apacheignite/ignite | public static void startThreads ( Iterable < ? extends Thread > threads ) { if ( threads != null ) { for ( Thread thread : threads ) { if ( thread != null ) thread . start ( ) ; } } }
apacheignite/ignite | public static void cancel ( @ Nullable GridWorker w ) { if ( w != null ) w . cancel ( ) ; }
apacheignite/ignite | public static void cancel ( Iterable < ? extends GridWorker > ws ) { if ( ws != null ) for ( GridWorker w : ws ) w . cancel ( ) ; }
apacheignite/ignite | public static boolean join ( @ Nullable GridWorker w , @ Nullable IgniteLogger log ) { if ( w != null ) try { w . join ( ) ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ runnable : ▁ " + w ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
apacheignite/ignite | public static boolean join ( Iterable < ? extends GridWorker > ws , IgniteLogger log ) { boolean retval = true ; if ( ws != null ) for ( GridWorker w : ws ) if ( ! join ( w , log ) ) retval = false ; return retval ; }
apacheignite/ignite | public static void shutdownNow ( Class < ? > owner , @ Nullable ExecutorService exec , @ Nullable IgniteLogger log ) { if ( exec != null ) { List < Runnable > tasks = exec . shutdownNow ( ) ; if ( ! F . isEmpty ( tasks ) ) U . warn ( log , " Runnable ▁ tasks ▁ outlived ▁ thread ▁ pool ▁ executor ▁ service ▁ [ owner = " + getSimpleName ( owner ) + " , ▁ tasks = " + tasks + ' ] ' ) ; try { exec . awaitTermination ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ignored ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ executor ▁ service ▁ to ▁ stop . " ) ; exec . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } }
apacheignite/ignite | public static ClusterGroupEmptyCheckedException emptyTopologyException ( ) { return new ClusterGroupEmptyCheckedException ( " Cluster ▁ group ▁ is ▁ empty . " ) ; }
apacheignite/ignite | public static void writeUuids ( DataOutput out , @ Nullable Collection < UUID > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( UUID id : col ) writeUuid ( out , id ) ; } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | @ Nullable public static List < UUID > readUuids ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < UUID > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( readUuid ( in ) ) ; return col ; }
apacheignite/ignite | public static void writeGridUuids ( DataOutput out , @ Nullable Collection < IgniteUuid > col ) throws IOException { if ( col != null ) { out . writeBoolean ( true ) ; out . writeInt ( col . size ( ) ) ; for ( IgniteUuid id : col ) writeGridUuid ( out , id ) ; } else out . writeBoolean ( false ) ; }
apacheignite/ignite | @ Nullable public static List < IgniteUuid > readGridUuids ( DataInput in ) throws IOException { List < IgniteUuid > col = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( readGridUuid ( in ) ) ; } return col ; }
apacheignite/ignite | public static void writeUuid ( DataOutput out , UUID uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . getMostSignificantBits ( ) ) ; out . writeLong ( uid . getLeastSignificantBits ( ) ) ; } }
apacheignite/ignite | @ Nullable public static UUID readUuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; return IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) ; } return null ; }
apacheignite/ignite | public static void writeGridUuid ( DataOutput out , IgniteUuid uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . globalId ( ) . getMostSignificantBits ( ) ) ; out . writeLong ( uid . globalId ( ) . getLeastSignificantBits ( ) ) ; out . writeLong ( uid . localId ( ) ) ; } }
apacheignite/ignite | @ Nullable public static IgniteUuid readGridUuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; UUID globalId = IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) ; long locId = in . readLong ( ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
apacheignite/ignite | public static byte [ ] igniteUuidToBytes ( IgniteUuid uuid ) { assert uuid != null ; byte [ ] out = new byte [ 24 ] ; igniteUuidToBytes ( uuid , out , 0 ) ; return out ; }
apacheignite/ignite | public static void igniteUuidToBytes ( IgniteUuid uuid , byte [ ] out , int off ) { assert uuid != null ; longToBytes ( uuid . globalId ( ) . getMostSignificantBits ( ) , out , off ) ; longToBytes ( uuid . globalId ( ) . getLeastSignificantBits ( ) , out , off + 8 ) ; longToBytes ( uuid . localId ( ) , out , off + 16 ) ; }
apacheignite/ignite | public static IgniteUuid bytesToIgniteUuid ( byte [ ] in , int off ) { long most = bytesToLong ( in , off ) ; long least = bytesToLong ( in , off + 8 ) ; long locId = bytesToLong ( in , off + 16 ) ; return new IgniteUuid ( IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) , locId ) ; }
apacheignite/ignite | public static void writeBooleanArray ( DataOutput out , @ Nullable boolean [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( boolean b : arr ) out . writeBoolean ( b ) ; } }
apacheignite/ignite | public static void writeIntArray ( DataOutput out , @ Nullable int [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( int b : arr ) out . writeInt ( b ) ; } }
apacheignite/ignite | @ Nullable public static boolean [ ] readBooleanArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; boolean [ ] res = new boolean [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readBoolean ( ) ; return res ; }
apacheignite/ignite | @ Nullable public static int [ ] readIntArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; int [ ] res = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readInt ( ) ; return res ; }
apacheignite/ignite | public static int hashCode ( ByteBuffer ... bufs ) { int res = 1 ; for ( ByteBuffer buf : bufs ) { int pos = buf . position ( ) ; while ( buf . hasRemaining ( ) ) res = 31 * res + buf . get ( ) ; buf . position ( pos ) ; } return res ; }
apacheignite/ignite | public static void writeMap ( ObjectOutput out , Map < ? , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < ? , ? > e : map . entrySet ( ) ) { out . writeObject ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static void writeStringMap ( DataOutput out , @ Nullable Map < String , String > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < String , String > e : map . entrySet ( ) ) { writeUTFStringNullable ( out , e . getKey ( ) ) ; writeUTFStringNullable ( out , e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static Map < String , String > readStringMap ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; else { Map < String , String > map = U . newHashMap ( size ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( readUTFStringNullable ( in ) , readUTFStringNullable ( in ) ) ; return map ; } }
apacheignite/ignite | public static void writeUTFStringNullable ( DataOutput out , @ Nullable String val ) throws IOException { if ( val != null ) { out . writeBoolean ( true ) ; out . writeUTF ( val ) ; } else out . writeBoolean ( false ) ; }
apacheignite/ignite | public static String readUTFStringNullable ( DataInput in ) throws IOException { return in . readBoolean ( ) ? in . readUTF ( ) : null ; }
apacheignite/ignite | public static void writeIntKeyMap ( ObjectOutput out , Map < Integer , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , ? > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
apacheignite/ignite | public static void writeIntKeyIntValueMap ( DataOutput out , Map < Integer , Integer > map ) throws IOException { if ( map != null ) { out . writeBoolean ( true ) ; out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeInt ( e . getValue ( ) ) ; } } else out . writeBoolean ( false ) ; }
apacheignite/ignite | ) @ Nullable public static Map < Integer , Integer > readIntKeyIntValueMap ( DataInput in ) throws IOException { Map < Integer , Integer > map = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; map = new HashMap < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( in . readInt ( ) , in . readInt ( ) ) ; } return map ; }
apacheignite/ignite | @ Nullable public static List < Integer > readIntList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
apacheignite/ignite | @ Nullable public static Set < Integer > readIntSet ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Set < Integer > set = new HashSet < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) set . add ( in . readInt ( ) ) ; return set ; }
apacheignite/ignite | public static void writeString ( DataOutput out , String s ) throws IOException { out . writeBoolean ( s == null ) ; if ( s != null ) out . writeUTF ( s ) ; }
apacheignite/ignite | @ Nullable public static String readString ( DataInput in ) throws IOException { return ! in . readBoolean ( ) ? in . readUTF ( ) : null ; }
apacheignite/ignite | public static < E extends Enum > void writeEnum ( DataOutput out , E e ) throws IOException { out . writeByte ( e == null ? - 1 : e . ordinal ( ) ) ; }
apacheignite/ignite | public static < T > T getByIndex ( Collection < T > vals , int idx ) { assert idx < vals . size ( ) ; int i = 0 ; for ( T val : vals ) { if ( idx == i ) return val ; i ++ ; } assert false : " Should ▁ never ▁ be ▁ reached . " ; return null ; }
apacheignite/ignite | @ Nullable public static < T extends Annotation > T getAnnotation ( Class < ? > cls , Class < T > annCls ) { if ( cls == Object . class ) return null ; T ann = cls . getAnnotation ( annCls ) ; if ( ann != null ) return ann ; for ( Class < ? > itf : cls . getInterfaces ( ) ) { ann = getAnnotation ( itf , annCls ) ; if ( ann != null ) return ann ; } if ( ! cls . isInterface ( ) ) { ann = getAnnotation ( cls . getSuperclass ( ) , annCls ) ; if ( ann != null ) return ann ; } return null ; }
apacheignite/ignite | public static < T extends Annotation > boolean hasAnnotation ( Class < ? > cls , Class < T > annCls ) { return getAnnotation ( cls , annCls ) != null ; }
apacheignite/ignite | public static < T extends Annotation > boolean hasAnnotation ( Object o , Class < T > annCls ) { return o != null && hasAnnotation ( o . getClass ( ) , annCls ) ; }
apacheignite/ignite | public static String getSimpleName ( Class < ? > cls ) { String name = cls . getSimpleName ( ) ; if ( F . isEmpty ( name ) ) name = cls . getName ( ) . substring ( cls . getPackage ( ) . getName ( ) . length ( ) + 1 ) ; return name ; }
apacheignite/ignite | ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return false ; } else return false ; return true ; }
apacheignite/ignite | public static String getTaskName ( Class < ? extends ComputeTask < ? , ? > > taskCls ) { ComputeTaskName nameAnn = getAnnotation ( taskCls , ComputeTaskName . class ) ; return nameAnn == null ? taskCls . getName ( ) : nameAnn . value ( ) ; }
apacheignite/ignite | public static String spiAttribute ( IgniteSpi spi , String attrName ) { assert spi != null ; assert spi . getName ( ) != null ; return spi . getName ( ) + ' . ' + attrName ; }
apacheignite/ignite | public static String classNameToResourceName ( String clsName ) { return clsName . replaceAll ( " \\ . " , " / " ) + " . class " ; }
apacheignite/ignite | public static RuntimeMXBean getRuntimeMx ( ) { return ManagementFactory . getRuntimeMXBean ( ) ; }
apacheignite/ignite | public static ThreadMXBean getThreadMx ( ) { return ManagementFactory . getThreadMXBean ( ) ; }
apacheignite/ignite | public static OperatingSystemMXBean getOsMx ( ) { return ManagementFactory . getOperatingSystemMXBean ( ) ; }
apacheignite/ignite | public static MemoryMXBean getMemoryMx ( ) { return ManagementFactory . getMemoryMXBean ( ) ; }
apacheignite/ignite | public static CompilationMXBean getCompilerMx ( ) { return ManagementFactory . getCompilationMXBean ( ) ; }
apacheignite/ignite | public static Class < ? > detectClass ( Object obj ) { assert obj != null ; if ( obj instanceof GridPeerDeployAware ) return ( ( GridPeerDeployAware ) obj ) . deployClass ( ) ; if ( U . isPrimitiveArray ( obj ) ) return obj . getClass ( ) ; if ( ! U . isJdk ( obj . getClass ( ) ) ) return obj . getClass ( ) ; if ( obj instanceof Iterable < ? > ) { Object o = F . first ( ( Iterable < ? > ) obj ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } if ( obj instanceof Map ) { Map . Entry < ? , ? > e = F . firstEntry ( ( Map < ? , ? > ) obj ) ; if ( e != null ) { Object k = e . getKey ( ) ; if ( k != null && ! U . isJdk ( k . getClass ( ) ) ) return k . getClass ( ) ; Object v = e . getValue ( ) ; return v != null ? v . getClass ( ) : obj . getClass ( ) ; } } if ( obj . getClass ( ) . isArray ( ) ) { int len = Array . getLength ( obj ) ; if ( len > 0 ) { Object o = Array . get ( obj , 0 ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } else return obj . getClass ( ) . getComponentType ( ) ; } return obj . getClass ( ) ; }
apacheignite/ignite | public static ClassLoader detectClassLoader ( Class < ? > cls ) { return GridClassLoaderCache . classLoader ( cls ) ; }
apacheignite/ignite | @ Nullable public static ClassLoader detectObjectClassLoader ( @ Nullable Object obj ) { if ( obj == null ) return null ; if ( obj instanceof GridPeerDeployAware ) return ( ( GridPeerDeployAware ) obj ) . classLoader ( ) ; return detectClassLoader ( obj . getClass ( ) ) ; }
apacheignite/ignite | public static boolean isLoadableBy ( String clsName , @ Nullable ClassLoader ldr ) { assert clsName != null ; if ( ldr == null ) ldr = gridClassLoader ; String lambdaParent = U . lambdaEnclosingClassName ( clsName ) ; try { ldr . loadClass ( lambdaParent == null ? clsName : lambdaParent ) ; return true ; } catch ( ClassNotFoundException ignore ) { return false ; } }
apacheignite/ignite | public static GridPeerDeployAware peerDeployAware0 ( @ Nullable Iterable < ? > c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; Collection < Object > tmpC = new ArrayList < > ( ) ; for ( Object e : c ) tmpC . add ( e ) ; tmpC . add ( c ) ; boolean notAllNulls = false ; for ( Object obj : tmpC ) { if ( obj != null ) { notAllNulls = true ; if ( hasCommonClassLoader ( obj , tmpC ) ) return obj == c ? peerDeployAware ( obj ) : peerDeployAware0 ( obj ) ; } } if ( notAllNulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peerDeployAware ( c ) ; }
apacheignite/ignite | private static boolean hasCommonClassLoader ( Object obj , Iterable < ? > c ) { assert obj != null ; assert c != null ; ClassLoader ldr = obj instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj ) . classLoader ( ) : detectClassLoader ( obj . getClass ( ) ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String clsName = obj2 instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj2 ) . deployClass ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! isLoadableBy ( clsName , ldr ) ) { found = false ; break ; } } return found ; }
apacheignite/ignite | ) public static GridPeerDeployAware peerDeployAware0 ( @ Nullable Object ... c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; boolean notAllNulls = false ; for ( Object obj : c ) { if ( obj != null ) { notAllNulls = true ; ClassLoader ldr = obj instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj ) . classLoader ( ) : obj . getClass ( ) . getClassLoader ( ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String clsName = obj2 instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj2 ) . deployClass ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! isLoadableBy ( clsName , ldr ) ) { found = false ; break ; } } if ( found ) return peerDeployAware0 ( obj ) ; } } if ( notAllNulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peerDeployAware ( new Object [ 0 ] ) ; }
apacheignite/ignite | public static GridPeerDeployAware peerDeployAware0 ( Object obj ) { if ( obj instanceof Iterable ) return peerDeployAware0 ( ( Iterable ) obj ) ; if ( obj . getClass ( ) . isArray ( ) && ! U . isPrimitiveArray ( obj ) ) return peerDeployAware0 ( ( Object [ ] ) obj ) ; return peerDeployAware ( obj ) ; }
apacheignite/ignite | public static GridPeerDeployAware peerDeployAware ( Object obj ) { assert obj != null ; if ( obj instanceof GridPeerDeployAware ) return ( GridPeerDeployAware ) obj ; final Class < ? > cls = obj instanceof Class ? ( Class ) obj : obj . getClass ( ) ; return new GridPeerDeployAware ( ) { private ClassLoader ldr ; @ Override public Class < ? > deployClass ( ) { return cls ; } @ Override public ClassLoader classLoader ( ) { if ( ldr == null ) ldr = detectClassLoader ( cls ) ; return ldr ; } } ; }
apacheignite/ignite | public static GridPeerDeployAware detectPeerDeployAware ( GridPeerDeployAware obj ) { GridPeerDeployAware p = nestedPeerDeployAware ( obj , true , new GridLeanIdentitySet < > ( ) ) ; return p != null ? p : peerDeployAware ( obj . getClass ( ) ) ; }
apacheignite/ignite | @ Nullable private static GridPeerDeployAware nestedPeerDeployAware ( Object obj , boolean top , Set < Object > processed ) { if ( ! processed . add ( obj ) ) return null ; if ( obj instanceof GridPeerDeployAware ) { GridPeerDeployAware p = ( GridPeerDeployAware ) obj ; if ( ! top && p . deployClass ( ) != null ) return p ; for ( Class < ? > cls = obj . getClass ( ) ; ! cls . equals ( Object . class ) ; cls = cls . getSuperclass ( ) ) { IgniteBiTuple < Class < ? > , Collection < Field > > tup = p2pFields . get ( cls . getName ( ) ) ; boolean cached = tup != null && tup . get1 ( ) . equals ( cls ) ; Iterable < Field > fields = cached ? tup . get2 ( ) : Arrays . asList ( cls . getDeclaredFields ( ) ) ; if ( ! cached ) { tup = F . t2 ( ) ; tup . set1 ( cls ) ; } for ( Field f : fields ) if ( cached || f . getName ( ) . startsWith ( " this $ " ) || f . getName ( ) . startsWith ( " val $ " ) ) { if ( ! cached ) { f . setAccessible ( true ) ; if ( tup . get2 ( ) == null ) tup . set2 ( new LinkedList < Field > ( ) ) ; tup . get2 ( ) . add ( f ) ; } try { Object o = f . get ( obj ) ; if ( o != null ) { p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) { if ( ! cached ) p2pFields . put ( cls . getName ( ) , tup ) ; return p ; } } } catch ( IllegalAccessException ignored ) { return null ; } } } } else if ( isIgnite ( obj . getClass ( ) ) ) return null ; else if ( obj instanceof Iterable ) for ( Object o : ( Iterable < ? > ) obj ) { GridPeerDeployAware p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) return p ; } else if ( obj . getClass ( ) . isArray ( ) ) { Class < ? > type = obj . getClass ( ) . getComponentType ( ) ; if ( ! type . isPrimitive ( ) && ! isJdk ( type ) ) { Object [ ] arr = ( Object [ ] ) obj ; for ( Object o : arr ) { GridPeerDeployAware p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) return p ; } } } return null ; }
apacheignite/ignite | public static boolean isIgnite ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite " ) ; }
apacheignite/ignite | public static boolean isGrid ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite . internal " ) ; }
apacheignite/ignite | public static String compact ( String s ) { return s . replace ( " org . apache . ignite . internal . visor . " , " o . a . i . i . v . " ) . replace ( " org . apache . ignite . internal . " , " o . a . i . i . " ) . replace ( " org . apache . ignite . scalar . " , " o . a . i . s . " ) . replace ( " org . apache . ignite . " , " o . a . i . " ) ; }
apacheignite/ignite | public static boolean isJdk ( Class < ? > cls ) { if ( cls . isPrimitive ( ) ) return true ; String s = cls . getName ( ) ; return s . startsWith ( " java . " ) || s . startsWith ( " javax . " ) ; }
apacheignite/ignite | ) public static void wait ( Object mux ) throws IgniteInterruptedCheckedException { try { mux . wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | ) public static void unzip ( File zipFile , File toDir , @ Nullable IgniteLogger log ) throws IOException { ZipFile zip = null ; try { zip = new ZipFile ( zipFile ) ; for ( ZipEntry entry : asIterable ( zip . entries ( ) ) ) { if ( entry . isDirectory ( ) ) { new File ( toDir , entry . getName ( ) ) . mkdirs ( ) ; continue ; } InputStream in = null ; OutputStream out = null ; try { in = zip . getInputStream ( entry ) ; File outFile = new File ( toDir , entry . getName ( ) ) ; if ( ! outFile . getParentFile ( ) . exists ( ) ) outFile . getParentFile ( ) . mkdirs ( ) ; out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; copy ( in , out ) ; } finally { close ( in , log ) ; close ( out , log ) ; } } } finally { if ( zip != null ) zip . close ( ) ; } }
apacheignite/ignite | public static String osJdkString ( ) { return osJdkStr ; }
apacheignite/ignite | public static String osString ( ) { return osStr ; }
apacheignite/ignite | public static String jdkString ( ) { return jdkStr ; }
apacheignite/ignite | public static boolean isLinux ( ) { return linux ; }
apacheignite/ignite | public static String jdkName ( ) { return jdkName ; }
apacheignite/ignite | public static String jdkVendor ( ) { return jdkVendor ; }
apacheignite/ignite | public static String jdkVersion ( ) { return jdkVer ; }
apacheignite/ignite | public static String osArchitecture ( ) { return osArch ; }
apacheignite/ignite | public static String osName ( ) { return osName ; }
apacheignite/ignite | public static String osVersion ( ) { return osVer ; }
apacheignite/ignite | public static boolean isMacOs ( ) { return mac ; }
apacheignite/ignite | public static boolean isNetWare ( ) { return netware ; }
apacheignite/ignite | public static boolean isSolaris ( ) { return solaris ; }
apacheignite/ignite | public static boolean isSolarisSparc ( ) { return solaris && sparc ; }
apacheignite/ignite | public static boolean isSolarisX86 ( ) { return solaris && x86 ; }
apacheignite/ignite | public static boolean isUnix ( ) { return unix ; }
apacheignite/ignite | public static boolean isWindows ( ) { return win7 || win8 || win81 || winXp || win95 || win98 || winNt || win2k || win2003 || win2008 || winVista || unknownWin ; }
apacheignite/ignite | public static boolean isWindowsVista ( ) { return winVista ; }
apacheignite/ignite | public static boolean isWindows7 ( ) { return win7 ; }
apacheignite/ignite | public static boolean isWindows8 ( ) { return win8 ; }
apacheignite/ignite | public static boolean isWindows81 ( ) { return win81 ; }
apacheignite/ignite | public static boolean isWindows2k ( ) { return win2k ; }
apacheignite/ignite | public static boolean isWindows2003 ( ) { return win2003 ; }
apacheignite/ignite | public static boolean isWindows2008 ( ) { return win2008 ; }
apacheignite/ignite | public static boolean isWindows95 ( ) { return win95 ; }
apacheignite/ignite | public static boolean isWindows98 ( ) { return win98 ; }
apacheignite/ignite | public static boolean isWindowsNt ( ) { return winNt ; }
apacheignite/ignite | public static boolean isSufficientlyTestedOs ( ) { return win7 || win8 || win81 || winXp || winVista || mac || linux || solaris ; }
apacheignite/ignite | public static boolean isWindowsXp ( ) { return winXp ; }
apacheignite/ignite | public static String jvmSpec ( ) { return jvmSpecName ; }
apacheignite/ignite | public static String jvmVersion ( ) { return jvmImplVer ; }
apacheignite/ignite | public static String jvmVendor ( ) { return jvmImplVendor ; }
apacheignite/ignite | public static String jvmName ( ) { return jvmImplName ; }
apacheignite/ignite | public static int compareVersionNumbers ( @ Nullable String v1 , @ Nullable String v2 ) { if ( v1 == null && v2 == null ) return 0 ; if ( v1 == null ) return - 1 ; if ( v2 == null ) return 1 ; String [ ] part1 = v1 . split ( " [ \\ . \\ _ \\ - ] " ) ; String [ ] part2 = v2 . split ( " [ \\ . \\ _ \\ - ] " ) ; int idx = 0 ; for ( ; idx < part1 . length && idx < part2 . length ; idx ++ ) { String p1 = part1 [ idx ] ; String p2 = part2 [ idx ] ; int cmp = ( p1 . matches ( " \\ d + " ) && p2 . matches ( " \\ d + " ) ) ? Integer . valueOf ( p1 ) . compareTo ( Integer . valueOf ( p2 ) ) : p1 . compareTo ( p2 ) ; if ( cmp != 0 ) return cmp ; } if ( part1 . length == part2 . length ) return 0 ; else return part1 . length > idx ? 1 : - 1 ; }
apacheignite/ignite | public static IgniteProductVersion productVersion ( ClusterNode node ) { String verStr = node . attribute ( ATTR_BUILD_VER ) ; String buildDate = node . attribute ( ATTR_BUILD_DATE ) ; if ( buildDate != null ) verStr += ' - ' + buildDate ; return IgniteProductVersion . fromString ( verStr ) ; }
apacheignite/ignite | public static boolean isJavaVersionAtLeast ( String v ) { return compareVersionNumbers ( javaRtVer , v ) >= 0 ; }
apacheignite/ignite | public static String jreName ( ) { return javaRtName ; }
apacheignite/ignite | public static String jreVersion ( ) { return javaRtVer ; }
apacheignite/ignite | public static boolean isHotSpot ( ) { return jvmImplName . contains ( " Java ▁ HotSpot ( TM ) " ) ; }
apacheignite/ignite | @ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , Callable < R > c ) throws IgniteCheckedException { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . call ( ) ; } catch ( IgniteCheckedException | RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
apacheignite/ignite | @ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , IgniteOutClosure < R > c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . apply ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
apacheignite/ignite | public static void wrapThreadLoader ( ClassLoader ldr , Runnable c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; c . run ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
apacheignite/ignite | public static String toShortString ( ClusterNode n ) { return " GridNode ▁ [ id = " + n . id ( ) + " , ▁ order = " + n . order ( ) + " , ▁ addr = " + n . addresses ( ) + " , ▁ daemon = " + n . isDaemon ( ) + ' ] ' ; }
apacheignite/ignite | public static String toShortString ( Collection < ? extends ClusterNode > ns ) { SB sb = new SB ( " Grid ▁ nodes ▁ [ cnt = " + ns . size ( ) ) ; for ( ClusterNode n : ns ) sb . a ( " , ▁ " ) . a ( toShortString ( n ) ) ; return sb . a ( ' ] ' ) . toString ( ) ; }
apacheignite/ignite | public static int [ ] toIntArray ( @ Nullable Collection < Integer > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_INTS ; int [ ] arr = new int [ c . size ( ) ] ; int idx = 0 ; for ( Integer i : c ) arr [ idx ++ ] = i ; return arr ; }
apacheignite/ignite | public static int [ ] addAll ( int [ ] arr1 , int [ ] arr2 ) { int [ ] all = new int [ arr1 . length + arr2 . length ] ; System . arraycopy ( arr1 , 0 , all , 0 , arr1 . length ) ; System . arraycopy ( arr2 , 0 , all , arr1 . length , arr2 . length ) ; return all ; }
apacheignite/ignite | public static List < Integer > toIntList ( @ Nullable int [ ] arr , IgnitePredicate < Integer > ... p ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Integer > ret = new ArrayList < > ( arr . length ) ; if ( F . isEmpty ( p ) ) for ( int i : arr ) ret . add ( i ) ; else { for ( int i : arr ) if ( F . isAll ( i , p ) ) ret . add ( i ) ; } return ret ; }
apacheignite/ignite | public static long [ ] toLongArray ( @ Nullable Collection < Long > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_LONGS ; long [ ] arr = new long [ c . size ( ) ] ; int idx = 0 ; for ( Long l : c ) arr [ idx ++ ] = l ; return arr ; }
apacheignite/ignite | public static List < Long > toLongList ( @ Nullable long [ ] arr ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Long > ret = new ArrayList < > ( arr . length ) ; for ( long l : arr ) ret . add ( l ) ; return ret ; }
apacheignite/ignite | ) public static < T > T [ ] toArray ( Collection < ? extends T > c , T [ ] arr ) { T [ ] a = c . toArray ( arr ) ; assert a == arr ; return arr ; }
apacheignite/ignite | public static int [ ] unique ( int [ ] a , int aLen , int [ ] b , int bLen ) { assert a != null ; assert b != null ; assert isIncreasingArray ( a , aLen ) ; assert isIncreasingArray ( b , bLen ) ; int [ ] res = new int [ aLen + bLen ] ; int resLen = 0 ; int i = 0 ; int j = 0 ; while ( i < aLen && j < bLen ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ resLen ++ ] = a [ i ++ ] ; else res [ resLen ++ ] = b [ j ++ ] ; } while ( i < aLen ) res [ resLen ++ ] = a [ i ++ ] ; while ( j < bLen ) res [ resLen ++ ] = b [ j ++ ] ; return copyIfExceeded ( res , resLen ) ; }
apacheignite/ignite | public static int [ ] difference ( int [ ] a , int aLen , int [ ] b , int bLen ) { assert a != null ; assert b != null ; assert isIncreasingArray ( a , aLen ) ; assert isIncreasingArray ( b , bLen ) ; int [ ] res = new int [ aLen ] ; int resLen = 0 ; int i = 0 ; int j = 0 ; while ( i < aLen && j < bLen ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ resLen ++ ] = a [ i ++ ] ; else j ++ ; } while ( i < aLen ) res [ resLen ++ ] = a [ i ++ ] ; return copyIfExceeded ( res , resLen ) ; }
apacheignite/ignite | public static boolean isIncreasingArray ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) return false ; } return true ; }
apacheignite/ignite | public static boolean isNonDecreasingArray ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) return false ; } return true ; }
apacheignite/ignite | public static int [ ] copyIfExceeded ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; return len == arr . length ? arr : Arrays . copyOf ( arr , len ) ; }
apacheignite/ignite | private static boolean checkNextToken ( StringTokenizer t , String str , String date ) throws IgniteCheckedException { try { if ( t . nextToken ( ) . equals ( str ) ) return true ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + date ) ; } catch ( NoSuchElementException ignored ) { return false ; } }
apacheignite/ignite | public static Calendar parseIsoDate ( String str ) throws IgniteCheckedException { StringTokenizer t = new StringTokenizer ( str , " + - : . TZ " , true ) ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; try { if ( t . hasMoreTokens ( ) ) cal . set ( Calendar . YEAR , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( checkNextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MONTH , Integer . parseInt ( t . nextToken ( ) ) - 1 ) ; else return cal ; if ( checkNextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . DAY_OF_MONTH , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( checkNextToken ( t , " T " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . HOUR_OF_DAY , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return cal ; } if ( checkNextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MINUTE , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return cal ; } if ( ! t . hasMoreTokens ( ) ) return cal ; String tok = t . nextToken ( ) ; if ( " : " . equals ( tok ) ) { if ( t . hasMoreTokens ( ) ) { cal . set ( Calendar . SECOND , Integer . parseInt ( t . nextToken ( ) ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; if ( " . " . equals ( tok ) ) { String nt = t . nextToken ( ) ; while ( nt . length ( ) < 3 ) nt += "0" ; nt = nt . substring ( 0 , 3 ) ; cal . set ( Calendar . MILLISECOND , Integer . parseInt ( nt ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; } else cal . set ( Calendar . MILLISECOND , 0 ) ; } else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } else { cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; } if ( ! " Z " . equals ( tok ) ) { if ( ! " + " . equals ( tok ) && ! " - " . equals ( tok ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; boolean plus = " + " . equals ( tok ) ; if ( ! t . hasMoreTokens ( ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; tok = t . nextToken ( ) ; int tzHour ; int tzMin ; if ( tok . length ( ) == 4 ) { tzHour = Integer . parseInt ( tok . substring ( 0 , 2 ) ) ; tzMin = Integer . parseInt ( tok . substring ( 2 , 4 ) ) ; } else { tzHour = Integer . parseInt ( tok ) ; if ( checkNextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) tzMin = Integer . parseInt ( t . nextToken ( ) ) ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } if ( plus ) cal . set ( Calendar . ZONE_OFFSET , ( tzHour * 60 + tzMin ) * 60 * 1000 ) ; else cal . set ( Calendar . ZONE_OFFSET , - ( tzHour * 60 + tzMin ) * 60 * 1000 ) ; } else cal . setTimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; } catch ( NumberFormatException ex ) { throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str , ex ) ; } return cal ; }
apacheignite/ignite | public static < V , C extends Collection < ? super V > > C addAll ( C c , V ... vals ) { Collections . addAll ( c , vals ) ; return c ; }
apacheignite/ignite | public static < K , V , M extends Map < K , V > > M addAll ( M m , Map . Entry < K , V > ... entries ) { for ( Map . Entry < K , V > e : entries ) m . put ( e . getKey ( ) , e . getValue ( ) ) ; return m ; }
apacheignite/ignite | public static < K , V , M extends Map < K , V > > M addAll ( M m , IgniteBiTuple < K , V > ... entries ) { for ( IgniteBiTuple < K , V > t : entries ) m . put ( t . get1 ( ) , t . get2 ( ) ) ; return m ; }
apacheignite/ignite | public static JMException jmException ( Throwable e ) { JMException x = new JMException ( ) ; x . initCause ( e ) ; return x ; }
apacheignite/ignite | public static Exception unwrap ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof GridClosureException ) { t = ( ( GridClosureException ) t ) . unwrap ( ) ; continue ; } return ( Exception ) t ; } }
apacheignite/ignite | public static IgniteCheckedException cast ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof GridClosureException ) { t = ( ( GridClosureException ) t ) . unwrap ( ) ; continue ; } if ( t instanceof IgniteCheckedException ) return ( IgniteCheckedException ) t ; if ( ! ( t instanceof IgniteException ) || t . getCause ( ) == null ) return new IgniteCheckedException ( t ) ; assert t . getCause ( ) != null ; t = t . getCause ( ) ; } }
apacheignite/ignite | public static boolean p2pLoader ( Object o ) { return o != null && p2pLoader ( o . getClass ( ) . getClassLoader ( ) ) ; }
apacheignite/ignite | public static boolean p2pLoader ( ClassLoader ldr ) { return ldr instanceof GridDeploymentInfo ; }
apacheignite/ignite | public static String format ( Date date , String ptrn ) { java . text . DateFormat format = new java . text . SimpleDateFormat ( ptrn ) ; return format . format ( date ) ; }
apacheignite/ignite | public static IgniteClosure < UUID , ClusterNode > id2Node ( final GridKernalContext ctx ) { assert ctx != null ; return new C1 < UUID , ClusterNode > ( ) { @ Nullable @ Override public ClusterNode apply ( UUID id ) { return ctx . discovery ( ) . node ( id ) ; } } ; }
apacheignite/ignite | @ Deprecated public static void dumpStack ( Thread t ) { dumpStack ( t , System . err ) ; }
apacheignite/ignite | ) @ Deprecated public static void dumpStack ( Thread t , PrintStream s ) { synchronized ( s ) { s . println ( " Dumping ▁ stack ▁ trace ▁ for ▁ thread : ▁ " + t ) ; for ( StackTraceElement trace : t . getStackTrace ( ) ) s . println ( " \tat ▁ " + trace ) ; } }
apacheignite/ignite | public static boolean isPrimitiveArray ( Object obj ) { Class < ? > cls = obj . getClass ( ) ; return cls . isArray ( ) && cls . getComponentType ( ) . isPrimitive ( ) ; }
apacheignite/ignite | public static boolean isPrimitiveOrWrapper ( Class < ? > cls ) { return cls . isPrimitive ( ) || Boolean . class . equals ( cls ) || Byte . class . equals ( cls ) || Character . class . equals ( cls ) || Short . class . equals ( cls ) || Integer . class . equals ( cls ) || Long . class . equals ( cls ) || Float . class . equals ( cls ) || Double . class . equals ( cls ) || Void . class . equals ( cls ) ; }
apacheignite/ignite | public static void await ( Condition cond ) throws IgniteInterruptedCheckedException { try { cond . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static boolean await ( Condition cond , long time , TimeUnit unit ) throws IgniteInterruptedCheckedException { try { return cond . await ( time , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void await ( CountDownLatch latch ) throws IgniteInterruptedCheckedException { try { if ( latch . getCount ( ) > 0 ) latch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static boolean await ( CountDownLatch latch , long timeout , TimeUnit unit ) throws IgniteInterruptedCheckedException { try { return latch . await ( timeout , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void awaitQuiet ( CountDownLatch latch ) { boolean interrupted = false ; while ( true ) { try { latch . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
apacheignite/ignite | public static void awaitQuiet ( CyclicBarrier barrier ) { boolean interrupted = false ; while ( true ) { try { barrier . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } catch ( BrokenBarrierException ignored ) { break ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
apacheignite/ignite | public static void sleep ( long ms ) throws IgniteInterruptedCheckedException { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void join ( GridWorker w ) throws IgniteInterruptedCheckedException { try { if ( w != null ) w . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static < T > T get ( Future < T > fut ) throws IgniteCheckedException { try { return fut . get ( ) ; } catch ( ExecutionException e ) { throw new IgniteCheckedException ( e . getCause ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } catch ( CancellationException e ) { throw new IgniteCheckedException ( e ) ; } }
apacheignite/ignite | public static void join ( Thread t ) throws IgniteInterruptedCheckedException { try { t . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static void acquire ( Semaphore sem ) throws IgniteInterruptedCheckedException { try { sem . acquire ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static GridCacheAttributes [ ] cacheAttributes ( ClusterNode n ) { return n . attribute ( ATTR_CACHE ) ; }
apacheignite/ignite | public static boolean hasNearCache ( ClusterNode n , String cacheName ) { GridCacheAttributes [ ] caches = n . attribute ( ATTR_CACHE ) ; if ( caches != null ) for ( GridCacheAttributes attrs : caches ) if ( F . eq ( cacheName , attrs . cacheName ( ) ) ) return attrs . nearCacheEnabled ( ) ; return false ; }
apacheignite/ignite | public static void asyncLogError ( IgniteInternalFuture < ? > f , final IgniteLogger log ) { if ( f != null ) f . listen ( new CI1 < IgniteInternalFuture < ? > > ( ) { @ Override public void apply ( IgniteInternalFuture < ? > f ) { try { f . get ( ) ; } catch ( IgniteCheckedException e ) { U . error ( log , " Failed ▁ to ▁ execute ▁ future : ▁ " + f , e ) ; } } } ) ; }
apacheignite/ignite | public static Collection < UUID > nodeIds ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . viewReadOnly ( nodes , F . node2id ( ) ) ; }
apacheignite/ignite | public static Collection < UUID > gridIds ( @ Nullable Collection < ? extends Ignite > grids ) { return F . viewReadOnly ( grids , new C1 < Ignite , UUID > ( ) { @ Override public UUID apply ( Ignite g ) { return g . cluster ( ) . localNode ( ) . id ( ) ; } } ) ; }
apacheignite/ignite | public static Collection < String > grids2names ( @ Nullable Collection < ? extends Ignite > grids ) { return F . viewReadOnly ( grids , new C1 < Ignite , String > ( ) { @ Override public String apply ( Ignite g ) { return g . name ( ) ; } } ) ; }
apacheignite/ignite | public static Collection < String > nodes2names ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . viewReadOnly ( nodes , new C1 < ClusterNode , String > ( ) { @ Override public String apply ( ClusterNode n ) { return G . ignite ( n . id ( ) ) . name ( ) ; } } ) ; }
apacheignite/ignite | public static boolean addLastCause ( @ Nullable Throwable e , @ Nullable Throwable cause , IgniteLogger log ) { if ( e == null || cause == null ) return false ; for ( Throwable t = e ; t != null ; t = t . getCause ( ) ) { if ( t == cause ) return false ; if ( t . getCause ( ) == null || t . getCause ( ) == t ) { try { t . initCause ( cause ) ; } catch ( IllegalStateException ignored ) { error ( log , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain ▁ ( cause ▁ is ▁ printed ▁ here ▁ but ▁ will ▁ " + " not ▁ be ▁ propagated ▁ to ▁ callee ) : ▁ " + e , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain : ▁ " + e , cause ) ; } return true ; } } return false ; }
apacheignite/ignite | public static String nl ( ) { return NL ; }
apacheignite/ignite | public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Object obj ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( obj . getClass ( ) ) ) ; log = logRef . get ( ) ; } return log ; }
apacheignite/ignite | public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Class < ? > cls ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( cls ) ) ; log = logRef . get ( ) ; } return log ; }
apacheignite/ignite | public static int concurrentMapSegment ( int hash , int concurLvl ) { hash += ( hash << 15 ) ^ 0xffffcd7d ; hash ^= ( hash >>> 10 ) ; hash += ( hash << 3 ) ; hash ^= ( hash >>> 6 ) ; hash += ( hash << 2 ) + ( hash << 14 ) ; int shift = 0 ; int size = 1 ; while ( size < concurLvl ) { ++ shift ; size <<= 1 ; } int segmentShift = 32 - shift ; int segmentMask = size - 1 ; return ( hash >>> segmentShift ) & segmentMask ; }
apacheignite/ignite | public static < K , V > void printConcurrentHashMapInfo ( ConcurrentHashMap < K , V > map ) { assert map != null ; Object [ ] segs = field ( map , " segments " ) ; X . println ( " Concurrent ▁ map ▁ stats ▁ [ identityHash = ▁ " + System . identityHashCode ( map ) + " , ▁ segsCnt = " + segs . length + ' ] ' ) ; int emptySegsCnt = 0 ; int totalCollisions = 0 ; for ( int i = 0 ; i < segs . length ; i ++ ) { int segCnt = IgniteUtils . < Integer > field ( segs [ i ] , " count " ) ; if ( segCnt == 0 ) { emptySegsCnt ++ ; continue ; } Object [ ] tab = field ( segs [ i ] , " table " ) ; int tabLen = tab . length ; X . println ( " ▁ ▁ ▁ ▁ Segment - " + i + " ▁ [ count = " + segCnt + " , ▁ len = " + tabLen + ' ] ' ) ; Map < Integer , Integer > bucketsStats = new TreeMap < > ( ) ; for ( Object entry : tab ) { int cnt = 0 ; while ( entry != null ) { cnt ++ ; entry = field ( entry , " next " ) ; } Integer bucketCnt = bucketsStats . get ( cnt ) ; if ( bucketCnt == null ) bucketCnt = 0 ; bucketCnt ++ ; bucketsStats . put ( cnt , bucketCnt ) ; if ( cnt > 1 ) totalCollisions += ( cnt - 1 ) ; } for ( Map . Entry < Integer , Integer > e : bucketsStats . entrySet ( ) ) X . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Buckets ▁ with ▁ count ▁ " + e . getKey ( ) + " : ▁ " + e . getValue ( ) ) ; } X . println ( " ▁ ▁ ▁ ▁ Map ▁ summary ▁ [ emptySegs = " + emptySegsCnt + " , ▁ collisions = " + totalCollisions + ' ] ' ) ; }
apacheignite/ignite | public static < T > T field ( Object obj , String fieldName ) { assert obj != null ; assert fieldName != null ; try { for ( Class cls = obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { for ( Field field : cls . getDeclaredFields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; T val = ( T ) field . get ( obj ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } } } catch ( Exception e ) { throw new IgniteException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' , e ) ; } throw new IgniteException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' ) ; }
apacheignite/ignite | public static < T > T field ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Class c = cls ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { for ( Field field : c . getDeclaredFields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ class ▁ field ▁ ( field ▁ is ▁ not ▁ static ) ▁ [ cls = " + cls + " , ▁ fieldName = " + fieldName + ' ] ' ) ; boolean accessible = field . isAccessible ( ) ; T val ; try { field . setAccessible ( true ) ; val = ( T ) field . get ( null ) ; } finally { if ( ! accessible ) field . setAccessible ( false ) ; } return val ; } } } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ ( field ▁ was ▁ not ▁ found ) ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mtdName , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mtdName != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { Method mtd = null ; for ( Method declaredMtd : c . getDeclaredMethods ( ) ) { if ( declaredMtd . getName ( ) . equals ( mtdName ) ) { if ( mtd == null ) mtd = declaredMtd ; else throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( ambigous ▁ method ▁ name ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; } } if ( mtd == null ) continue ; boolean accessible = mtd . isAccessible ( ) ; T res ; try { mtd . setAccessible ( true ) ; res = ( T ) mtd . invoke ( obj , params ) ; } finally { if ( ! accessible ) mtd . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mtdName , Class [ ] paramTypes , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mtdName != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { Method mtd ; try { mtd = c . getDeclaredMethod ( mtdName , paramTypes ) ; } catch ( NoSuchMethodException ignored ) { continue ; } boolean accessible = mtd . isAccessible ( ) ; T res ; try { mtd . setAccessible ( true ) ; res = ( T ) mtd . invoke ( obj , params ) ; } finally { if ( ! accessible ) mtd . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | public static < T > T property ( Object obj , String propName ) { assert obj != null ; assert propName != null ; try { Method m ; try { m = obj . getClass ( ) . getMethod ( " get " + capitalFirst ( propName ) ) ; } catch ( NoSuchMethodException ignored ) { m = obj . getClass ( ) . getMethod ( " is " + capitalFirst ( propName ) ) ; } assert F . isEmpty ( m . getParameterTypes ( ) ) ; boolean accessible = m . isAccessible ( ) ; try { m . setAccessible ( true ) ; return ( T ) m . invoke ( obj ) ; } finally { m . setAccessible ( accessible ) ; } } catch ( Exception e ) { throw new IgniteException ( " Failed ▁ to ▁ get ▁ property ▁ value ▁ [ property = " + propName + " , ▁ obj = " + obj + ' ] ' , e ) ; } }
apacheignite/ignite | public static < T > T staticField ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Field field : cls . getDeclaredFields ( ) ) if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . isAccessible ( ) ; if ( ! accessible ) field . setAccessible ( true ) ; T val = ( T ) field . get ( null ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
apacheignite/ignite | private static String capitalFirst ( @ Nullable String str ) { return str == null ? null : str . isEmpty ( ) ? " " : Character . toUpperCase ( str . charAt ( 0 ) ) + str . substring ( 1 ) ; }
apacheignite/ignite | public static boolean isVisorNodeStartProperty ( String name ) { return IGNITE_SSH_HOST . equals ( name ) || IGNITE_SSH_USER_NAME . equals ( name ) ; }
apacheignite/ignite | public static boolean isVisorRequiredProperty ( String name ) { return " java . version " . equals ( name ) || " java . vm . name " . equals ( name ) || " os . arch " . equals ( name ) || " os . name " . equals ( name ) || " os . version " . equals ( name ) ; }
apacheignite/ignite | public static IgniteBiTuple < Object , Object > addLog4jNoOpLogger ( ) throws IgniteCheckedException { Object rootLog ; Object nullApp ; try { Class < ? > logCls = Class . forName ( " org . apache . log4j . Logger " ) ; rootLog = logCls . getMethod ( " getRootLogger " ) . invoke ( logCls ) ; try { nullApp = Class . forName ( " org . apache . log4j . varia . NullAppender " ) . newInstance ( ) ; } catch ( ClassNotFoundException ignore ) { return new IgniteBiTuple < > ( rootLog , null ) ; } Class appCls = Class . forName ( " org . apache . log4j . Appender " ) ; rootLog . getClass ( ) . getMethod ( " addAppender " , appCls ) . invoke ( rootLog , nullApp ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ add ▁ no - op ▁ logger ▁ for ▁ Log4j . " , e ) ; } return new IgniteBiTuple < > ( rootLog , nullApp ) ; }
apacheignite/ignite | public static void removeLog4jNoOpLogger ( IgniteBiTuple < Object , Object > t ) throws IgniteCheckedException { Object rootLog = t . get1 ( ) ; Object nullApp = t . get2 ( ) ; if ( nullApp == null ) return ; try { Class appenderCls = Class . forName ( " org . apache . log4j . Appender " ) ; rootLog . getClass ( ) . getMethod ( " removeAppender " , appenderCls ) . invoke ( rootLog , nullApp ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ remove ▁ previously ▁ added ▁ no - op ▁ logger ▁ for ▁ Log4j . " , e ) ; } }
apacheignite/ignite | public static Collection < Handler > addJavaNoOpLogger ( ) { Collection < Handler > savedHnds = new ArrayList < > ( ) ; Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . getHandlers ( ) ) { log . removeHandler ( h ) ; savedHnds . add ( h ) ; } ConsoleHandler hnd = new ConsoleHandler ( ) ; hnd . setLevel ( Level . OFF ) ; log . addHandler ( hnd ) ; return savedHnds ; }
apacheignite/ignite | public static void removeJavaNoOpLogger ( Collection < Handler > rmvHnds ) { Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . getHandlers ( ) ) log . removeHandler ( h ) ; if ( ! F . isEmpty ( rmvHnds ) ) { for ( Handler h : rmvHnds ) log . addHandler ( h ) ; } }
apacheignite/ignite | public static String nodeIdLogFileName ( UUID nodeId , String fileName ) { assert nodeId != null ; assert fileName != null ; fileName = GridFilenameUtils . separatorsToSystem ( fileName ) ; int dot = fileName . lastIndexOf ( ' . ' ) ; if ( dot < 0 || dot == fileName . length ( ) - 1 ) return fileName + ' - ' + U . id8 ( nodeId ) ; else return fileName . substring ( 0 , dot ) + ' - ' + U . id8 ( nodeId ) + fileName . substring ( dot ) ; }
apacheignite/ignite | public static String customDirectoryLogFileName ( @ Nullable String dir , String fileName ) { assert fileName != null ; if ( dir == null ) return fileName ; int sep = fileName . lastIndexOf ( File . separator ) ; return dir + ( sep < 0 ? File . separator + fileName : fileName . substring ( sep ) ) ; }
apacheignite/ignite | public static String fl ( String msg , Object ... args ) { assert args . length % 2 == 0 ; StringBuilder sb = new StringBuilder ( msg ) ; if ( args . length > 0 ) { sb . append ( " ▁ [ " ) ; for ( int i = 0 ; i < args . length / 2 ; i ++ ) { sb . append ( args [ i * 2 ] ) . append ( ' = ' ) . append ( args [ i * 2 + 1 ] ) ; sb . append ( " , ▁ " ) ; } sb . delete ( sb . length ( ) - 2 , sb . length ( ) ) ; sb . append ( ' ] ' ) ; } return sb . toString ( ) ; }
apacheignite/ignite | public static int safeAbs ( int i ) { i = Math . abs ( i ) ; return i < 0 ? 0 : i ; }
apacheignite/ignite | @ Nullable public static Class < ? > box ( @ Nullable Class < ? > cls ) { if ( cls == null ) return null ; if ( ! cls . isPrimitive ( ) ) return cls ; return boxedClsMap . get ( cls ) ; }
apacheignite/ignite | public static Class < ? > forName ( String clsName , @ Nullable ClassLoader ldr ) throws ClassNotFoundException { assert clsName != null ; Class < ? > cls = primitiveMap . get ( clsName ) ; if ( cls != null ) return cls ; if ( ldr == null ) ldr = gridClassLoader ; ConcurrentMap < String , Class > ldrMap = classCache . get ( ldr ) ; if ( ldrMap == null ) { ConcurrentMap < String , Class > old = classCache . putIfAbsent ( ldr , ldrMap = new ConcurrentHashMap8 < > ( ) ) ; if ( old != null ) ldrMap = old ; } cls = ldrMap . get ( clsName ) ; if ( cls == null ) { Class old = ldrMap . putIfAbsent ( clsName , cls = Class . forName ( clsName , true , ldr ) ) ; if ( old != null ) cls = old ; } return cls ; }
apacheignite/ignite | public static void clearClassCache ( ClassLoader ldr ) { classCache . remove ( ldr ) ; }
apacheignite/ignite | public static void clearClassCache ( ) { classCache . clear ( ) ; }
apacheignite/ignite | public static int hash ( int h ) { h ^= h >>> 16 ; h *= 0x85ebca6b ; h ^= h >>> 13 ; h *= 0xc2b2ae35 ; return ( h >>> 16 ) ^ h ; }
apacheignite/ignite | public static int hash ( Object key ) { return hash ( key . hashCode ( ) ) ; }
apacheignite/ignite | public static int jvmPid ( ) { String name = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; try { int idx = name . indexOf ( ' @ ' ) ; return idx > 0 ? Integer . parseInt ( name . substring ( 0 , idx ) ) : - 1 ; } catch ( NumberFormatException ignored ) { return - 1 ; } }
apacheignite/ignite | public static List < String > jvmArgs ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; }
apacheignite/ignite | private static boolean unsafeByteArrayCopyAvailable ( ) { try { Class < ? extends Unsafe > unsafeCls = UNSAFE . getClass ( ) ; unsafeCls . getMethod ( " copyMemory " , Object . class , long . class , Object . class , long . class , long . class ) ; return true ; } catch ( Exception ignored ) { return false ; } }
apacheignite/ignite | public static int arrayCopy ( byte [ ] src , int off , byte [ ] resBuf , int resOff , int len ) { assert resBuf . length >= resOff + len ; if ( UNSAFE_BYTE_ARR_CP ) UNSAFE . copyMemory ( src , BYTE_ARRAY_DATA_OFFSET + off , resBuf , BYTE_ARRAY_DATA_OFFSET + resOff , len ) ; else System . arraycopy ( src , off , resBuf , resOff , len ) ; return resOff + len ; }
apacheignite/ignite | public static String consistentId ( Collection < String > addrs , int port ) { assert ! F . isEmpty ( addrs ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String addr : addrs ) sb . append ( addr ) . append ( ' , ' ) ; sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; sb . append ( ' : ' ) . append ( port ) ; return sb . toString ( ) ; }
apacheignite/ignite | public static boolean overridesEqualsAndHashCode ( Object obj ) { try { Class < ? > cls = obj . getClass ( ) ; return ! Object . class . equals ( cls . getMethod ( " equals " , Object . class ) . getDeclaringClass ( ) ) && ! Object . class . equals ( cls . getMethod ( " hashCode " ) . getDeclaringClass ( ) ) ; } catch ( NoSuchMethodException | SecurityException ignore ) { return true ; } }
apacheignite/ignite | public static boolean isMacInvalidArgumentError ( Exception e ) { return U . isMacOs ( ) && e instanceof SocketException && e . getMessage ( ) != null && e . getMessage ( ) . toLowerCase ( ) . contains ( " invalid ▁ argument " ) ; }
apacheignite/ignite | @ Nullable public static < T > T firstNotNull ( @ Nullable T ... vals ) { if ( vals == null ) return null ; for ( T val : vals ) { if ( val != null ) return val ; } return null ; }
apacheignite/ignite | public static void startLifecycleAware ( Iterable < ? > objs ) throws IgniteCheckedException { try { for ( Object obj : objs ) { if ( obj instanceof LifecycleAware ) ( ( LifecycleAware ) obj ) . start ( ) ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ start ▁ component : ▁ " + e , e ) ; } }
apacheignite/ignite | public static void stopLifecycleAware ( IgniteLogger log , Iterable < ? > objs ) { for ( Object obj : objs ) { if ( obj instanceof LifecycleAware ) { try { ( ( LifecycleAware ) obj ) . stop ( ) ; } catch ( Exception e ) { U . error ( log , " Failed ▁ to ▁ stop ▁ component ▁ ( ignoring ) : ▁ " + obj , e ) ; } } } }
apacheignite/ignite | public static Map < String , Collection < ClusterNode > > neighborhood ( Iterable < ClusterNode > nodes ) { Map < String , Collection < ClusterNode > > map = new HashMap < > ( ) ; for ( ClusterNode n : nodes ) { String macs = n . attribute ( ATTR_MACS ) ; assert macs != null : " Missing ▁ MACs ▁ attribute : ▁ " + n ; Collection < ClusterNode > neighbors = map . get ( macs ) ; if ( neighbors == null ) map . put ( macs , neighbors = new ArrayList < > ( 2 ) ) ; neighbors . add ( n ) ; } return map ; }
apacheignite/ignite | public static Collection < InetAddress > toInetAddresses ( ClusterNode node ) throws IgniteCheckedException { return toInetAddresses ( node . addresses ( ) , node . hostNames ( ) ) ; }
apacheignite/ignite | public static Collection < InetAddress > toInetAddresses ( Collection < String > addrs , Collection < String > hostNames ) throws IgniteCheckedException { List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; InetAddress inetAddr = null ; if ( ! F . isEmpty ( hostName ) ) { try { inetAddr = InetAddress . getByName ( hostName ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr == null || inetAddr . isLoopbackAddress ( ) ) { try { inetAddr = InetAddress . getByName ( addr ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr != null ) res . add ( inetAddr ) ; } if ( res . isEmpty ( ) ) throw new IgniteCheckedException ( " Addresses ▁ can ▁ not ▁ be ▁ resolved ▁ [ addr = " + addrs + " , ▁ hostNames = " + hostNames + ' ] ' ) ; return F . viewListReadOnly ( res , F . < InetAddress > identity ( ) ) ; }
apacheignite/ignite | public static Collection < InetSocketAddress > toSocketAddresses ( ClusterNode node , int port ) { return toSocketAddresses ( node . addresses ( ) , node . hostNames ( ) , port ) ; }
apacheignite/ignite | public static Collection < InetSocketAddress > toSocketAddresses ( Collection < String > addrs , Collection < String > hostNames , int port ) { List < InetSocketAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; if ( ! F . isEmpty ( hostName ) ) { InetSocketAddress inetSockAddr = new InetSocketAddress ( hostName , port ) ; if ( inetSockAddr . isUnresolved ( ) || inetSockAddr . getAddress ( ) . isLoopbackAddress ( ) ) inetSockAddr = new InetSocketAddress ( addr , port ) ; res . add ( inetSockAddr ) ; } res . add ( new InetSocketAddress ( addr , port ) ) ; } return F . viewListReadOnly ( res , F . < InetSocketAddress > identity ( ) ) ; }
apacheignite/ignite | public static Collection < InetSocketAddress > resolveAddresses ( AddressResolver addrRslvr , Iterable < String > addrs , int port ) throws IgniteSpiException { assert addrRslvr != null ; Collection < InetSocketAddress > extAddrs = new HashSet < > ( ) ; for ( String addr : addrs ) { InetSocketAddress sockAddr = new InetSocketAddress ( addr , port ) ; if ( ! sockAddr . isUnresolved ( ) ) { try { Collection < InetSocketAddress > extAddrs0 = addrRslvr . getExternalAddresses ( sockAddr ) ; if ( extAddrs0 != null ) extAddrs . addAll ( extAddrs0 ) ; } catch ( IgniteCheckedException e ) { throw new IgniteSpiException ( " Failed ▁ to ▁ get ▁ mapped ▁ external ▁ addresses ▁ " + " [ addrRslvr = " + addrRslvr + " , ▁ addr = " + addr + ' ] ' , e ) ; } } } return extAddrs ; }
apacheignite/ignite | public static String addressesAsString ( ClusterNode node ) { return addressesAsString ( node . addresses ( ) , node . hostNames ( ) ) ; }
apacheignite/ignite | public static String addressesAsString ( Collection < String > addrs , Collection < String > hostNames ) { if ( F . isEmpty ( addrs ) ) return " " ; if ( F . isEmpty ( hostNames ) ) return addrs . toString ( ) ; SB sb = new SB ( " [ " ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; boolean first = true ; for ( String addr : addrs ) { if ( first ) first = false ; else sb . a ( " , ▁ " ) ; String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; sb . a ( hostName != null ? hostName : " " ) . a ( ' / ' ) . a ( addr ) ; } sb . a ( ' ] ' ) ; return sb . toString ( ) ; }
apacheignite/ignite | public static void setWorkDirectory ( @ Nullable String userWorkDir , @ Nullable String userIgniteHome ) throws IgniteCheckedException { String igniteWork0 = igniteWork ; if ( igniteWork0 == null ) { synchronized ( IgniteUtils . class ) { igniteWork0 = igniteWork ; if ( igniteWork0 != null ) return ; File workDir ; if ( ! F . isEmpty ( userWorkDir ) ) workDir = new File ( userWorkDir ) ; else if ( ! F . isEmpty ( IGNITE_WORK_DIR ) ) workDir = new File ( IGNITE_WORK_DIR ) ; else if ( ! F . isEmpty ( userIgniteHome ) ) workDir = new File ( userIgniteHome , " work " ) ; else { String tmpDirPath = System . getProperty ( " java . io . tmpdir " ) ; if ( tmpDirPath == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ work ▁ directory ▁ in ▁ OS ▁ temp ▁ " + " ( property ▁ ' java . io . tmpdir ' ▁ is ▁ null ) . " ) ; workDir = new File ( tmpDirPath , " ignite " + File . separator + " work " ) ; } if ( ! workDir . isAbsolute ( ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ path ▁ must ▁ be ▁ absolute : ▁ " + workDir ) ; if ( ! mkdirs ( workDir ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + workDir ) ; if ( ! workDir . canRead ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ work ▁ directory : ▁ " + workDir ) ; if ( ! workDir . canWrite ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ work ▁ directory : ▁ " + workDir ) ; igniteWork = workDir . getAbsolutePath ( ) ; } } }
apacheignite/ignite | public static void nullifyHomeDirectory ( ) { ggHome = null ; }
apacheignite/ignite | public static void nullifyWorkDirectory ( ) { igniteWork = null ; }
apacheignite/ignite | public static File resolveWorkDirectory ( String path , boolean delIfExist ) throws IgniteCheckedException { File dir = new File ( path ) ; if ( ! dir . isAbsolute ( ) ) { String ggWork0 = igniteWork ; if ( F . isEmpty ( ggWork0 ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ resolve ▁ path ▁ ( work ▁ directory ▁ has ▁ not ▁ been ▁ set ) : ▁ " + path ) ; dir = new File ( ggWork0 , dir . getPath ( ) ) ; } if ( delIfExist && dir . exists ( ) ) { if ( ! U . delete ( dir ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ delete ▁ directory : ▁ " + dir ) ; } if ( ! mkdirs ( dir ) ) throw new IgniteCheckedException ( " Directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + dir ) ; if ( ! dir . canRead ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ directory : ▁ " + dir ) ; if ( ! dir . canWrite ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ directory : ▁ " + dir ) ; return dir ; }
apacheignite/ignite | public static IgniteCheckedException exceptionWithSuppressed ( String msg , @ Nullable Collection < Throwable > suppressed ) { IgniteCheckedException e = new IgniteCheckedException ( msg ) ; if ( suppressed != null ) { for ( Throwable th : suppressed ) e . addSuppressed ( th ) ; } return e ; }
apacheignite/ignite | @ Nullable public static String lambdaEnclosingClassName ( String clsName ) { int idx = clsName . indexOf ( " $ $ Lambda $ " ) ; return idx != - 1 ? clsName . substring ( 0 , idx ) : null ; }
apacheignite/ignite | public static int toDigit ( char ch , int idx ) throws IgniteCheckedException { int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) throw new IgniteCheckedException ( " Illegal ▁ hexadecimal ▁ character ▁ " + ch + " ▁ at ▁ index ▁ " + idx ) ; return digit ; }
apacheignite/ignite | public static ClusterNode oldest ( Collection < ClusterNode > c , @ Nullable IgnitePredicate < ClusterNode > p ) { ClusterNode oldest = null ; long minOrder = Long . MAX_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) < minOrder ) { oldest = n ; minOrder = n . order ( ) ; } } return oldest ; }
apacheignite/ignite | public static ClusterNode youngest ( Collection < ClusterNode > c , @ Nullable IgnitePredicate < ClusterNode > p ) { ClusterNode youngest = null ; long maxOrder = Long . MIN_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) > maxOrder ) { youngest = n ; maxOrder = n . order ( ) ; } } return youngest ; }
apacheignite/ignite | public static long writeGridUuid ( byte [ ] arr , long off , @ Nullable IgniteUuid uid ) { UNSAFE . putBoolean ( arr , off ++ , uid != null ) ; if ( uid != null ) { UNSAFE . putLong ( arr , off , uid . globalId ( ) . getMostSignificantBits ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , uid . globalId ( ) . getLeastSignificantBits ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , uid . localId ( ) ) ; off += 8 ; } return off ; }
apacheignite/ignite | @ Nullable public static IgniteUuid readGridUuid ( byte [ ] arr , long off ) { if ( UNSAFE . getBoolean ( arr , off ++ ) ) { long most = UNSAFE . getLong ( arr , off ) ; off += 8 ; long least = UNSAFE . getLong ( arr , off ) ; off += 8 ; UUID globalId = new UUID ( most , least ) ; long locId = UNSAFE . getLong ( arr , off ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
apacheignite/ignite | @ Nullable public static IgniteUuid readGridUuid ( long ptr ) { if ( UNSAFE . getBoolean ( null , ptr ++ ) ) { long most = UNSAFE . getLong ( ptr ) ; ptr += 8 ; long least = UNSAFE . getLong ( ptr ) ; ptr += 8 ; UUID globalId = new UUID ( most , least ) ; long locId = UNSAFE . getLong ( ptr ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
apacheignite/ignite | public static long writeVersion ( byte [ ] arr , long off , GridCacheVersion ver ) { boolean verEx = ver instanceof GridCacheVersionEx ; UNSAFE . putBoolean ( arr , off ++ , verEx ) ; if ( verEx ) { GridCacheVersion drVer = ver . conflictVersion ( ) ; assert drVer != null ; UNSAFE . putInt ( arr , off , drVer . topologyVersion ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , drVer . nodeOrderAndDrIdRaw ( ) ) ; off += 4 ; UNSAFE . putLong ( arr , off , drVer . globalTime ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , drVer . order ( ) ) ; off += 8 ; } UNSAFE . putInt ( arr , off , ver . topologyVersion ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , ver . nodeOrderAndDrIdRaw ( ) ) ; off += 4 ; UNSAFE . putLong ( arr , off , ver . globalTime ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , ver . order ( ) ) ; off += 8 ; return off ; }
apacheignite/ignite | public static GridCacheVersion readVersion ( long ptr , boolean verEx ) { GridCacheVersion ver = new GridCacheVersion ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) ) ; if ( verEx ) { ptr += 24 ; ver = new GridCacheVersionEx ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) , ver ) ; } return ver ; }
apacheignite/ignite | public static GridCacheVersion readVersion ( byte [ ] arr , long off , boolean verEx ) { int topVer = UNSAFE . getInt ( arr , off ) ; off += 4 ; int nodeOrderDrId = UNSAFE . getInt ( arr , off ) ; off += 4 ; long globalTime = UNSAFE . getLong ( arr , off ) ; off += 8 ; long order = UNSAFE . getLong ( arr , off ) ; off += 8 ; GridCacheVersion ver = new GridCacheVersion ( topVer , nodeOrderDrId , globalTime , order ) ; if ( verEx ) { topVer = UNSAFE . getInt ( arr , off ) ; off += 4 ; nodeOrderDrId = UNSAFE . getInt ( arr , off ) ; off += 4 ; globalTime = UNSAFE . getLong ( arr , off ) ; off += 8 ; order = UNSAFE . getLong ( arr , off ) ; ver = new GridCacheVersionEx ( topVer , nodeOrderDrId , globalTime , order , ver ) ; } return ver ; }
apacheignite/ignite | public static byte [ ] copyMemory ( long ptr , int size ) { byte [ ] res = new byte [ size ] ; UNSAFE . copyMemory ( null , ptr , res , BYTE_ARRAY_DATA_OFFSET , size ) ; return res ; }
apacheignite/ignite | public static int capacity ( int expSize ) { if ( expSize < 3 ) return expSize + 1 ; if ( expSize < ( 1 << 30 ) ) return expSize + expSize / 3 ; return Integer . MAX_VALUE ; }
apacheignite/ignite | public static < K , V > HashMap < K , V > newHashMap ( int expSize ) { return new HashMap < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < K , V > LinkedHashMap < K , V > newLinkedHashMap ( int expSize ) { return new LinkedHashMap < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < T > HashSet < T > newHashSet ( int expSize ) { return new HashSet < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < T > LinkedHashSet < T > newLinkedHashSet ( int expSize ) { return new LinkedHashSet < > ( capacity ( expSize ) ) ; }
apacheignite/ignite | public static < K , V > Map < K , V > limitedMap ( int limit ) { if ( limit == 0 ) return Collections . emptyMap ( ) ; if ( limit < 5 ) return new GridLeanMap < > ( limit ) ; return new HashMap < > ( capacity ( limit ) , 0.75f ) ; }
apacheignite/ignite | public static Comparator < InetSocketAddress > inetAddressesComparator ( final boolean sameHost ) { return new Comparator < InetSocketAddress > ( ) { @ Override public int compare ( InetSocketAddress addr1 , InetSocketAddress addr2 ) { if ( addr1 . isUnresolved ( ) && addr2 . isUnresolved ( ) ) return 0 ; if ( addr1 . isUnresolved ( ) || addr2 . isUnresolved ( ) ) return addr1 . isUnresolved ( ) ? 1 : - 1 ; boolean addr1Loopback = addr1 . getAddress ( ) . isLoopbackAddress ( ) ; if ( addr1Loopback == addr2 . getAddress ( ) . isLoopbackAddress ( ) ) return 0 ; if ( sameHost ) return addr1Loopback ? - 1 : 1 ; else return addr1Loopback ? 1 : - 1 ; } } ; }
apacheignite/ignite | @ Nullable public static Method findNonPublicMethod ( Class < ? > cls , String name , Class < ? > ... paramTypes ) { while ( cls != null ) { try { Method mtd = cls . getDeclaredMethod ( name , paramTypes ) ; if ( mtd . getReturnType ( ) != void . class ) { mtd . setAccessible ( true ) ; return mtd ; } } catch ( NoSuchMethodException ignored ) { } cls = cls . getSuperclass ( ) ; } return null ; }
apacheignite/ignite | public static < T extends R , R > List < R > arrayList ( Collection < T > c , @ Nullable IgnitePredicate < ? super T > ... p ) { assert c != null ; return IgniteUtils . arrayList ( c , c . size ( ) , p ) ; }
apacheignite/ignite | public static < T extends R , R > List < R > arrayList ( Collection < T > c ) { assert c != null ; return new ArrayList < R > ( c ) ; }
apacheignite/ignite | public static < T extends R , R > List < R > arrayList ( Iterable < T > c , int cap , @ Nullable IgnitePredicate < ? super T > ... p ) { assert c != null ; assert cap >= 0 ; List < R > list = new ArrayList < > ( cap ) ; for ( T t : c ) { if ( F . isAll ( t , p ) ) list . add ( t ) ; } return list ; }
apacheignite/ignite | public static int writeMessageFully ( Message msg , OutputStream out , ByteBuffer buf , MessageWriter writer ) throws IOException { assert msg != null ; assert out != null ; assert buf != null ; assert buf . hasArray ( ) ; boolean finished = false ; int cnt = 0 ; while ( ! finished ) { finished = msg . writeTo ( buf , writer ) ; out . write ( buf . array ( ) , 0 , buf . position ( ) ) ; cnt += buf . position ( ) ; buf . clear ( ) ; } return cnt ; }
apacheignite/ignite | public static void assertParameter ( boolean cond , String condDesc ) throws IgniteException { if ( ! cond ) throw new IgniteException ( " Parameter ▁ failed ▁ condition ▁ check : ▁ " + condDesc ) ; }
apacheignite/ignite | public static boolean hasSharedMemory ( ) { if ( hasShmem == null ) { if ( isWindows ( ) ) hasShmem = false ; else { try { IpcSharedMemoryNativeLoader . load ( null ) ; hasShmem = true ; } catch ( IgniteCheckedException ignore ) { hasShmem = false ; } } } return hasShmem ; }
apacheignite/ignite | public static void writeLock ( ReadWriteLock lock ) throws IgniteInterruptedCheckedException { try { lock . writeLock ( ) . lockInterruptibly ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
apacheignite/ignite | public static byte directProtocolVersion ( GridKernalContext ctx , UUID nodeId ) throws IgniteCheckedException { assert nodeId != null ; ClusterNode node = ctx . discovery ( ) . node ( nodeId ) ; if ( node == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ define ▁ communication ▁ protocol ▁ version ▁ " + " ( has ▁ node ▁ left ▁ topology ? ) : ▁ " + nodeId ) ; assert ! node . isLocal ( ) ; Byte attr = node . attribute ( GridIoManager . DIRECT_PROTO_VER_ATTR ) ; byte rmtProtoVer = attr != null ? attr : 1 ; if ( rmtProtoVer < GridIoManager . DIRECT_PROTO_VER ) return rmtProtoVer ; else return GridIoManager . DIRECT_PROTO_VER ; }
BlueBrain/bluima | public static String extractText ( Article article ) { StringBuilder sb = new StringBuilder ( ) ; List < Abstract > abstracts = article . getFront ( ) . getArticleMeta ( ) . getAbstract ( ) ; for ( Abstract abstrct : abstracts ) { for ( Sec sec : abstrct . getSec ( ) ) { processTextContent ( sec . getAddressOrAlternativesOrArray ( ) , sb , true ) ; } } sb . append ( ' \n ' ) ; Body body = article . getBody ( ) ; if ( body != null ) { for ( Sec sec : body . getSec ( ) ) { Title title = sec . getTitle ( ) ; if ( title != null && title . getContent ( ) != null ) { processTextContent ( title . getContent ( ) , sb , true ) ; sb . append ( ' \n ' ) ; } processTextContent ( sec . getAddressOrAlternativesOrArray ( ) , sb , false ) ; } } return removeNoise ( sb . toString ( ) ) ; }
BlueBrain/bluima | private static String removeNoise ( String s ) { return s . replace ( " ▁ ▁ ▁ " , " ▁ " ) . replace ( " ▁ ▁ " , " ▁ " ) . replace ( " ▁ , ▁ " , " ▁ " ) . replace ( " ▁ ( ▁ ) " , " " ) . replace ( " & # x000a0 ; " , " ▁ " ) . replace ( " " , " ▁ " ) . replace ( " [ ▁ – ▁ ] " , " ▁ " ) . replace ( " [ ▁ ] " , " " ) ; }
BlueBrain/bluima | private static void processTextContent ( List < Object > contents , StringBuilder sb , boolean addSpace ) { for ( Object o : contents ) { if ( o instanceof P ) { P p = ( P ) o ; processTextContent ( p . getContent ( ) , sb , true ) ; sb . append ( ' \n ' ) ; } else if ( o instanceof Italic ) { Italic i = ( Italic ) o ; processTextContent ( i . getContent ( ) , sb , true ) ; } else if ( o instanceof Bold ) { Bold b = ( Bold ) o ; processTextContent ( b . getContent ( ) , sb , true ) ; } else if ( o instanceof Monospace ) { Monospace m = ( Monospace ) o ; processTextContent ( m . getContent ( ) , sb , true ) ; } else if ( o instanceof Sup ) { Sup s = ( Sup ) o ; processTextContent ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Sub ) { Sub s = ( Sub ) o ; processTextContent ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Sc ) { Sc s = ( Sc ) o ; processTextContent ( s . getContent ( ) , sb , false ) ; } else if ( o instanceof Xref ) { } else if ( o instanceof String ) { sb . append ( o ) ; if ( addSpace ) sb . append ( ' ▁ ' ) ; } else { } } }
BlueBrain/bluima | public static Integer extractPmid ( Article article ) { try { List < ArticleId > ids = article . getFront ( ) . getArticleMeta ( ) . getArticleId ( ) ; for ( ArticleId id : ids ) { if ( " pmid " . equals ( id . getPubIdType ( ) ) ) { return parseInt ( id . getContent ( ) ) ; } } if ( ! ids . isEmpty ( ) && isNumeric ( ids . get ( 0 ) . getContent ( ) ) ) { return parseInt ( ids . get ( 0 ) . getContent ( ) ) ; } } catch ( Exception e ) { System . err . println ( e ) ; } return null ; }
BlueBrain/bluima | public static String extractDoi ( Article article ) { try { List < ArticleId > ids = article . getFront ( ) . getArticleMeta ( ) . getArticleId ( ) ; for ( ArticleId id : ids ) { if ( " doi " . equals ( id . getPubIdType ( ) ) ) { return id . getContent ( ) ; } } } catch ( Exception e ) { System . err . println ( e ) ; } return null ; }
BlueBrain/bluima | public static String extractTitle ( Article article ) { return null ; }
guedeWebGate/org.openntf.base | public static FieldChoicesdialogs fromValue ( String v ) { for ( FieldChoicesdialogs c : FieldChoicesdialogs . values ( ) ) { if ( c . value . equals ( v ) ) { return c ; } } throw new IllegalArgumentException ( v ) ; }
sapirgolan/MFIBlocking | public static CandidateMatchComparator getInstance ( ) { if ( self == null ) { self = new CandidateMatchComparator ( ) ; } return self ; }
zuoweitan/Hitalk | public static long addCap ( long a , long b ) { long u = a + b ; if ( u < 0L ) { u = Long . MAX_VALUE ; } return u ; }
zuoweitan/Hitalk | public static long getAndAddRequest ( AtomicLong requested , long n ) { while ( true ) { long current = requested . get ( ) ; long next = addCap ( current , n ) ; if ( requested . compareAndSet ( current , next ) ) { return current ; } } }
zuoweitan/Hitalk | public static void print ( ) { }
joewalnes/idea-community | public static void invokeLater ( Project p , Runnable r ) { invokeLater ( p , ModalityState . defaultModalityState ( ) , r ) ; }
joewalnes/idea-community | public static void invokeLater ( final Project p , final ModalityState state , final Runnable r ) { if ( isNoBackgroundMode ( ) ) { r . run ( ) ; } else { ApplicationManager . getApplication ( ) . invokeLater ( new Runnable ( ) { public void run ( ) { if ( p . isDisposed ( ) ) return ; r . run ( ) ; } } , state ) ; } }
joewalnes/idea-community | public static void invokeAndWait ( Project p , Runnable r ) { invokeAndWait ( p , ModalityState . defaultModalityState ( ) , r ) ; }
joewalnes/idea-community | public static void invokeAndWait ( final Project p , final ModalityState state , final Runnable r ) { if ( isNoBackgroundMode ( ) ) { r . run ( ) ; } else { if ( ApplicationManager . getApplication ( ) . isDispatchThread ( ) ) { r . run ( ) ; } else { ApplicationManager . getApplication ( ) . invokeAndWait ( new Runnable ( ) { public void run ( ) { if ( p . isDisposed ( ) ) return ; r . run ( ) ; } } , state ) ; } } }
joewalnes/idea-community | public static void invokeAndWaitWriteAction ( Project p , final Runnable r ) { invokeAndWait ( p , new Runnable ( ) { public void run ( ) { ApplicationManager . getApplication ( ) . runWriteAction ( r ) ; } } ) ; }
joewalnes/idea-community | public static void runDumbAware ( final Project project , final Runnable r ) { if ( DumbService . isDumbAware ( r ) ) { r . run ( ) ; } else { DumbService . getInstance ( project ) . runWhenSmart ( new Runnable ( ) { public void run ( ) { if ( project . isDisposed ( ) ) return ; r . run ( ) ; } } ) ; } }
joewalnes/idea-community | public static void runWhenInitialized ( final Project project , final Runnable r ) { if ( project . isDisposed ( ) ) return ; if ( isNoBackgroundMode ( ) ) { r . run ( ) ; return ; } if ( ! project . isInitialized ( ) ) { StartupManager . getInstance ( project ) . registerPostStartupActivity ( r ) ; return ; } runDumbAware ( project , r ) ; }
joewalnes/idea-community | public static boolean isNoBackgroundMode ( ) { return ( ApplicationManager . getApplication ( ) . isUnitTestMode ( ) || ApplicationManager . getApplication ( ) . isHeadlessEnvironment ( ) ) ; }
joewalnes/idea-community | public static boolean isInModalContext ( ) { if ( isNoBackgroundMode ( ) ) return false ; return LaterInvocator . isInModalContext ( ) ; }
joewalnes/idea-community | public static void showError ( Project project , String title , Throwable e ) { MavenLog . LOG . warn ( title , e ) ; Notifications . Bus . notify ( new Notification ( MAVEN_NOTIFICATION_GROUP , title , e . getMessage ( ) , NotificationType . ERROR ) , project ) ; }
joewalnes/idea-community | public static Properties getSystemProperties ( ) { Properties result = ( Properties ) System . getProperties ( ) . clone ( ) ; for ( String each : new THashSet < String > ( ( Set ) result . keySet ( ) ) ) { if ( each . startsWith ( " idea . " ) ) { result . remove ( each ) ; } } return result ; }
joewalnes/idea-community | public static Properties getEnvProperties ( ) { Properties reuslt = new Properties ( ) ; for ( Map . Entry < String , String > each : System . getenv ( ) . entrySet ( ) ) { if ( isMagicalProperty ( each . getKey ( ) ) ) continue ; reuslt . put ( each . getKey ( ) , each . getValue ( ) ) ; } return reuslt ; }
joewalnes/idea-community | private static boolean isMagicalProperty ( String key ) { return key . startsWith ( " = " ) ; }
joewalnes/idea-community | public static File getPluginSystemDir ( String folder ) { return new File ( PathManager . getSystemPath ( ) , " Maven " + " / " + folder ) . getAbsoluteFile ( ) ; }
joewalnes/idea-community | public static VirtualFile findProfilesXmlFile ( VirtualFile pomFile ) { return pomFile . getParent ( ) . findChild ( MavenConstants . PROFILES_XML ) ; }
joewalnes/idea-community | public static File getProfilesXmlIoFile ( VirtualFile pomFile ) { return new File ( pomFile . getParent ( ) . getPath ( ) , MavenConstants . PROFILES_XML ) ; }
joewalnes/idea-community | public static < T , U > List < T > collectFirsts ( List < Pair < T , U > > pairs ) { List < T > result = new ArrayList < T > ( pairs . size ( ) ) ; for ( Pair < T , ? > each : pairs ) { result . add ( each . first ) ; } return result ; }
joewalnes/idea-community | public static < T , U > List < U > collectSeconds ( List < Pair < T , U > > pairs ) { List < U > result = new ArrayList < U > ( pairs . size ( ) ) ; for ( Pair < T , U > each : pairs ) { result . add ( each . second ) ; } return result ; }
joewalnes/idea-community | public static List < String > collectPaths ( List < VirtualFile > files ) { return ContainerUtil . map ( files , new Function < VirtualFile , String > ( ) { public String fun ( VirtualFile file ) { return file . getPath ( ) ; } } ) ; }
joewalnes/idea-community | public static List < VirtualFile > collectFiles ( Collection < MavenProject > projects ) { return ContainerUtil . map ( projects , new Function < MavenProject , VirtualFile > ( ) { public VirtualFile fun ( MavenProject project ) { return project . getFile ( ) ; } } ) ; }
joewalnes/idea-community | public static < T > boolean equalAsSets ( final Collection < T > collection1 , final Collection < T > collection2 ) { return toSet ( collection1 ) . equals ( toSet ( collection2 ) ) ; }
joewalnes/idea-community | private static < T > Collection < T > toSet ( final Collection < T > collection ) { return ( collection instanceof Set ? collection : new THashSet < T > ( collection ) ) ; }
joewalnes/idea-community | public static < T , U > List < Pair < T , U > > mapToList ( Map < T , U > map ) { return ContainerUtil . map2List ( map . entrySet ( ) , new Function < Map . Entry < T , U > , Pair < T , U > > ( ) { public Pair < T , U > fun ( Map . Entry < T , U > tuEntry ) { return Pair . create ( tuEntry . getKey ( ) , tuEntry . getValue ( ) ) ; } } ) ; }
joewalnes/idea-community | public static String formatHtmlImage ( URL url ) { return " < img ▁ src = \" " + url + " \" > ▁ " ; }
joewalnes/idea-community | public static void runOrApplyMavenProjectFileTemplate ( Project project , VirtualFile file , MavenId projectId , MavenId parentId , boolean interactive ) throws IOException { Properties properties = new Properties ( ) ; Properties conditions = new Properties ( ) ; properties . setProperty ( " GROUP _ ID " , projectId . getGroupId ( ) ) ; properties . setProperty ( " ARTIFACT _ ID " , projectId . getArtifactId ( ) ) ; properties . setProperty ( " VERSION " , projectId . getVersion ( ) ) ; if ( parentId != null ) { conditions . setProperty ( " HAS _ PARENT " , " true " ) ; properties . setProperty ( " PARENT _ GROUP _ ID " , parentId . getGroupId ( ) ) ; properties . setProperty ( " PARENT _ ARTIFACT _ ID " , parentId . getArtifactId ( ) ) ; properties . setProperty ( " PARENT _ VERSION " , parentId . getVersion ( ) ) ; } runOrApplyFileTemplate ( project , file , MavenFileTemplateGroupFactory . MAVEN_PROJECT_XML_TEMPLATE , properties , conditions , interactive ) ; }
joewalnes/idea-community | public static void runFileTemplate ( Project project , VirtualFile file , String templateName ) throws IOException { runOrApplyFileTemplate ( project , file , templateName , new Properties ( ) , new Properties ( ) , true ) ; }
joewalnes/idea-community | private static void runOrApplyFileTemplate ( Project project , VirtualFile file , String templateName , Properties properties , Properties conditions , boolean interactive ) throws IOException { FileTemplateManager manager = FileTemplateManager . getInstance ( ) ; FileTemplate fileTemplate = manager . getJ2eeTemplate ( templateName ) ; Properties allProperties = manager . getDefaultProperties ( ) ; if ( ! interactive ) { allProperties . putAll ( properties ) ; } allProperties . putAll ( conditions ) ; String text = fileTemplate . getText ( allProperties ) ; Pattern pattern = Pattern . compile ( " \\ $ \\ { ( . * ) \\ } " ) ; Matcher matcher = pattern . matcher ( text ) ; StringBuffer builder = new StringBuffer ( ) ; while ( matcher . find ( ) ) { matcher . appendReplacement ( builder , " \\ $ " + matcher . group ( 1 ) . toUpperCase ( ) + " \\ $ " ) ; } matcher . appendTail ( builder ) ; text = builder . toString ( ) ; TemplateImpl template = ( TemplateImpl ) TemplateManager . getInstance ( project ) . createTemplate ( " " , " " , text ) ; for ( int i = 0 ; i < template . getSegmentsCount ( ) ; i ++ ) { if ( i == template . getEndSegmentNumber ( ) ) continue ; String name = template . getSegmentName ( i ) ; String value = " \" " + properties . getProperty ( name , " " ) + " \" " ; template . addVariable ( name , value , value , true ) ; } if ( interactive ) { OpenFileDescriptor descriptor = new OpenFileDescriptor ( project , file ) ; Editor editor = FileEditorManager . getInstance ( project ) . openTextEditor ( descriptor , true ) ; editor . getDocument ( ) . setText ( " " ) ; TemplateManager . getInstance ( project ) . startTemplate ( editor , template ) ; } else { VfsUtil . saveText ( file , template . getTemplateText ( ) ) ; } }
joewalnes/idea-community | public static < T extends Collection < Pattern > > T collectPattern ( String text , T result ) { String antPattern = FileUtil . convertAntToRegexp ( text . trim ( ) ) ; try { result . add ( Pattern . compile ( antPattern ) ) ; } catch ( PatternSyntaxException ignore ) { } return result ; }
joewalnes/idea-community | public static boolean isIncluded ( String relativeName , List < Pattern > includes , List < Pattern > excludes ) { boolean result = false ; for ( Pattern each : includes ) { if ( each . matcher ( relativeName ) . matches ( ) ) { result = true ; break ; } } if ( ! result ) return false ; for ( Pattern each : excludes ) { if ( each . matcher ( relativeName ) . matches ( ) ) return false ; } return true ; }
joewalnes/idea-community | public static void run ( Project project , String title , final MavenTask task ) throws MavenProcessCanceledException { final Exception [ ] canceledEx = new Exception [ 1 ] ; final RuntimeException [ ] runtimeEx = new RuntimeException [ 1 ] ; final Error [ ] errorEx = new Error [ 1 ] ; ProgressManager . getInstance ( ) . run ( new Task . Modal ( project , title , true ) { public void run ( @ NotNull ProgressIndicator i ) { try { task . run ( new MavenProgressIndicator ( i ) ) ; } catch ( MavenProcessCanceledException e ) { canceledEx [ 0 ] = e ; } catch ( ProcessCanceledException e ) { canceledEx [ 0 ] = e ; } catch ( RuntimeException e ) { runtimeEx [ 0 ] = e ; } catch ( Error e ) { errorEx [ 0 ] = e ; } } } ) ; if ( canceledEx [ 0 ] instanceof MavenProcessCanceledException ) throw ( MavenProcessCanceledException ) canceledEx [ 0 ] ; if ( canceledEx [ 0 ] instanceof ProcessCanceledException ) throw new MavenProcessCanceledException ( ) ; if ( runtimeEx [ 0 ] != null ) throw runtimeEx [ 0 ] ; if ( errorEx [ 0 ] != null ) throw errorEx [ 0 ] ; }
joewalnes/idea-community | public static MavenTaskHandler runInBackground ( final Project project , final String title , final boolean cancellable , final MavenTask task ) { final MavenProgressIndicator indicator = new MavenProgressIndicator ( ) ; Runnable runnable = new Runnable ( ) { public void run ( ) { try { task . run ( indicator ) ; } catch ( MavenProcessCanceledException ignore ) { indicator . cancel ( ) ; } catch ( ProcessCanceledException ignore ) { indicator . cancel ( ) ; } } } ; if ( isNoBackgroundMode ( ) ) { runnable . run ( ) ; return new MavenTaskHandler ( ) { public void waitFor ( ) { } } ; } else { final Future < ? > future = ApplicationManager . getApplication ( ) . executeOnPooledThread ( runnable ) ; final MavenTaskHandler handler = new MavenTaskHandler ( ) { public void waitFor ( ) { try { future . get ( ) ; } catch ( InterruptedException e ) { MavenLog . LOG . error ( e ) ; } catch ( ExecutionException e ) { MavenLog . LOG . error ( e ) ; } } } ; invokeLater ( project , new Runnable ( ) { public void run ( ) { if ( future . isDone ( ) ) return ; new Task . Backgroundable ( project , title , cancellable ) { public void run ( @ NotNull ProgressIndicator i ) { indicator . setIndicator ( i ) ; handler . waitFor ( ) ; } } . queue ( ) ; } } ) ; return handler ; } }
joewalnes/idea-community | @ Nullable public static File resolveMavenHomeDirectory ( @ Nullable String overrideMavenHome ) { if ( ! isEmptyOrSpaces ( overrideMavenHome ) ) { return new File ( overrideMavenHome ) ; } String m2home = System . getenv ( ENV_M2_HOME ) ; if ( ! isEmptyOrSpaces ( m2home ) ) { final File homeFromEnv = new File ( m2home ) ; if ( isValidMavenHome ( homeFromEnv ) ) { return homeFromEnv ; } } String userHome = System . getProperty ( PROP_USER_HOME ) ; if ( ! isEmptyOrSpaces ( userHome ) ) { final File underUserHome = new File ( userHome , M2_DIR ) ; if ( isValidMavenHome ( underUserHome ) ) { return underUserHome ; } } return null ; }
joewalnes/idea-community | public static boolean isEmptyOrSpaces ( @ Nullable String str ) { return str == null || str . length ( ) == 0 || str . trim ( ) . length ( ) == 0 ; }
joewalnes/idea-community | public static boolean isValidMavenHome ( File home ) { return getMavenConfFile ( home ) . exists ( ) ; }
joewalnes/idea-community | public static File getMavenConfFile ( File mavenHome ) { return new File ( new File ( mavenHome , BIN_DIR ) , M2_CONF_FILE ) ; }
joewalnes/idea-community | @ Nullable public static File resolveGlobalSettingsFile ( @ Nullable String overriddenMavenHome ) { File directory = resolveMavenHomeDirectory ( overriddenMavenHome ) ; if ( directory == null ) return null ; return new File ( new File ( directory , CONF_DIR ) , SETTINGS_XML ) ; }
joewalnes/idea-community | @ NotNull public static File resolveUserSettingsFile ( @ Nullable String overriddenUserSettingsFile ) { if ( ! isEmptyOrSpaces ( overriddenUserSettingsFile ) ) return new File ( overriddenUserSettingsFile ) ; return new File ( resolveM2Dir ( ) , SETTINGS_XML ) ; }
joewalnes/idea-community | @ NotNull public static File resolveM2Dir ( ) { return new File ( System . getProperty ( PROP_USER_HOME ) , DOT_M2_DIR ) ; }
joewalnes/idea-community | @ NotNull public static File resolveLocalRepository ( @ Nullable String overridenLocalRepository , @ Nullable String overridenMavenHome , @ Nullable String overriddenUserSettingsFile ) { File result = null ; if ( ! isEmptyOrSpaces ( overridenLocalRepository ) ) result = new File ( overridenLocalRepository ) ; if ( result == null ) { result = doResolveLocalRepository ( resolveUserSettingsFile ( overriddenUserSettingsFile ) , resolveGlobalSettingsFile ( overridenMavenHome ) ) ; } try { return result . getCanonicalFile ( ) ; } catch ( IOException e ) { return result ; } }
joewalnes/idea-community | @ NotNull public static File doResolveLocalRepository ( @ Nullable File userSettingsFile , @ Nullable File globalSettingsFile ) { if ( userSettingsFile != null ) { final String fromUserSettings = getRepositoryFromSettings ( userSettingsFile ) ; if ( ! StringUtil . isEmpty ( fromUserSettings ) ) { return new File ( fromUserSettings ) ; } } if ( globalSettingsFile != null ) { final String fromGlobalSettings = getRepositoryFromSettings ( globalSettingsFile ) ; if ( ! StringUtil . isEmpty ( fromGlobalSettings ) ) { return new File ( fromGlobalSettings ) ; } } return new File ( resolveM2Dir ( ) , REPOSITORY_DIR ) ; }
joewalnes/idea-community | @ Nullable public static String getRepositoryFromSettings ( final File file ) { try { byte [ ] bytes = FileUtil . loadFileBytes ( file ) ; return expandProperties ( MavenJDOMUtil . findChildValueByPath ( MavenJDOMUtil . read ( bytes , null ) , " localRepository " , null ) ) ; } catch ( IOException e ) { return null ; } }
joewalnes/idea-community | public static String expandProperties ( String text ) { if ( StringUtil . isEmptyOrSpaces ( text ) ) return text ; Properties props = MavenFacadeUtil . collectSystemProperties ( ) ; for ( Map . Entry < Object , Object > each : props . entrySet ( ) ) { Object val = each . getValue ( ) ; text = text . replace ( " $ { " + each . getKey ( ) + " } " , val instanceof CharSequence ? ( CharSequence ) val : val . toString ( ) ) ; } return text ; }
joewalnes/idea-community | @ NotNull public static VirtualFile resolveSuperPomFile ( @ Nullable File mavenHome ) { VirtualFile result = null ; if ( mavenHome != null ) { result = doResolveSuperPomFile ( new File ( mavenHome , LIB_DIR ) ) ; } if ( result == null ) { result = doResolveSuperPomFile ( MavenFacadeManager . collectClassPathAndLIbsFolder ( ) . second ) ; } return result ; }
joewalnes/idea-community | @ Nullable public static VirtualFile doResolveSuperPomFile ( @ Nullable File mavenHome ) { File lib = resolveMavenLib ( mavenHome ) ; if ( lib == null ) return null ; VirtualFile file = LocalFileSystem . getInstance ( ) . findFileByIoFile ( lib ) ; if ( file == null ) return null ; VirtualFile root = JarFileSystem . getInstance ( ) . getJarRootForLocalFile ( file ) ; if ( root == null ) return null ; return root . findFileByRelativePath ( SUPER_POM_PATH ) ; }
joewalnes/idea-community | @ Nullable public static File resolveMavenLib ( @ NotNull File dir ) { File [ ] files = dir . listFiles ( ) ; if ( files != null ) { Pattern pattern = Pattern . compile ( " maven - \\ d + \\ . \\ d + \\ . \\ d + - uber \\ . jar " ) ; for ( File each : files ) { if ( pattern . matcher ( each . getName ( ) ) . matches ( ) ) { return each ; } } } return null ; }
Buzzardo/spring-boot | private static String buildMessage ( ConfigurationPropertyName name , Bindable < ? > target ) { StringBuilder message = new StringBuilder ( ) ; message . append ( " Failed ▁ to ▁ bind ▁ properties " ) ; message . append ( ( name != null ) ? " ▁ under ▁ ' " + name + " ' " : " " ) ; message . append ( " ▁ to ▁ " ) . append ( target . getType ( ) ) ; return message . toString ( ) ; }
camunda/camunda-bpm-platform | @ Deployment public static WebArchive processArchive ( ) { return initWebArchiveDeployment ( ) . addAsLibraries ( ShrinkWrap . create ( JavaArchive . class , " engine1 . jar " ) . addAsResource ( " singleEngine . xml " , " META - INF / processes . xml " ) ) ; }
trejkaz/derby | private static ContextService getContextService ( ) { return AccessController . doPrivileged ( new PrivilegedAction < ContextService > ( ) { public ContextService run ( ) { return ContextService . getFactory ( ) ; } } ) ; }
trejkaz/derby | private static Object createPersistentService ( final String factoryInterface , final String serviceName , final Properties properties ) throws StandardException { try { return AccessController . doPrivileged ( new PrivilegedExceptionAction < Object > ( ) { public Object run ( ) throws StandardException { return Monitor . createPersistentService ( factoryInterface , serviceName , properties ) ; } } ) ; } catch ( PrivilegedActionException pae ) { throw StandardException . plainWrapException ( pae ) ; } }
aemay2/hapi-fhir | @ Bean public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer ( ) { return new PropertySourcesPlaceholderConfigurer ( ) ; }
Alachisoft/TayzGrid | public static void registerAllExtensions ( com . google . protobuf . ExtensionRegistry registry ) { }
Alachisoft/TayzGrid | public static RegisterBulkKeyNotifResponse getDefaultInstance ( ) { return defaultInstance ; }
Alachisoft/TayzGrid | public static final com . google . protobuf . Descriptors . Descriptor getDescriptor ( ) { return com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . internal_static_com_alachisoft_tayzgrid_common_protobuf_RegisterBulkKeyNotifResponse_descriptor ; }
Alachisoft/TayzGrid | public static Builder newBuilder ( ) { return Builder . create ( ) ; }
Alachisoft/TayzGrid | public static Builder newBuilder ( com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse prototype ) { return newBuilder ( ) . mergeFrom ( prototype ) ; }
Alachisoft/TayzGrid | private static Builder create ( ) { Builder builder = new Builder ( ) ; builder . result = new com . alachisoft . tayzgrid . common . protobuf . RegisterBulkKeyNotifResponseProtocol . RegisterBulkKeyNotifResponse ( ) ; return builder ; }
Alachisoft/TayzGrid | public static com . google . protobuf . Descriptors . FileDescriptor getDescriptor ( ) { return descriptor ; }
Alachisoft/TayzGrid | public static void internalForceInit ( ) { }
MovingBlocks/box2d-editor | public static Assets inst ( ) { return instance ; }
JuntaoZhang/myhadoop-2.2.0 | private static boolean isDfsClientClose ( DFSClient c ) { try { c . exists ( " " ) ; } catch ( IOException e ) { return e . getMessage ( ) . equals ( " Filesystem ▁ closed " ) ; } return false ; }
andy-goryachev/FindFiles | public static < T > void add ( GlobalProperty < T > p ) { properties . add ( p ) ; p . addListener ( ( src , old , cur ) -> store ( p ) ) ; load ( p ) ; }
andy-goryachev/FindFiles | protected static < T > void store ( GlobalProperty < T > p ) { try { String k = p . getName ( ) ; T v = p . getValue ( ) ; String s ; if ( v == null ) { s = null ; } else { StringConverter < T > c = p . getConverter ( ) ; s = c . toString ( v ) ; } GlobalSettings . setString ( k , s ) ; } catch ( Exception e ) { Log . ex ( e ) ; } }
andy-goryachev/FindFiles | protected static < T > void load ( GlobalProperty < T > p ) { try { String k = p . getName ( ) ; String s = GlobalSettings . getString ( k ) ; if ( s != null ) { T v = p . getConverter ( ) . fromString ( s ) ; p . setValue ( v ) ; } } catch ( Exception e ) { Log . ex ( e ) ; } }
JackSprat/Knifeybot | protected static SQLException appendMessageToException ( SQLException sqlEx , String messageToAppend , ExceptionInterceptor interceptor ) { String origMessage = sqlEx . getMessage ( ) ; String sqlState = sqlEx . getSQLState ( ) ; int vendorErrorCode = sqlEx . getErrorCode ( ) ; StringBuilder messageBuf = new StringBuilder ( origMessage . length ( ) + messageToAppend . length ( ) ) ; messageBuf . append ( origMessage ) ; messageBuf . append ( messageToAppend ) ; SQLException sqlExceptionWithNewMessage = SQLError . createSQLException ( messageBuf . toString ( ) , sqlState , vendorErrorCode , interceptor ) ; try { Method getStackTraceMethod = null ; Method setStackTraceMethod = null ; Object theStackTraceAsObject = null ; Class < ? > stackTraceElementClass = Class . forName ( " java . lang . StackTraceElement " ) ; Class < ? > stackTraceElementArrayClass = Array . newInstance ( stackTraceElementClass , new int [ ] { 0 } ) . getClass ( ) ; getStackTraceMethod = Throwable . class . getMethod ( " getStackTrace " , new Class [ ] { } ) ; setStackTraceMethod = Throwable . class . getMethod ( " setStackTrace " , new Class [ ] { stackTraceElementArrayClass } ) ; if ( getStackTraceMethod != null && setStackTraceMethod != null ) { theStackTraceAsObject = getStackTraceMethod . invoke ( sqlEx , new Object [ 0 ] ) ; setStackTraceMethod . invoke ( sqlExceptionWithNewMessage , new Object [ ] { theStackTraceAsObject } ) ; } } catch ( NoClassDefFoundError noClassDefFound ) { } catch ( NoSuchMethodException noSuchMethodEx ) { } catch ( Throwable catchAll ) { } return sqlExceptionWithNewMessage ; }
JackSprat/Knifeybot | protected static Connection getInstance ( String hostToConnectTo , int portToConnectTo , Properties info , String databaseToConnectTo , String url ) throws SQLException { if ( ! Util . isJdbc4 ( ) ) { return new ConnectionImpl ( hostToConnectTo , portToConnectTo , info , databaseToConnectTo , url ) ; } return ( Connection ) Util . handleNewInstance ( JDBC_4_CONNECTION_CTOR , new Object [ ] { hostToConnectTo , Integer . valueOf ( portToConnectTo ) , info , databaseToConnectTo , url } , null ) ; }
JackSprat/Knifeybot | protected static synchronized int getNextRoundRobinHostIndex ( String url , List < ? > hostList ) { int indexRange = hostList . size ( ) ; int index = random . nextInt ( indexRange ) ; return index ; }
JackSprat/Knifeybot | private static boolean nullSafeCompare ( String s1 , String s2 ) { if ( s1 == null && s2 == null ) { return true ; } if ( s1 == null && s2 != null ) { return false ; } return s1 != null && s1 . equals ( s2 ) ; }
navalev/azure-sdk-for-java | @ JsonCreator public static ApplicationGatewayTier fromString ( String name ) { return fromString ( name , ApplicationGatewayTier . class ) ; }
navalev/azure-sdk-for-java | public static Collection < ApplicationGatewayTier > values ( ) { return values ( ApplicationGatewayTier . class ) ; }
google/copybara | private static String detailedError ( String httpMethod , String path , @ Nullable String request , String response , int httpCode ) { StringBuilder sb = new StringBuilder ( " GitHub ▁ API ▁ call ▁ failed ▁ with ▁ code ▁ " ) . append ( httpCode ) . append ( " ▁ The ▁ request ▁ was ▁ " ) . append ( httpMethod ) . append ( ' ▁ ' ) . append ( path ) . append ( ' \n ' ) ; if ( request != null ) { sb . append ( " Request ▁ object : \n " ) . append ( request ) . append ( " \n " ) ; } sb . append ( " Response : \n " ) . append ( response ) . append ( " \n " ) ; return sb . toString ( ) ; }
google/copybara | private static ResponseCode parseResponseCode ( int code ) { ResponseCode responseCode = CODE_MAP . get ( code ) ; return responseCode == null ? ResponseCode . UNKNOWN : responseCode ; }
gjordi/gwt-jsni | public static JsArrayString wrapArray ( String [ ] srcArray ) { JsArrayString result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static String [ ] unwrapArray ( JsArrayString jsArrayString ) { String [ ] result = new String [ jsArrayString . length ( ) ] ; for ( int i = 0 ; i < jsArrayString . length ( ) ; i ++ ) { result [ i ] = jsArrayString . get ( i ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayNumber wrapArray ( float [ ] srcArray ) { JsArrayNumber result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayNumber wrapArray ( double [ ] srcArray ) { JsArrayNumber result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayInteger wrapArray ( int [ ] srcArray ) { JsArrayInteger result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayInteger wrapArray ( byte [ ] srcArray ) { JsArrayInteger result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
gjordi/gwt-jsni | public static JsArrayBoolean wrapArray ( boolean [ ] srcArray ) { JsArrayBoolean result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
daniel-beck/sorcerer | public static < T > JsArray < T > create ( ) { return ( JsArray < T > ) createArray ( ) ; }
ginere/ginere-base | public static String getStringSize ( long size ) { Language lang = I18NConnector . getThreadLocalLanguage ( ) ; return getStringSize ( lang , size ) ; }
ginere/ginere-base | public static String getStringSize ( Language language , long size ) { NumberFormat format = NumberFormat . getNumberInstance ( language . getLocale ( ) ) ; if ( size < BYTES_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , BYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < KB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / BYTES_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , KBYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < MB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / KB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , MBYTE_LBL ) ) ; return buffer . toString ( ) ; } else if ( size < GB_LIMIT ) { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / MB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , GBYTE_LBL ) ) ; return buffer . toString ( ) ; } else { StringBuffer buffer = new StringBuffer ( ) ; buffer . append ( format . format ( size / GB_LIMIT ) ) ; buffer . append ( " ▁ " ) ; buffer . append ( I18NConnector . getLabel ( language , StringFileSize . class , GBYTE_LBL ) ) ; return buffer . toString ( ) ; } }
joypupil/study | public static SystemInfo getInstance ( ) { if ( currentSystem == null ) currentSystem = new SystemInfo ( ) ; return currentSystem ; }
joypupil/study | public static void main ( String [ ] args ) { String mac = " " ; try { Process p = new ProcessBuilder ( " ifconfig " ) . start ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( p . getInputStream ( ) ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { Pattern pat = Pattern . compile ( " \\ b \\ w + : \\ w + : \\ w + : \\ w + : \\ w + : \\ w + \\ b " ) ; Matcher mat = pat . matcher ( line ) ; if ( mat . find ( ) ) { mac = mat . group ( 0 ) ; } } br . close ( ) ; } catch ( IOException e ) { } System . out . println ( " 本机MAC地址为 : \n " + mac ) ; }
wangsongpeng/jdk-src | public static TemporalQuery < ZoneId > zoneId ( ) { return TemporalQueries . ZONE_ID ; }
wangsongpeng/jdk-src | public static TemporalQuery < Chronology > chronology ( ) { return TemporalQueries . CHRONO ; }
wangsongpeng/jdk-src | public static TemporalQuery < TemporalUnit > precision ( ) { return TemporalQueries . PRECISION ; }
wangsongpeng/jdk-src | public static TemporalQuery < ZoneId > zone ( ) { return TemporalQueries . ZONE ; }
wangsongpeng/jdk-src | public static TemporalQuery < ZoneOffset > offset ( ) { return TemporalQueries . OFFSET ; }
wangsongpeng/jdk-src | public static TemporalQuery < LocalDate > localDate ( ) { return TemporalQueries . LOCAL_DATE ; }
wangsongpeng/jdk-src | public static TemporalQuery < LocalTime > localTime ( ) { return TemporalQueries . LOCAL_TIME ; }
justin-espedal/polydes | public static PaintExtension get ( ) { return _instance ; }
indashnet/InDashNet.Open.UN2000 | public static int getMaxSpeechInputLength ( ) { return 4000 ; }
india-rose/old-indiarose | public static Typeface loadFont ( String _fontPath ) { if ( ! m_fonts . containsKey ( _fontPath ) ) { Typeface font = Typeface . createFromFile ( _fontPath ) ; if ( font == null ) { font = Typeface . DEFAULT ; } m_fonts . put ( _fontPath , font ) ; } return m_fonts . get ( _fontPath ) ; }
aws/aws-sdk-java | public static DescribeAuditStreamConfigurationResultJsonUnmarshaller getInstance ( ) { if ( instance == null ) instance = new DescribeAuditStreamConfigurationResultJsonUnmarshaller ( ) ; return instance ; }
mattyb149/pentaho-kettle | public static void validateImportedElement ( ImportRules importRules , Object subject ) throws KettleException { List < ImportValidationFeedback > feedback = importRules . verifyRules ( subject ) ; List < ImportValidationFeedback > errors = ImportValidationFeedback . getErrors ( feedback ) ; if ( ! errors . isEmpty ( ) ) { StringBuilder message = new StringBuilder ( BaseMessages . getString ( PKG , " RepositoryImporter . ValidationFailed . Message " , subject . toString ( ) ) ) ; message . append ( Const . CR ) ; for ( ImportValidationFeedback error : errors ) { message . append ( " ▁ - ▁ " ) ; message . append ( error . toString ( ) ) ; message . append ( Const . CR ) ; } throw new KettleException ( message . toString ( ) ) ; } }
mattyb149/pentaho-kettle | private static boolean containsVariables ( String entryPath ) { List < String > variablesList = new ArrayList < String > ( ) ; StringUtil . getUsedVariables ( entryPath , variablesList , true ) ; return ! variablesList . isEmpty ( ) ; }
MobileCloudNetworking/icnaas | @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { CCNTestBase . setUpBeforeClass ( ) ; }
MobileCloudNetworking/icnaas | @ AfterClass public static void tearDownAfterClass ( ) throws Exception { CCNTestBase . tearDownAfterClass ( ) ; }
salyh/geronimo-specs | public static Collector < JsonValue , JsonArrayBuilder , JsonArray > toJsonArray ( ) { return null ; }
salyh/geronimo-specs | public static Collector < Map . Entry < String , JsonValue > , JsonObjectBuilder , JsonObject > toJsonObject ( ) { return null ; }
salyh/geronimo-specs | public static Collector < JsonValue , JsonObjectBuilder , JsonObject > toJsonObject ( Function < JsonValue , String > keyMapper , Function < JsonValue , JsonValue > valueMapper ) { return null ; }
salyh/geronimo-specs | public static Collector < JsonValue , Map < String , JsonArrayBuilder > , JsonObject > groupingBy ( Function < JsonValue , String > classifier , Collector < JsonValue , JsonArrayBuilder , JsonArray > downstream ) { return null ; }
salyh/geronimo-specs | public static Collector < JsonValue , Map < String , JsonArrayBuilder > , JsonObject > groupingBy ( Function < JsonValue , String > classifier ) { return null ; }
cguzel/gora | public static void main ( String [ ] args ) { if ( args . length == 1 && ( args [ 0 ] . equals ( " - - help " ) || args [ 0 ] . equals ( " - h " ) ) ) { printHelp ( ) ; System . exit ( 0 ) ; } if ( args . length < 2 ) { LOG . error ( " Must ▁ supply ▁ at ▁ least ▁ one ▁ source ▁ file ▁ and ▁ an ▁ output ▁ directory . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } LicenseHeaders licenseHeader = new LicenseHeaders ( " ASLv2" ) ; for ( int i = 0 ; i < args . length ; i ++ ) { if ( " - license " . equals ( args [ i ] ) ) { if ( i == args . length - 1 ) { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } if ( licenseHeader . isValidLicense ( args [ i + 1 ] ) ) { licenseHeader . setLicenseName ( args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . removeElement ( args , args [ i + 1 ] ) ; args = ( String [ ] ) ArrayUtils . removeElement ( args , args [ i ] ) ; } else { LOG . error ( " Must ▁ supply ▁ a ▁ valid ▁ license ▁ id . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } } } File outputDir = new File ( args [ args . length - 1 ] ) ; if ( ! outputDir . isDirectory ( ) ) { LOG . error ( " Must ▁ supply ▁ a ▁ directory ▁ for ▁ output " ) ; printHelp ( ) ; System . exit ( 1 ) ; } File inputDir = new File ( args [ 0 ] ) ; File [ ] inputFiles = null ; if ( inputDir . isDirectory ( ) ) { if ( inputDir . length ( ) > 0 ) inputFiles = inputDir . listFiles ( ) ; else { LOG . error ( " Input ▁ directory ▁ must ▁ include ▁ at ▁ least ▁ one ▁ file . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } } else { inputFiles = new File [ args . length - 1 ] ; for ( int i = 0 ; i < inputFiles . length ; i ++ ) { File inputFile = new File ( args [ i ] ) ; if ( ! inputFile . isFile ( ) ) { LOG . error ( " Input ▁ must ▁ be ▁ a ▁ file . " ) ; printHelp ( ) ; System . exit ( 1 ) ; } inputFiles [ i ] = inputFile ; } } try { GoraCompiler . compileSchema ( inputFiles , outputDir , licenseHeader ) ; LOG . info ( " Compiler ▁ executed ▁ SUCCESSFULL . " ) ; } catch ( IOException e ) { LOG . error ( " Error ▁ while ▁ compiling ▁ schema ▁ files . ▁ Check ▁ that ▁ the ▁ schemas ▁ are ▁ properly ▁ formatted . " ) ; printHelp ( ) ; throw new RuntimeException ( e ) ; } }
cguzel/gora | private static void printHelp ( ) { LOG . info ( " Usage : ▁ gora - compiler ▁ ( ▁ - h ▁ | ▁ - - help ▁ ) ▁ | ▁ ( < input > ▁ [ < input > . . . ] ▁ < output > ▁ [ - license ▁ < id > ] ) " ) ; LOG . error ( " License ▁ header ▁ options ▁ include ; \n " + " \t\t ▁ ▁ ASLv2 ▁ ▁ ▁ ( Apache ▁ Software ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ AGPLv3 ▁ ▁ ( GNU ▁ Affero ▁ General ▁ Public ▁ License ) ▁ \n " + " \t\t ▁ ▁ CDDLv1 ▁ ▁ ( Common ▁ Development ▁ and ▁ Distribution ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ FDLv13 ▁ ▁ ( GNU ▁ Free ▁ Documentation ▁ License ▁ v1.3 ) ▁ \n " + " \t\t ▁ ▁ GPLv1 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v1.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv2 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v2.0 ) ▁ \n " + " \t\t ▁ ▁ GPLv3 ▁ ▁ ▁ ( GNU ▁ General ▁ Public ▁ License ▁ v3.0 ) ▁ \n " + " \t\t ▁ ▁ LGPLv21 ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v2.1 ) ▁ \n " + " \t\t ▁ ▁ LGPLv3 ▁ ▁ ( GNU ▁ Lesser ▁ General ▁ Public ▁ License ▁ v2.1 ) " ) ; }
AstromechZA/HoughCircleDetection | public static ShortImageBuffer norm ( ShortImageBuffer input ) { ShortImageBuffer after = input . copyShape ( ) ; int min = 0xFFFF ; int max = 0 ; for ( int y = 0 ; y < input . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < input . getWidth ( ) ; x ++ ) { int v = input . get ( y , x ) & 0xFFFF ; min = ( v < min ) ? v : min ; max = ( v > max ) ? v : max ; } } int diff = ( max - min ) ; if ( diff > 0 ) { float scale = ( ( float ) 0xFF ) / diff ; for ( int y = 0 ; y < input . getHeight ( ) ; y ++ ) { for ( int x = 0 ; x < input . getWidth ( ) ; x ++ ) { int v = input . get ( y , x ) & 0xFFFF ; after . set ( y , x , ( short ) ( ( int ) ( ( v - min ) * scale ) & 0xFF ) ) ; } } } return after ; }
jeikerxiao/SpringBootStudy | public static void main ( String [ ] args ) { SpringApplication . run ( SpringBootActuatorApplication . class , args ) ; }
khomisha/ui | public static CSSInjector getCSSInjector ( ) { return ( cssInjector ) ; }
khomisha/ui | public static void setCssInjector ( CSSInjector cssInjector ) { CSSHelper . cssInjector = cssInjector ; }
khomisha/ui | public static void addCSSName ( Element elem , String sCSSName ) { elem . addClassName ( sCSSName ) ; }
khomisha/ui | public static void addCSSName ( UIObject parent , String sChildCssName , String sCSSName ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; if ( ( e . getClassName ( ) ) . contains ( sChildCssName ) ) { addCSSName ( e , sCSSName ) ; } } }
khomisha/ui | public static void addCSSName ( UIObject parent , Map < String , String > customCSS ) { NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; String [ ] as = e . getClassName ( ) . split ( " ▁ " ) ; for ( String sClassName : as ) { if ( customCSS . containsKey ( sClassName ) ) { addCSSName ( e , customCSS . get ( sClassName ) ) ; } } } }
khomisha/ui | public static Element getChild ( UIObject parent , String sCssClass ) { Element child = null ; NodeList < Element > list = parent . getElement ( ) . getElementsByTagName ( " * " ) ; for ( int iNode = 0 ; iNode < list . getLength ( ) ; iNode ++ ) { Element e = list . getItem ( iNode ) ; if ( ( e . getClassName ( ) ) . contains ( sCssClass ) ) { child = e ; break ; } } return ( child ) ; }
MerritCR/merrit | public static void reloadChanges ( ChangeSet cs ) throws OrmException { for ( ChangeData cd : cs . changes ( ) ) { cd . reloadChange ( ) ; cd . setPatchSets ( null ) ; } }
AntoineAugusti/incubator-zeppelin | private static < I extends Iface > Map < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > getProcessMap ( Map < String , org . apache . thrift . ProcessFunction < I , ? extends org . apache . thrift . TBase > > processMap ) { processMap . put ( " createInterpreter " , new createInterpreter ( ) ) ; processMap . put ( " open " , new open ( ) ) ; processMap . put ( " close " , new close ( ) ) ; processMap . put ( " interpret " , new interpret ( ) ) ; processMap . put ( " cancel " , new cancel ( ) ) ; processMap . put ( " getProgress " , new getProgress ( ) ) ; processMap . put ( " getFormType " , new getFormType ( ) ) ; processMap . put ( " completion " , new completion ( ) ) ; processMap . put ( " shutdown " , new shutdown ( ) ) ; processMap . put ( " getStatus " , new getStatus ( ) ) ; processMap . put ( " getEvent " , new getEvent ( ) ) ; processMap . put ( " angularObjectUpdate " , new angularObjectUpdate ( ) ) ; processMap . put ( " angularObjectAdd " , new angularObjectAdd ( ) ) ; processMap . put ( " angularObjectRemove " , new angularObjectRemove ( ) ) ; return processMap ; }
AntoineAugusti/incubator-zeppelin | private static < I extends AsyncIface > Map < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > getProcessMap ( Map < String , org . apache . thrift . AsyncProcessFunction < I , ? extends org . apache . thrift . TBase , ? > > processMap ) { processMap . put ( " createInterpreter " , new createInterpreter ( ) ) ; processMap . put ( " open " , new open ( ) ) ; processMap . put ( " close " , new close ( ) ) ; processMap . put ( " interpret " , new interpret ( ) ) ; processMap . put ( " cancel " , new cancel ( ) ) ; processMap . put ( " getProgress " , new getProgress ( ) ) ; processMap . put ( " getFormType " , new getFormType ( ) ) ; processMap . put ( " completion " , new completion ( ) ) ; processMap . put ( " shutdown " , new shutdown ( ) ) ; processMap . put ( " getStatus " , new getStatus ( ) ) ; processMap . put ( " getEvent " , new getEvent ( ) ) ; processMap . put ( " angularObjectUpdate " , new angularObjectUpdate ( ) ) ; processMap . put ( " angularObjectAdd " , new angularObjectAdd ( ) ) ; processMap . put ( " angularObjectRemove " , new angularObjectRemove ( ) ) ; return processMap ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return PROPERTIES ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return ST ; case 3 : return INTERPRETER_CONTEXT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return INTERPRETER_CONTEXT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return INTERPRETER_CONTEXT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return class_NAME ; case 2 : return BUF ; case 3 : return CURSOR ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return JOB_ID ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 0 : return SUCCESS ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_ID ; case 3 : return OBJECT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_ID ; case 3 : return OBJECT ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case 1 : return NAME ; case 2 : return NOTE_ID ; default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { default : return null ; } }
AntoineAugusti/incubator-zeppelin | public static _Fields findByThriftIdOrThrow ( int fieldId ) { _Fields fields = findByThriftId ( fieldId ) ; if ( fields == null ) throw new IllegalArgumentException ( " Field ▁ " + fieldId + " ▁ doesn ' t ▁ exist ! " ) ; return fields ; }
AntoineAugusti/incubator-zeppelin | public static _Fields findByName ( String name ) { return byName . get ( name ) ; }
kzm4269/plen__Scenography_for_Android | @ NonNull public static < T > ReadOnlyProperty < T > create ( @ NonNull Observable < T > observable ) { return new ReadOnlyProperty < > ( observable ) ; }
tesseract2048/ansj_segd | public static void main ( String [ ] args ) throws Exception { loadFormFile ( ) ; loadFormStr ( ) ; Value value = new Value ( " 三个和尚 " , " 三个 " , " m " , " 和尚 " , " n " ) ; Library . insertWord ( UserDefineLibrary . ambiguityForest , value ) ; Library . removeWord ( UserDefineLibrary . ambiguityForest , " 三个和尚 " ) ; }
tesseract2048/ansj_segd | private static void loadFormStr ( ) { Forest forest = new Forest ( ) ; Value value = new Value ( " 三个和尚 " , " 三个 " , " m " , " 和尚 " , " n " ) ; Library . insertWord ( forest , value ) ; UserDefineLibrary . ambiguityForest = forest ; }
tesseract2048/ansj_segd | private static void loadFormFile ( ) throws Exception { Forest forest = Library . makeForest ( " new _ Library _ Path " ) ; UserDefineLibrary . ambiguityForest = forest ; }
dukechain/Qassandra | public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , List < SSTableReader > sstables ) { return create ( cfs , maxSSTableSize , sstables , new SizeTieredCompactionStrategyOptions ( ) ) ; }
dukechain/Qassandra | public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , Iterable < SSTableReader > sstables , SizeTieredCompactionStrategyOptions options ) { LeveledManifest manifest = new LeveledManifest ( cfs , maxSSTableSize , options ) ; for ( SSTableReader ssTableReader : sstables ) { manifest . add ( ssTableReader ) ; } for ( int i = 1 ; i < manifest . getAllLevelSize ( ) . length ; i ++ ) { manifest . repairOverlappingSSTables ( i ) ; } return manifest ; }
dukechain/Qassandra | private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) { assert ! candidates . isEmpty ( ) ; Iterator < SSTableReader > iter = candidates . iterator ( ) ; SSTableReader sstable = iter . next ( ) ; Token first = sstable . first . token ; Token last = sstable . last . token ; while ( iter . hasNext ( ) ) { sstable = iter . next ( ) ; first = first . compareTo ( sstable . first . token ) <= 0 ? first : sstable . first . token ; last = last . compareTo ( sstable . last . token ) >= 0 ? last : sstable . last . token ; } return overlapping ( first , last , others ) ; }
dukechain/Qassandra | @ VisibleForTesting static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) { return overlapping ( sstable . first . token , sstable . last . token , others ) ; }
dukechain/Qassandra | private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sstables ) { assert start . compareTo ( end ) <= 0 ; Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; Bounds < Token > promotedBounds = new Bounds < Token > ( start , end ) ; for ( SSTableReader candidate : sstables ) { Bounds < Token > candidateBounds = new Bounds < Token > ( candidate . first . token , candidate . last . token ) ; if ( candidateBounds . intersects ( promotedBounds ) ) overlapped . add ( candidate ) ; } return overlapped ; }
dukechain/Qassandra | private static final Predicate < SSTableReader > suspectP = new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader candidate ) { return candidate . isMarkedSuspect ( ) ; } }
dukechain/Qassandra | public static synchronized void mutateLevel ( SSTableMetadata oldMetadata , Descriptor descriptor , String filename , int level ) throws IOException { logger . debug ( " Mutating ▁ { } ▁ to ▁ level ▁ { } " , descriptor . filenameFor ( Component . STATS ) , level ) ; SSTableMetadata metadata = SSTableMetadata . copyWithNewSSTableLevel ( oldMetadata , level ) ; DataOutputStream out = new DataOutputStream ( new FileOutputStream ( filename + " - tmp " ) ) ; SSTableMetadata . serializer . legacySerialize ( metadata , descriptor , out ) ; out . flush ( ) ; out . close ( ) ; FileUtils . renameWithConfirm ( filename + " - tmp " , filename ) ; }
virajsenevirathne/wso2-commons-vfs | public static FTPSClient createConnection ( String hostname , int port , char [ ] username , char [ ] password , String workingDirectory , FileSystemOptions fileSystemOptions ) throws FileSystemException { return createConnection ( hostname , port , username , password , workingDirectory , fileSystemOptions , null ) ; }
virajsenevirathne/wso2-commons-vfs | public static FTPSClient createConnection ( String hostname , int port , char [ ] username , char [ ] password , String workingDirectory , FileSystemOptions fileSystemOptions , Integer defaultTimeout ) throws FileSystemException { if ( username == null ) { username = " anonymous " . toCharArray ( ) ; } if ( password == null ) { password = " anonymous " . toCharArray ( ) ; } try { final FTPSClient client ; if ( FtpsFileSystemConfigBuilder . getInstance ( ) . getFtpsType ( fileSystemOptions ) . equals ( " explicit " ) ) { client = new FTPSClient ( ) ; } else if ( FtpsFileSystemConfigBuilder . getInstance ( ) . getFtpsType ( fileSystemOptions ) . equals ( " implicit " ) ) { client = new FTPSClient ( true ) ; } else { throw new FileSystemException ( " Invalid ▁ FTPS ▁ type ▁ of ▁ " + FtpsFileSystemConfigBuilder . getInstance ( ) . getFtpsType ( fileSystemOptions ) + " ▁ specified . ▁ Must ▁ be ▁ ' implicit ' ▁ or ▁ ' explicit ' " ) ; } String key = FtpsFileSystemConfigBuilder . getInstance ( ) . getEntryParser ( fileSystemOptions ) ; if ( key != null ) { FTPClientConfig config = new FTPClientConfig ( key ) ; String serverLanguageCode = FtpsFileSystemConfigBuilder . getInstance ( ) . getServerLanguageCode ( fileSystemOptions ) ; if ( serverLanguageCode != null ) { config . setServerLanguageCode ( serverLanguageCode ) ; } String defaultDateFormat = FtpsFileSystemConfigBuilder . getInstance ( ) . getDefaultDateFormat ( fileSystemOptions ) ; if ( defaultDateFormat != null ) { config . setDefaultDateFormatStr ( defaultDateFormat ) ; } String recentDateFormat = FtpsFileSystemConfigBuilder . getInstance ( ) . getRecentDateFormat ( fileSystemOptions ) ; if ( recentDateFormat != null ) { config . setRecentDateFormatStr ( recentDateFormat ) ; } String serverTimeZoneId = FtpsFileSystemConfigBuilder . getInstance ( ) . getServerTimeZoneId ( fileSystemOptions ) ; if ( serverTimeZoneId != null ) { config . setServerTimeZoneId ( serverTimeZoneId ) ; } String [ ] shortMonthNames = FtpsFileSystemConfigBuilder . getInstance ( ) . getShortMonthNames ( fileSystemOptions ) ; if ( shortMonthNames != null ) { StringBuilder shortMonthNamesStr = new StringBuilder ( 40 ) ; for ( int i = 0 ; i < shortMonthNames . length ; i ++ ) { if ( shortMonthNamesStr . length ( ) > 0 ) { shortMonthNamesStr . append ( " | " ) ; } shortMonthNamesStr . append ( shortMonthNames [ i ] ) ; } config . setShortMonthNames ( shortMonthNamesStr . toString ( ) ) ; } client . configure ( config ) ; } FTPFileEntryParserFactory myFactory = FtpsFileSystemConfigBuilder . getInstance ( ) . getEntryParserFactory ( fileSystemOptions ) ; if ( myFactory != null ) { client . setParserFactory ( myFactory ) ; } try { addSSLParameters ( client , fileSystemOptions ) ; if ( defaultTimeout != null && ( defaultTimeout > 0 ) ) { client . setDefaultTimeout ( defaultTimeout ) ; } client . connect ( hostname , port ) ; if ( defaultTimeout != null && ( defaultTimeout > 0 ) ) { client . setSoTimeout ( defaultTimeout ) ; } log . info ( " Successfully ▁ connected ▁ to ▁ the ▁ FTP ▁ server " ) ; int reply = client . getReplyCode ( ) ; if ( ! FTPReply . isPositiveCompletion ( reply ) ) { throw new FileSystemException ( " vfs . provider . ftp / connect - rejected . error " , hostname ) ; } if ( ! client . login ( UserAuthenticatorUtils . toString ( username ) , UserAuthenticatorUtils . toString ( password ) ) ) { throw new FileSystemException ( " vfs . provider . ftp / login . error " , new Object [ ] { hostname , UserAuthenticatorUtils . toString ( username ) } , null ) ; } Integer fileType = FtpsFileSystemConfigBuilder . getInstance ( ) . getFileType ( fileSystemOptions ) ; if ( fileType == null ) { fileType = FTP . BINARY_FILE_TYPE ; } if ( ! client . setFileType ( fileType ) ) { throw new FileSystemException ( " vfs . provider . ftp / set - fileType . error " , hostname ) ; } Integer dataTimeout = FtpsFileSystemConfigBuilder . getInstance ( ) . getDataTimeout ( fileSystemOptions ) ; if ( dataTimeout != null ) { client . setDataTimeout ( dataTimeout . intValue ( ) ) ; } Boolean userDirIsRoot = FtpsFileSystemConfigBuilder . getInstance ( ) . getUserDirIsRoot ( fileSystemOptions ) ; if ( workingDirectory != null && ( userDirIsRoot == null || ! userDirIsRoot . booleanValue ( ) ) ) { if ( ! client . changeWorkingDirectory ( workingDirectory ) ) { throw new FileSystemException ( " vfs . provider . ftp / change - work - directory . error " , workingDirectory ) ; } } Boolean passiveMode = FtpsFileSystemConfigBuilder . getInstance ( ) . getPassiveMode ( fileSystemOptions ) ; if ( passiveMode != null && passiveMode . booleanValue ( ) ) { client . enterLocalPassiveMode ( ) ; } } catch ( final IOException e ) { if ( client . isConnected ( ) ) { client . disconnect ( ) ; } throw e ; } return client ; } catch ( final Exception exc ) { log . error ( exc ) ; throw new FileSystemException ( " vfs . provider . ftp / connect . error " , new Object [ ] { hostname } , exc ) ; } }
virajsenevirathne/wso2-commons-vfs | private static void addSSLParameters ( FTPSClient ftpsClient , FileSystemOptions fileSystemOptions ) throws Exception { KEYSTORE = FtpsFileSystemConfigBuilder . getInstance ( ) . getKeyStore ( fileSystemOptions ) ; TRUSTSTORE = FtpsFileSystemConfigBuilder . getInstance ( ) . getTrustStore ( fileSystemOptions ) ; KS_PASSWD = FtpsFileSystemConfigBuilder . getInstance ( ) . getKeyStorePW ( fileSystemOptions ) ; TS_PASSWD = FtpsFileSystemConfigBuilder . getInstance ( ) . getTrustStorePW ( fileSystemOptions ) ; KEY_PASSWD = FtpsFileSystemConfigBuilder . getInstance ( ) . getKeyPW ( fileSystemOptions ) ; KeyManagerFactory keyManagerFactory = null ; TrustManagerFactory trustManagerFactory = null ; try { FileInputStream keystorePath = new FileInputStream ( new File ( KEYSTORE ) ) ; FileInputStream truststorePath = new FileInputStream ( new File ( TRUSTSTORE ) ) ; KeyStore keyStore = KeyStore . getInstance ( " jks " ) ; KeyStore trustStore = KeyStore . getInstance ( " jks " ) ; keyStore . load ( keystorePath , KS_PASSWD . toCharArray ( ) ) ; trustStore . load ( truststorePath , TS_PASSWD . toCharArray ( ) ) ; keystorePath . close ( ) ; truststorePath . close ( ) ; keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; keyManagerFactory . init ( keyStore , KEY_PASSWD . toCharArray ( ) ) ; trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( trustStore ) ; } catch ( KeyStoreException e ) { log . error ( " Error ▁ occurred ▁ when ▁ initializing ▁ keystores " , e ) ; throw e ; } catch ( IOException e ) { log . error ( " Error ▁ occurred ▁ while ▁ retrieving ▁ the ▁ keystore ▁ paths " , e ) ; throw e ; } catch ( NoSuchAlgorithmException e ) { log . error ( " Error ▁ when ▁ getting ▁ the ▁ default ▁ algorithm " , e ) ; throw e ; } catch ( CertificateException e ) { log . error ( " Certificate ▁ exception ▁ occurred ▁ when ▁ loading ▁ the ▁ KeyStores ▁ " , e ) ; throw e ; } catch ( UnrecoverableKeyException e ) { log . error ( " Unrecoverable ▁ Key ▁ exception ▁ occurred " , e ) ; throw e ; } clientKeyManager = keyManagerFactory . getKeyManagers ( ) [ 0 ] ; clientTrustManager = trustManagerFactory . getTrustManagers ( ) [ 0 ] ; ftpsClient . setKeyManager ( clientKeyManager ) ; ftpsClient . setTrustManager ( clientTrustManager ) ; log . info ( " SSL ▁ parameters ▁ added ▁ to ▁ the ▁ FTPS ▁ client " ) ; }
asedunov/intellij-community | public static TempFileSystem getInstance ( ) { return ApplicationManager . getApplication ( ) . getComponent ( TempFileSystem . class ) ; }
akjava/akjava_gwtlib | public static Voice getVoiceAtLang ( String lang ) { JsArray < Voice > voices = SpeechSynthesis . get ( ) . getVoices ( ) ; for ( int i = 0 ; i < voices . length ( ) ; i ++ ) { if ( voices . get ( i ) . getLang ( ) . equals ( lang ) ) { return voices . get ( i ) ; } } return null ; }
akjava/akjava_gwtlib | public static Voice getVoiceAtLang ( List < Voice > voices , String lang ) { String hifun = lang . replace ( ' _ ' , ' - ' ) ; for ( int i = 0 ; i < voices . size ( ) ; i ++ ) { if ( voices . get ( i ) . getLang ( ) . equals ( lang ) || voices . get ( i ) . getLang ( ) . equals ( hifun ) ) { return voices . get ( i ) ; } } return null ; }
emil-wcislo/sbql4j8 | public static void main ( String [ ] args ) { TestLiteralCodeInPre tester = new TestLiteralCodeInPre ( ) ; run ( tester , ARGS , TEST , NEGATED_TEST ) ; tester . printSummary ( ) ; }
rokn/Count_Words_2015 | public static final Mac getInstance ( String algorithm ) throws NoSuchAlgorithmException { List services = GetInstance . getServices ( " Mac " , algorithm ) ; Iterator t = services . iterator ( ) ; while ( t . hasNext ( ) ) { Service s = ( Service ) t . next ( ) ; if ( JceSecurity . canUseProvider ( s . getProvider ( ) ) == false ) { continue ; } return new Mac ( s , t , algorithm ) ; } throw new NoSuchAlgorithmException ( " Algorithm ▁ " + algorithm + " ▁ not ▁ available " ) ; }
rokn/Count_Words_2015 | public static final Mac getInstance ( String algorithm , Provider provider ) throws NoSuchAlgorithmException { Instance instance = JceSecurity . getInstance ( " Mac " , MacSpi . class , algorithm , provider ) ; return new Mac ( ( MacSpi ) instance . impl , instance . provider , algorithm ) ; }
smblott-github/intent_radio | public static String copy ( Context context , int id , String path ) { return copy ( context , id , path , false ) ; }
smblott-github/intent_radio | public static String copy ( Context context , int id , String path , boolean overwrite ) { log ( " CopyResource ▁ id : ▁ " , " " + id ) ; log ( " CopyResource ▁ path : ▁ " , path ) ; File tmp = null ; InputStream input = null ; FileOutputStream output = null ; boolean success = true ; File sdcard = Environment . getExternalStorageDirectory ( ) ; if ( sdcard == null || ! Environment . getExternalStorageState ( ) . equals ( Environment . MEDIA_MOUNTED ) ) { return " SD ▁ card ▁ not ▁ found ▁ or ▁ not ▁ ready . " ; } path = sdcard . getAbsolutePath ( ) + " / " + path ; log ( " CopyResource ▁ full ▁ path : ▁ " , path ) ; File file = new File ( path ) ; if ( file . exists ( ) && ! overwrite ) { return " File ▁ already ▁ exists , ▁ not ▁ copied . . . " ; } File directory = new File ( file . getParent ( ) ) ; if ( ! directory . isDirectory ( ) ) { return " Directory ▁ does ▁ not ▁ exist . . . " ; } try { tmp = File . createTempFile ( prefix , null , directory ) ; log ( " CopyResource ▁ tmp ▁ path : ▁ " , tmp . toString ( ) ) ; input = context . getResources ( ) . openRawResource ( id ) ; output = new FileOutputStream ( tmp ) ; byte [ ] buffer = new byte [ 1024 ] ; int count = 0 ; while ( 0 < ( count = input . read ( buffer ) ) ) output . write ( buffer , 0 , count ) ; } catch ( Exception e1 ) { success = false ; } finally { try { if ( output != null ) output . close ( ) ; } catch ( Exception e2 ) { success = false ; } try { if ( input != null ) input . close ( ) ; } catch ( Exception e2 ) { } } if ( success ) success = tmp . renameTo ( file ) ; if ( tmp != null && tmp . exists ( ) ) if ( ! tmp . delete ( ) ) log ( " CopyResource ▁ failed ▁ to ▁ delete : ▁ " , tmp . toString ( ) ) ; return success ? null : " Unknown ▁ error . . . " ; }
tommista/android-net | static final void registerGson ( GsonBuilder gb ) { gb . registerTypeAdapter ( ObjectRef . class , AutoParcelAdapter . create ( AutoParcel_ObjectRef . class ) ) ; }
tommista/android-net | public static final Builder builder ( ) { return new AutoParcel_ObjectRef . Builder ( ) ; }
akhettar/camel | @ Converter public static ACK toACK ( String body ) throws HL7Exception { return toMessage ( ACK . class , body ) ; }
akhettar/camel | @ Converter public static ADR_A19 toAdrA19 ( String body ) throws HL7Exception { return toMessage ( ADR_A19 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A01 toAdtA01 ( String body ) throws HL7Exception { return toMessage ( ADT_A01 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A02 toAdtA02 ( String body ) throws HL7Exception { return toMessage ( ADT_A02 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A03 toAdtA03 ( String body ) throws HL7Exception { return toMessage ( ADT_A03 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A04 toAdtA04 ( String body ) throws HL7Exception { return toMessage ( ADT_A04 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A05 toAdtA05 ( String body ) throws HL7Exception { return toMessage ( ADT_A05 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A06 toAdtA06 ( String body ) throws HL7Exception { return toMessage ( ADT_A06 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A07 toAdtA07 ( String body ) throws HL7Exception { return toMessage ( ADT_A07 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A08 toAdtA08 ( String body ) throws HL7Exception { return toMessage ( ADT_A08 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A09 toAdtA09 ( String body ) throws HL7Exception { return toMessage ( ADT_A09 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A10 toAdtA10 ( String body ) throws HL7Exception { return toMessage ( ADT_A10 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A11 toAdtA11 ( String body ) throws HL7Exception { return toMessage ( ADT_A11 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A12 toAdtA12 ( String body ) throws HL7Exception { return toMessage ( ADT_A12 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A13 toAdtA13 ( String body ) throws HL7Exception { return toMessage ( ADT_A13 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A14 toAdtA14 ( String body ) throws HL7Exception { return toMessage ( ADT_A14 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A15 toAdtA15 ( String body ) throws HL7Exception { return toMessage ( ADT_A15 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A16 toAdtA16 ( String body ) throws HL7Exception { return toMessage ( ADT_A16 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A17 toAdtA17 ( String body ) throws HL7Exception { return toMessage ( ADT_A17 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A18 toAdtA18 ( String body ) throws HL7Exception { return toMessage ( ADT_A18 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A20 toAdtA20 ( String body ) throws HL7Exception { return toMessage ( ADT_A20 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A21 toAdtA21 ( String body ) throws HL7Exception { return toMessage ( ADT_A21 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A22 toAdtA22 ( String body ) throws HL7Exception { return toMessage ( ADT_A22 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A23 toAdtA23 ( String body ) throws HL7Exception { return toMessage ( ADT_A23 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A24 toAdtA24 ( String body ) throws HL7Exception { return toMessage ( ADT_A24 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A25 toAdtA25 ( String body ) throws HL7Exception { return toMessage ( ADT_A25 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A26 toAdtA26 ( String body ) throws HL7Exception { return toMessage ( ADT_A26 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A27 toAdtA27 ( String body ) throws HL7Exception { return toMessage ( ADT_A27 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A28 toAdtA28 ( String body ) throws HL7Exception { return toMessage ( ADT_A28 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A29 toAdtA29 ( String body ) throws HL7Exception { return toMessage ( ADT_A29 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A30 toAdtA30 ( String body ) throws HL7Exception { return toMessage ( ADT_A30 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A31 toAdtA31 ( String body ) throws HL7Exception { return toMessage ( ADT_A31 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A32 toAdtA32 ( String body ) throws HL7Exception { return toMessage ( ADT_A32 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A33 toAdtA33 ( String body ) throws HL7Exception { return toMessage ( ADT_A33 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A34 toAdtA34 ( String body ) throws HL7Exception { return toMessage ( ADT_A34 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A35 toAdtA35 ( String body ) throws HL7Exception { return toMessage ( ADT_A35 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A36 toAdtA36 ( String body ) throws HL7Exception { return toMessage ( ADT_A36 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A37 toAdtA37 ( String body ) throws HL7Exception { return toMessage ( ADT_A37 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A38 toAdtA38 ( String body ) throws HL7Exception { return toMessage ( ADT_A38 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A39 toAdtA39 ( String body ) throws HL7Exception { return toMessage ( ADT_A39 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A40 toAdtA40 ( String body ) throws HL7Exception { return toMessage ( ADT_A40 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A41 toAdtA41 ( String body ) throws HL7Exception { return toMessage ( ADT_A41 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A42 toAdtA42 ( String body ) throws HL7Exception { return toMessage ( ADT_A42 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A43 toAdtA43 ( String body ) throws HL7Exception { return toMessage ( ADT_A43 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A44 toAdtA44 ( String body ) throws HL7Exception { return toMessage ( ADT_A44 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A45 toAdtA45 ( String body ) throws HL7Exception { return toMessage ( ADT_A45 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A46 toAdtA46 ( String body ) throws HL7Exception { return toMessage ( ADT_A46 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A47 toAdtA47 ( String body ) throws HL7Exception { return toMessage ( ADT_A47 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A48 toAdtA48 ( String body ) throws HL7Exception { return toMessage ( ADT_A48 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A49 toAdtA49 ( String body ) throws HL7Exception { return toMessage ( ADT_A49 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A50 toAdtA50 ( String body ) throws HL7Exception { return toMessage ( ADT_A50 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_A51 toAdtA51 ( String body ) throws HL7Exception { return toMessage ( ADT_A51 . class , body ) ; }
akhettar/camel | @ Converter public static ADT_AXX toAdtAXX ( String body ) throws HL7Exception { return toMessage ( ADT_AXX . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P01 toBarP01 ( String body ) throws HL7Exception { return toMessage ( BAR_P01 . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P02 toBarP02 ( String body ) throws HL7Exception { return toMessage ( BAR_P02 . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P05 toBarP05 ( String body ) throws HL7Exception { return toMessage ( BAR_P05 . class , body ) ; }
akhettar/camel | @ Converter public static BAR_P06 toBarP06 ( String body ) throws HL7Exception { return toMessage ( BAR_P06 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C01 toCrmC01 ( String body ) throws HL7Exception { return toMessage ( CRM_C01 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C02 toCrmC02 ( String body ) throws HL7Exception { return toMessage ( CRM_C02 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C03 toCrmC03 ( String body ) throws HL7Exception { return toMessage ( CRM_C03 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C04 toCrmC04 ( String body ) throws HL7Exception { return toMessage ( CRM_C04 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C05 toCrmC05 ( String body ) throws HL7Exception { return toMessage ( CRM_C05 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C06 toCrmC06 ( String body ) throws HL7Exception { return toMessage ( CRM_C06 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C07 toCrmC07 ( String body ) throws HL7Exception { return toMessage ( CRM_C07 . class , body ) ; }
akhettar/camel | @ Converter public static CRM_C08 toCrmC08 ( String body ) throws HL7Exception { return toMessage ( CRM_C08 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C09 toCsuC09 ( String body ) throws HL7Exception { return toMessage ( CSU_C09 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C10 toCsuC10 ( String body ) throws HL7Exception { return toMessage ( CSU_C10 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C11 toCsuC11 ( String body ) throws HL7Exception { return toMessage ( CSU_C11 . class , body ) ; }
akhettar/camel | @ Converter public static CSU_C12 toCsuC12 ( String body ) throws HL7Exception { return toMessage ( CSU_C12 . class , body ) ; }
akhettar/camel | @ Converter public static DFT_P03 toDftP03 ( String body ) throws HL7Exception { return toMessage ( DFT_P03 . class , body ) ; }
akhettar/camel | @ Converter public static DOC_T12 toDocT12 ( String body ) throws HL7Exception { return toMessage ( DOC_T12 . class , body ) ; }
akhettar/camel | @ Converter public static DSR_Q01 toDsrQ01 ( String body ) throws HL7Exception { return toMessage ( DSR_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static DSR_Q03 toDsrQ03 ( String body ) throws HL7Exception { return toMessage ( DSR_Q03 . class , body ) ; }
akhettar/camel | @ Converter public static EDR_Q01 toEdrQ01 ( String body ) throws HL7Exception { return toMessage ( EDR_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static EQQ_Q01 toEqqQ01 ( String body ) throws HL7Exception { return toMessage ( EQQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static ERP_Q01 toErpQ01 ( String body ) throws HL7Exception { return toMessage ( ERP_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T01 toMdmT01 ( String body ) throws HL7Exception { return toMessage ( MDM_T01 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T02 toMdmT02 ( String body ) throws HL7Exception { return toMessage ( MDM_T02 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T03 toMdmT03 ( String body ) throws HL7Exception { return toMessage ( MDM_T03 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T04 toMdmT04 ( String body ) throws HL7Exception { return toMessage ( MDM_T04 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T05 toMdmT05 ( String body ) throws HL7Exception { return toMessage ( MDM_T05 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T06 toMdmT06 ( String body ) throws HL7Exception { return toMessage ( MDM_T06 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T07 toMdmT07 ( String body ) throws HL7Exception { return toMessage ( MDM_T07 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T08 toMdmT08 ( String body ) throws HL7Exception { return toMessage ( MDM_T08 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T09 toMdmT09 ( String body ) throws HL7Exception { return toMessage ( MDM_T09 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T10 toMdmT10 ( String body ) throws HL7Exception { return toMessage ( MDM_T10 . class , body ) ; }
akhettar/camel | @ Converter public static MDM_T11 toMdmT11 ( String body ) throws HL7Exception { return toMessage ( MDM_T11 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M01 toMfkM01 ( String body ) throws HL7Exception { return toMessage ( MFK_M01 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M02 toMfkM02 ( String body ) throws HL7Exception { return toMessage ( MFK_M02 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M03 toMfkM03 ( String body ) throws HL7Exception { return toMessage ( MFK_M03 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M04 toMfkM04 ( String body ) throws HL7Exception { return toMessage ( MFK_M04 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M05 toMfkM05 ( String body ) throws HL7Exception { return toMessage ( MFK_M05 . class , body ) ; }
akhettar/camel | @ Converter public static MFK_M07 toMfkM07 ( String body ) throws HL7Exception { return toMessage ( MFK_M07 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M01 toMfnM01 ( String body ) throws HL7Exception { return toMessage ( MFN_M01 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M02 toMfnM02 ( String body ) throws HL7Exception { return toMessage ( MFN_M02 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M03 toMfnM03 ( String body ) throws HL7Exception { return toMessage ( MFN_M03 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M04 toMfnM04 ( String body ) throws HL7Exception { return toMessage ( MFN_M04 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M05 toMfnM05 ( String body ) throws HL7Exception { return toMessage ( MFN_M05 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M06 toMfnM06 ( String body ) throws HL7Exception { return toMessage ( MFN_M06 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M07 toMfnM07 ( String body ) throws HL7Exception { return toMessage ( MFN_M07 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M08 toMfnM08 ( String body ) throws HL7Exception { return toMessage ( MFN_M08 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M09 toMfnM09 ( String body ) throws HL7Exception { return toMessage ( MFN_M09 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M10 toMfnM10 ( String body ) throws HL7Exception { return toMessage ( MFN_M10 . class , body ) ; }
akhettar/camel | @ Converter public static MFN_M11 toMfnM11 ( String body ) throws HL7Exception { return toMessage ( MFN_M11 . class , body ) ; }
akhettar/camel | @ Converter public static OMD_O01 toOmdO01 ( String body ) throws HL7Exception { return toMessage ( OMD_O01 . class , body ) ; }
akhettar/camel | @ Converter public static OMN_O01 toOmnO01 ( String body ) throws HL7Exception { return toMessage ( OMN_O01 . class , body ) ; }
akhettar/camel | @ Converter public static OMS_O01 toOmsO01 ( String body ) throws HL7Exception { return toMessage ( OMS_O01 . class , body ) ; }
akhettar/camel | @ Converter public static ORD_O02 toOrdO02 ( String body ) throws HL7Exception { return toMessage ( ORD_O02 . class , body ) ; }
akhettar/camel | @ Converter public static ORF_R02 toOrfR02 ( String body ) throws HL7Exception { return toMessage ( ORF_R02 . class , body ) ; }
akhettar/camel | @ Converter public static ORF_R04 toOrfR04 ( String body ) throws HL7Exception { return toMessage ( ORF_R04 . class , body ) ; }
akhettar/camel | @ Converter public static ORM_O01 toOrmO01 ( String body ) throws HL7Exception { return toMessage ( ORM_O01 . class , body ) ; }
akhettar/camel | @ Converter public static ORN_O02 toOrnO02 ( String body ) throws HL7Exception { return toMessage ( ORN_O02 . class , body ) ; }
akhettar/camel | @ Converter public static ORR_O02 toOrrO02 ( String body ) throws HL7Exception { return toMessage ( ORR_O02 . class , body ) ; }
akhettar/camel | @ Converter public static ORU_R01 toOruR01 ( String body ) throws HL7Exception { return toMessage ( ORU_R01 . class , body ) ; }
akhettar/camel | @ Converter public static OSQ_Q06 toOsqQ06 ( String body ) throws HL7Exception { return toMessage ( OSQ_Q06 . class , body ) ; }
akhettar/camel | @ Converter public static OSR_Q06 toOsrQ06 ( String body ) throws HL7Exception { return toMessage ( OSR_Q06 . class , body ) ; }
akhettar/camel | @ Converter public static PEX_P07 toPexP07 ( String body ) throws HL7Exception { return toMessage ( PEX_P07 . class , body ) ; }
akhettar/camel | @ Converter public static PEX_P08 toPexP08 ( String body ) throws HL7Exception { return toMessage ( PEX_P08 . class , body ) ; }
akhettar/camel | @ Converter public static PGL_PC6 toPglPc6 ( String body ) throws HL7Exception { return toMessage ( PGL_PC6 . class , body ) ; }
akhettar/camel | @ Converter public static PGL_PC7 toPglPc7 ( String body ) throws HL7Exception { return toMessage ( PGL_PC7 . class , body ) ; }
akhettar/camel | @ Converter public static PGL_PC8 toPglPc8 ( String body ) throws HL7Exception { return toMessage ( PGL_PC8 . class , body ) ; }
akhettar/camel | @ Converter public static PIN_I07 toPinI07 ( String body ) throws HL7Exception { return toMessage ( PIN_I07 . class , body ) ; }
akhettar/camel | @ Converter public static PPG_PCG toPpgPcg ( String body ) throws HL7Exception { return toMessage ( PPG_PCG . class , body ) ; }
akhettar/camel | @ Converter public static PPG_PCH toPpgPch ( String body ) throws HL7Exception { return toMessage ( PPG_PCH . class , body ) ; }
akhettar/camel | @ Converter public static PPG_PCJ toPpgPcj ( String body ) throws HL7Exception { return toMessage ( PPG_PCJ . class , body ) ; }
akhettar/camel | @ Converter public static PPP_PCB toPppPcb ( String body ) throws HL7Exception { return toMessage ( PPP_PCB . class , body ) ; }
akhettar/camel | @ Converter public static PPP_PCC toPppPcc ( String body ) throws HL7Exception { return toMessage ( PPP_PCC . class , body ) ; }
akhettar/camel | @ Converter public static PPP_PCD toPppPcd ( String body ) throws HL7Exception { return toMessage ( PPP_PCD . class , body ) ; }
akhettar/camel | @ Converter public static PPR_PC1 toPprPc1 ( String body ) throws HL7Exception { return toMessage ( PPR_PC1 . class , body ) ; }
akhettar/camel | @ Converter public static PPR_PC2 toPprPc2 ( String body ) throws HL7Exception { return toMessage ( PPR_PC2 . class , body ) ; }
akhettar/camel | @ Converter public static PPR_PC3 toPprPc3 ( String body ) throws HL7Exception { return toMessage ( PPR_PC3 . class , body ) ; }
akhettar/camel | @ Converter public static PPT_PCL toPptPcl ( String body ) throws HL7Exception { return toMessage ( PPT_PCL . class , body ) ; }
akhettar/camel | @ Converter public static PPV_PCA toPpvPca ( String body ) throws HL7Exception { return toMessage ( PPV_PCA . class , body ) ; }
akhettar/camel | @ Converter public static PRR_PC5 toPrrPc5 ( String body ) throws HL7Exception { return toMessage ( PRR_PC5 . class , body ) ; }
akhettar/camel | @ Converter public static PTR_PCF toPtrPcf ( String body ) throws HL7Exception { return toMessage ( PTR_PCF . class , body ) ; }
akhettar/camel | @ Converter public static QCK_Q02 toQckQ02 ( String body ) throws HL7Exception { return toMessage ( QCK_Q02 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_A19 toQryA19 ( String body ) throws HL7Exception { return toMessage ( QRY_A19 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PC4 toQryPC4 ( String body ) throws HL7Exception { return toMessage ( QRY_PC4 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PC9 toQryPC9 ( String body ) throws HL7Exception { return toMessage ( QRY_PC9 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PCE toQryPCE ( String body ) throws HL7Exception { return toMessage ( QRY_PCE . class , body ) ; }
akhettar/camel | @ Converter public static QRY_PCK toQryPCK ( String body ) throws HL7Exception { return toMessage ( QRY_PCK . class , body ) ; }
akhettar/camel | @ Converter public static QRY_Q01 toQryQ01 ( String body ) throws HL7Exception { return toMessage ( QRY_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_Q02 toQryQ02 ( String body ) throws HL7Exception { return toMessage ( QRY_Q02 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_R02 toQryR02 ( String body ) throws HL7Exception { return toMessage ( QRY_R02 . class , body ) ; }
akhettar/camel | @ Converter public static QRY_T12 toQryT12 ( String body ) throws HL7Exception { return toMessage ( QRY_T12 . class , body ) ; }
akhettar/camel | @ Converter public static RAR_RAR toRarRar ( String body ) throws HL7Exception { return toMessage ( RAR_RAR . class , body ) ; }
akhettar/camel | @ Converter public static RAS_O01 toRasO01 ( String body ) throws HL7Exception { return toMessage ( RAS_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RAS_O02 toRasO02 ( String body ) throws HL7Exception { return toMessage ( RAS_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RCI_I05 toRciI05 ( String body ) throws HL7Exception { return toMessage ( RCI_I05 . class , body ) ; }
akhettar/camel | @ Converter public static RCL_I06 toRclI06 ( String body ) throws HL7Exception { return toMessage ( RCL_I06 . class , body ) ; }
akhettar/camel | @ Converter public static RDE_O01 toRdeO01 ( String body ) throws HL7Exception { return toMessage ( RDE_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RDO_O01 toRdoO01 ( String body ) throws HL7Exception { return toMessage ( RDO_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RDR_RDR toRdrRdr ( String body ) throws HL7Exception { return toMessage ( RDR_RDR . class , body ) ; }
akhettar/camel | @ Converter public static RDS_O01 toRdsO01 ( String body ) throws HL7Exception { return toMessage ( RDS_O01 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I12 toRefI12 ( String body ) throws HL7Exception { return toMessage ( REF_I12 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I13 toRefI13 ( String body ) throws HL7Exception { return toMessage ( REF_I13 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I14 toRefI14 ( String body ) throws HL7Exception { return toMessage ( REF_I14 . class , body ) ; }
akhettar/camel | @ Converter public static REF_I15 toRefI15 ( String body ) throws HL7Exception { return toMessage ( REF_I15 . class , body ) ; }
akhettar/camel | @ Converter public static RER_RER toRerRer ( String body ) throws HL7Exception { return toMessage ( RER_RER . class , body ) ; }
akhettar/camel | @ Converter public static RGR_RGR toRgrRgr ( String body ) throws HL7Exception { return toMessage ( RGR_RGR . class , body ) ; }
akhettar/camel | @ Converter public static RGV_O01 toRgvO01 ( String body ) throws HL7Exception { return toMessage ( RGV_O01 . class , body ) ; }
akhettar/camel | @ Converter public static ROR_ROR toRorRor ( String body ) throws HL7Exception { return toMessage ( ROR_ROR . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I08 toRpaI08 ( String body ) throws HL7Exception { return toMessage ( RPA_I08 . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I09 toRpaI09 ( String body ) throws HL7Exception { return toMessage ( RPA_I09 . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I10 toRpaI10 ( String body ) throws HL7Exception { return toMessage ( RPA_I10 . class , body ) ; }
akhettar/camel | @ Converter public static RPA_I11 toRpaI11 ( String body ) throws HL7Exception { return toMessage ( RPA_I11 . class , body ) ; }
akhettar/camel | @ Converter public static RPI_I01 toRpiI01 ( String body ) throws HL7Exception { return toMessage ( RPI_I01 . class , body ) ; }
akhettar/camel | @ Converter public static RPI_I04 toRpiI04 ( String body ) throws HL7Exception { return toMessage ( RPI_I04 . class , body ) ; }
akhettar/camel | @ Converter public static RPL_I02 toRplI02 ( String body ) throws HL7Exception { return toMessage ( RPL_I02 . class , body ) ; }
akhettar/camel | @ Converter public static RPR_I03 toRprI03 ( String body ) throws HL7Exception { return toMessage ( RPR_I03 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I08 toRqaI08 ( String body ) throws HL7Exception { return toMessage ( RQA_I08 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I09 toRqaI09 ( String body ) throws HL7Exception { return toMessage ( RQA_I09 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I10 toRqaI10 ( String body ) throws HL7Exception { return toMessage ( RQA_I10 . class , body ) ; }
akhettar/camel | @ Converter public static RQA_I11 toRqaI11 ( String body ) throws HL7Exception { return toMessage ( RQA_I11 . class , body ) ; }
akhettar/camel | @ Converter public static RQC_I05 toRqcI05 ( String body ) throws HL7Exception { return toMessage ( RQC_I05 . class , body ) ; }
akhettar/camel | @ Converter public static RQC_I06 toRqcI06 ( String body ) throws HL7Exception { return toMessage ( RQC_I06 . class , body ) ; }
akhettar/camel | @ Converter public static RQI_I01 toRqiI01 ( String body ) throws HL7Exception { return toMessage ( RQI_I01 . class , body ) ; }
akhettar/camel | @ Converter public static RQI_I02 toRqiI02 ( String body ) throws HL7Exception { return toMessage ( RQI_I02 . class , body ) ; }
akhettar/camel | @ Converter public static RQI_I03 toRqiI03 ( String body ) throws HL7Exception { return toMessage ( RQI_I03 . class , body ) ; }
akhettar/camel | @ Converter public static RQP_I04 toRqpI04 ( String body ) throws HL7Exception { return toMessage ( RQP_I04 . class , body ) ; }
akhettar/camel | @ Converter public static RQQ_Q01 toRqqQ01 ( String body ) throws HL7Exception { return toMessage ( RQQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static RRA_O02 toRraO02 ( String body ) throws HL7Exception { return toMessage ( RRA_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RRD_O02 toRrdO02 ( String body ) throws HL7Exception { return toMessage ( RRD_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RRE_O01 toRreO01 ( String body ) throws HL7Exception { return toMessage ( RRE_O01 . class , body ) ; }
akhettar/camel | @ Converter public static RRG_O02 toRrgO02 ( String body ) throws HL7Exception { return toMessage ( RRG_O02 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I12 toRriI12 ( String body ) throws HL7Exception { return toMessage ( RRI_I12 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I13 toRriI13 ( String body ) throws HL7Exception { return toMessage ( RRI_I13 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I14 toRriI14 ( String body ) throws HL7Exception { return toMessage ( RRI_I14 . class , body ) ; }
akhettar/camel | @ Converter public static RRI_I15 toRriI15 ( String body ) throws HL7Exception { return toMessage ( RRI_I15 . class , body ) ; }
akhettar/camel | @ Converter public static RRO_O02 toRroO02 ( String body ) throws HL7Exception { return toMessage ( RRO_O02 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S12 toSiuS12 ( String body ) throws HL7Exception { return toMessage ( SIU_S12 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S13 toSiuS13 ( String body ) throws HL7Exception { return toMessage ( SIU_S13 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S14 toSiuS14 ( String body ) throws HL7Exception { return toMessage ( SIU_S14 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S15 toSiuS15 ( String body ) throws HL7Exception { return toMessage ( SIU_S15 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S16 toSiuS16 ( String body ) throws HL7Exception { return toMessage ( SIU_S16 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S17 toSiuS17 ( String body ) throws HL7Exception { return toMessage ( SIU_S17 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S18 toSiuS18 ( String body ) throws HL7Exception { return toMessage ( SIU_S18 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S19 toSiuS19 ( String body ) throws HL7Exception { return toMessage ( SIU_S19 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S20 toSiuS20 ( String body ) throws HL7Exception { return toMessage ( SIU_S20 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S21 toSiuS21 ( String body ) throws HL7Exception { return toMessage ( SIU_S21 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S22 toSiuS22 ( String body ) throws HL7Exception { return toMessage ( SIU_S22 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S23 toSiuS23 ( String body ) throws HL7Exception { return toMessage ( SIU_S23 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S24 toSiuS24 ( String body ) throws HL7Exception { return toMessage ( SIU_S24 . class , body ) ; }
akhettar/camel | @ Converter public static SIU_S26 toSiuS26 ( String body ) throws HL7Exception { return toMessage ( SIU_S26 . class , body ) ; }
akhettar/camel | @ Converter public static SPQ_Q01 toSpqQ01 ( String body ) throws HL7Exception { return toMessage ( SPQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static SQM_S25 toSqmS25 ( String body ) throws HL7Exception { return toMessage ( SQM_S25 . class , body ) ; }
akhettar/camel | @ Converter public static SQR_S25 toSqrS25 ( String body ) throws HL7Exception { return toMessage ( SQR_S25 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S01 toSrmS01 ( String body ) throws HL7Exception { return toMessage ( SRM_S01 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S02 toSrmS02 ( String body ) throws HL7Exception { return toMessage ( SRM_S02 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S03 toSrmS03 ( String body ) throws HL7Exception { return toMessage ( SRM_S03 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S04 toSrmS04 ( String body ) throws HL7Exception { return toMessage ( SRM_S04 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S05 toSrmS05 ( String body ) throws HL7Exception { return toMessage ( SRM_S05 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S06 toSrmS06 ( String body ) throws HL7Exception { return toMessage ( SRM_S06 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S07 toSrmS07 ( String body ) throws HL7Exception { return toMessage ( SRM_S07 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S08 toSrmS08 ( String body ) throws HL7Exception { return toMessage ( SRM_S08 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S09 toSrmS09 ( String body ) throws HL7Exception { return toMessage ( SRM_S09 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S10 toSrmS10 ( String body ) throws HL7Exception { return toMessage ( SRM_S10 . class , body ) ; }
akhettar/camel | @ Converter public static SRM_S11 toSrmS11 ( String body ) throws HL7Exception { return toMessage ( SRM_S11 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S01 toSrrS01 ( String body ) throws HL7Exception { return toMessage ( SRR_S01 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S02 toSrrS02 ( String body ) throws HL7Exception { return toMessage ( SRR_S02 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S03 toSrrS03 ( String body ) throws HL7Exception { return toMessage ( SRR_S03 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S04 toSrrS04 ( String body ) throws HL7Exception { return toMessage ( SRR_S04 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S05 toSrrS05 ( String body ) throws HL7Exception { return toMessage ( SRR_S05 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S06 toSrrS06 ( String body ) throws HL7Exception { return toMessage ( SRR_S06 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S07 toSrrS07 ( String body ) throws HL7Exception { return toMessage ( SRR_S07 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S08 toSrrS08 ( String body ) throws HL7Exception { return toMessage ( SRR_S08 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S09 toSrrS09 ( String body ) throws HL7Exception { return toMessage ( SRR_S09 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S10 toSrrS10 ( String body ) throws HL7Exception { return toMessage ( SRR_S10 . class , body ) ; }
akhettar/camel | @ Converter public static SRR_S11 toSrrS11 ( String body ) throws HL7Exception { return toMessage ( SRR_S11 . class , body ) ; }
akhettar/camel | @ Converter public static SUR_P09 toSurP09 ( String body ) throws HL7Exception { return toMessage ( SUR_P09 . class , body ) ; }
akhettar/camel | @ Converter public static TBR_Q01 toTbrQ01 ( String body ) throws HL7Exception { return toMessage ( TBR_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static UDM_Q05 toUdmQ05 ( String body ) throws HL7Exception { return toMessage ( UDM_Q05 . class , body ) ; }
akhettar/camel | @ Converter public static VQQ_Q01 toVqqQ01 ( String body ) throws HL7Exception { return toMessage ( VQQ_Q01 . class , body ) ; }
akhettar/camel | @ Converter public static VXQ_V01 toVxqV01 ( String body ) throws HL7Exception { return toMessage ( VXQ_V01 . class , body ) ; }
akhettar/camel | @ Converter public static VXR_V03 toVxrV03 ( String body ) throws HL7Exception { return toMessage ( VXR_V03 . class , body ) ; }
akhettar/camel | @ Converter public static VXU_V04 toVxuV04 ( String body ) throws HL7Exception { return toMessage ( VXU_V04 . class , body ) ; }
akhettar/camel | @ Converter public static VXX_V02 toVxxV02 ( String body ) throws HL7Exception { return toMessage ( VXX_V02 . class , body ) ; }
akhettar/camel | static < T extends Message > T toMessage ( Class < T > messageClass , String hl7String ) { try { T genericMessage = DEFAULT_CONTEXT . newMessage ( messageClass ) ; genericMessage . parse ( hl7String ) ; return genericMessage ; } catch ( HL7Exception conversionEx ) { throw new TypeConversionException ( hl7String , String . class , conversionEx ) ; } }
akhettar/camel | static < T extends Message > T toMessage ( Class < T > messageClass , byte [ ] hl7Bytes , Exchange exchange ) { try { T genericMessage = DEFAULT_CONTEXT . newMessage ( messageClass ) ; genericMessage . parse ( IOConverter . toString ( hl7Bytes , exchange ) ) ; return genericMessage ; } catch ( HL7Exception | IOException conversionEx ) { throw new TypeConversionException ( hl7Bytes , byte [ ] . class , conversionEx ) ; } }
impro3-nerdle/nerdle | public static SingletonGraph getInstance ( ) throws ConfigurationException { if ( SingletonGraph . instance == null ) { SingletonGraph . instance = new SingletonGraph ( ) ; } return SingletonGraph . instance ; }
mrodrigues/ASD-Teaching-Tool | public static Context getContext ( ) { return initialContext ; }
lifechurch/nuclei-android | public static Matcher < View > atPosition ( final int position , @ NonNull final Matcher < View > itemMatcher ) { return new BoundedMatcher < View , RecyclerView > ( RecyclerView . class ) { @ Override public void describeTo ( Description description ) { description . appendText ( " adapter ▁ position ▁ " + position + " : ▁ " ) ; itemMatcher . describeTo ( description ) ; } @ Override protected boolean matchesSafely ( final RecyclerView view ) { RecyclerView . ViewHolder viewHolder = view . findViewHolderForAdapterPosition ( position ) ; return viewHolder != null && itemMatcher . matches ( viewHolder . itemView ) ; } } ; }
lifechurch/nuclei-android | public static ViewAction scrollToPosition ( final int position ) { return new ViewAction ( ) { @ SuppressWarnings ( " unchecked " ) @ Override public Matcher < View > getConstraints ( ) { return isAssignableFrom ( RecyclerView . class ) ; } @ Override public void perform ( UiController uiController , View view ) { ( ( RecyclerView ) view ) . scrollToPosition ( position ) ; } @ Override public String getDescription ( ) { return " scroll ▁ to " ; } } ; }
SpannaProject/SpannaAPI | public static List < Command > parse ( Component component ) { List < Command > componentCmds = new ArrayList < Command > ( ) ; Map < String , Map < String , Object > > map = component . getDescription ( ) . getCommands ( ) ; if ( map == null ) { return componentCmds ; } for ( Entry < String , Map < String , Object > > entry : map . entrySet ( ) ) { if ( entry . getKey ( ) . contains ( " : " ) ) { Spanna . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ command ▁ " + entry . getKey ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; continue ; } Command newCmd = new ComponentCommand ( entry . getKey ( ) , component ) ; Object description = entry . getValue ( ) . get ( " description " ) ; Object usage = entry . getValue ( ) . get ( " usage " ) ; Object aliases = entry . getValue ( ) . get ( " aliases " ) ; Object permission = entry . getValue ( ) . get ( " permission " ) ; Object permissionMessage = entry . getValue ( ) . get ( " permission - message " ) ; if ( description != null ) { newCmd . setDescription ( description . toString ( ) ) ; } if ( usage != null ) { newCmd . setUsage ( usage . toString ( ) ) ; } if ( aliases != null ) { List < String > aliasList = new ArrayList < String > ( ) ; if ( aliases instanceof List ) { for ( Object o : ( List < ? > ) aliases ) { if ( o . toString ( ) . contains ( " : " ) ) { Spanna . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ alias ▁ " + o . toString ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; continue ; } aliasList . add ( o . toString ( ) ) ; } } else { if ( aliases . toString ( ) . contains ( " : " ) ) { Spanna . getServer ( ) . getLogger ( ) . severe ( " [ ERROR ] ▁ Could ▁ not ▁ load ▁ alias ▁ " + aliases . toString ( ) + " ▁ for ▁ component ▁ " + component . getName ( ) + " : ▁ Illegal ▁ Characters " ) ; } else { aliasList . add ( aliases . toString ( ) ) ; } } newCmd . setAliases ( aliasList ) ; } if ( permission != null ) { newCmd . setPermission ( permission . toString ( ) ) ; } if ( permissionMessage != null ) { newCmd . setPermissionMessage ( permissionMessage . toString ( ) ) ; } componentCmds . add ( newCmd ) ; } return componentCmds ; }
DDTH/ddth-queue | public static Test suite ( ) { return new TestSuite ( TestInmemQueueBoundSmallEphemeralDisabled . class ) ; }
IBM-Bluemix/BluemixBoutique | private static EntityManager getEm ( ) { InitialContext ic ; try { ic = new InitialContext ( ) ; return ( EntityManager ) ic . lookup ( " java : comp / env / bluemixboutiquepu / entitymanager " ) ; } catch ( NamingException e ) { System . out . println ( " ERROR ▁ obtaining ▁ EntityManager " ) ; e . printStackTrace ( ) ; } return null ; }
Java-Discord-Bot-System/JDA | public static OffsetDateTime getCreationTime ( String entityId ) { try { long timestamp = ( ( Long . parseLong ( entityId ) >> 22 ) + 1420070400000L ) ; Calendar gmt = Calendar . getInstance ( TimeZone . getTimeZone ( " GMT " ) ) ; gmt . setTimeInMillis ( timestamp ) ; return OffsetDateTime . ofInstant ( gmt . toInstant ( ) , gmt . getTimeZone ( ) . toZoneId ( ) ) ; } catch ( NumberFormatException ex ) { return null ; } }
Java-Discord-Bot-System/JDA | public static OffsetDateTime getCreationTime ( Object entity ) { try { Method idMethod = entity . getClass ( ) . getMethod ( " getId " ) ; if ( idMethod . getReturnType ( ) != String . class ) { JDAImpl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } String objId = ( String ) idMethod . invoke ( entity ) ; return getCreationTime ( objId ) ; } catch ( Exception e ) { JDAImpl . LOG . warn ( " Tried ▁ to ▁ look ▁ up ▁ creation - time ▁ for ▁ entity ▁ of ▁ class ▁ " + entity . getClass ( ) . getName ( ) + " ▁ which ▁ doesn ' t ▁ have ▁ the ▁ correct ▁ id ▁ getter " ) ; return null ; } }
Java-Discord-Bot-System/JDA | public static String getDateTimeString ( OffsetDateTime time ) { return time . format ( dtFormatter ) ; }
BryceARich/TransactionsMR | private static HttpServletRequest createMockRequest ( String handler , boolean taskQueueRequest , boolean ajaxRequest ) { HttpServletRequest request = createMock ( HttpServletRequest . class ) ; if ( taskQueueRequest ) { expect ( request . getHeader ( " X - AppEngine - QueueName " ) ) . andReturn ( " default " ) . anyTimes ( ) ; } else { expect ( request . getHeader ( " X - AppEngine - QueueName " ) ) . andReturn ( null ) . anyTimes ( ) ; } if ( ajaxRequest ) { expect ( request . getHeader ( " X - Requested - With " ) ) . andReturn ( " XMLHttpRequest " ) . anyTimes ( ) ; } else { expect ( request . getHeader ( " X - Requested - With " ) ) . andReturn ( null ) . anyTimes ( ) ; } expect ( request . getPathInfo ( ) ) . andReturn ( " / " + handler ) . anyTimes ( ) ; return request ; }
sapirgolan/MFIBlocking | public static String tokenTerm ( String inputTerm ) { StringBuilder builder = new StringBuilder ( ) ; try { TokenStream tokenStream = analyzer . tokenStream ( null , inputTerm ) ; OffsetAttribute offsetAttribute = tokenStream . addAttribute ( OffsetAttribute . class ) ; CharTermAttribute charTermAttribute = tokenStream . addAttribute ( CharTermAttribute . class ) ; tokenStream . reset ( ) ; while ( tokenStream . incrementToken ( ) ) { int startOffset = offsetAttribute . startOffset ( ) ; int endOffset = offsetAttribute . endOffset ( ) ; String term = charTermAttribute . toString ( ) ; builder . append ( term ) . append ( ' ▁ ' ) ; } tokenStream . end ( ) ; tokenStream . close ( ) ; } catch ( IOException e ) { logger . error ( " Failed ▁ to ▁ tokenize ▁ " + inputTerm , e ) ; } if ( builder . length ( ) != 0 ) { builder . deleteCharAt ( builder . length ( ) - 1 ) ; } return builder . toString ( ) ; }
xuegongzi/rabbitframework | public static < E > Set < E > asSet ( E ... elements ) { if ( elements == null || elements . length == 0 ) { return Collections . emptySet ( ) ; } if ( elements . length == 1 ) { return Collections . singleton ( elements [ 0 ] ) ; } LinkedHashSet < E > set = new LinkedHashSet < E > ( elements . length * 4 / 3 + 1 ) ; Collections . addAll ( set , elements ) ; return set ; }
xuegongzi/rabbitframework | public static boolean isEmpty ( Collection c ) { return c == null || c . isEmpty ( ) ; }
xuegongzi/rabbitframework | public static boolean isEmpty ( Map m ) { return m == null || m . isEmpty ( ) ; }
xuegongzi/rabbitframework | public static int size ( Collection c ) { return c != null ? c . size ( ) : 0 ; }
xuegongzi/rabbitframework | public static int size ( Map m ) { return m != null ? m . size ( ) : 0 ; }
xuegongzi/rabbitframework | public static boolean isEmpty ( PrincipalCollection principals ) { return principals == null || principals . isEmpty ( ) ; }
xuegongzi/rabbitframework | public static < E > List < E > asList ( E ... elements ) { if ( elements == null || elements . length == 0 ) { return Collections . emptyList ( ) ; } return Arrays . asList ( elements ) ; }
xuegongzi/rabbitframework | static int computeListCapacity ( int arraySize ) { return ( int ) Math . min ( 5L + arraySize + ( arraySize / 10 ) , Integer . MAX_VALUE ) ; }
ecarm002/incubator-asterixdb | public static final IFunctionDescriptorFactory FACTORY = new IFunctionDescriptorFactory ( ) { @ Override public IFunctionDescriptor createFunctionDescriptor ( ) { return new StringPositionDescriptor ( ) ; } @ Override public IFunctionTypeInferer createFunctionTypeInferer ( ) { return FunctionTypeInferers . SET_STRING_OFFSET ; } }
jalian-systems/marathonv5 | public static void main ( String [ ] args ) { launch ( args ) ; }
McJty/EFab | private static void rotateFacing ( TileEntity tileEntity ) { IBlockState state = tileEntity . getWorld ( ) . getBlockState ( tileEntity . getPos ( ) ) ; EnumFacing orientation = BaseBlock . getFrontDirection ( ModBlocks . gridBlock . getRotationType ( ) , state ) ; switch ( orientation ) { case NORTH : GlStateManager . rotate ( 180 , 0 , 1 , 0 ) ; break ; case SOUTH : break ; case WEST : GlStateManager . rotate ( 270 , 0 , 1 , 0 ) ; break ; case EAST : GlStateManager . rotate ( 90 , 0 , 1 , 0 ) ; break ; case DOWN : case UP : break ; } }
McJty/EFab | private static void renderHandle ( GridTE te , int x , int y , boolean half ) { ItemStack stackInSlot = te . getStackInSlot ( y * 3 + x ) ; if ( ! stackInSlot . isEmpty ( ) ) { renderItemStackInWorld ( new Vec3d ( x * .3 - .3 , .1 + ( half ? 0.2 : 1 ) , y * .3 - .3 ) , stackInSlot ) ; } }
McJty/EFab | private static void renderItemStackInWorld ( Vec3d offset , ItemStack stack ) { net . minecraft . client . renderer . RenderHelper . enableStandardItemLighting ( ) ; GlStateManager . translate ( offset . x , offset . y , offset . z ) ; renderItemCustom ( stack , 0 , 0.1f ) ; GlStateManager . translate ( - offset . x , - offset . y , - offset . z ) ; }
McJty/EFab | public static void renderItemCustom ( ItemStack is , int rotation , float scale ) { if ( ! is . isEmpty ( ) ) { GlStateManager . pushMatrix ( ) ; GlStateManager . scale ( scale , scale , scale ) ; if ( rotation != 0 ) { GlStateManager . rotate ( rotation , 0F , 1F , 0F ) ; } customRenderItem ( is ) ; GlStateManager . popMatrix ( ) ; } }
McJty/EFab | public static void customRenderItem ( ItemStack is ) { RenderItem renderItem = Minecraft . getMinecraft ( ) . getRenderItem ( ) ; TextureManager textureManager = Minecraft . getMinecraft ( ) . getTextureManager ( ) ; EntityPlayerSP player = Minecraft . getMinecraft ( ) . player ; IBakedModel ibakedmodel = renderItem . getItemModelWithOverrides ( is , player . getEntityWorld ( ) , player ) ; textureManager . bindTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) ; textureManager . getTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) . setBlurMipmap ( false , false ) ; preTransform ( renderItem , is ) ; GlStateManager . enableRescaleNormal ( ) ; GlStateManager . alphaFunc ( 516 , 0.1F ) ; GlStateManager . enableBlend ( ) ; GlStateManager . tryBlendFuncSeparate ( GlStateManager . SourceFactor . SRC_ALPHA , GlStateManager . DestFactor . ONE_MINUS_SRC_ALPHA , GlStateManager . SourceFactor . ONE , GlStateManager . DestFactor . ZERO ) ; GlStateManager . pushMatrix ( ) ; ibakedmodel = net . minecraftforge . client . ForgeHooksClient . handleCameraTransforms ( ibakedmodel , ItemCameraTransforms . TransformType . NONE , false ) ; renderItem . renderItem ( is , ibakedmodel ) ; GlStateManager . cullFace ( GlStateManager . CullFace . BACK ) ; GlStateManager . popMatrix ( ) ; GlStateManager . disableRescaleNormal ( ) ; GlStateManager . disableBlend ( ) ; textureManager . bindTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) ; textureManager . getTexture ( TextureMap . LOCATION_BLOCKS_TEXTURE ) . restoreLastBlurMipmap ( ) ; }
McJty/EFab | private static void preTransform ( RenderItem renderItem , ItemStack stack ) { IBakedModel ibakedmodel = renderItem . getItemModelMesher ( ) . getItemModel ( stack ) ; Item item = stack . getItem ( ) ; if ( item != null ) { boolean flag = ibakedmodel . isGui3d ( ) ; if ( ! flag ) { GlStateManager . scale ( 2.0F , 2.0F , 2.0F ) ; } GlStateManager . color ( 1.0F , 1.0F , 1.0F , 1.0F ) ; } }
McJty/EFab | public static void register ( ) { ClientRegistry . bindTileEntitySpecialRenderer ( GridTE . class , new GridRenderer ( ) ) ; }
samtingleff/dgrid | public static void main ( String [ ] args ) { System . out . println ( " Hello , ▁ world " ) ; }
facebook/fresco | public static String toString ( @ ImageLoadStatus int imageLoadStatus ) { switch ( imageLoadStatus ) { case ImageLoadStatus . REQUESTED : return " requested " ; case ImageLoadStatus . ORIGIN_AVAILABLE : return " origin _ available " ; case ImageLoadStatus . SUCCESS : return " success " ; case ImageLoadStatus . CANCELED : return " canceled " ; case ImageLoadStatus . INTERMEDIATE_AVAILABLE : return " intermediate _ available " ; case ImageLoadStatus . ERROR : return " error " ; default : return " unknown " ; } }
charlesccychen/beam | private static void checkBigQueryOptions ( String dataset , String table ) { Preconditions . checkArgument ( dataset != null , " Please ▁ specify ▁ - - bigQueryDataset ▁ option ▁ if ▁ you ▁ want ▁ to ▁ publish ▁ to ▁ BigQuery " ) ; Preconditions . checkArgument ( table != null , " Please ▁ specify ▁ - - bigQueryTable ▁ option ▁ if ▁ you ▁ want ▁ to ▁ publish ▁ to ▁ BigQuery " ) ; }
Kokil/opengse | public static MutableWebAppContextParam create ( ) { return new MutableWebAppContextParam ( ) ; }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getSSAVariables ( @ NotNull ControlFlow flow ) { return getSSAVariables ( flow , 0 , flow . getSize ( ) , false ) ; }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getSSAVariables ( @ NotNull ControlFlow flow , int from , int to , boolean reportVarsIfNonInitializingPathExists ) { List < Instruction > instructions = flow . getInstructions ( ) ; Collection < PsiVariable > writtenVariables = getWrittenVariables ( flow , from , to , false ) ; List < PsiVariable > result = new ArrayList < > ( 1 ) ; variables : for ( PsiVariable psiVariable : writtenVariables ) { final List < SSAInstructionState > queue = new ArrayList < > ( ) ; queue . add ( new SSAInstructionState ( 0 , from ) ) ; Set < SSAInstructionState > processedStates = new THashSet < > ( ) ; while ( ! queue . isEmpty ( ) ) { final SSAInstructionState state = queue . remove ( 0 ) ; if ( state . getWriteCount ( ) > 1 ) continue variables ; if ( ! processedStates . contains ( state ) ) { processedStates . add ( state ) ; int i = state . getInstructionIdx ( ) ; if ( i < to ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReturnInstruction ) { int [ ] offsets = ( ( ReturnInstruction ) instruction ) . getPossibleReturnOffsets ( ) ; for ( int offset : offsets ) { queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , Math . min ( offset , to ) ) ) ; } } else if ( instruction instanceof GoToInstruction ) { int nextOffset = ( ( GoToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; } else if ( instruction instanceof ThrowToInstruction ) { int nextOffset = ( ( ThrowToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; } else if ( instruction instanceof ConditionalGoToInstruction ) { int nextOffset = ( ( ConditionalGoToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } else if ( instruction instanceof ConditionalThrowToInstruction ) { int nextOffset = ( ( ConditionalThrowToInstruction ) instruction ) . offset ; nextOffset = Math . min ( nextOffset , to ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , nextOffset ) ) ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } else if ( instruction instanceof WriteVariableInstruction ) { WriteVariableInstruction write = ( WriteVariableInstruction ) instruction ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) + ( write . variable == psiVariable ? 1 : 0 ) , i + 1 ) ) ; } else if ( instruction instanceof ReadVariableInstruction ) { ReadVariableInstruction read = ( ReadVariableInstruction ) instruction ; if ( read . variable == psiVariable && state . getWriteCount ( ) == 0 ) continue variables ; queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } else { queue . add ( new SSAInstructionState ( state . getWriteCount ( ) , i + 1 ) ) ; } } else if ( ! reportVarsIfNonInitializingPathExists && state . getWriteCount ( ) == 0 ) continue variables ; } } result . add ( psiVariable ) ; } return result ; }
msebire/intellij-community | public static boolean needVariableValueAt ( @ NotNull PsiVariable variable , @ NotNull ControlFlow flow , final int offset ) { InstructionClientVisitor < Boolean > visitor = new InstructionClientVisitor < Boolean > ( ) { final boolean [ ] neededBelow = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void procedureEntered ( int startOffset , int endOffset ) { for ( int i = startOffset ; i < endOffset ; i ++ ) neededBelow [ i ] = false ; } @ Override public void visitReadVariableInstruction ( ReadVariableInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean needed = neededBelow [ nextOffset ] ; if ( instruction . variable . equals ( variable ) ) { needed = true ; } neededBelow [ offset ] |= needed ; } @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean needed = neededBelow [ nextOffset ] ; if ( instruction . variable . equals ( variable ) ) { needed = false ; } neededBelow [ offset ] = needed ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean needed = neededBelow [ nextOffset ] ; neededBelow [ offset ] |= needed ; } @ Override public Boolean getResult ( ) { return neededBelow [ offset ] ; } } ; depthFirstSearch ( flow , visitor , offset , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | @ NotNull public static Collection < PsiVariable > getWrittenVariables ( @ NotNull ControlFlow flow , int start , int end , final boolean ignoreNotReachingWrites ) { Set < PsiVariable > set = new HashSet < > ( ) ; getWrittenVariables ( flow , start , end , ignoreNotReachingWrites , set ) ; return set ; }
msebire/intellij-community | public static void getWrittenVariables ( @ NotNull ControlFlow flow , int start , int end , final boolean ignoreNotReachingWrites , @ NotNull Collection < ? super PsiVariable > set ) { List < Instruction > instructions = flow . getInstructions ( ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof WriteVariableInstruction && ( ! ignoreNotReachingWrites || isInstructionReachable ( flow , end , i ) ) ) { set . add ( ( ( WriteVariableInstruction ) instruction ) . variable ) ; } } }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getUsedVariables ( @ NotNull ControlFlow flow , int start , int end ) { List < PsiVariable > array = new ArrayList < > ( ) ; if ( start < 0 ) return array ; List < Instruction > instructions = flow . getInstructions ( ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { PsiVariable variable = ( ( ReadVariableInstruction ) instruction ) . variable ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } else if ( instruction instanceof WriteVariableInstruction ) { PsiVariable variable = ( ( WriteVariableInstruction ) instruction ) . variable ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } } return array ; }
msebire/intellij-community | public static boolean isVariableUsed ( @ NotNull ControlFlow flow , int start , int end , @ NotNull PsiVariable variable ) { List < Instruction > instructions = flow . getInstructions ( ) ; LOG . assertTrue ( start >= 0 , " flow ▁ start " ) ; LOG . assertTrue ( end <= instructions . size ( ) , " flow ▁ end " ) ; for ( int i = start ; i < end ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { if ( ( ( ReadVariableInstruction ) instruction ) . variable == variable ) { return true ; } } else if ( instruction instanceof WriteVariableInstruction ) { if ( ( ( WriteVariableInstruction ) instruction ) . variable == variable ) { return true ; } } } return false ; }
msebire/intellij-community | private static int findSingleReadOffset ( @ NotNull ControlFlow flow , int startOffset , int endOffset , @ NotNull PsiVariable variable ) { List < Instruction > instructions = flow . getInstructions ( ) ; if ( startOffset < 0 || endOffset < 0 || endOffset > instructions . size ( ) ) return - 1 ; int readOffset = - 1 ; for ( int i = startOffset ; i < endOffset ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { if ( ( ( ReadVariableInstruction ) instruction ) . variable == variable ) { if ( readOffset < 0 ) { readOffset = i ; } else { return - 1 ; } } } else if ( instruction instanceof WriteVariableInstruction ) { if ( ( ( WriteVariableInstruction ) instruction ) . variable == variable ) { return - 1 ; } } } return readOffset ; }
msebire/intellij-community | public static PsiReferenceExpression findSingleReadOccurrence ( @ NotNull ControlFlow flow , @ NotNull PsiElement element , @ NotNull PsiVariable variable ) { int readOffset = findSingleReadOffset ( flow , flow . getStartOffset ( element ) , flow . getEndOffset ( element ) , variable ) ; if ( readOffset >= 0 ) { PsiElement readElement = flow . getElement ( readOffset ) ; readElement = PsiTreeUtil . findFirstParent ( readElement , false , e -> e == element || e instanceof PsiReferenceExpression ) ; if ( readElement instanceof PsiReferenceExpression ) { return ( PsiReferenceExpression ) readElement ; } } return null ; }
msebire/intellij-community | public static boolean isVariableReadInFinally ( @ NotNull ControlFlow flow , @ Nullable PsiElement startElement , @ NotNull PsiElement enclosingCodeFragment , @ NotNull PsiVariable variable ) { for ( PsiElement element = startElement ; element != null && element != enclosingCodeFragment ; element = element . getParent ( ) ) { if ( element instanceof PsiCodeBlock ) { final PsiElement parent = element . getParent ( ) ; if ( parent instanceof PsiTryStatement ) { final PsiTryStatement tryStatement = ( PsiTryStatement ) parent ; if ( tryStatement . getTryBlock ( ) == element ) { final PsiCodeBlock finallyBlock = tryStatement . getFinallyBlock ( ) ; if ( finallyBlock != null ) { final List < Instruction > instructions = flow . getInstructions ( ) ; final int startOffset = flow . getStartOffset ( finallyBlock ) ; final int endOffset = flow . getEndOffset ( finallyBlock ) ; LOG . assertTrue ( startOffset >= 0 , " flow ▁ start " ) ; LOG . assertTrue ( endOffset <= instructions . size ( ) , " flow ▁ end " ) ; for ( int i = startOffset ; i < endOffset ; i ++ ) { final Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction && ( ( ReadVariableInstruction ) instruction ) . variable == variable ) { return true ; } } } } } } } return false ; }
msebire/intellij-community | @ NotNull public static List < PsiVariable > getInputVariables ( @ NotNull ControlFlow flow , int start , int end ) { List < PsiVariable > usedVariables = getUsedVariables ( flow , start , end ) ; List < PsiVariable > array = new ArrayList < > ( usedVariables . size ( ) ) ; for ( PsiVariable variable : usedVariables ) { if ( needVariableValueAt ( variable , flow , start ) ) { array . add ( variable ) ; } } return array ; }
msebire/intellij-community | @ NotNull public static PsiVariable [ ] getOutputVariables ( @ NotNull ControlFlow flow , int start , int end , @ NotNull int [ ] exitPoints ) { Collection < PsiVariable > writtenVariables = getWrittenVariables ( flow , start , end , false ) ; List < PsiVariable > array = new ArrayList < > ( ) ; for ( PsiVariable variable : writtenVariables ) { for ( int exitPoint : exitPoints ) { if ( needVariableValueAt ( variable , flow , exitPoint ) ) { array . add ( variable ) ; } } } PsiVariable [ ] outputVariables = array . toArray ( new PsiVariable [ 0 ] ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( " output ▁ variables : " ) ; for ( PsiVariable variable : outputVariables ) { LOG . debug ( " ▁ ▁ " + variable ) ; } } return outputVariables ; }
msebire/intellij-community | @ NotNull public static Collection < PsiStatement > findExitPointsAndStatements ( @ NotNull ControlFlow flow , final int start , final int end , @ NotNull IntArrayList exitPoints , @ NotNull Class < ? extends PsiStatement > ... classesFilter ) { if ( end == start ) { exitPoints . add ( end ) ; return Collections . emptyList ( ) ; } final Collection < PsiStatement > exitStatements = new THashSet < > ( ) ; InstructionClientVisitor visitor = new InstructionClientVisitor ( ) { @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { processGotoStatement ( exitStatements , findStatement ( flow , offset ) , classesFilter ) ; } @ Override public void visitBranchingInstruction ( BranchingInstruction instruction , int offset , int nextOffset ) { processGoto ( flow , start , end , exitPoints , exitStatements , instruction , findStatement ( flow , offset ) , classesFilter ) ; } @ Override public void visitReturnInstruction ( ReturnInstruction instruction , int offset , int nextOffset ) { } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { visitInstruction ( instruction , offset , nextOffset ) ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( offset >= end - 1 ) { int exitOffset = end ; exitOffset = promoteThroughGotoChain ( flow , exitOffset ) ; if ( ! exitPoints . contains ( exitOffset ) ) { exitPoints . add ( exitOffset ) ; } } } @ Override public Object getResult ( ) { return null ; } } ; depthFirstSearch ( flow , visitor , start , end ) ; return exitStatements ; }
msebire/intellij-community | private static void processGoto ( @ NotNull ControlFlow flow , int start , int end , @ NotNull IntArrayList exitPoints , @ NotNull Collection < ? super PsiStatement > exitStatements , @ NotNull BranchingInstruction instruction , final PsiStatement statement , @ NotNull Class ... classesFilter ) { if ( statement == null ) return ; int gotoOffset = instruction . offset ; if ( start > gotoOffset || gotoOffset >= end || isElementOfClass ( statement , classesFilter ) ) { gotoOffset = promoteThroughGotoChain ( flow , gotoOffset ) ; if ( gotoOffset > 0 && ( gotoOffset >= end || gotoOffset < start ) && ! exitPoints . contains ( gotoOffset ) ) { exitPoints . add ( gotoOffset ) ; } if ( gotoOffset >= end || gotoOffset < start ) { processGotoStatement ( exitStatements , statement , classesFilter ) ; } else { boolean isReturn = instruction instanceof GoToInstruction && ( ( GoToInstruction ) instruction ) . isReturn ; final Instruction gotoInstruction = flow . getInstructions ( ) . get ( gotoOffset ) ; isReturn |= gotoInstruction instanceof GoToInstruction && ( ( GoToInstruction ) gotoInstruction ) . isReturn ; if ( isReturn ) { processGotoStatement ( exitStatements , statement , classesFilter ) ; } } } }
msebire/intellij-community | private static void processGotoStatement ( @ NotNull Collection < ? super PsiStatement > exitStatements , PsiStatement statement , @ NotNull Class ... classesFilter ) { if ( statement != null && isElementOfClass ( statement , classesFilter ) ) { exitStatements . add ( statement ) ; } }
msebire/intellij-community | private static boolean isElementOfClass ( @ NotNull PsiElement element , @ NotNull Class ... classesFilter ) { for ( Class aClassesFilter : classesFilter ) { if ( ReflectionUtil . isAssignable ( aClassesFilter , element . getClass ( ) ) ) { return true ; } } return false ; }
msebire/intellij-community | private static int promoteThroughGotoChain ( @ NotNull ControlFlow flow , int offset ) { List < Instruction > instructions = flow . getInstructions ( ) ; while ( true ) { if ( offset >= instructions . size ( ) ) break ; Instruction instruction = instructions . get ( offset ) ; if ( ! ( instruction instanceof GoToInstruction ) || ( ( GoToInstruction ) instruction ) . isReturn ) break ; offset = ( ( BranchingInstruction ) instruction ) . offset ; } return offset ; }
msebire/intellij-community | private static PsiStatement findStatement ( @ NotNull ControlFlow flow , int offset ) { PsiElement element = flow . getElement ( offset ) ; return PsiTreeUtil . getParentOfType ( element , PsiStatement . class , false ) ; }
msebire/intellij-community | public static boolean hasObservableThrowExitPoints ( @ NotNull final ControlFlow flow , final int flowStart , final int flowEnd , @ NotNull PsiElement [ ] elements , @ NotNull PsiElement enclosingCodeFragment ) { final List < Instruction > instructions = flow . getInstructions ( ) ; class Worker { @ NotNull private Map < PsiVariable , IntArrayList > getWritesOffsets ( ) { final Map < PsiVariable , IntArrayList > writeOffsets = new THashMap < > ( ) ; for ( int i = flowStart ; i < flowEnd ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof WriteVariableInstruction ) { final PsiVariable variable = ( ( WriteVariableInstruction ) instruction ) . variable ; if ( variable instanceof PsiLocalVariable || variable instanceof PsiParameter ) { IntArrayList offsets = writeOffsets . get ( variable ) ; if ( offsets == null ) writeOffsets . put ( variable , offsets = new IntArrayList ( ) ) ; offsets . add ( i ) ; } } } LOG . debug ( " writeOffsets : " , writeOffsets ) ; return writeOffsets ; } @ NotNull private Map < PsiVariable , IntArrayList > getVisibleReadsOffsets ( @ NotNull Map < PsiVariable , IntArrayList > writeOffsets , @ NotNull PsiCodeBlock tryBlock ) { final Map < PsiVariable , IntArrayList > visibleReadOffsets = new THashMap < > ( ) ; for ( PsiVariable variable : writeOffsets . keySet ( ) ) { if ( ! PsiTreeUtil . isAncestor ( tryBlock , variable , true ) ) { visibleReadOffsets . put ( variable , new IntArrayList ( ) ) ; } } if ( visibleReadOffsets . isEmpty ( ) ) return visibleReadOffsets ; for ( int i = 0 ; i < instructions . size ( ) ; i ++ ) { final Instruction instruction = instructions . get ( i ) ; if ( instruction instanceof ReadVariableInstruction ) { final PsiVariable variable = ( ( ReadVariableInstruction ) instruction ) . variable ; final IntArrayList readOffsets = visibleReadOffsets . get ( variable ) ; if ( readOffsets != null ) { readOffsets . add ( i ) ; } } } LOG . debug ( " visibleReadOffsets : " , visibleReadOffsets ) ; return visibleReadOffsets ; } @ NotNull private Map < PsiVariable , Set < PsiElement > > getReachableAfterWrite ( @ NotNull Map < PsiVariable , IntArrayList > writeOffsets , @ NotNull Map < PsiVariable , IntArrayList > visibleReadOffsets ) { final Map < PsiVariable , Set < PsiElement > > afterWrite = new THashMap < > ( ) ; for ( PsiVariable variable : visibleReadOffsets . keySet ( ) ) { final Function < Integer , BitSet > calculator = getReachableInstructionsCalculator ( ) ; final BitSet collectedOffsets = new BitSet ( flowEnd ) ; for ( final int writeOffset : writeOffsets . get ( variable ) . toArray ( ) ) { LOG . assertTrue ( writeOffset >= flowStart , " writeOffset " ) ; final BitSet reachableOffsets = calculator . fun ( writeOffset ) ; collectedOffsets . or ( reachableOffsets ) ; } Set < PsiElement > throwSources = afterWrite . get ( variable ) ; if ( throwSources == null ) afterWrite . put ( variable , throwSources = new THashSet < > ( ) ) ; for ( int i = flowStart ; i < flowEnd ; i ++ ) { if ( collectedOffsets . get ( i ) ) { throwSources . add ( flow . getElement ( i ) ) ; } } final List < PsiElement > subordinates = new ArrayList < > ( ) ; for ( PsiElement element : throwSources ) { if ( throwSources . contains ( element . getParent ( ) ) ) { subordinates . add ( element ) ; } } throwSources . removeAll ( subordinates ) ; } LOG . debug ( " afterWrite : " , afterWrite ) ; return afterWrite ; } @ NotNull private IntArrayList getCatchOrFinallyOffsets ( @ NotNull List < ? extends PsiTryStatement > tryStatements , @ NotNull List < ? extends PsiClassType > thrownExceptions ) { final IntArrayList catchOrFinallyOffsets = new IntArrayList ( ) ; for ( PsiTryStatement tryStatement : tryStatements ) { final PsiCodeBlock finallyBlock = tryStatement . getFinallyBlock ( ) ; if ( finallyBlock != null ) { int offset = flow . getStartOffset ( finallyBlock ) ; if ( offset >= 0 ) { catchOrFinallyOffsets . add ( offset - 2 ) ; } } for ( PsiCatchSection catchSection : tryStatement . getCatchSections ( ) ) { final PsiCodeBlock catchBlock = catchSection . getCatchBlock ( ) ; final PsiParameter parameter = catchSection . getParameter ( ) ; if ( catchBlock != null && parameter != null ) { for ( PsiClassType throwType : thrownExceptions ) { if ( isCaughtExceptionType ( throwType , parameter . getType ( ) ) ) { int offset = flow . getStartOffset ( catchBlock ) ; if ( offset >= 0 ) { catchOrFinallyOffsets . add ( offset - 1 ) ; } } } } } } return catchOrFinallyOffsets ; } private boolean isAnyReadOffsetReachableFrom ( @ Nullable IntArrayList readOffsets , @ NotNull IntArrayList fromOffsets ) { if ( readOffsets != null && ! readOffsets . isEmpty ( ) ) { final int [ ] readOffsetsArray = readOffsets . toArray ( ) ; for ( int j = 0 ; j < fromOffsets . size ( ) ; j ++ ) { int fromOffset = fromOffsets . get ( j ) ; if ( areInstructionsReachable ( flow , readOffsetsArray , fromOffset ) ) { LOG . debug ( " reachableFromOffset : " , fromOffset ) ; return true ; } } } return false ; } @ NotNull private Function < Integer , BitSet > getReachableInstructionsCalculator ( ) { final ControlFlowGraph graph = new ControlFlowGraph ( flow . getSize ( ) ) { @ Override void addArc ( int offset , int nextOffset ) { nextOffset = promoteThroughGotoChain ( flow , nextOffset ) ; if ( nextOffset >= flowStart && nextOffset < flowEnd ) { super . addArc ( offset , nextOffset ) ; } } } ; graph . buildFrom ( flow ) ; return startOffset -> { BitSet visitedOffsets = new BitSet ( flowEnd ) ; graph . depthFirstSearch ( startOffset , visitedOffsets ) ; return visitedOffsets ; } ; } } final Worker worker = new Worker ( ) ; final Map < PsiVariable , IntArrayList > writeOffsets = worker . getWritesOffsets ( ) ; if ( writeOffsets . isEmpty ( ) ) return false ; final PsiElement commonParent = elements . length != 1 ? PsiTreeUtil . findCommonParent ( elements ) : elements [ 0 ] . getParent ( ) ; final List < PsiTryStatement > tryStatements = collectTryStatementStack ( commonParent , enclosingCodeFragment ) ; if ( tryStatements . isEmpty ( ) ) return false ; final PsiCodeBlock tryBlock = tryStatements . get ( 0 ) . getTryBlock ( ) ; if ( tryBlock == null ) return false ; final Map < PsiVariable , IntArrayList > visibleReadOffsets = worker . getVisibleReadsOffsets ( writeOffsets , tryBlock ) ; if ( visibleReadOffsets . isEmpty ( ) ) return false ; final Map < PsiVariable , Set < PsiElement > > afterWrite = worker . getReachableAfterWrite ( writeOffsets , visibleReadOffsets ) ; if ( afterWrite . isEmpty ( ) ) return false ; for ( Map . Entry < PsiVariable , Set < PsiElement > > entry : afterWrite . entrySet ( ) ) { final PsiVariable variable = entry . getKey ( ) ; final PsiElement [ ] psiElements = entry . getValue ( ) . toArray ( PsiElement . EMPTY_ARRAY ) ; final List < PsiClassType > thrownExceptions = ExceptionUtil . getThrownExceptions ( psiElements ) ; if ( ! thrownExceptions . isEmpty ( ) ) { final IntArrayList catchOrFinallyOffsets = worker . getCatchOrFinallyOffsets ( tryStatements , thrownExceptions ) ; if ( worker . isAnyReadOffsetReachableFrom ( visibleReadOffsets . get ( variable ) , catchOrFinallyOffsets ) ) { return true ; } } } return false ; }
msebire/intellij-community | @ Nullable private static PsiTryStatement getEnclosingTryStatementHavingCatchOrFinally ( @ Nullable PsiElement startElement , @ NotNull PsiElement enclosingCodeFragment ) { for ( PsiElement element = startElement ; element != null && element != enclosingCodeFragment ; element = element . getParent ( ) ) { if ( element instanceof PsiCodeBlock ) { final PsiElement parent = element . getParent ( ) ; if ( parent instanceof PsiTryStatement ) { final PsiTryStatement tryStatement = ( PsiTryStatement ) parent ; if ( tryStatement . getTryBlock ( ) == element && ( tryStatement . getFinallyBlock ( ) != null || tryStatement . getCatchBlocks ( ) . length != 0 ) ) { return tryStatement ; } } } } return null ; }
msebire/intellij-community | @ NotNull private static List < PsiTryStatement > collectTryStatementStack ( @ Nullable PsiElement startElement , @ NotNull PsiElement enclosingCodeFragment ) { final List < PsiTryStatement > stack = new ArrayList < > ( ) ; for ( PsiTryStatement tryStatement = getEnclosingTryStatementHavingCatchOrFinally ( startElement , enclosingCodeFragment ) ; tryStatement != null ; tryStatement = getEnclosingTryStatementHavingCatchOrFinally ( tryStatement , enclosingCodeFragment ) ) { stack . add ( tryStatement ) ; } return stack ; }
msebire/intellij-community | @ NotNull public static PsiElement findCodeFragment ( @ NotNull PsiElement element ) { PsiElement codeFragment = element ; PsiElement parent = codeFragment . getParent ( ) ; while ( parent != null ) { if ( parent instanceof PsiDirectory || parent instanceof PsiMethod || parent instanceof PsiField || parent instanceof PsiClassInitializer || parent instanceof DummyHolder || parent instanceof PsiLambdaExpression ) { break ; } codeFragment = parent ; parent = parent . getParent ( ) ; } return codeFragment ; }
msebire/intellij-community | private static boolean checkReferenceExpressionScope ( @ NotNull PsiReferenceExpression ref , @ NotNull PsiElement targetClassMember ) { final JavaResolveResult resolveResult = ref . advancedResolve ( false ) ; final PsiElement def = resolveResult . getElement ( ) ; if ( def != null ) { PsiElement parent = def . getParent ( ) ; PsiElement commonParent = parent == null ? null : PsiTreeUtil . findCommonParent ( parent , targetClassMember ) ; if ( commonParent == null ) { parent = resolveResult . getCurrentFileResolveScope ( ) ; } if ( parent instanceof PsiClass ) { final PsiClass clss = ( PsiClass ) parent ; if ( PsiTreeUtil . isAncestor ( targetClassMember , clss , false ) ) return false ; PsiClass containingClass = PsiTreeUtil . getParentOfType ( ref , PsiClass . class ) ; while ( containingClass != null ) { if ( containingClass . isInheritor ( clss , true ) && PsiTreeUtil . isAncestor ( targetClassMember , containingClass , false ) ) { return false ; } containingClass = containingClass . getContainingClass ( ) ; } } } return true ; }
msebire/intellij-community | public static boolean collectOuterLocals ( @ NotNull List < ? super PsiVariable > array , @ NotNull PsiElement scope , @ NotNull PsiElement member , @ NotNull PsiElement targetClassMember ) { if ( scope instanceof PsiMethodCallExpression ) { final PsiMethodCallExpression call = ( PsiMethodCallExpression ) scope ; if ( ! checkReferenceExpressionScope ( call . getMethodExpression ( ) , targetClassMember ) ) { return false ; } } else if ( scope instanceof PsiReferenceExpression ) { if ( ! checkReferenceExpressionScope ( ( PsiReferenceExpression ) scope , targetClassMember ) ) { return false ; } } if ( scope instanceof PsiJavaCodeReferenceElement ) { final PsiJavaCodeReferenceElement ref = ( PsiJavaCodeReferenceElement ) scope ; final JavaResolveResult result = ref . advancedResolve ( false ) ; final PsiElement refElement = result . getElement ( ) ; if ( refElement != null ) { PsiElement parent = refElement . getParent ( ) ; parent = parent != null ? PsiTreeUtil . findCommonParent ( parent , member ) : null ; if ( parent == null ) { parent = result . getCurrentFileResolveScope ( ) ; } if ( parent != null && ! member . equals ( parent ) ) { parent = PsiTreeUtil . findCommonParent ( parent , targetClassMember ) ; if ( targetClassMember . equals ( parent ) ) { if ( refElement instanceof PsiVariable ) { if ( scope instanceof PsiReferenceExpression && PsiUtil . isAccessedForWriting ( ( PsiReferenceExpression ) scope ) ) { return false ; } PsiVariable variable = ( PsiVariable ) refElement ; if ( ! array . contains ( variable ) ) { array . add ( variable ) ; } } else { return false ; } } } } } else if ( scope instanceof PsiThisExpression ) { PsiJavaCodeReferenceElement qualifier = ( ( PsiThisExpression ) scope ) . getQualifier ( ) ; if ( qualifier == null ) { return false ; } } else if ( scope instanceof PsiSuperExpression ) { if ( ( ( PsiSuperExpression ) scope ) . getQualifier ( ) == null ) { return false ; } } for ( PsiElement child = scope . getFirstChild ( ) ; child != null ; child = child . getNextSibling ( ) ) { if ( ! collectOuterLocals ( array , child , member , targetClassMember ) ) return false ; } return true ; }
msebire/intellij-community | public static boolean returnPresent ( @ NotNull ControlFlow flow ) { InstructionClientVisitor < Boolean > visitor = new ReturnPresentClientVisitor ( flow ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean processReturns ( @ NotNull ControlFlow flow , @ NotNull ReturnStatementsVisitor afterVisitor ) throws IncorrectOperationException { final ConvertReturnClientVisitor instructionsVisitor = new ConvertReturnClientVisitor ( flow , afterVisitor ) ; depthFirstSearch ( flow , instructionsVisitor ) ; instructionsVisitor . afterProcessing ( ) ; return instructionsVisitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean returnPresentBetween ( @ NotNull ControlFlow flow , final int startOffset , final int endOffset ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] isNormalCompletion = new boolean [ flow . getSize ( ) + 1 ] ; MyVisitor ( ) { int i ; final int length = flow . getSize ( ) ; for ( i = 0 ; i < startOffset ; i ++ ) { isNormalCompletion [ i ] = true ; } for ( i = endOffset ; i <= length ; i ++ ) { isNormalCompletion [ i ] = true ; } } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; int throwToOffset = instruction . offset ; boolean isNormal ; if ( throwToOffset == nextOffset ) { if ( throwToOffset <= endOffset ) { isNormal = ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] ; } else { return ; } } else { isNormal = isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; } isNormalCompletion [ offset ] |= isNormal ; } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset <= endOffset ) { boolean isNormal = ! isLeaf ( nextOffset ) && isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; } } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset > endOffset && nextOffset != offset + 1 ) { return ; } boolean isNormal = isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; } @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; boolean isRethrowFromFinally = instruction instanceof ReturnInstruction && ( ( ReturnInstruction ) instruction ) . isRethrowFromFinally ( ) ; boolean isNormal = ! instruction . isReturn && isNormalCompletion [ nextOffset ] && ! isRethrowFromFinally ; isNormalCompletion [ offset ] |= isNormal ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; final boolean isNormal = isLeaf ( nextOffset ) || isNormalCompletion [ nextOffset ] ; isNormalCompletion [ offset ] |= isNormal ; } @ Override @ NotNull public Boolean getResult ( ) { return ! isNormalCompletion [ startOffset ] ; } } final MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , endOffset ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean canCompleteNormally ( @ NotNull ControlFlow flow , final int startOffset , final int endOffset ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] canCompleteNormally = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visitConditionalGoToInstruction ( ConditionalGoToInstruction instruction , int offset , int nextOffset ) { checkInstruction ( offset , nextOffset , false ) ; } @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { checkInstruction ( offset , nextOffset , instruction . isReturn ) ; } private void checkInstruction ( int offset , int nextOffset , boolean isReturn ) { if ( offset > endOffset ) return ; if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean isNormal = nextOffset <= endOffset && ! isReturn && ( nextOffset == endOffset || canCompleteNormally [ nextOffset ] ) ; if ( isNormal && nextOffset == endOffset ) { PsiElement element = flow . getElement ( offset ) ; if ( element instanceof PsiBreakStatement ) { PsiStatement exitedStatement = ( ( PsiBreakStatement ) element ) . findExitedStatement ( ) ; if ( exitedStatement == null || flow . getStartOffset ( exitedStatement ) < startOffset ) { isNormal = false ; } } else if ( element instanceof PsiContinueStatement ) { PsiStatement continuedStatement = ( ( PsiContinueStatement ) element ) . findContinuedStatement ( ) ; if ( continuedStatement == null || flow . getStartOffset ( continuedStatement ) < startOffset ) { isNormal = false ; } } } canCompleteNormally [ offset ] |= isNormal ; } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; int throwToOffset = instruction . offset ; boolean isNormal ; if ( throwToOffset == nextOffset ) { isNormal = throwToOffset <= endOffset && ! isLeaf ( nextOffset ) && canCompleteNormally [ nextOffset ] ; } else { isNormal = canCompleteNormally [ nextOffset ] ; } canCompleteNormally [ offset ] |= isNormal ; } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset <= endOffset ) { boolean isNormal = ! isLeaf ( nextOffset ) && canCompleteNormally [ nextOffset ] ; canCompleteNormally [ offset ] |= isNormal ; } } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( offset > endOffset ) return ; if ( nextOffset > endOffset && nextOffset != offset + 1 ) { return ; } boolean isNormal = canCompleteNormally [ nextOffset ] ; canCompleteNormally [ offset ] |= isNormal ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { checkInstruction ( offset , nextOffset , false ) ; } @ Override @ NotNull public Boolean getResult ( ) { return canCompleteNormally [ startOffset ] ; } } final MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , endOffset ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static PsiElement getUnreachableStatement ( @ NotNull ControlFlow flow ) { final InstructionClientVisitor < PsiElement > visitor = new UnreachableStatementClientVisitor ( flow ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | @ Nullable private static PsiElement getUnreachableExpressionParent ( @ Nullable PsiElement element ) { if ( element instanceof PsiExpression ) { final PsiElement expression = PsiTreeUtil . findFirstParent ( element , e -> ! ( e . getParent ( ) instanceof PsiParenthesizedExpression ) ) ; if ( expression != null ) { final PsiElement parent = expression . getParent ( ) ; if ( parent instanceof PsiExpressionStatement ) { return getUnreachableStatementParent ( parent ) ; } if ( parent instanceof PsiIfStatement && ( ( PsiIfStatement ) parent ) . getCondition ( ) == expression || parent instanceof PsiSwitchBlock && ( ( PsiSwitchBlock ) parent ) . getExpression ( ) == expression || parent instanceof PsiWhileStatement && ( ( PsiWhileStatement ) parent ) . getCondition ( ) == expression || parent instanceof PsiForeachStatement && ( ( PsiForeachStatement ) parent ) . getIteratedValue ( ) == expression ) { return parent ; } } } return null ; }
msebire/intellij-community | @ Nullable private static PsiElement getEnclosingUnreachableStatement ( @ NotNull PsiElement statement ) { final PsiElement parent = statement . getParent ( ) ; if ( parent instanceof PsiDoWhileStatement && ( ( PsiDoWhileStatement ) parent ) . getBody ( ) == statement ) { return parent ; } if ( parent instanceof PsiCodeBlock && PsiTreeUtil . getNextSiblingOfType ( parent . getFirstChild ( ) , PsiStatement . class ) == statement ) { final PsiBlockStatement blockStatement = ObjectUtils . tryCast ( parent . getParent ( ) , PsiBlockStatement . class ) ; if ( blockStatement != null ) { final PsiElement blockParent = blockStatement . getParent ( ) ; if ( blockParent instanceof PsiDoWhileStatement && ( ( PsiDoWhileStatement ) blockParent ) . getBody ( ) == blockStatement ) { return blockParent ; } } } return getUnreachableStatementParent ( statement ) ; }
msebire/intellij-community | @ Nullable private static PsiElement getUnreachableStatementParent ( @ NotNull PsiElement statement ) { final PsiElement parent = statement . getParent ( ) ; if ( parent instanceof PsiForStatement && ( ( PsiForStatement ) parent ) . getInitialization ( ) == statement ) { return parent ; } return null ; }
msebire/intellij-community | private static PsiReferenceExpression getEnclosingReferenceExpression ( @ NotNull PsiElement element , @ NotNull PsiVariable variable ) { final PsiReferenceExpression reference = findReferenceTo ( element , variable ) ; if ( reference != null ) return reference ; while ( element != null ) { if ( element instanceof PsiReferenceExpression ) { return ( PsiReferenceExpression ) element ; } if ( element instanceof PsiMethod || element instanceof PsiClass ) { return null ; } element = element . getParent ( ) ; } return null ; }
msebire/intellij-community | private static PsiReferenceExpression findReferenceTo ( @ NotNull PsiElement element , @ NotNull PsiVariable variable ) { if ( element instanceof PsiReferenceExpression && ExpressionUtil . isEffectivelyUnqualified ( ( PsiReferenceExpression ) element ) && ( ( PsiReferenceExpression ) element ) . resolve ( ) == variable ) { return ( PsiReferenceExpression ) element ; } final PsiElement [ ] children = element . getChildren ( ) ; for ( PsiElement child : children ) { final PsiReferenceExpression reference = findReferenceTo ( child , variable ) ; if ( reference != null ) return reference ; } return null ; }
msebire/intellij-community | public static boolean isDominator ( ControlFlow flow , int maybeDominator , int target ) { class MyVisitor extends InstructionClientVisitor < Boolean > { final BitSet myReachedWithoutDominator = new BitSet ( ) ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { super . visitInstruction ( instruction , offset , nextOffset ) ; if ( nextOffset != maybeDominator && ( target == nextOffset || myReachedWithoutDominator . get ( nextOffset ) ) ) { myReachedWithoutDominator . set ( offset ) ; } } @ Override public Boolean getResult ( ) { return myReachedWithoutDominator . get ( 0 ) ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , 0 , target ) ; return ! visitor . getResult ( ) ; }
msebire/intellij-community | public static boolean isVariableDefinitelyAssigned ( @ NotNull final PsiVariable variable , @ NotNull final ControlFlow flow ) { final int variableDeclarationOffset = flow . getStartOffset ( variable . getParent ( ) ) ; int offset = variableDeclarationOffset > - 1 ? variableDeclarationOffset : 0 ; boolean [ ] unassignedOffsets = getVariablePossiblyUnassignedOffsets ( variable , flow ) ; return ! unassignedOffsets [ offset ] ; }
msebire/intellij-community | public static boolean [ ] getVariablePossiblyUnassignedOffsets ( @ NotNull PsiVariable variable , @ NotNull ControlFlow flow ) { class MyVisitor extends InstructionClientVisitor < boolean [ ] > { private final boolean [ ] maybeUnassigned = new boolean [ flow . getSize ( ) + 1 ] ; { maybeUnassigned [ maybeUnassigned . length - 1 ] = true ; } @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { if ( instruction . variable == variable ) { maybeUnassigned [ offset ] = false ; } else { visitInstruction ( instruction , offset , nextOffset ) ; } } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = offset == flow . getSize ( ) - 1 || ! isLeaf ( nextOffset ) && maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { visitInstruction ( instruction , offset , nextOffset ) ; for ( int i = instruction . procBegin ; i < instruction . procEnd + 3 ; i ++ ) { maybeUnassigned [ i ] = false ; } } @ Override public void visitGoToInstruction ( GoToInstruction instruction , int offset , int nextOffset ) { if ( instruction . isReturn && variable instanceof PsiLocalVariable ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = ! isLeaf ( nextOffset ) && maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } else { super . visitGoToInstruction ( instruction , offset , nextOffset ) ; } } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = ! isLeaf ( nextOffset ) && maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean unassigned = isLeaf ( nextOffset ) || maybeUnassigned [ nextOffset ] ; maybeUnassigned [ offset ] |= unassigned ; } @ Override @ NotNull public boolean [ ] getResult ( ) { return maybeUnassigned ; } } if ( flow . getSize ( ) == 0 ) return new boolean [ ] { true } ; MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | public static boolean isVariableDefinitelyNotAssigned ( @ NotNull PsiVariable variable , @ NotNull ControlFlow flow ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] maybeAssigned = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visitWriteVariableInstruction ( WriteVariableInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean assigned = instruction . variable == variable || maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override public void visitThrowToInstruction ( ThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean assigned = ! isLeaf ( nextOffset ) && maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override public void visitConditionalThrowToInstruction ( ConditionalThrowToInstruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; int throwToOffset = instruction . offset ; boolean assigned = throwToOffset == nextOffset ? ! isLeaf ( nextOffset ) && maybeAssigned [ nextOffset ] : maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean assigned = maybeAssigned [ nextOffset ] ; maybeAssigned [ offset ] |= assigned ; } @ Override @ NotNull public Boolean getResult ( ) { return ! maybeAssigned [ 0 ] ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean isValueUsedWithoutVisitingStop ( @ NotNull ControlFlow flow , final int start , final int stop , @ NotNull PsiVariable variable ) { if ( start == stop ) return false ; class MyVisitor extends InstructionClientVisitor < Boolean > { private final boolean [ ] maybeReferenced = new boolean [ flow . getSize ( ) + 1 ] ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( offset == stop ) { maybeReferenced [ offset ] = false ; return ; } if ( instruction instanceof WriteVariableInstruction && ( ( WriteVariableInstruction ) instruction ) . variable == variable ) { maybeReferenced [ offset ] = false ; return ; } if ( maybeReferenced [ offset ] ) return ; if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; boolean nextState = maybeReferenced [ nextOffset ] ; maybeReferenced [ offset ] = nextState || instruction instanceof ReadVariableInstruction && ( ( ReadVariableInstruction ) instruction ) . variable == variable ; } @ Override @ NotNull public Boolean getResult ( ) { return maybeReferenced [ start ] ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , start , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | public static boolean isVariableAccess ( @ NotNull ControlFlow flow , int offset , @ NotNull PsiVariable variable ) { Instruction instruction = flow . getInstructions ( ) . get ( offset ) ; return instruction instanceof ReadVariableInstruction && ( ( ReadVariableInstruction ) instruction ) . variable == variable || instruction instanceof WriteVariableInstruction && ( ( WriteVariableInstruction ) instruction ) . variable == variable ; }
msebire/intellij-community | @ NotNull public static List < ControlFlowEdge > getEdges ( @ NotNull ControlFlow flow , int start ) { final List < ControlFlowEdge > list = new ArrayList < > ( ) ; depthFirstSearch ( flow , new InstructionClientVisitor < Void > ( ) { @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { list . add ( new ControlFlowEdge ( offset , nextOffset ) ) ; } @ Override public Void getResult ( ) { return null ; } } , start , flow . getSize ( ) ) ; return list ; }
msebire/intellij-community | public static int getMinDefinitelyReachedOffset ( @ NotNull ControlFlow flow , final int sourceOffset , @ NotNull List < ? extends PsiElement > references ) { class MyVisitor extends InstructionClientVisitor < Integer > { private final TIntHashSet [ ] exitPoints = new TIntHashSet [ flow . getSize ( ) ] ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( nextOffset > flow . getSize ( ) ) nextOffset = flow . getSize ( ) ; if ( exitPoints [ offset ] == null ) { exitPoints [ offset ] = new TIntHashSet ( ) ; } if ( isLeaf ( nextOffset ) ) { exitPoints [ offset ] . add ( offset ) ; } else if ( exitPoints [ nextOffset ] != null ) { exitPoints [ offset ] . addAll ( exitPoints [ nextOffset ] . toArray ( ) ) ; } } @ Override @ NotNull public Integer getResult ( ) { int minOffset = flow . getSize ( ) ; int maxExitPoints = 0 ; nextOffset : for ( int i = sourceOffset ; i < exitPoints . length ; i ++ ) { TIntHashSet exitPointSet = exitPoints [ i ] ; final int size = exitPointSet == null ? 0 : exitPointSet . size ( ) ; if ( size > maxExitPoints ) { for ( PsiElement element : references ) { final PsiElement statement = PsiUtil . getEnclosingStatement ( element ) ; if ( statement == null ) continue ; final int endOffset = flow . getEndOffset ( statement ) ; if ( endOffset == - 1 ) continue ; if ( i != endOffset && ! isInstructionReachable ( flow , i , endOffset ) ) continue nextOffset ; } minOffset = i ; maxExitPoints = size ; } } return minOffset ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) . intValue ( ) ; }
msebire/intellij-community | private static int findUnprocessed ( int startOffset , int endOffset , @ NotNull InstructionClientVisitor < ? > visitor ) { for ( int i = startOffset ; i < endOffset ; i ++ ) { if ( ! visitor . processedInstructions [ i ] ) { return i ; } } return endOffset ; }
msebire/intellij-community | private static void depthFirstSearch ( @ NotNull ControlFlow flow , @ NotNull InstructionClientVisitor visitor ) { depthFirstSearch ( flow , visitor , 0 , flow . getSize ( ) ) ; }
msebire/intellij-community | private static void depthFirstSearch ( @ NotNull ControlFlow flow , @ NotNull InstructionClientVisitor visitor , int startOffset , int endOffset ) { visitor . processedInstructions = new boolean [ endOffset ] ; internalDepthFirstSearch ( flow . getInstructions ( ) , visitor , startOffset , endOffset ) ; }
msebire/intellij-community | private static void internalDepthFirstSearch ( @ NotNull List < ? extends Instruction > instructions , @ NotNull InstructionClientVisitor clientVisitor , int startOffset , int endOffset ) { final WalkThroughStack walkThroughStack = new WalkThroughStack ( instructions . size ( ) / 2 ) ; walkThroughStack . push ( startOffset ) ; synchronized ( instructions ) { final IntArrayList currentProcedureReturnOffsets = new IntArrayList ( ) ; ControlFlowInstructionVisitor getNextOffsetVisitor = new ControlFlowInstructionVisitor ( ) { @ Override public void visitCallInstruction ( CallInstruction instruction , int offset , int nextOffset ) { instruction . execute ( offset + 1 ) ; int newOffset = instruction . offset ; int i ; for ( i = instruction . procBegin ; i < clientVisitor . processedInstructions . length && ( i < instruction . procEnd || i < instructions . size ( ) && instructions . get ( i ) instanceof ReturnInstruction ) ; i ++ ) { clientVisitor . processedInstructions [ i ] = false ; } clientVisitor . procedureEntered ( instruction . procBegin , i ) ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; currentProcedureReturnOffsets . add ( offset + 1 ) ; } @ Override public void visitReturnInstruction ( ReturnInstruction instruction , int offset , int nextOffset ) { int newOffset = instruction . execute ( false ) ; if ( newOffset != - 1 ) { walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; } } @ Override public void visitBranchingInstruction ( BranchingInstruction instruction , int offset , int nextOffset ) { int newOffset = instruction . offset ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; } @ Override public void visitConditionalBranchingInstruction ( ConditionalBranchingInstruction instruction , int offset , int nextOffset ) { int newOffset = instruction . offset ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( offset , offset + 1 ) ; walkThroughStack . push ( newOffset ) ; walkThroughStack . push ( offset + 1 ) ; } @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { int newOffset = offset + 1 ; walkThroughStack . push ( offset , newOffset ) ; walkThroughStack . push ( newOffset ) ; } } ; while ( ! walkThroughStack . isEmpty ( ) ) { final int offset = walkThroughStack . peekOldOffset ( ) ; final int newOffset = walkThroughStack . popNewOffset ( ) ; if ( offset >= endOffset ) { continue ; } Instruction instruction = instructions . get ( offset ) ; if ( clientVisitor . processedInstructions [ offset ] ) { if ( newOffset != - 1 ) { instruction . accept ( clientVisitor , offset , newOffset ) ; } if ( ! currentProcedureReturnOffsets . isEmpty ( ) && currentProcedureReturnOffsets . get ( currentProcedureReturnOffsets . size ( ) - 1 ) - 1 == offset ) { currentProcedureReturnOffsets . remove ( currentProcedureReturnOffsets . size ( ) - 1 ) ; } continue ; } if ( ! currentProcedureReturnOffsets . isEmpty ( ) ) { int returnOffset = currentProcedureReturnOffsets . get ( currentProcedureReturnOffsets . size ( ) - 1 ) ; CallInstruction callInstruction = ( CallInstruction ) instructions . get ( returnOffset - 1 ) ; synchronized ( callInstruction . stack ) { if ( callInstruction . procBegin <= offset && offset < callInstruction . procEnd + 2 && ( callInstruction . stack . size ( ) == 0 || callInstruction . stack . peekReturnOffset ( ) != returnOffset ) ) { callInstruction . stack . push ( returnOffset , callInstruction ) ; } } } clientVisitor . processedInstructions [ offset ] = true ; instruction . accept ( getNextOffsetVisitor , offset , newOffset ) ; } } }
msebire/intellij-community | private static boolean isInsideReturnStatement ( PsiElement element ) { while ( element instanceof PsiExpression ) element = element . getParent ( ) ; return element instanceof PsiReturnStatement ; }
msebire/intellij-community | @ NotNull public static CopyOnWriteList add ( @ Nullable CopyOnWriteList list , @ NotNull VariableInfo value ) { return list == null ? new CopyOnWriteList ( value ) : list . add ( value ) ; }
msebire/intellij-community | private static void merge ( int offset , CopyOnWriteList source , @ NotNull CopyOnWriteList [ ] target ) { if ( source != null ) { CopyOnWriteList existing = target [ offset ] ; target [ offset ] = existing == null ? source : existing . addAll ( source ) ; } }
msebire/intellij-community | @ NotNull public static List < PsiReferenceExpression > getReadBeforeWriteLocals ( @ NotNull ControlFlow flow ) { final InstructionClientVisitor < List < PsiReferenceExpression > > visitor = new ReadBeforeWriteClientVisitor ( flow , true ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | @ NotNull public static List < PsiReferenceExpression > getReadBeforeWrite ( @ NotNull ControlFlow flow ) { return getReadBeforeWrite ( flow , 0 ) ; }
msebire/intellij-community | @ NotNull private static List < PsiReferenceExpression > getReadBeforeWrite ( @ NotNull ControlFlow flow , int startOffset ) { if ( startOffset < 0 || startOffset >= flow . getSize ( ) ) { return Collections . emptyList ( ) ; } final ReadBeforeWriteClientVisitor visitor = new ReadBeforeWriteClientVisitor ( flow , false ) ; depthFirstSearch ( flow , visitor ) ; return visitor . getResult ( startOffset ) ; }
msebire/intellij-community | private static boolean isMethodParameter ( @ NotNull PsiVariable variable ) { if ( variable instanceof PsiParameter ) { final PsiParameter parameter = ( PsiParameter ) variable ; return ! ( parameter . getDeclarationScope ( ) instanceof PsiForeachStatement ) ; } return false ; }
msebire/intellij-community | public static int getCompletionReasons ( @ NotNull ControlFlow flow , final int offset , final int endOffset ) { class MyVisitor extends InstructionClientVisitor < Integer > { private final boolean [ ] normalCompletion = new boolean [ endOffset ] ; private final boolean [ ] returnCalled = new boolean [ endOffset ] ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { boolean ret = nextOffset < endOffset && returnCalled [ nextOffset ] ; boolean normal = nextOffset < endOffset && normalCompletion [ nextOffset ] ; final PsiElement element = flow . getElement ( offset ) ; boolean goToReturn = instruction instanceof GoToInstruction && ( ( GoToInstruction ) instruction ) . isReturn ; if ( goToReturn || isInsideReturnStatement ( element ) ) { ret = true ; } else if ( instruction instanceof ConditionalThrowToInstruction ) { final int throwOffset = ( ( ConditionalThrowToInstruction ) instruction ) . offset ; boolean normalWhenThrow = throwOffset < endOffset && normalCompletion [ throwOffset ] ; boolean normalWhenNotThrow = offset == endOffset - 1 || normalCompletion [ offset + 1 ] ; normal = normalWhenThrow || normalWhenNotThrow ; } else if ( ! ( instruction instanceof ThrowToInstruction ) && nextOffset >= endOffset ) { normal = true ; } returnCalled [ offset ] |= ret ; normalCompletion [ offset ] |= normal ; } @ Override @ NotNull public Integer getResult ( ) { return ( returnCalled [ offset ] ? RETURN_COMPLETION_REASON : 0 ) | ( normalCompletion [ offset ] ? NORMAL_COMPLETION_REASON : 0 ) ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , offset , endOffset ) ; return visitor . getResult ( ) . intValue ( ) ; }
msebire/intellij-community | @ NotNull public static Collection < VariableInfo > getInitializedTwice ( @ NotNull ControlFlow flow ) { return getInitializedTwice ( flow , 0 , flow . getSize ( ) ) ; }
msebire/intellij-community | @ NotNull public static Collection < VariableInfo > getInitializedTwice ( @ NotNull ControlFlow flow , int startOffset , int endOffset ) { while ( startOffset < endOffset ) { InitializedTwiceClientVisitor visitor = new InitializedTwiceClientVisitor ( flow , startOffset ) ; depthFirstSearch ( flow , visitor , startOffset , endOffset ) ; Collection < VariableInfo > result = visitor . getResult ( ) ; if ( ! result . isEmpty ( ) ) { return result ; } startOffset = findUnprocessed ( startOffset , endOffset , visitor ) ; } return Collections . emptyList ( ) ; }
msebire/intellij-community | @ Nullable private static PsiElement getExpression ( @ NotNull PsiElement element ) { if ( element instanceof PsiAssignmentExpression ) { PsiExpression target = PsiUtil . skipParenthesizedExprDown ( ( ( PsiAssignmentExpression ) element ) . getLExpression ( ) ) ; return ObjectUtils . tryCast ( target , PsiReferenceExpression . class ) ; } if ( element instanceof PsiUnaryExpression ) { PsiExpression target = PsiUtil . skipParenthesizedExprDown ( ( ( PsiUnaryExpression ) element ) . getOperand ( ) ) ; return ObjectUtils . tryCast ( target , PsiReferenceExpression . class ) ; } if ( element instanceof PsiDeclarationStatement ) { return element ; } return null ; }
msebire/intellij-community | @ Nullable private static PsiElement getLatestWriteVarExpression ( @ Nullable CopyOnWriteList writeVars , @ NotNull PsiVariable variable ) { if ( writeVars == null ) return null ; for ( final VariableInfo variableInfo : writeVars . getList ( ) ) { if ( variableInfo . variable == variable ) { return variableInfo . expression ; } } return null ; }
msebire/intellij-community | @ NotNull public static Map < PsiElement , PsiVariable > getWritesBeforeReads ( @ NotNull ControlFlow flow , @ NotNull Set < PsiVariable > writeVars , @ NotNull Set < PsiVariable > readVars , final int stopPoint ) { Map < PsiElement , PsiVariable > writes = new HashMap < > ( ) ; List < Instruction > instructions = flow . getInstructions ( ) ; for ( int i = 0 ; i < instructions . size ( ) ; i ++ ) { Instruction instruction = instructions . get ( i ) ; if ( ! ( instruction instanceof WriteVariableInstruction ) ) continue ; PsiVariable writtenVar = ( ( WriteVariableInstruction ) instruction ) . variable ; if ( ! writeVars . contains ( writtenVar ) ) continue ; if ( readBeforeStopPoint ( flow , readVars , i , stopPoint ) ) writes . put ( flow . getElement ( i ) , writtenVar ) ; } return writes ; }
msebire/intellij-community | private static boolean readBeforeStopPoint ( @ NotNull final ControlFlow flow , @ NotNull Set < PsiVariable > readVars , final int startOffset , final int stopPoint ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private boolean reachable = false ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { if ( offset == stopPoint || isWriteToReadVar ( instruction ) ) { reachable = false ; return ; } boolean foundRead = instruction instanceof ReadVariableInstruction && readVars . contains ( ( ( ReadVariableInstruction ) instruction ) . variable ) ; reachable |= foundRead ; } private boolean isWriteToReadVar ( Instruction instruction ) { return instruction instanceof WriteVariableInstruction && readVars . contains ( ( ( WriteVariableInstruction ) instruction ) . variable ) ; } @ Override public Boolean getResult ( ) { return reachable ; } } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , flow . getSize ( ) ) ; return visitor . getResult ( ) ; }
msebire/intellij-community | public static boolean isInstructionReachable ( @ NotNull final ControlFlow flow , final int instructionOffset , final int startOffset ) { return areInstructionsReachable ( flow , new int [ ] { instructionOffset } , startOffset ) ; }
msebire/intellij-community | private static boolean areInstructionsReachable ( @ NotNull final ControlFlow flow , @ NotNull final int [ ] instructionOffsets , final int startOffset ) { class MyVisitor extends InstructionClientVisitor < Boolean > { private boolean reachable ; @ Override public void visitInstruction ( Instruction instruction , int offset , int nextOffset ) { reachable |= ArrayUtil . indexOf ( instructionOffsets , nextOffset ) >= 0 ; } @ Override @ NotNull public Boolean getResult ( ) { return reachable ; } } if ( startOffset != 0 && hasCalls ( flow ) ) { return areInstructionsReachableWithCalls ( flow , instructionOffsets , startOffset ) ; } MyVisitor visitor = new MyVisitor ( ) ; depthFirstSearch ( flow , visitor , startOffset , flow . getSize ( ) ) ; return visitor . getResult ( ) . booleanValue ( ) ; }
msebire/intellij-community | private static boolean hasCalls ( @ NotNull ControlFlow flow ) { for ( Instruction instruction : flow . getInstructions ( ) ) { if ( instruction instanceof CallInstruction ) { return true ; } } return false ; }
msebire/intellij-community | private static boolean areInstructionsReachableWithCalls ( @ NotNull final ControlFlow flow , @ NotNull final int [ ] instructionOffsets , final int startOffset ) { ControlFlowGraph graph = new ControlFlowGraph ( flow . getSize ( ) ) { @ Override boolean isComplete ( int offset , int nextOffset ) { return ArrayUtil . indexOf ( instructionOffsets , nextOffset ) >= 0 ; } } ; graph . buildFrom ( flow ) ; return graph . depthFirstSearch ( startOffset ) ; }
msebire/intellij-community | public static boolean isVariableAssignedInLoop ( @ NotNull PsiReferenceExpression expression , @ NotNull PsiElement resolved ) { if ( ! ( expression . getParent ( ) instanceof PsiAssignmentExpression ) || ( ( PsiAssignmentExpression ) expression . getParent ( ) ) . getLExpression ( ) != expression ) { return false ; } PsiExpression qualifier = expression . getQualifierExpression ( ) ; if ( qualifier != null && ! ( qualifier instanceof PsiThisExpression ) ) return false ; if ( ! ( resolved instanceof PsiVariable ) ) return false ; PsiVariable variable = ( PsiVariable ) resolved ; final PsiElement codeBlock = PsiUtil . getVariableCodeBlock ( variable , expression ) ; if ( codeBlock == null ) return false ; final ControlFlow flow ; try { flow = ControlFlowFactory . getInstance ( codeBlock . getProject ( ) ) . getControlFlow ( codeBlock , LocalsOrMyInstanceFieldsControlFlowPolicy . getInstance ( ) , true ) ; } catch ( AnalysisCanceledException e ) { return false ; } final PsiAssignmentExpression assignmentExpression = ( PsiAssignmentExpression ) expression . getParent ( ) ; int startOffset = flow . getStartOffset ( assignmentExpression ) ; return startOffset != - 1 && isInstructionReachable ( flow , startOffset , startOffset ) ; }
msebire/intellij-community | static boolean isCaughtExceptionType ( @ NotNull PsiClassType throwType , @ NotNull PsiType catchType ) { return catchType . isAssignableFrom ( throwType ) || mightBeAssignableFromSubclass ( throwType , catchType ) ; }
msebire/intellij-community | private static boolean mightBeAssignableFromSubclass ( @ NotNull final PsiClassType throwType , @ NotNull PsiType catchType ) { if ( catchType instanceof PsiDisjunctionType ) { for ( PsiType catchDisjunction : ( ( PsiDisjunctionType ) catchType ) . getDisjunctions ( ) ) { if ( throwType . isAssignableFrom ( catchDisjunction ) ) { return true ; } } return false ; } return throwType . isAssignableFrom ( catchType ) ; }
msebire/intellij-community | public static boolean areVariablesUnmodifiedAtLocations ( @ NotNull ControlFlow flow , int startOffset , int endOffset , @ NotNull Set < ? extends PsiVariable > variables , @ NotNull Iterable < ? extends PsiElement > locations ) { List < Instruction > instructions = flow . getInstructions ( ) ; startOffset = Math . max ( startOffset , 0 ) ; endOffset = Math . min ( endOffset , instructions . size ( ) ) ; IntArrayList locationOffsetList = new IntArrayList ( ) ; for ( PsiElement location : locations ) { int offset = flow . getStartOffset ( location ) ; if ( offset >= startOffset && offset < endOffset ) { locationOffsetList . add ( offset ) ; } } int [ ] locationOffsets = locationOffsetList . toArray ( ) ; for ( int offset = startOffset ; offset < endOffset ; offset ++ ) { Instruction instruction = instructions . get ( offset ) ; if ( instruction instanceof WriteVariableInstruction && variables . contains ( ( ( WriteVariableInstruction ) instruction ) . variable ) ) { if ( areInstructionsReachable ( flow , locationOffsets , offset ) ) { return false ; } } } return true ; }
Karm/undertow | public static void cleanClose ( StreamConnection connection , Closeable ... additional ) { try { connection . getSinkChannel ( ) . shutdownWrites ( ) ; if ( ! connection . getSinkChannel ( ) . flush ( ) ) { connection . getSinkChannel ( ) . setWriteListener ( ChannelListeners . flushingChannelListener ( new ChannelListener < ConduitStreamSinkChannel > ( ) { @ Override public void handleEvent ( ConduitStreamSinkChannel channel ) { doDrain ( connection , additional ) ; } } , new ChannelExceptionHandler < ConduitStreamSinkChannel > ( ) { @ Override public void handleException ( ConduitStreamSinkChannel channel , IOException exception ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( exception ) ; IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } } ) ) ; connection . getSinkChannel ( ) . resumeWrites ( ) ; } else { doDrain ( connection , additional ) ; } } catch ( Throwable e ) { if ( e instanceof IOException ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( ( IOException ) e ) ; } else { UndertowLogger . REQUEST_IO_LOGGER . ioException ( new IOException ( e ) ) ; } IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } }
Karm/undertow | private static void doDrain ( final StreamConnection connection , final Closeable ... additional ) { if ( ! connection . getSourceChannel ( ) . isOpen ( ) ) { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; return ; } final ByteBuffer b = ByteBuffer . allocate ( 1 ) ; try { int res = connection . getSourceChannel ( ) . read ( b ) ; b . clear ( ) ; if ( res == 0 ) { final XnioExecutor . Key key = WorkerUtils . executeAfter ( connection . getIoThread ( ) , new Runnable ( ) { @ Override public void run ( ) { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } } , MAX_DRAIN_TIME , TimeUnit . MILLISECONDS ) ; connection . getSourceChannel ( ) . setReadListener ( new ChannelListener < ConduitStreamSourceChannel > ( ) { @ Override public void handleEvent ( ConduitStreamSourceChannel channel ) { try { int res = channel . read ( b ) ; if ( res != 0 ) { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; key . remove ( ) ; } } catch ( Exception e ) { if ( e instanceof IOException ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( ( IOException ) e ) ; } else { UndertowLogger . REQUEST_IO_LOGGER . ioException ( new IOException ( e ) ) ; } IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; key . remove ( ) ; } } } ) ; connection . getSourceChannel ( ) . resumeReads ( ) ; } else { IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } } catch ( Throwable e ) { if ( e instanceof IOException ) { UndertowLogger . REQUEST_IO_LOGGER . ioException ( ( IOException ) e ) ; } else { UndertowLogger . REQUEST_IO_LOGGER . ioException ( new IOException ( e ) ) ; } IoUtils . safeClose ( connection ) ; IoUtils . safeClose ( additional ) ; } }
jack0707/coldweather | public synchronized static ColdWeatherDB getInstance ( Context context ) { if ( coldWeatherDB == null ) { coldWeatherDB = new ColdWeatherDB ( context ) ; } return coldWeatherDB ; }
Alachisoft/TayzGrid | public static boolean IsValidIP ( String ip ) { if ( ip == null || ip . isEmpty ( ) ) { return false ; } ip = ip . trim ( ) ; if ( ( ip . length ( ) < 6 ) & ( ip . length ( ) > 15 ) ) { return false ; } try { Pattern pattern = Pattern . compile ( " ^ ( ? : ( ? :25[0-5 ] | 2[0-4 ] [ 0-9 ] | [ 01 ] ? [0-9 ] [ 0-9 ] ? ) \\ . ) { 3 } ( ? : 25[0-5 ] | 2[0-4 ] [ 0-9 ] | [ 01 ] ? [0-9 ] [ 0-9 ] ? ) $ " ) ; Matcher matcher = pattern . matcher ( ip ) ; return matcher . matches ( ) ; } catch ( PatternSyntaxException ex ) { return false ; } }
Alachisoft/TayzGrid | private static boolean ValidateParameters ( ) { AssemblyUsage . PrintLogo ( cParam . getIsLogo ( ) ) ; if ( tangible . DotNetToJavaStringHelper . isNullOrEmpty ( cParam . getCacheId ( ) ) ) { System . err . println ( " Error : ▁ Cache ▁ Name ▁ not ▁ specified " ) ; return false ; } if ( tangible . DotNetToJavaStringHelper . isNullOrEmpty ( cParam . getServer ( ) ) ) { System . err . println ( " Error : ▁ Server ▁ not ▁ specified " ) ; return false ; } if ( ! IsValidIP ( cParam . getServer ( ) ) ) { System . err . println ( " Error : ▁ Invalid ▁ Server ▁ IP " ) ; return false ; } if ( tangible . DotNetToJavaStringHelper . isNullOrEmpty ( cParam . getClientNode ( ) ) ) { System . err . println ( " Error : ▁ Client ▁ Node ▁ not ▁ specified " ) ; return false ; } if ( ! IsValidIP ( cParam . getClientNode ( ) ) ) { System . err . println ( " Error : ▁ ClientNode ( IP ) ▁ is ▁ invalid " ) ; return false ; } return true ; }
Alachisoft/TayzGrid | private static void LogEvent ( String msg ) { EventLogEntryType type = EventLogEntryType . Error ; try { } finally { } }
Alachisoft/TayzGrid | private static boolean IsValidAddress ( String iPaddress ) { InetAddress address = null ; try { address = InetAddress . getByName ( iPaddress ) ; } catch ( UnknownHostException e ) { return false ; } return true ; }
Alachisoft/TayzGrid | private static com . alachisoft . tayzgrid . management . clientconfiguration . CacheServerList GetSeversPriorityList ( ) throws UnknownHostException { java . util . HashMap < Integer , com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer > serversPriorityList = new java . util . HashMap < Integer , com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer > ( ) ; java . util . ArrayList < Address > hosts = config . getCacheDeployment ( ) . getServers ( ) . GetAllConfiguredNodes ( ) ; int priority = 0 ; for ( Address addr : hosts ) { com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer server = new com . alachisoft . tayzgrid . management . clientconfiguration . dom . CacheServer ( ) ; server . setServerName ( addr . getIpAddress ( ) . getHostAddress ( ) ) ; server . setPriority ( priority ) ; serversPriorityList . put ( priority , server ) ; priority ++ ; } com . alachisoft . tayzgrid . management . clientconfiguration . CacheServerList csList = new com . alachisoft . tayzgrid . management . clientconfiguration . CacheServerList ( ) ; csList . setServersList ( serversPriorityList ) ; return csList ; }
shakamunyi/drill | @ BeforeClass public static void testSetUp ( ) throws Exception { testDrillDriver = new Driver ( ) ; }
wentch/redkale | public static HttpScope refer ( String template ) { HttpScope rs = new HttpScope ( ) ; rs . setReferid ( template ) ; return rs ; }
miniway/presto | @ InputFunction public static void input ( @ AggregationState GeometryState state , @ SqlType ( GEOMETRY_TYPE_NAME ) Slice input ) { OGCGeometry geometry = GeometrySerde . deserialize ( input ) ; if ( state . getGeometry ( ) == null ) { state . setGeometry ( geometry . convexHull ( ) ) ; } else if ( ! geometry . isEmpty ( ) ) { state . setGeometry ( state . getGeometry ( ) . union ( geometry ) . convexHull ( ) ) ; } }
miniway/presto | @ CombineFunction public static void combine ( @ AggregationState GeometryState state , @ AggregationState GeometryState otherState ) { if ( state . getGeometry ( ) == null ) { state . setGeometry ( otherState . getGeometry ( ) ) ; } else if ( otherState . getGeometry ( ) != null && ! otherState . getGeometry ( ) . isEmpty ( ) ) { state . setGeometry ( state . getGeometry ( ) . union ( otherState . getGeometry ( ) ) . convexHull ( ) ) ; } }
miniway/presto | @ OutputFunction ( GEOMETRY_TYPE_NAME ) public static void output ( @ AggregationState GeometryState state , BlockBuilder out ) { if ( state . getGeometry ( ) == null ) { out . appendNull ( ) ; } else { GEOMETRY . writeSlice ( out , GeometrySerde . serialize ( state . getGeometry ( ) ) ) ; } }
miniway/presto | private static void validateType ( String function , OGCGeometry geometry , Set < GeometryType > validTypes ) { GeometryType type = GeometryType . getForEsriGeometryType ( geometry . geometryType ( ) ) ; if ( ! validTypes . contains ( type ) ) { throw new PrestoException ( INVALID_FUNCTION_ARGUMENT , format ( " % s ▁ only ▁ applies ▁ to ▁ % s . ▁ Input ▁ type ▁ is : ▁ % s " , function , OR_JOINER . join ( validTypes ) , type ) ) ; } }
clairton/repository-vraptor | public static Record valueOf ( final String [ ] values ) { if ( values . length == 1 ) { return valueOf ( values [ 0 ] ) ; } else { return new Record ( values , EQUAL ) ; } }
clairton/repository-vraptor | public static Record valueOf ( final String value ) { for ( final Comparator comparator : values ( ) ) { final String expression = escaper . matcher ( comparator . toString ( ) ) . replaceAll ( " \\ \\ $ 1" ) . replace ( " ^ " , " \\ ^ " ) ; final String regex = " ^ " + expression + " . * " ; logger . log ( FINE , regex ) ; if ( value . matches ( regex ) ) { return new Record ( value . replaceAll ( expression , " " ) , comparator ) ; } } return new Record ( value , EQUAL ) ; }
jentfoo/aws-sdk-java | public static ChangeBatchStaxUnmarshaller getInstance ( ) { if ( instance == null ) instance = new ChangeBatchStaxUnmarshaller ( ) ; return instance ; }
Azure/azure-sdk-for-java | public static void main ( String [ ] args ) throws Exception { final MachineEventsProcessor aggregator = new MachineEventsProcessor ( REPORTING_INTERVAL ) ; final EventProcessorClient client = new EventProcessorClientBuilder ( ) . consumerGroup ( EventHubClientBuilder . DEFAULT_CONSUMER_GROUP_NAME ) . connectionString ( EH_CONNECTION_STRING ) . processPartitionInitialization ( context -> aggregator . onInitialize ( context ) ) . processPartitionClose ( context -> aggregator . onClose ( context ) ) . processEvent ( event -> aggregator . onEvent ( event ) ) . processError ( error -> aggregator . onError ( error ) ) . checkpointStore ( new SampleCheckpointStore ( ) ) . buildEventProcessorClient ( ) ; System . out . println ( " Starting ▁ event ▁ processor " ) ; final AtomicBoolean isRunning = new AtomicBoolean ( true ) ; client . start ( ) ; generateEvents ( isRunning ) . subscribe ( ) ; System . out . println ( " Sleeping . . . " ) ; Thread . sleep ( TimeUnit . SECONDS . toMillis ( 30 ) ) ; isRunning . set ( false ) ; System . out . println ( " Stopping ▁ event ▁ processor " ) ; client . stop ( ) ; System . out . println ( " Exiting ▁ process " ) ; }
Azure/azure-sdk-for-java | private static Mono < Void > generateEvents ( AtomicBoolean isRunning ) { final Logger logger = LoggerFactory . getLogger ( " Producer " ) ; final Scheduler scheduler = Schedulers . elastic ( ) ; final Duration operationTimeout = Duration . ofSeconds ( 5 ) ; final String [ ] machineIds = new String [ ] { "2A " , "9B " , "6C " } ; final Random random = new Random ( ) ; final EventHubProducerAsyncClient client = new EventHubClientBuilder ( ) . connectionString ( EH_CONNECTION_STRING ) . buildAsyncProducerClient ( ) ; return Mono . < Void > fromRunnable ( ( ) -> { while ( isRunning . get ( ) ) { int milliseconds = random . nextInt ( 1000 ) ; try { TimeUnit . MILLISECONDS . sleep ( milliseconds ) ; } catch ( InterruptedException ignored ) { } final String machineId = machineIds [ random . nextInt ( machineIds . length ) ] ; final int temperature = Math . abs ( random . nextInt ( ) % 101 ) ; logger . info ( " [ { } ] ▁ Temperature : ▁ { } C " , machineId , temperature ) ; final EventData event = new EventData ( String . valueOf ( temperature ) ) ; final CreateBatchOptions batchOptions = new CreateBatchOptions ( ) . setPartitionKey ( machineId ) ; client . createBatch ( batchOptions ) . flatMap ( batch -> { batch . tryAdd ( event ) ; return client . send ( batch ) ; } ) . block ( operationTimeout ) ; } } ) . subscribeOn ( scheduler ) . doFinally ( signal -> { logger . info ( " Disposing ▁ of ▁ producer . " ) ; client . close ( ) ; } ) ; }
xasx/assertj-core | public static ErrorMessageFactory shouldEndWith ( Object actual , Object expected , ComparisonStrategy comparisonStrategy ) { return new ShouldEndWith ( actual , expected , comparisonStrategy ) ; }
xasx/assertj-core | public static ErrorMessageFactory shouldEndWith ( Object actual , Object expected ) { return new ShouldEndWith ( actual , expected , StandardComparisonStrategy . instance ( ) ) ; }
Netflix/photon | public static void validateRangeRequest ( long resourceSize , long rangeStart , long rangeEnd ) { if ( rangeStart < 0 ) { throw new IllegalArgumentException ( String . format ( " rangeStart ▁ = ▁ % d ▁ is ▁ < ▁ 0" , rangeStart ) ) ; } if ( rangeStart > rangeEnd ) { throw new IllegalArgumentException ( String . format ( " rangeStart ▁ = ▁ % d ▁ is ▁ not ▁ < = ▁ % d ▁ rangeEnd " , rangeStart , rangeEnd ) ) ; } if ( rangeEnd > ( resourceSize - 1 ) ) { throw new IllegalArgumentException ( String . format ( " rangeEnd ▁ = ▁ % d ▁ is ▁ not ▁ < = ▁ ( resourceSize ▁ - 1 ) ▁ = ▁ % d " , rangeEnd , ( resourceSize - 1 ) ) ) ; } }
GunoH/intellij-community | private static void zipOutput ( @ NotNull String traceFilePath ) { Path traceFile = Paths . get ( traceFilePath ) ; Path parent = traceFile . getParent ( ) ; String zipName = traceFile . getFileName ( ) + " . zip " ; System . out . println ( " Preparing ▁ zip . " ) ; try { Path zipFile = parent . resolve ( zipName ) ; ZipUtil . compressFile ( traceFile , zipFile ) ; FileUtil . delete ( traceFile ) ; System . out . println ( " archive ▁ " + zipFile + " ▁ prepared " ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
haakom/EnergiWeb-remake | public static void main ( String [ ] args ) { RadiusReader test = new RadiusReader ( ) ; RadiusData data = test . readData ( ) ; System . out . println ( " Antall ▁ terminaler : ▁ " + data . getNumSegments ( ) ) ; System . out . println ( " Neste ▁ IP : ▁ " + data . nextAvailableIP ( 0 ) ) ; if ( data . getNumSegments ( ) > 0 ) { } }
wuyinlei/MyHearts | public static CategoryFragment newInstance ( int index ) { Bundle bundle = new Bundle ( ) ; bundle . putInt ( Contants . INDEX , index ) ; CategoryFragment fragment = new CategoryFragment ( ) ; fragment . setArguments ( bundle ) ; return fragment ; }
bbranan/fcrepo4 | private static String currentVersion ( final FedoraSession session , final FedoraResource resource ) throws RepositoryException { return getJcrSession ( session ) . getWorkspace ( ) . getVersionManager ( ) . getBaseVersion ( getJcrNode ( resource ) . getPath ( ) ) . getFrozenNode ( ) . getIdentifier ( ) ; }
bbranan/fcrepo4 | private static long countVersions ( final FedoraSession session , final FedoraResource resource ) throws RepositoryException { final VersionHistory versions = getJcrSession ( session ) . getWorkspace ( ) . getVersionManager ( ) . getVersionHistory ( getJcrNode ( resource ) . getPath ( ) ) ; return versions . getAllVersions ( ) . getSize ( ) ; }
dhaval0129/PSAlgs | private static int LCSubStr_DP ( char X [ ] , char Y [ ] ) { int m = X . length ; int n = Y . length ; int LCStuff [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; int result = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = 1 + LCStuff [ i - 1 ] [ j - 1 ] ; result = Integer . max ( result , LCStuff [ i ] [ j ] ) ; } else { LCStuff [ i ] [ j ] = 0 ; } } } return result ; }
dhaval0129/PSAlgs | public static void main ( String [ ] args ) { String X = " abcdaf " ; String Y = " zbcdf " ; System . out . println ( " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ " + LCSubStr_DP ( X . toCharArray ( ) , Y . toCharArray ( ) ) ) ; }
HelloBugs/Review-It | public static String getFirstNodeText ( Elements elements ) { return elements . get ( 0 ) . text ( ) ; }
apache/jackrabbit-oak | @ NotNull private static SharedAccessBlobPolicy policy ( EnumSet < SharedAccessBlobPermissions > permissions , Instant expirationTime ) { SharedAccessBlobPolicy sharedAccessBlobPolicy = new SharedAccessBlobPolicy ( ) ; sharedAccessBlobPolicy . setPermissions ( permissions ) ; sharedAccessBlobPolicy . setSharedAccessExpiryTime ( Date . from ( expirationTime ) ) ; return sharedAccessBlobPolicy ; }
apache/jackrabbit-oak | @ NotNull private static SharedAccessBlobPolicy policy ( EnumSet < SharedAccessBlobPermissions > permissions ) { return policy ( permissions , Instant . now ( ) . plus ( Duration . ofDays ( 7 ) ) ) ; }
apache/jackrabbit-oak | private static void assertReadAccessGranted ( SegmentNodeStorePersistence persistence , Set < String > expectedBlobs ) throws Exception { CloudBlobContainer container = getContainerFrom ( persistence ) ; Set < String > actualBlobNames = StreamSupport . stream ( container . listBlobs ( ) . spliterator ( ) , false ) . map ( blob -> blob . getUri ( ) . getPath ( ) ) . map ( path -> path . substring ( path . lastIndexOf ( ' / ' ) + 1 ) ) . collect ( toSet ( ) ) ; Set < String > expectedBlobNames = expectedBlobs . stream ( ) . map ( name -> name + " . txt " ) . collect ( toSet ( ) ) ; assertEquals ( expectedBlobNames , actualBlobNames ) ; Set < String > actualBlobContent = actualBlobNames . stream ( ) . map ( name -> { try { return container . getBlockBlobReference ( name ) . downloadText ( ) ; } catch ( StorageException | IOException | URISyntaxException e ) { throw new RuntimeException ( " Error ▁ while ▁ reading ▁ blob ▁ " + name , e ) ; } } ) . collect ( toSet ( ) ) ; assertEquals ( expectedBlobs , actualBlobContent ) ; }
apache/jackrabbit-oak | private static void assertWriteAccessGranted ( SegmentNodeStorePersistence persistence ) throws Exception { getContainerFrom ( persistence ) . getBlockBlobReference ( " test . txt " ) . uploadText ( " test " ) ; }
apache/jackrabbit-oak | private static CloudBlobContainer getContainerFrom ( SegmentNodeStorePersistence persistence ) throws Exception { return ( ( AzurePersistence ) persistence ) . getSegmentstoreDirectory ( ) . getContainer ( ) ; }
apache/jackrabbit-oak | private static void assertWriteAccessNotGranted ( SegmentNodeStorePersistence persistence ) { try { assertWriteAccessGranted ( persistence ) ; fail ( " Write ▁ access ▁ should ▁ not ▁ be ▁ granted , ▁ but ▁ writing ▁ to ▁ the ▁ storage ▁ succeeded . " ) ; } catch ( Exception e ) { } }
apache/jackrabbit-oak | private static void assertReadAccessNotGranted ( SegmentNodeStorePersistence persistence ) { try { assertReadAccessGranted ( persistence , BLOBS ) ; fail ( " Read ▁ access ▁ should ▁ not ▁ be ▁ granted , ▁ but ▁ reading ▁ from ▁ the ▁ storage ▁ succeeded . " ) ; } catch ( Exception e ) { } }
apache/jackrabbit-oak | private static Instant yesterday ( ) { return Instant . now ( ) . minus ( Duration . ofDays ( 1 ) ) ; }
apache/jackrabbit-oak | private static ImmutableSet < String > concat ( ImmutableSet < String > blobs , String element ) { return ImmutableSet . < String > builder ( ) . addAll ( blobs ) . add ( element ) . build ( ) ; }
apache/jackrabbit-oak | private static Configuration getConfigurationWithSharedAccessSignature ( String sasToken ) { return getConfiguration ( sasToken , null , null ) ; }
apache/jackrabbit-oak | private static Configuration getConfigurationWithAccessKey ( String accessKey ) { return getConfiguration ( null , accessKey , null ) ; }
apache/jackrabbit-oak | private static Configuration getConfigurationWithConfigurationURL ( String accessKey ) { String connectionString = " DefaultEndpointsProtocol = https ; " + " BlobEndpoint = " + azurite . getBlobEndpoint ( ) + ' ; ' + " AccountName = " + AzuriteDockerRule . ACCOUNT_NAME + ' ; ' + " AccountKey = " + accessKey + ' ; ' ; return getConfiguration ( null , null , connectionString ) ; }
apache/jackrabbit-oak | @ NotNull private static Configuration getConfiguration ( String sasToken , String accessKey , String connectionURL ) { return new Configuration ( ) { @ Override public String accountName ( ) { return AzuriteDockerRule . ACCOUNT_NAME ; } @ Override public String containerName ( ) { return AzureSegmentStoreService . DEFAULT_CONTAINER_NAME ; } @ Override public String accessKey ( ) { return accessKey != null ? accessKey : " " ; } @ Override public String rootPath ( ) { return AzureSegmentStoreService . DEFAULT_ROOT_PATH ; } @ Override public String connectionURL ( ) { return connectionURL != null ? connectionURL : " " ; } @ Override public String sharedAccessSignature ( ) { return sasToken != null ? sasToken : " " ; } @ Override public String blobEndpoint ( ) { return azurite . getBlobEndpoint ( ) ; } @ Override public Class < ? extends Annotation > annotationType ( ) { return Configuration . class ; } } ; }
Log10Solutions/querydsl | @ QueryDelegate ( DelegateTest . User . class ) public static StringPath getName ( QDelegateTest_User user ) { return user . name ; }
apache/tomcat | public static boolean arrayequals ( final byte [ ] a , final byte [ ] b , final int count ) { for ( int i = 0 ; i < count ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; }
rekhajoshm/pig | public static void replaceWithPOJoinPackage ( PhysicalPlan plan , MapReduceOper mr , POPackage pack , POForEach forEach , String chunkSize ) throws VisitorException { String scope = pack . getOperatorKey ( ) . scope ; NodeIdGenerator nig = NodeIdGenerator . getGenerator ( ) ; POJoinPackage joinPackage ; joinPackage = new POJoinPackage ( new OperatorKey ( scope , nig . getNextNodeId ( scope ) ) , - 1 , pack , forEach ) ; joinPackage . setChunkSize ( Long . parseLong ( chunkSize ) ) ; List < PhysicalOperator > succs = plan . getSuccessors ( forEach ) ; if ( succs != null ) { if ( succs . size ( ) != 1 ) { int errCode = 2028 ; String msg = " ForEach ▁ can ▁ only ▁ have ▁ one ▁ successor . ▁ Found ▁ " + succs . size ( ) + " ▁ successors . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG ) ; } } plan . remove ( pack ) ; try { plan . replace ( forEach , joinPackage ) ; } catch ( PlanException e ) { int errCode = 2029 ; String msg = " Error ▁ rewriting ▁ POJoinPackage . " ; throw new MRCompilerException ( msg , errCode , PigException . BUG , e ) ; } mr . phyToMRMap . put ( forEach , joinPackage ) ; LogFactory . getLog ( LastInputStreamingOptimizer . class ) . info ( " Rewrite : ▁ POPackage - > POForEach ▁ to ▁ POJoinPackage " ) ; }
eayun/ovirt-engine | public static EventNotificationEntity forValue ( int value ) { return values ( ) [ value ] ; }
HappyRay/azkaban | public static SlaAlertAction createFromJson ( final Object obj ) throws Exception { return createFromJson ( ( HashMap < String , Object > ) obj ) ; }
HappyRay/azkaban | public static SlaAlertAction createFromJson ( final HashMap < String , Object > obj ) throws Exception { final Map < String , Object > jsonObj = ( HashMap < String , Object > ) obj ; if ( ! jsonObj . get ( " type " ) . equals ( type ) ) { throw new Exception ( " Cannot ▁ create ▁ action ▁ of ▁ " + type + " ▁ from ▁ " + jsonObj . get ( " type " ) ) ; } final String actionId = ( String ) jsonObj . get ( " actionId " ) ; SlaOption slaOption ; List < String > emails ; slaOption = SlaOption . fromObject ( jsonObj . get ( " slaOption " ) ) ; final int execId = Integer . valueOf ( ( String ) jsonObj . get ( " execId " ) ) ; return new SlaAlertAction ( actionId , slaOption , execId ) ; }
marszczybrew/Diorite | private static boolean isDigit ( final char ch ) { return ( ch >= '0' ) && ( ch <= '9' ) ; }
marszczybrew/Diorite | private static String getChunk ( final CharSequence s , final int slength , int marker ) { final StringBuilder chunk = new StringBuilder ( ) ; char c = s . charAt ( marker ) ; chunk . append ( c ) ; marker ++ ; if ( isDigit ( c ) ) { while ( marker < slength ) { c = s . charAt ( marker ) ; if ( ! isDigit ( c ) ) { break ; } chunk . append ( c ) ; marker ++ ; } } else { while ( marker < slength ) { c = s . charAt ( marker ) ; if ( isDigit ( c ) ) { break ; } chunk . append ( c ) ; marker ++ ; } } return chunk . toString ( ) ; }
marszczybrew/Diorite | public static int compareStatic ( final String s1 , final String s2 ) { int thisMarker = 0 ; int thatMarker = 0 ; final int s1Length = s1 . length ( ) ; final int s2Length = s2 . length ( ) ; while ( ( thisMarker < s1Length ) && ( thatMarker < s2Length ) ) { final String thisChunk = getChunk ( s1 , s1Length , thisMarker ) ; thisMarker += thisChunk . length ( ) ; final String thatChunk = getChunk ( s2 , s2Length , thatMarker ) ; thatMarker += thatChunk . length ( ) ; int result ; if ( isDigit ( thisChunk . charAt ( 0 ) ) && isDigit ( thatChunk . charAt ( 0 ) ) ) { final int thisChunkLength = thisChunk . length ( ) ; result = thisChunkLength - thatChunk . length ( ) ; if ( result == 0 ) { for ( int i = 0 ; i < thisChunkLength ; i ++ ) { result = thisChunk . charAt ( i ) - thatChunk . charAt ( i ) ; if ( result != 0 ) { return result ; } } } } else { result = thisChunk . compareTo ( thatChunk ) ; } if ( result != 0 ) { return result ; } } return s1Length - s2Length ; }
deroneriksson/incubator-systemml | private static boolean [ ] createAssignment ( int len , int off , long pos ) { boolean [ ] ret = new boolean [ off + len ] ; Arrays . fill ( ret , 0 , off , true ) ; long tmp = pos ; for ( int i = 0 ; i < len ; i ++ ) { long mask = UtilFunctions . pow ( 2 , len - i - 1 ) ; ret [ off + i ] = tmp >= mask ; tmp %= mask ; } return ret ; }
deroneriksson/incubator-systemml | private static long getNumSkipPlans ( boolean [ ] plan ) { int pos = ArrayUtils . lastIndexOf ( plan , true ) ; return UtilFunctions . pow ( 2 , plan . length - pos - 1 ) ; }
deroneriksson/incubator-systemml | private static double getLowerBoundCosts ( PlanPartition part , InterestingPoint [ ] M , CPlanMemoTable memo , StaticCosts costs , boolean [ ] plan ) { double lb = Math . max ( costs . _read , costs . _compute ) + costs . _write + getMaterializationCost ( part , M , memo , plan ) ; if ( part . hasOuter ( ) ) lb *= costs . _minSparsity ; return lb ; }
deroneriksson/incubator-systemml | private static double getMaterializationCost ( PlanPartition part , InterestingPoint [ ] M , CPlanMemoTable memo , boolean [ ] plan ) { double costs = 0 ; HashSet < Long > matTargets = new HashSet < > ( ) ; for ( int i = 0 ; i < plan . length ; i ++ ) { long hopID = M [ i ] . getToHopID ( ) ; if ( plan [ i ] && ! matTargets . contains ( hopID ) ) { matTargets . add ( hopID ) ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; long size = getSize ( hop ) ; costs += size * 8 / WRITE_BANDWIDTH_MEM + size * 8 / READ_BANDWIDTH_MEM ; } } for ( Long hopID : part . getExtConsumed ( ) ) if ( ! matTargets . contains ( hopID ) ) { matTargets . add ( hopID ) ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSize ( hop ) * 8 / WRITE_BANDWIDTH_MEM ; } return costs ; }
deroneriksson/incubator-systemml | private static double getReadCost ( PlanPartition part , CPlanMemoTable memo ) { double costs = 0 ; for ( Long hopID : part . getInputs ( ) ) { Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSafeMemEst ( hop ) / READ_BANDWIDTH_MEM ; } return costs ; }
deroneriksson/incubator-systemml | private static double getWriteCost ( Collection < Long > R , CPlanMemoTable memo ) { double costs = 0 ; for ( Long hopID : R ) { Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; costs += getSize ( hop ) * 8 / WRITE_BANDWIDTH_MEM ; } return costs ; }
deroneriksson/incubator-systemml | private static double sumComputeCost ( HashMap < Long , Double > computeCosts ) { return computeCosts . values ( ) . stream ( ) . mapToDouble ( d -> d / COMPUTE_BANDWIDTH ) . sum ( ) ; }
deroneriksson/incubator-systemml | private static double minOuterSparsity ( PlanPartition part , CPlanMemoTable memo ) { return ! part . hasOuter ( ) ? 1.0 : part . getPartition ( ) . stream ( ) . map ( k -> HopRewriteUtils . getLargestInput ( memo . getHopRefs ( ) . get ( k ) ) ) . mapToDouble ( h -> h . dimsKnown ( true ) ? h . getSparsity ( ) : SPARSE_SAFE_SPARSITY_EST ) . min ( ) . orElse ( SPARSE_SAFE_SPARSITY_EST ) ; }
deroneriksson/incubator-systemml | private static double sumTmpInputOutputSize ( CPlanMemoTable memo , CostVector vect ) { return vect . outSize + vect . inSizes . entrySet ( ) . stream ( ) . filter ( e -> ! HopRewriteUtils . isData ( memo . getHopRefs ( ) . get ( e . getKey ( ) ) , DataOpTypes . TRANSIENTREAD ) ) . mapToDouble ( e -> e . getValue ( ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | private static double sumInputMemoryEstimates ( CPlanMemoTable memo , CostVector vect ) { return vect . inSizes . keySet ( ) . stream ( ) . mapToDouble ( e -> getSafeMemEst ( memo . getHopRefs ( ) . get ( e ) ) ) . sum ( ) ; }
deroneriksson/incubator-systemml | private static double getSafeMemEst ( Hop hop ) { return ! hop . dimsKnown ( ) ? getSize ( hop ) * 8 : hop . getOutputMemEstimate ( ) ; }
deroneriksson/incubator-systemml | private static long getSize ( Hop hop ) { return Math . max ( hop . getDim1 ( ) , 1 ) * Math . max ( hop . getDim2 ( ) , 1 ) ; }
deroneriksson/incubator-systemml | private static void createAndAddMultiAggPlans ( CPlanMemoTable memo , HashSet < Long > partition , HashSet < Long > R ) { HashSet < Long > refHops = new HashSet < > ( ) ; for ( Entry < Long , List < MemoTableEntry > > e : memo . getPlans ( ) . entrySet ( ) ) if ( ! e . getValue ( ) . isEmpty ( ) ) { Hop hop = memo . getHopRefs ( ) . get ( e . getKey ( ) ) ; for ( Hop c : hop . getInput ( ) ) refHops . add ( c . getHopID ( ) ) ; } ArrayList < Long > fullAggs = new ArrayList < > ( ) ; for ( Long hopID : R ) { Hop root = memo . getHopRefs ( ) . get ( hopID ) ; if ( ! refHops . contains ( hopID ) && isMultiAggregateRoot ( root ) ) fullAggs . add ( hopID ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ within - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( fullAggs . toArray ( new Long [ 0 ] ) ) ) ; } for ( int i = 0 ; i < fullAggs . size ( ) ; i += 3 ) { int ito = Math . min ( i + 3 , fullAggs . size ( ) ) ; if ( ito - i >= 2 ) { MemoTableEntry me = new MemoTableEntry ( TemplateType . MAGG , fullAggs . get ( i ) , fullAggs . get ( i + 1 ) , ( ( ito - i ) == 3 ) ? fullAggs . get ( i + 2 ) : - 1 , ito - i ) ; if ( isValidMultiAggregate ( memo , me ) ) { for ( int j = i ; j < ito ; j ++ ) { memo . add ( memo . getHopRefs ( ) . get ( fullAggs . get ( j ) ) , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multiagg ▁ plan : ▁ " + fullAggs . get ( j ) + " ▁ " + me ) ; } } else if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ invalid ▁ multiagg ▁ plan : ▁ " + me ) ; } } } }
deroneriksson/incubator-systemml | private static boolean isMultiAggregateRoot ( Hop root ) { return ( HopRewriteUtils . isAggUnaryOp ( root , AggOp . SUM , AggOp . SUM_SQ , AggOp . MIN , AggOp . MAX ) && ( ( AggUnaryOp ) root ) . getDirection ( ) == Direction . RowCol ) || ( root instanceof AggBinaryOp && root . getDim1 ( ) == 1 && root . getDim2 ( ) == 1 && HopRewriteUtils . isTransposeOperation ( root . getInput ( ) . get ( 0 ) ) ) ; }
deroneriksson/incubator-systemml | private static boolean isValidMultiAggregate ( CPlanMemoTable memo , MemoTableEntry me ) { boolean ret = true ; Hop refSize = memo . getHopRefs ( ) . get ( me . input1 ) . getInput ( ) . get ( 0 ) ; for ( int i = 1 ; ret && i < 3 ; i ++ ) { if ( me . isPlanRef ( i ) ) ret &= HopRewriteUtils . isEqualSize ( refSize , memo . getHopRefs ( ) . get ( me . input ( i ) ) . getInput ( ) . get ( 0 ) ) ; } for ( int i = 0 ; ret && i < 3 ; i ++ ) if ( me . isPlanRef ( i ) ) { HashSet < Long > probe = new HashSet < > ( ) ; for ( int j = 0 ; j < 3 ; j ++ ) if ( i != j ) probe . add ( me . input ( j ) ) ; ret &= rCheckMultiAggregate ( memo . getHopRefs ( ) . get ( me . input ( i ) ) , probe ) ; } return ret ; }
deroneriksson/incubator-systemml | private static boolean rCheckMultiAggregate ( Hop current , HashSet < Long > probe ) { boolean ret = true ; for ( Hop c : current . getInput ( ) ) ret &= rCheckMultiAggregate ( c , probe ) ; ret &= ! probe . contains ( current . getHopID ( ) ) ; return ret ; }
deroneriksson/incubator-systemml | private static void rCollectFullAggregates ( Hop current , HashSet < Long > aggs ) { if ( current . isVisited ( ) ) return ; if ( isMultiAggregateRoot ( current ) ) aggs . add ( current . getHopID ( ) ) ; for ( Hop c : current . getInput ( ) ) rCollectFullAggregates ( c , aggs ) ; current . setVisited ( ) ; }
deroneriksson/incubator-systemml | private static void rExtractAggregateInfo ( CPlanMemoTable memo , Hop current , AggregateInfo aggInfo , TemplateType type ) { if ( isMultiAggregateRoot ( current ) ) aggInfo . addInputAggregate ( current . getHopID ( ) ) ; MemoTableEntry me = ( type != null ) ? memo . getBest ( current . getHopID ( ) ) : null ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( me != null && me . isPlanRef ( i ) ) rExtractAggregateInfo ( memo , c , aggInfo , type ) ; else { if ( type != null && c . getDataType ( ) . isMatrix ( ) ) aggInfo . addFusedInput ( c . getHopID ( ) ) ; rExtractAggregateInfo ( memo , c , aggInfo , null ) ; } } }
deroneriksson/incubator-systemml | private static HashSet < Long > collectIrreplaceableRowOps ( CPlanMemoTable memo , PlanPartition part ) { HashSet < Long > blacklist = new HashSet < > ( ) ; HashSet < Pair < Long , Integer > > visited = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) { rCollectDependentRowOps ( memo . getHopRefs ( ) . get ( hopID ) , memo , part , blacklist , visited , null , false ) ; } return blacklist ; }
deroneriksson/incubator-systemml | private static void rCollectDependentRowOps ( Hop hop , CPlanMemoTable memo , PlanPartition part , HashSet < Long > blacklist , HashSet < Pair < Long , Integer > > visited , TemplateType type , boolean foundRowOp ) { Pair < Long , Integer > key = Pair . of ( hop . getHopID ( ) , ( foundRowOp ? Short . MAX_VALUE : 0 ) + ( ( type != null ) ? type . ordinal ( ) + 1 : 0 ) ) ; if ( visited . contains ( key ) || ! part . getPartition ( ) . contains ( hop . getHopID ( ) ) ) { return ; } MemoTableEntry me = ( type == null ) ? memo . getBest ( hop . getHopID ( ) ) : memo . getBest ( hop . getHopID ( ) , type ) ; boolean inRow = ( me != null && me . type == TemplateType . ROW && type == TemplateType . ROW ) ; boolean diffPlans = part . getMatPointsExt ( ) . length > 0 && memo . contains ( hop . getHopID ( ) , TemplateType . ROW ) && ! memo . hasOnlyExactMatches ( hop . getHopID ( ) , TemplateType . ROW , TemplateType . CELL ) ; if ( inRow && foundRowOp ) blacklist . add ( hop . getHopID ( ) ) ; if ( isRowAggOp ( hop , inRow ) || diffPlans ) { blacklist . add ( hop . getHopID ( ) ) ; foundRowOp = true ; } for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) { boolean lfoundRowOp = foundRowOp && me != null && ( me . isPlanRef ( i ) || isImplicitlyFused ( hop , i , me . type ) ) ; rCollectDependentRowOps ( hop . getInput ( ) . get ( i ) , memo , part , blacklist , visited , me != null ? me . type : null , lfoundRowOp ) ; } if ( ! blacklist . contains ( hop . getHopID ( ) ) ) { for ( int i = 0 ; i < hop . getInput ( ) . size ( ) ; i ++ ) if ( me != null && me . type == TemplateType . ROW && ( me . isPlanRef ( i ) || isImplicitlyFused ( hop , i , me . type ) ) && blacklist . contains ( hop . getInput ( ) . get ( i ) . getHopID ( ) ) ) { blacklist . add ( hop . getHopID ( ) ) ; } } visited . add ( key ) ; }
deroneriksson/incubator-systemml | private static boolean isRowAggOp ( Hop hop , boolean inRow ) { return HopRewriteUtils . isBinary ( hop , OpOp2 . CBIND ) || HopRewriteUtils . isNary ( hop , OpOpN . CBIND ) || ( hop instanceof AggBinaryOp && ( inRow || ! hop . dimsKnown ( ) || ( hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) ) ) || ( HopRewriteUtils . isTransposeOperation ( hop ) && ( hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) && ! HopRewriteUtils . isDataGenOp ( hop . getInput ( ) . get ( 0 ) , DataGenMethod . SEQ ) ) || ( hop instanceof AggUnaryOp && inRow ) ; }
deroneriksson/incubator-systemml | private static boolean isValidRow2CellOp ( Hop hop ) { return ! ( HopRewriteUtils . isBinary ( hop , OpOp2 . CBIND ) || ( hop instanceof AggBinaryOp && hop . getDim1 ( ) != 1 && hop . getDim2 ( ) != 1 ) ) ; }
deroneriksson/incubator-systemml | private static void pruneInvalidAndSpecialCasePlans ( CPlanMemoTable memo , PlanPartition part ) { if ( OptimizerUtils . isSparkExecutionMode ( ) ) { for ( Long hopID : part . getPartition ( ) ) { if ( ! memo . contains ( hopID , TemplateType . ROW ) ) continue ; Hop hop = memo . getHopRefs ( ) . get ( hopID ) ; boolean isSpark = ConfigurationManager . getExecutionMode ( ) == RUNTIME_PLATFORM . SPARK || OptimizerUtils . getTotalMemEstimate ( hop . getInput ( ) . toArray ( new Hop [ 0 ] ) , hop , true ) > OptimizerUtils . getLocalMemBudget ( ) ; boolean validNcol = hop . getDataType ( ) . isScalar ( ) || ( HopRewriteUtils . isTransposeOperation ( hop ) ? hop . getDim1 ( ) <= hop . getRowsInBlock ( ) : hop . getDim2 ( ) <= hop . getColsInBlock ( ) ) ; for ( Hop in : hop . getInput ( ) ) validNcol &= in . getDataType ( ) . isScalar ( ) || ( in . getDim2 ( ) <= in . getColsInBlock ( ) ) || ( hop instanceof AggBinaryOp && in . getDim1 ( ) <= in . getRowsInBlock ( ) && HopRewriteUtils . isTransposeOperation ( in ) ) ; if ( isSpark && ! validNcol ) { List < MemoTableEntry > blacklist = memo . get ( hopID , TemplateType . ROW ) ; memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , TemplateType . ROW ) ; memo . removeAllRefTo ( hopID , TemplateType . ROW ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / ▁ violated ▁ blocksize ▁ constraint ▁ ( " + hopID + " ) : ▁ " + Arrays . toString ( blacklist . toArray ( new MemoTableEntry [ 0 ] ) ) ) ; } } } } HashSet < Long > blacklist = collectIrreplaceableRowOps ( memo , part ) ; for ( Long hopID : part . getPartition ( ) ) { if ( blacklist . contains ( hopID ) ) continue ; MemoTableEntry me = memo . getBest ( hopID , TemplateType . ROW ) ; if ( me != null && me . type == TemplateType . ROW && memo . hasOnlyExactMatches ( hopID , TemplateType . ROW , TemplateType . CELL ) ) { List < MemoTableEntry > rmList = memo . get ( hopID , TemplateType . ROW ) ; memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , new HashSet < > ( rmList ) ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Removed ▁ row ▁ memo ▁ table ▁ entries ▁ w / o ▁ aggregation : ▁ " + Arrays . toString ( rmList . toArray ( new MemoTableEntry [ 0 ] ) ) ) ; } } } for ( Long hopID : part . getPartition ( ) ) { if ( memo . countEntries ( hopID , TemplateType . OUTER ) == 2 ) { List < MemoTableEntry > entries = memo . get ( hopID , TemplateType . OUTER ) ; MemoTableEntry me1 = entries . get ( 0 ) ; MemoTableEntry me2 = entries . get ( 1 ) ; MemoTableEntry rmEntry = TemplateOuterProduct . dropAlternativePlan ( memo , me1 , me2 ) ; if ( rmEntry != null ) { memo . remove ( memo . getHopRefs ( ) . get ( hopID ) , Collections . singleton ( rmEntry ) ) ; memo . getPlansBlacklisted ( ) . remove ( rmEntry . input ( rmEntry . getPlanRefIndex ( ) ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ dominated ▁ outer ▁ product ▁ memo ▁ table ▁ entry : ▁ " + rmEntry ) ; } } } }
deroneriksson/incubator-systemml | private static void rPruneSuboptimalPlans ( CPlanMemoTable memo , Hop current , HashSet < Long > visited , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan ) { if ( visited . contains ( current . getHopID ( ) ) ) return ; long hopID = current . getHopID ( ) ; if ( part . getPartition ( ) . contains ( hopID ) && memo . contains ( hopID ) ) { Iterator < MemoTableEntry > iter = memo . get ( hopID ) . iterator ( ) ; while ( iter . hasNext ( ) ) { MemoTableEntry me = iter . next ( ) ; if ( ! hasNoRefToMatPoint ( hopID , me , matPoints , plan ) && me . type != TemplateType . OUTER ) { iter . remove ( ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ memo ▁ table ▁ entry : ▁ " + me ) ; } } } for ( Hop c : current . getInput ( ) ) rPruneSuboptimalPlans ( memo , c , visited , part , matPoints , plan ) ; visited . add ( current . getHopID ( ) ) ; }
deroneriksson/incubator-systemml | private static void rPruneInvalidPlans ( CPlanMemoTable memo , Hop current , HashSet < Long > visited , PlanPartition part , boolean [ ] plan ) { if ( visited . contains ( current . getHopID ( ) ) ) return ; for ( Hop c : current . getInput ( ) ) rPruneInvalidPlans ( memo , c , visited , part , plan ) ; long hopID = current . getHopID ( ) ; if ( part . getPartition ( ) . contains ( hopID ) && memo . contains ( hopID , TemplateType . ROW ) ) { Iterator < MemoTableEntry > iter = memo . get ( hopID , TemplateType . ROW ) . iterator ( ) ; while ( iter . hasNext ( ) ) { MemoTableEntry me = iter . next ( ) ; boolean applyLeaf = ( ! me . hasPlanRef ( ) && ! TemplateUtils . hasMatrixInput ( current ) ) ; boolean applyInner = ! applyLeaf && ! ROW_TPL . open ( current ) ; for ( int i = 0 ; i < 3 & applyInner ; i ++ ) if ( me . isPlanRef ( i ) ) applyInner &= ! memo . contains ( me . input ( i ) , TemplateType . ROW ) ; if ( applyLeaf || applyInner ) { String type = applyLeaf ? " leaf " : " inner " ; if ( isValidRow2CellOp ( current ) ) { me . type = TemplateType . CELL ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Converted ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ from ▁ row ▁ to ▁ cell : ▁ " + me ) ; } else { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Removed ▁ " + type + " ▁ memo ▁ table ▁ entry ▁ row ▁ ( unsupported ▁ cell ) : ▁ " + me ) ; iter . remove ( ) ; } } } } visited . add ( current . getHopID ( ) ) ; }
deroneriksson/incubator-systemml | private static void getComputeCosts ( Hop current , HashMap < Long , Double > computeCosts ) { double costs = 1 ; if ( current instanceof UnaryOp ) { switch ( ( ( UnaryOp ) current ) . getOp ( ) ) { case ABS : case ROUND : case CEIL : case FLOOR : case SIGN : costs = 1 ; break ; case SPROP : case SQRT : costs = 2 ; break ; case EXP : costs = 18 ; break ; case SIGMOID : costs = 21 ; break ; case LOG : case LOG_NZ : costs = 32 ; break ; case NCOL : case NROW : case PRINT : case ASSERT : case CAST_AS_BOOLEAN : case CAST_AS_DOUBLE : case CAST_AS_INT : case CAST_AS_MATRIX : case CAST_AS_SCALAR : costs = 1 ; break ; case SIN : costs = 18 ; break ; case COS : costs = 22 ; break ; case TAN : costs = 42 ; break ; case ASIN : costs = 93 ; break ; case ACOS : costs = 103 ; break ; case ATAN : costs = 40 ; break ; case SINH : costs = 93 ; break ; case COSH : costs = 103 ; break ; case TANH : costs = 40 ; break ; case CUMSUM : case CUMMIN : case CUMMAX : case CUMPROD : costs = 1 ; break ; case CUMSUMPROD : costs = 2 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( UnaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof BinaryOp ) { switch ( ( ( BinaryOp ) current ) . getOp ( ) ) { case MULT : case PLUS : case MINUS : case MIN : case MAX : case AND : case OR : case EQUAL : case NOTEQUAL : case LESS : case LESSEQUAL : case GREATER : case GREATEREQUAL : case CBIND : case RBIND : costs = 1 ; break ; case INTDIV : costs = 6 ; break ; case MODULUS : costs = 8 ; break ; case DIV : costs = 22 ; break ; case LOG : case LOG_NZ : costs = 32 ; break ; case POW : costs = ( HopRewriteUtils . isLiteralOfValue ( current . getInput ( ) . get ( 1 ) , 2 ) ? 1 : 16 ) ; break ; case MINUS_NZ : case MINUS1_MULT : costs = 2 ; break ; case MOMENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof LiteralOp ? HopRewriteUtils . getIntValueSafe ( ( LiteralOp ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 1 ; break ; case 1 : costs = 8 ; break ; case 2 : costs = 16 ; break ; case 3 : costs = 31 ; break ; case 4 : costs = 51 ; break ; case 5 : costs = 16 ; break ; } break ; case COV : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( BinaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof TernaryOp ) { switch ( ( ( TernaryOp ) current ) . getOp ( ) ) { case IFELSE : case PLUS_MULT : case MINUS_MULT : costs = 2 ; break ; case CTABLE : costs = 3 ; break ; case MOMENT : int type = ( int ) ( current . getInput ( ) . get ( 1 ) instanceof LiteralOp ? HopRewriteUtils . getIntValueSafe ( ( LiteralOp ) current . getInput ( ) . get ( 1 ) ) : 2 ) ; switch ( type ) { case 0 : costs = 2 ; break ; case 1 : costs = 9 ; break ; case 2 : costs = 17 ; break ; case 3 : costs = 32 ; break ; case 4 : costs = 52 ; break ; case 5 : costs = 17 ; break ; } break ; case COV : costs = 23 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( TernaryOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof NaryOp ) { costs = HopRewriteUtils . isNary ( current , OpOpN . MIN , OpOpN . MAX ) ? current . getInput ( ) . size ( ) : 1 ; } else if ( current instanceof ParameterizedBuiltinOp ) { costs = 1 ; } else if ( current instanceof IndexingOp ) { costs = 1 ; } else if ( current instanceof ReorgOp ) { costs = 1 ; } else if ( current instanceof DnnOp ) { switch ( ( ( DnnOp ) current ) . getOp ( ) ) { case BIASADD : case BIASMULT : costs = 2 ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( DnnOp ) current ) . getOp ( ) ) ; } } else if ( current instanceof AggBinaryOp ) { costs = 2 * current . getInput ( ) . get ( 0 ) . getDim2 ( ) ; if ( current . getInput ( ) . get ( 0 ) . dimsKnown ( true ) ) costs *= current . getInput ( ) . get ( 0 ) . getSparsity ( ) ; } else if ( current instanceof AggUnaryOp ) { switch ( ( ( AggUnaryOp ) current ) . getOp ( ) ) { case SUM : costs = 4 ; break ; case SUM_SQ : costs = 5 ; break ; case MIN : case MAX : costs = 1 ; break ; default : LOG . warn ( " Cost ▁ model ▁ not ▁ " + " implemented ▁ yet ▁ for : ▁ " + ( ( AggUnaryOp ) current ) . getOp ( ) ) ; } switch ( ( ( AggUnaryOp ) current ) . getDirection ( ) ) { case Col : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . getDim1 ( ) , 1 ) ; break ; case Row : costs *= Math . max ( current . getInput ( ) . get ( 0 ) . getDim2 ( ) , 1 ) ; break ; case RowCol : costs *= getSize ( current . getInput ( ) . get ( 0 ) ) ; break ; } } costs *= getSize ( current ) ; computeCosts . put ( current . getHopID ( ) , costs ) ; }
deroneriksson/incubator-systemml | private static boolean hasNoRefToMatPoint ( long hopID , MemoTableEntry me , InterestingPoint [ ] M , boolean [ ] plan ) { return ! InterestingPoint . isMatPoint ( M , hopID , me , plan ) ; }
deroneriksson/incubator-systemml | private static boolean isImplicitlyFused ( Hop hop , int index , TemplateType type ) { return type == TemplateType . ROW && HopRewriteUtils . isMatrixMultiply ( hop ) && index == 0 && HopRewriteUtils . isTransposeOperation ( hop . getInput ( ) . get ( index ) ) ; }
deroneriksson/incubator-systemml | private static boolean probePlanCache ( InterestingPoint [ ] matPoints ) { return matPoints . length >= PLAN_CACHE_NUM_POINTS ; }
deroneriksson/incubator-systemml | private static boolean [ ] getPlan ( PartitionSignature pKey ) { boolean [ ] plan = null ; synchronized ( _planCache ) { plan = _planCache . get ( pKey ) ; } if ( ConfigurationManager . isStatistics ( ) ) { if ( plan != null ) Statistics . incrementCodegenPlanCacheHits ( ) ; Statistics . incrementCodegenPlanCacheTotal ( ) ; } return plan ; }
deroneriksson/incubator-systemml | private static void putPlan ( PartitionSignature pKey , boolean [ ] plan ) { synchronized ( _planCache ) { if ( _planCache . size ( ) >= PLAN_CACHE_SIZE ) { Iterator < Entry < PartitionSignature , boolean [ ] > > iter = _planCache . entrySet ( ) . iterator ( ) ; iter . next ( ) ; iter . remove ( ) ; } _planCache . put ( pKey , plan ) ; } }
archos-sa/aos-MediaLib | public static MetaFile2 getMetaFileForUrl ( Uri uri ) throws Exception { if ( " upnp " . equals ( uri . getScheme ( ) ) ) { return UpnpFile2 . fromUri ( uri ) ; } if ( " http " . equals ( uri . getScheme ( ) ) || " https " . equals ( uri . getScheme ( ) ) ) { return HttpFile2 . fromUri ( uri ) ; } else return MetaFile2Factory . getMetaFileForUrl ( uri ) ; }
freeVM/freeVM | public static void run ( File dir , File props ) { new MsgClassGenerator ( ) . generate ( dir , props ) ; }
freeVM/freeVM | private static File getResourceFromJar ( String entryPath , String fileName ) { try { InputStream jis = MsgClassGenerator . class . getClassLoader ( ) . getResourceAsStream ( entryPath + fileName ) ; if ( jis == null ) { logMessage ( " Error : ▁ there ▁ is ▁ no ▁ " + entryPath + fileName + " ▁ in ▁ the ▁ resources ! " ) ; return null ; } File resFile = new File ( fileName ) ; resFile . createNewFile ( ) ; resFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( resFile ) ; byte [ ] data = new byte [ jis . available ( ) ] ; int i ; while ( ( i = jis . read ( data ) ) > 0 ) { fos . write ( data , 0 , i ) ; data = new byte [ jis . available ( ) ] ; } jis . close ( ) ; fos . close ( ) ; return resFile ; } catch ( Exception e ) { logMessage ( " Couldn ' t ▁ extract ▁ resource ! " ) ; e . printStackTrace ( ) ; return null ; } }
freeVM/freeVM | public static void logMessage ( String msg ) { System . out . println ( msg ) ; }
Susankha/developer-studio | public static HTPackage init ( ) { if ( isInited ) return ( HTPackage ) EPackage . Registry . INSTANCE . getEPackage ( HTPackage . eNS_URI ) ; HTPackageImpl theHTPackage = ( HTPackageImpl ) ( EPackage . Registry . INSTANCE . get ( eNS_URI ) instanceof HTPackageImpl ? EPackage . Registry . INSTANCE . get ( eNS_URI ) : new HTPackageImpl ( ) ) ; isInited = true ; XMLNamespacePackage . eINSTANCE . eClass ( ) ; XMLTypePackage . eINSTANCE . eClass ( ) ; theHTPackage . createPackageContents ( ) ; theHTPackage . initializePackageContents ( ) ; theHTPackage . freeze ( ) ; EPackage . Registry . INSTANCE . put ( HTPackage . eNS_URI , theHTPackage ) ; return theHTPackage ; }
arivanajoki/keycloak | public static ClientModel authorizeClient ( String authorizationHeader , MultivaluedMap < String , String > formData , EventBuilder event , RealmModel realm ) { String client_id = null ; String clientSecret = null ; if ( authorizationHeader != null ) { String [ ] usernameSecret = BasicAuthHelper . parseHeader ( authorizationHeader ) ; if ( usernameSecret != null ) { client_id = usernameSecret [ 0 ] ; clientSecret = usernameSecret [ 1 ] ; } else { if ( ! formData . containsKey ( OAuth2Constants . CLIENT_ID ) ) { throw new UnauthorizedException ( " Bad ▁ Authorization ▁ header " , Response . status ( 401 ) . header ( HttpHeaders . WWW_AUTHENTICATE , " Basic ▁ realm = \" " + realm . getName ( ) + " \" " ) . build ( ) ) ; } } } if ( client_id == null ) { client_id = formData . getFirst ( OAuth2Constants . CLIENT_ID ) ; clientSecret = formData . getFirst ( " client _ secret " ) ; } if ( client_id == null ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2Constants . ERROR_DESCRIPTION , " Missing ▁ client _ id ▁ parameter " ) ; throw new BadRequestException ( " Could ▁ not ▁ find ▁ client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } event . client ( client_id ) ; ClientModel client = realm . getClientByClientId ( client_id ) ; if ( client == null ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2Constants . ERROR_DESCRIPTION , " Could ▁ not ▁ find ▁ client " ) ; event . error ( Errors . CLIENT_NOT_FOUND ) ; throw new BadRequestException ( " Could ▁ not ▁ find ▁ client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } if ( ! client . isEnabled ( ) ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " invalid _ client " ) ; error . put ( OAuth2Constants . ERROR_DESCRIPTION , " Client ▁ is ▁ not ▁ enabled " ) ; event . error ( Errors . CLIENT_DISABLED ) ; throw new BadRequestException ( " Client ▁ is ▁ not ▁ enabled " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } if ( ! client . isPublicClient ( ) ) { if ( clientSecret == null || ! client . validateSecret ( clientSecret ) ) { Map < String , String > error = new HashMap < String , String > ( ) ; error . put ( OAuth2Constants . ERROR , " unauthorized _ client " ) ; event . error ( Errors . INVALID_CLIENT_CREDENTIALS ) ; throw new BadRequestException ( " Unauthorized ▁ Client " , Response . status ( Response . Status . BAD_REQUEST ) . entity ( error ) . type ( MediaType . APPLICATION_JSON_TYPE ) . build ( ) ) ; } } return client ; }
jkandasa/hawkular-java-client | public static Metric < Double > genGaugeDef ( ) { return ( Metric < Double > ) genDef ( MetricType . GAUGE ) ; }
jkandasa/hawkular-java-client | public static Metric < Long > genCounterDef ( ) { return ( Metric < Long > ) genDef ( MetricType . COUNTER ) ; }
jkandasa/hawkular-java-client | public static Metric < AvailabilityType > genAvailDef ( ) { return ( Metric < AvailabilityType > ) genDef ( MetricType . AVAILABILITY ) ; }
jkandasa/hawkular-java-client | public static < T > Metric < ? > genDef ( MetricType < T > metricType ) { MetricId < ? > id = new MetricId < > ( BaseTest . getRandomId ( ) , metricType , BaseTest . getRandomId ( ) ) ; return new Metric < > ( id , TAGS , DATA_RETENTION ) ; }
nicolaferraro/camel | static CordaComponentBuilder corda ( ) { return new CordaComponentBuilderImpl ( ) ; }
c3p0hz/microscope | private static final DefaultFormat DATE_FORMAT = new DefaultFormat ( DateTimeFormat . getFormat ( " yyyy / MM / dd - HH : mm : ss " ) ) { @ Override public Date parse ( final DateBox box , final String text , final boolean report_error ) { if ( text . endsWith ( " ▁ ago " ) || text . endsWith ( " - ago " ) ) { int interval ; final int lastchar = text . length ( ) - 5 ; try { interval = Integer . parseInt ( text . substring ( 0 , lastchar ) ) ; } catch ( NumberFormatException e ) { setError ( box ) ; return null ; } if ( interval <= 0 ) { setError ( box ) ; return null ; } switch ( text . charAt ( lastchar ) ) { case ' s ' : break ; case ' m ' : interval *= 60 ; break ; case ' h ' : interval *= 3600 ; break ; case ' d ' : interval *= 3600 * 24 ; break ; case ' w ' : interval *= 3600 * 24 * 7 ; break ; case ' y ' : interval *= 3600 * 24 * 365 ; break ; } final Date d = new Date ( ) ; d . setTime ( d . getTime ( ) - interval * 1000L ) ; return d ; } else if ( text . length ( ) == 5 ) { try { return HHMM_FORMAT . parse ( text ) ; } catch ( IllegalArgumentException ignored ) { setError ( box ) ; return null ; } } return super . parse ( box , text , report_error ) ; } private void setError ( final DateBox box ) { box . addStyleName ( " dateBoxFormatError " ) ; } }
Kisamegr/Crawler | public static void main ( String [ ] args ) { new Exctractor ( ) ; new Analyzer ( ) ; }
yeastrc/proxl-web-app | public static DB_Insert_UnifiedRepPepIsotopeLabelLookupDAO getInstance ( ) { return new DB_Insert_UnifiedRepPepIsotopeLabelLookupDAO ( ) ; }
adrapereira/jena | @ BeforeClass public static void beforeClass ( ) { RIOT . init ( ) ; }
emory-libraries-ecds/namedropper-oxygen | public static String getGeoNamesUsername ( ) { return PluginOptions . getOption ( SelectionActionGeoNames . GEONAMES_USERNAME ) ; }
emory-libraries-ecds/namedropper-oxygen | public static void setGeoNamesUsername ( String value ) { PluginOptions . setOption ( SelectionActionGeoNames . GEONAMES_USERNAME , value ) ; }
georgewfraser/vscode-javac | private static String testMethodStatic ( ) { return " foo " ; }
Applications-Development/SimpleRssReader | public static < T > T get ( final Context context , final String key , final Class < T > clazz ) { if ( clazz . equals ( String . class ) ) { return ( T ) getSharedPreferences ( context ) . getString ( key , null ) ; } return ( T ) ( Integer ) getSharedPreferences ( context ) . getInt ( key , 0 ) ; }
Applications-Development/SimpleRssReader | public static < T > void put ( final Context context , final String key , @ Nullable final T value ) { final SharedPreferences . Editor preferences = getSharedPreferences ( context ) . edit ( ) ; if ( value == null || value instanceof String ) { preferences . putString ( key , ( String ) value ) ; } else { preferences . putInt ( key , ( Integer ) value ) ; } preferences . apply ( ) ; }
Applications-Development/SimpleRssReader | private static SharedPreferences getSharedPreferences ( final Context context ) { if ( sSharedPreferences == null ) { sSharedPreferences = context . getSharedPreferences ( KEY_SHARED_PREFERENCES , Context . MODE_PRIVATE ) ; } return sSharedPreferences ; }
Applications-Development/SimpleRssReader | private static LinkedListMultimap < String , String > getSubscriptions ( final Context context ) { if ( sSubscriptions == null ) { sSubscriptions = LinkedListMultimap . create ( ) ; final String subscriptions = get ( context , KEY_SUBSCRIPTIONS , String . class ) ; if ( ! TextUtils . isEmpty ( subscriptions ) ) { try { final JSONObject JSON = new JSONObject ( subscriptions ) ; final JSONArray titlesJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_TITLES ) ; final JSONArray categoriesJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_CATEGORIES ) ; final JSONArray idsJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_IDS ) ; final JSONArray urlsJSON = JSON . getJSONArray ( KEY_SUBSCRIPTION_URLS ) ; for ( int i = 0 ; i < titlesJSON . length ( ) ; i ++ ) { final String title = titlesJSON . getString ( i ) ; sSubscriptions . put ( title , categoriesJSON . getString ( i ) ) ; sSubscriptions . put ( title , idsJSON . getString ( i ) ) ; sSubscriptions . put ( title , urlsJSON . getString ( i ) ) ; } } catch ( final JSONException e ) { LogUtils . logError ( e ) ; } } } return sSubscriptions ; }
Applications-Development/SimpleRssReader | public static String getSubscriptionTitleAt ( final Context context , final int position ) { final List < String > titles = new ArrayList < > ( getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) ; if ( titles . size ( ) > position ) { return titles . get ( position ) ; } return null ; }
Applications-Development/SimpleRssReader | public static String getSubscriptionIdAt ( final Context context , final int position ) { final String title = getSubscriptionTitleAt ( context , position ) ; if ( ! TextUtils . isEmpty ( title ) ) { return getSubscriptions ( context ) . get ( title ) . get ( 1 ) ; } return null ; }
Applications-Development/SimpleRssReader | public static String getSubscriptionUrlAt ( final Context context , final int position ) { final String title = getSubscriptionTitleAt ( context , position ) ; if ( ! TextUtils . isEmpty ( title ) ) { return getSubscriptions ( context ) . get ( title ) . get ( 2 ) ; } return null ; }
Applications-Development/SimpleRssReader | public static List < String > getSubscriptionTitlesFor ( final Context context , final List < Integer > positions ) { final List < String > titles = new ArrayList < > ( getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) ; final List < String > result = new ArrayList < > ( positions . size ( ) ) ; for ( final int position : positions ) { result . add ( titles . get ( position ) ) ; } return result ; }
Applications-Development/SimpleRssReader | public static List < List < Object > > getSubscriptionsFor ( final Context context , final String newCategory ) { if ( sSubscriptionList == null ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final boolean queryEmpty = TextUtils . isEmpty ( newCategory ) ; sSubscriptionList = new ArrayList < > ( subscriptions . size ( ) ) ; int i = 0 ; for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { final String category = subscriptions . get ( title ) . get ( 0 ) ; if ( queryEmpty || newCategory . equals ( category ) ) { if ( queryEmpty ) { sSubscriptionList . add ( Arrays . < Object > asList ( title , category ) ) ; } else { sSubscriptionList . add ( Arrays . < Object > asList ( title , category , i ) ) ; } } i ++ ; } } return sSubscriptionList ; }
Applications-Development/SimpleRssReader | static List < Object > getSubscriptionsAsOutlines ( final Context context , final boolean retainCategories ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final List < Object > outlines = new ArrayList < > ( subscriptions . size ( ) ) ; final LinkedListMultimap < String , Outline > outlineGroups = LinkedListMultimap . create ( ) ; for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { final String category = subscriptions . get ( title ) . get ( 0 ) ; final String xmlUrl = subscriptions . get ( title ) . get ( 2 ) ; final Outline outline = new Outline . Builder ( ) . setText ( title ) . setTitle ( title ) . setXmlUrl ( xmlUrl ) . build ( ) ; if ( retainCategories ) { outlineGroups . put ( category , outline ) ; } else { outlines . add ( outline ) ; } } if ( retainCategories ) { for ( final String category : outlineGroups . asMap ( ) . keySet ( ) ) { outlines . add ( new OutlineGroup . Builder ( ) . setText ( category ) . setTitle ( category ) . addSubOutlines ( outlineGroups . get ( category ) ) . build ( ) ) ; } } return outlines ; }
Applications-Development/SimpleRssReader | public static String [ ] getSubscriptionCategories ( final Context context , final boolean edit ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final Set < String > categories = new TreeSet < > ( ) ; if ( ! edit ) { categories . add ( context . getString ( R . string . all_categories ) ) ; } else { categories . add ( context . getString ( R . string . clear_category ) ) ; } for ( final String title : subscriptions . asMap ( ) . keySet ( ) ) { categories . add ( subscriptions . get ( title ) . get ( 0 ) ) ; } return categories . toArray ( new String [ categories . size ( ) ] ) ; }
Applications-Development/SimpleRssReader | private static int getSubscriptionPositionAfterEdit ( final Context context , final String newTitle ) { int i = 0 ; for ( final String title : getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) { if ( title . equals ( newTitle ) ) { break ; } i ++ ; } return i ; }
Applications-Development/SimpleRssReader | public static int getSubscriptionsCnt ( final Context context ) { return getSubscriptions ( context ) . asMap ( ) . size ( ) ; }
Applications-Development/SimpleRssReader | public static int addSubscription ( final Context context , final String title , final String category , final String url ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final String currentTitle = getCurrentFeedTitle ( context ) ; subscriptions . putAll ( title , Arrays . asList ( category , " " , url ) ) ; saveSubscriptions ( context , subscriptions ) ; return updateCurrentFeedPosition ( context , currentTitle ) ; }
Applications-Development/SimpleRssReader | public static void addSubscriptions ( final Context context , final List outlines ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; for ( final Object outline : outlines ) { if ( outline instanceof Outline ) { final String text = ( ( Outline ) outline ) . getText ( ) ; final String xmlUrl = ( ( Outline ) outline ) . getXmlUrl ( ) ; final String category = context . getString ( R . string . uncategorized ) ; if ( ! TextUtils . isEmpty ( xmlUrl ) && ! TextUtils . isEmpty ( text ) && ! subscriptions . containsKey ( text ) ) { subscriptions . putAll ( text . trim ( ) , Arrays . asList ( category , " " , xmlUrl ) ) ; } } else { for ( final Outline subOutline : ( ( OutlineGroup ) outline ) . getOutlines ( ) ) { final String text = subOutline . getText ( ) ; final String xmlUrl = subOutline . getXmlUrl ( ) ; final String category = ( ( OutlineGroup ) outline ) . getText ( ) ; if ( ! TextUtils . isEmpty ( xmlUrl ) && ! TextUtils . isEmpty ( text ) && ! subscriptions . containsKey ( text ) ) { subscriptions . putAll ( text . trim ( ) , Arrays . asList ( category , " " , xmlUrl ) ) ; } } } } final String currentTitle = getCurrentFeedTitle ( context ) ; saveSubscriptions ( context , subscriptions ) ; updateCurrentFeedPosition ( context , currentTitle ) ; }
Applications-Development/SimpleRssReader | private static void saveSubscriptions ( final Context context , final LinkedListMultimap < String , String > subscriptions ) { if ( subscriptions != null ) { final JSONObject JSON = new JSONObject ( ) ; final JSONArray titlesJSON = new JSONArray ( ) ; final JSONArray categoriesJSON = new JSONArray ( ) ; final JSONArray idsJSON = new JSONArray ( ) ; final JSONArray urlsJSON = new JSONArray ( ) ; final List < String > titles = new ArrayList < > ( subscriptions . asMap ( ) . keySet ( ) ) ; Collections . sort ( titles ) ; for ( final String title : titles ) { final Iterator < String > iter = subscriptions . get ( title ) . iterator ( ) ; titlesJSON . put ( title ) ; categoriesJSON . put ( iter . next ( ) ) ; idsJSON . put ( iter . next ( ) ) ; urlsJSON . put ( iter . next ( ) ) ; } try { JSON . put ( KEY_SUBSCRIPTION_TITLES , titlesJSON ) ; JSON . put ( KEY_SUBSCRIPTION_CATEGORIES , categoriesJSON ) ; JSON . put ( KEY_SUBSCRIPTION_IDS , idsJSON ) ; JSON . put ( KEY_SUBSCRIPTION_URLS , urlsJSON ) ; put ( context , KEY_SUBSCRIPTIONS , JSON . toString ( ) ) ; } catch ( final JSONException e ) { LogUtils . logError ( e ) ; } } else { put ( context , KEY_SUBSCRIPTIONS , null ) ; } sSubscriptions = null ; sSubscriptionList = null ; }
Applications-Development/SimpleRssReader | public static void updateSubscriptionUrl ( final Context context , final String feedUrl ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final int position = getCurrentFeedPosition ( context ) ; final String title = getSubscriptionTitleAt ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; values . set ( 2 , feedUrl ) ; subscriptions . replaceValues ( title , values ) ; saveSubscriptions ( context , subscriptions ) ; }
Applications-Development/SimpleRssReader | public static void updateSubscriptionIdAt ( final Context context , final String id , final int position ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final String title = getSubscriptionTitleAt ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; values . set ( 1 , id ) ; subscriptions . replaceValues ( title , values ) ; saveSubscriptions ( context , subscriptions ) ; }
Applications-Development/SimpleRssReader | public static void updateSubscriptionCategoryTitleAt ( final Context context , final String category , final String newTitle , final int position ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; final String title = getSubscriptionTitleAt ( context , position ) ; final List < String > values = subscriptions . get ( title ) ; final boolean newCategory = ! values . get ( 0 ) . equals ( category ) ; if ( newCategory || ! newTitle . equals ( title ) ) { if ( newCategory ) { final List < String > newValues = new ArrayList < > ( subscriptions . removeAll ( title ) ) ; newValues . set ( 0 , category ) ; subscriptions . putAll ( newTitle , newValues ) ; } else { subscriptions . putAll ( newTitle , subscriptions . removeAll ( title ) ) ; } saveSubscriptions ( context , subscriptions ) ; updateCurrentFeedPosition ( context , newTitle ) ; } }
Applications-Development/SimpleRssReader | public static boolean unsubscribe ( final Context context , final List < String > titles ) { final LinkedListMultimap < String , String > subscriptions = getSubscriptions ( context ) ; if ( subscriptions . asMap ( ) . size ( ) < 2 ) { saveSubscriptions ( context , null ) ; putCurrentFeedPosition ( context , 0 ) ; putPreviousFeedPosition ( context , 0 ) ; return false ; } final String currentTitle = getCurrentFeedTitle ( context ) ; for ( final String title : titles ) { subscriptions . removeAll ( title ) ; } if ( subscriptions . isEmpty ( ) ) { saveSubscriptions ( context , null ) ; putCurrentFeedPosition ( context , 0 ) ; putPreviousFeedPosition ( context , 0 ) ; return false ; } saveSubscriptions ( context , subscriptions ) ; if ( subscriptions . containsKey ( currentTitle ) ) { updateCurrentFeedPosition ( context , currentTitle ) ; return false ; } return true ; }
Applications-Development/SimpleRssReader | public static void invalidateSubscriptionList ( ) { sSubscriptionList = null ; }
Applications-Development/SimpleRssReader | public static boolean isSubscriptionsEmpty ( final Context context ) { return getSubscriptions ( context ) . isEmpty ( ) ; }
Applications-Development/SimpleRssReader | public static SearchResults getSearchResultsFor ( final Context context , final String query , final int position ) { final List < Integer > positions = new ArrayList < > ( ) ; final List < LinkedHashMap < Integer , Integer > > indices = new ArrayList < > ( ) ; int i = 0 ; for ( final String title : getSubscriptions ( context ) . asMap ( ) . keySet ( ) ) { if ( StringUtils . containsIgnoreCase ( title , query ) ) { indices . add ( SearchUtils . getIndicesForQuery ( title , query ) ) ; positions . add ( i ) ; } i ++ ; } return new SearchResults ( position , positions , indices ) ; }
Applications-Development/SimpleRssReader | public static int getCurrentFeedPosition ( final Context context ) { return get ( context , KEY_CURRENT_FEED_POSITION , Integer . class ) ; }
Applications-Development/SimpleRssReader | public static void putCurrentFeedPosition ( final Context context , final int position ) { putPreviousFeedPosition ( context , getCurrentFeedPosition ( context ) ) ; put ( context , KEY_CURRENT_FEED_POSITION , position ) ; }
Applications-Development/SimpleRssReader | private static void putPreviousFeedPosition ( final Context context , final int position ) { put ( context , KEY_PREVIOUS_FEED_POSITION , position ) ; }
Applications-Development/SimpleRssReader | public static int getPreviousFeedPosition ( final Context context ) { return get ( context , KEY_PREVIOUS_FEED_POSITION , Integer . class ) ; }
Applications-Development/SimpleRssReader | private static int updateCurrentFeedPosition ( final Context context , final String title ) { if ( ! TextUtils . isEmpty ( title ) ) { final int position = getSubscriptionPositionAfterEdit ( context , title ) ; putCurrentFeedPosition ( context , position ) ; return position ; } return 0 ; }
Applications-Development/SimpleRssReader | public static String getCurrentFeedUrl ( final Context context ) { return getSubscriptionUrlAt ( context , getCurrentFeedPosition ( context ) ) ; }
Applications-Development/SimpleRssReader | public static String getCurrentFeedTitle ( final Context context ) { return getSubscriptionTitleAt ( context , getCurrentFeedPosition ( context ) ) ; }
leafclick/intellij-community | @ Contract ( " _ ▁ - > ▁ new " ) @ NotNull public static DFAType create ( @ Nullable PsiType type ) { return new DFAType ( type ) ; }
leafclick/intellij-community | private static boolean eq ( PsiType t1 , PsiType t2 ) { return t1 == t2 || Comparing . equal ( TypeConversionUtil . erasure ( t1 ) , TypeConversionUtil . erasure ( t2 ) ) ; }
leafclick/intellij-community | @ NotNull public static DFAType create ( DFAType t1 , DFAType t2 , PsiManager manager ) { if ( t1 . equals ( t2 ) ) return t1 ; final PsiType primary = TypesUtil . getLeastUpperBoundNullable ( t1 . primary , t2 . primary , manager ) ; final DFAType type = new DFAType ( primary ) ; final PsiType type1 = reduce ( t1 . mixins ) ; final PsiType type2 = reduce ( t2 . mixins ) ; if ( type1 != null && type2 != null ) { type . addMixin ( GenericsUtil . getLeastUpperBound ( type1 , type2 , manager ) , null ) ; } return type ; }
leafclick/intellij-community | private static PsiType reduce ( List < Mixin > mixins ) { List < PsiType > types = mixins . stream ( ) . filter ( it -> ! it . myNegated ) . map ( it -> it . myType ) . collect ( toList ( ) ) ; return types . isEmpty ( ) ? null : PsiIntersectionType . createIntersection ( types ) ; }
joinAero/DroidTurbo | public static boolean checkPermissionGranted ( @ NonNull Context context , @ NonNull String permission ) { return ContextCompat . checkSelfPermission ( context , permission ) == PackageManager . PERMISSION_GRANTED ; }
joinAero/DroidTurbo | public static boolean checkPermissionsGranted ( @ NonNull Context context , @ NonNull String ... permissions ) { for ( String permission : permissions ) { if ( ContextCompat . checkSelfPermission ( context , permission ) != PackageManager . PERMISSION_GRANTED ) { return false ; } } return true ; }
joinAero/DroidTurbo | public static boolean shouldPermissionShowRationale ( @ NonNull Activity activity , @ NonNull String permission ) { return ActivityCompat . shouldShowRequestPermissionRationale ( activity , permission ) ; }
joinAero/DroidTurbo | public static boolean shouldPermissionsShowRationale ( @ NonNull Activity activity , @ NonNull String ... permissions ) { for ( String permission : permissions ) { if ( ActivityCompat . shouldShowRequestPermissionRationale ( activity , permission ) ) { return true ; } } return false ; }
joinAero/DroidTurbo | public static boolean verifyPermission ( int [ ] grantResults ) { return grantResults . length == 1 && grantResults [ 0 ] == PackageManager . PERMISSION_GRANTED ; }
joinAero/DroidTurbo | public static boolean verifyPermissions ( int [ ] grantResults ) { if ( grantResults . length < 1 ) { return false ; } for ( int result : grantResults ) { if ( result != PackageManager . PERMISSION_GRANTED ) { return false ; } } return true ; }
poornan/product-is | public static List < KeyValue > extractDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { String [ ] tokens = line . split ( " ' " ) ; KeyValue keyValue = new KeyValue ( key , tokens [ keyPositionMap . get ( key ) ] ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractInputValueFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " value = \" ( \\ S + ) \" " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractLabelValueFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { Pattern p = Pattern . compile ( " > ( \\ S + ) < / label > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractTableRowDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { boolean lineReached = false ; List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { lineReached = true ; continue ; } if ( lineReached ) { if ( line . contains ( " < td > " ) ) { Pattern p = Pattern . compile ( " < td > ( \\ S + ) < / td > " ) ; Matcher m = p . matcher ( line ) ; if ( m . find ( ) ) { KeyValue keyValue = new KeyValue ( key , m . group ( 1 ) ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static List < KeyValue > extractSessionConsentDataFromResponse ( HttpResponse response , Map < String , Integer > keyPositionMap ) throws IOException { boolean lineReached = false ; List < KeyValue > keyValues = new ArrayList < KeyValue > ( ) ; BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; while ( ( line = rd . readLine ( ) ) != null ) { for ( String key : keyPositionMap . keySet ( ) ) { if ( line . contains ( key ) ) { lineReached = true ; } if ( lineReached ) { if ( line . contains ( " value " ) ) { String [ ] tokens = line . split ( " \" " ) ; KeyValue keyValue = new KeyValue ( key , tokens [ 1 ] ) ; keyValues . add ( keyValue ) ; return keyValues ; } } } } rd . close ( ) ; return null ; }
poornan/product-is | public static String extractAccessTokenFromQueryString ( String query ) { String [ ] params = query . split ( " & " ) ; for ( String param : params ) { String name = param . split ( " = " ) [ 0 ] ; String value = param . split ( " = " ) [ 1 ] ; if ( name . contains ( " access _ token " ) ) return value ; } return null ; }
poornan/product-is | public static String getContentData ( HttpResponse response ) throws IOException { BufferedReader rd = new BufferedReader ( new InputStreamReader ( response . getEntity ( ) . getContent ( ) ) ) ; String line ; StringBuffer result = new StringBuffer ( ) ; while ( ( line = rd . readLine ( ) ) != null ) { result = result . append ( line ) ; } rd . close ( ) ; return result . toString ( ) ; }
gustavoanatoly/flink | public static DataStream < Tuple3 < Integer , Long , String > > getSmall3TupleDataSet ( StreamExecutionEnvironment env ) { List < Tuple3 < Integer , Long , String > > data = new ArrayList < > ( ) ; data . add ( new Tuple3 < > ( 1 , 1L , " Hi " ) ) ; data . add ( new Tuple3 < > ( 2 , 2L , " Hello " ) ) ; data . add ( new Tuple3 < > ( 3 , 2L , " Hello ▁ world " ) ) ; Collections . shuffle ( data ) ; return env . fromCollection ( data ) ; }
gustavoanatoly/flink | public static DataStream < Tuple5 < Integer , Long , Integer , String , Long > > get5TupleDataStream ( StreamExecutionEnvironment env ) { List < Tuple5 < Integer , Long , Integer , String , Long > > data = new ArrayList < > ( ) ; data . add ( new Tuple5 < > ( 1 , 1L , 0 , " Hallo " , 1L ) ) ; data . add ( new Tuple5 < > ( 2 , 2L , 1 , " Hallo ▁ Welt " , 2L ) ) ; data . add ( new Tuple5 < > ( 2 , 3L , 2 , " Hallo ▁ Welt ▁ wie " , 1L ) ) ; data . add ( new Tuple5 < > ( 3 , 4L , 3 , " Hallo ▁ Welt ▁ wie ▁ gehts ? " , 2L ) ) ; data . add ( new Tuple5 < > ( 3 , 5L , 4 , " ABC " , 2L ) ) ; data . add ( new Tuple5 < > ( 3 , 6L , 5 , " BCD " , 3L ) ) ; data . add ( new Tuple5 < > ( 4 , 7L , 6 , " CDE " , 2L ) ) ; data . add ( new Tuple5 < > ( 4 , 8L , 7 , " DEF " , 1L ) ) ; data . add ( new Tuple5 < > ( 4 , 9L , 8 , " EFG " , 1L ) ) ; data . add ( new Tuple5 < > ( 4 , 10L , 9 , " FGH " , 2L ) ) ; data . add ( new Tuple5 < > ( 5 , 11L , 10 , " GHI " , 1L ) ) ; data . add ( new Tuple5 < > ( 5 , 12L , 11 , " HIJ " , 3L ) ) ; data . add ( new Tuple5 < > ( 5 , 13L , 12 , " IJK " , 3L ) ) ; data . add ( new Tuple5 < > ( 5 , 15L , 14 , " KLM " , 2L ) ) ; data . add ( new Tuple5 < > ( 5 , 14L , 13 , " JKL " , 2L ) ) ; return env . fromCollection ( data ) ; }
nobry/karuta-backend | public static java . sql . Timestamp toSQLTimestamp ( ZonedDateTime dt ) { java . sql . Timestamp ts = ( dt == null ? null : new java . sql . Timestamp ( dt . toInstant ( ) . toEpochMilli ( ) ) ) ; return ts ; }
nobry/karuta-backend | public static java . util . Date toJavaDate ( ZonedDateTime dt ) { java . util . Date ts = ( dt == null ? null : new java . util . Date ( dt . toInstant ( ) . toEpochMilli ( ) ) ) ; return ts ; }
nobry/karuta-backend | public static String toTimeZoneID ( ZonedDateTime dt ) { String s = ( dt == null ? null : dt . getZone ( ) . getId ( ) ) ; return s ; }
nobry/karuta-backend | public static java . sql . Date toSQLDate ( LocalDate ld ) { java . sql . Date d = ( ld == null ? null : new java . sql . Date ( ld . atStartOfDay ( paris ) . toInstant ( ) . toEpochMilli ( ) ) ) ; return d ; }
nobry/karuta-backend | public static java . util . Date toJavaDate ( LocalDate ld ) { java . util . Date d = ( ld == null ? null : Date . from ( ld . atStartOfDay ( paris ) . toInstant ( ) ) ) ; return d ; }
nobry/karuta-backend | public static String toString ( LocalDate ld ) { String s = ( ld == null ? null : localDateFormatter . withZone ( ZoneId . of ( " UTC " ) ) . format ( ld ) ) ; return s ; }
nobry/karuta-backend | public static java . sql . Timestamp toSQLTimestamp ( LocalDateTime ldt ) { java . sql . Timestamp ts = ( ldt == null ? null : Timestamp . valueOf ( ldt ) ) ; return ts ; }
nobry/karuta-backend | public static java . util . Date toJavaDate ( LocalDateTime ldt ) { java . util . Date d = ( ldt == null ? null : Date . from ( ldt . atZone ( paris ) . toInstant ( ) ) ) ; return d ; }
nobry/karuta-backend | public static java . sql . Time toSQLTime ( LocalTime lt ) { java . sql . Time t = ( lt == null ? null : Time . valueOf ( lt ) ) ; return t ; }
nobry/karuta-backend | public static Long toNanoSecond ( LocalTime lt ) { Long i = ( lt == null ? null : new Long ( lt . toNanoOfDay ( ) ) ) ; return i ; }
nobry/karuta-backend | public static String toString ( LocalTime lt ) { String s = ( lt == null ? null : lt . toString ( ) ) ; return s ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . sql . Date d ) { ZonedDateTime dm = ( d == null ? null : d . toLocalDate ( ) . atStartOfDay ( paris ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . util . Date d ) { ZonedDateTime dm = ( d == null ? null : toLocalDate ( d ) . atStartOfDay ( paris ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . sql . Date d , String timeZoneID ) { ZonedDateTime dm = ( d == null ? null : d . toLocalDate ( ) . atStartOfDay ( ZoneId . of ( timeZoneID ) ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateMidnight ( java . util . Date d , String timeZoneID ) { ZonedDateTime dm = ( d == null ? null : toLocalDate ( d ) . atStartOfDay ( ZoneId . of ( timeZoneID ) ) ) ; return dm ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . sql . Timestamp ts ) { ZonedDateTime dt = ( ts == null ? null : ZonedDateTime . ofInstant ( ts . toInstant ( ) , paris ) ) ; return dt ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . util . Date d ) { ZonedDateTime dt = ( d == null ? null : ZonedDateTime . ofInstant ( d . toInstant ( ) , paris ) ) ; return dt ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . sql . Timestamp ts , String timeZoneID ) { ZonedDateTime dt = ( ts == null ? null : ZonedDateTime . ofInstant ( ts . toInstant ( ) , ZoneId . of ( timeZoneID ) ) ) ; return dt ; }
nobry/karuta-backend | public static ZonedDateTime toDateTime ( java . util . Date d , String timeZoneID ) { ZonedDateTime dt = ( d == null ? null : ZonedDateTime . ofInstant ( d . toInstant ( ) , ZoneId . of ( timeZoneID ) ) ) ; return dt ; }
nobry/karuta-backend | public static LocalDate toLocalDate ( java . sql . Date d ) { LocalDate ld = ( d == null ? null : d . toLocalDate ( ) ) ; return ld ; }
nobry/karuta-backend | public static LocalDate toLocalDate ( java . util . Date d ) { LocalDate ld = ( d == null ? null : d . toInstant ( ) . atZone ( paris ) . toLocalDate ( ) ) ; return ld ; }
nobry/karuta-backend | public static LocalDate toLocalDate ( String s ) { LocalDate ld = ( s == null ? null : LocalDate . parse ( s , localDateFormatter . withZone ( ZoneId . of ( " UTC " ) ) ) ) ; return ld ; }
nobry/karuta-backend | public static LocalDateTime toLocalDateTime ( java . sql . Timestamp ts ) { LocalDateTime ldt = ( ts == null ? null : ts . toLocalDateTime ( ) ) ; return ldt ; }
nobry/karuta-backend | public static LocalDateTime toLocalDateTime ( java . util . Date d ) { LocalDateTime ldt = ( d == null ? null : d . toInstant ( ) . atZone ( paris ) . toLocalDateTime ( ) ) ; return ldt ; }
nobry/karuta-backend | public static LocalTime toLocalTime ( java . sql . Time t ) { LocalTime lt = ( t == null ? null : t . toInstant ( ) . atZone ( ZoneId . of ( " UTC " ) ) . toLocalTime ( ) ) ; return lt ; }
nobry/karuta-backend | public static LocalTime toLocalTime ( Long i ) { LocalTime lt = ( i == null ? null : LocalTime . ofNanoOfDay ( i ) ) ; return lt ; }
nobry/karuta-backend | public static LocalTime toLocalTime ( String s ) { LocalTime lt = ( s == null ? null : LocalTime . parse ( s ) ) ; return lt ; }
nobry/karuta-backend | public static void main ( String [ ] args ) { System . out . println ( " ▁ " ) ; test_dateTime ( ) ; System . out . println ( " ▁ " ) ; test_dateTime_tz ( ) ; System . out . println ( " ▁ " ) ; test_localDate ( ) ; System . out . println ( " ▁ " ) ; test_localDate_tz ( ) ; System . out . println ( " ▁ " ) ; test_localDateTime ( ) ; System . out . println ( " ▁ " ) ; test_localDate_shift_java_tz ( ) ; System . out . println ( " ▁ " ) ; test_localTime_as_integer ( ) ; System . out . println ( " ▁ " ) ; test_localTime_as_string ( ) ; System . out . println ( " ▁ " ) ; }
nobry/karuta-backend | public static void test_dateTime ( ) { System . out . println ( " Test ▁ ZonedDateTime " ) ; ZonedDateTime dt1 = ZonedDateTime . now ( ) ; java . sql . Timestamp ts = toSQLTimestamp ( dt1 ) ; ZonedDateTime dt2 = toDateTime ( ts ) ; System . out . println ( " ZonedDateTime ▁ 1 ▁ = ▁ " + dt1 ) ; System . out . println ( " Timestamp ▁ ▁ = ▁ " + ts ) ; System . out . println ( " ZonedDateTime ▁ 2 ▁ = ▁ " + dt2 ) ; if ( ! dt2 . equals ( dt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_dateTime_tz ( ) { System . out . println ( " Test ▁ ZonedDateTime ▁ with ▁ timezone " ) ; ZonedDateTime dt1 = ZonedDateTime . now ( losAngeles ) ; java . sql . Timestamp ts = toSQLTimestamp ( dt1 ) ; String tzID = toTimeZoneID ( dt1 ) ; ZonedDateTime dt2 = toDateTime ( ts , tzID ) ; System . out . println ( " ZonedDateTime ▁ 1 ▁ = ▁ " + dt1 ) ; System . out . println ( " Timestamp ▁ ▁ = ▁ " + ts ) ; System . out . println ( " TimeZoneID ▁ = ▁ " + tzID ) ; System . out . println ( " ZonedDateTime ▁ 2 ▁ = ▁ " + dt2 ) ; if ( ! dt2 . equals ( dt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDate ( ) { System . out . println ( " Test ▁ LocalDate " ) ; LocalDate ld1 = LocalDate . now ( ) ; java . sql . Date d = toSQLDate ( ld1 ) ; LocalDate ld2 = toLocalDate ( d ) ; System . out . println ( " LocalDate ▁ 1 ▁ = ▁ " + ld1 ) ; System . out . println ( " Date ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + d ) ; System . out . println ( " LocalDate ▁ 2 ▁ = ▁ " + ld2 ) ; if ( ! ld2 . equals ( ld1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDate_tz ( ) { System . out . println ( " Test ▁ LocalDate ▁ with ▁ timezone " ) ; LocalDate ld1 = LocalDate . now ( losAngeles ) ; java . sql . Date d = toSQLDate ( ld1 ) ; LocalDate ld2 = toLocalDate ( d ) ; System . out . println ( " LocalDate ▁ 1 ▁ = ▁ " + ld1 ) ; System . out . println ( " Date ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + d ) ; System . out . println ( " LocalDate ▁ 2 ▁ = ▁ " + ld2 ) ; if ( ! ld2 . equals ( ld1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDate_shift_java_tz ( ) { System . out . println ( " Test ▁ LocalDate ▁ with ▁ shifted ▁ Java ▁ timezone " ) ; TimeZone originalTZ = TimeZone . getDefault ( ) ; TimeZone losAngelesTZ = TimeZone . getTimeZone ( " America / Los _ Angeles " ) ; TimeZone . setDefault ( losAngelesTZ ) ; LocalDate ld1 = LocalDate . now ( ) ; System . out . println ( " ld1 ▁ LocalDate ( ) ▁ ▁ ▁ = ▁ " + ld1 + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; java . sql . Date d = toSQLDate ( ld1 ) ; System . out . println ( " d ▁ toSQLDate ( ld1 ) ▁ ▁ = ▁ " + d + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; TimeZone . setDefault ( originalTZ ) ; System . out . println ( " d ▁ toSQLDate ( ld1 ) ▁ ▁ = ▁ " + d + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; LocalDate ld2 = toLocalDate ( d ) ; System . out . println ( " ld2 ▁ toLocalDate ( d ) ▁ = ▁ " + ld2 + " ▁ when ▁ default ▁ TZ ▁ = ▁ " + TimeZone . getDefault ( ) ) ; TimeZone . setDefault ( originalTZ ) ; if ( ! ld2 . equals ( ld1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localDateTime ( ) { System . out . println ( " Test ▁ LocalDateTime " ) ; LocalDateTime ldt1 = LocalDateTime . now ( ) ; java . sql . Timestamp ts = toSQLTimestamp ( ldt1 ) ; LocalDateTime ldt2 = toLocalDateTime ( ts ) ; System . out . println ( " LocalDateTime ▁ 1 ▁ = ▁ " + ldt1 ) ; System . out . println ( " Timestamp ▁ ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + ts ) ; System . out . println ( " LocalDateTime ▁ 2 ▁ = ▁ " + ldt2 ) ; if ( ! ldt2 . equals ( ldt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localTime_as_integer ( ) { System . out . println ( " Test ▁ LocalTime ▁ as ▁ Integer " ) ; LocalTime lt1 = LocalTime . now ( ) ; Long i = toNanoSecond ( lt1 ) ; LocalTime lt2 = toLocalTime ( i ) ; System . out . println ( " LocalTime ▁ 1 ▁ = ▁ " + lt1 ) ; System . out . println ( " Integer ▁ ▁ ▁ ▁ ▁ = ▁ " + i ) ; System . out . println ( " LocalTime ▁ 2 ▁ = ▁ " + lt2 ) ; if ( ! lt2 . equals ( lt1 ) ) { throw new IllegalStateException ( ) ; } }
nobry/karuta-backend | public static void test_localTime_as_string ( ) { System . out . println ( " Test ▁ LocalTime ▁ as ▁ String " ) ; LocalTime lt1 = LocalTime . now ( ) ; String t = toString ( lt1 ) ; LocalTime lt2 = toLocalTime ( t ) ; System . out . println ( " LocalTime ▁ 1 ▁ = ▁ " + lt1 ) ; System . out . println ( " String ▁ ▁ ▁ ▁ ▁ ▁ = ▁ " + t ) ; System . out . println ( " LocalTime ▁ 2 ▁ = ▁ " + lt2 ) ; if ( ! lt2 . equals ( lt1 ) ) { throw new IllegalStateException ( ) ; } }
tdelev/MULLAN | public static void main ( String [ ] argv ) { runFilter ( new ClassOrder ( ) , argv ) ; }
Alex-Diez/Java-TDD-Katas | private static final Set < Character > LEGAL_NUMBER_CHAR = new HashSet < Character > ( ) { { add ( '0' ) ; add ( '1' ) ; add ( '2' ) ; add ( '3' ) ; add ( '4' ) ; add ( '5' ) ; add ( '6' ) ; add ( '7' ) ; add ( '8' ) ; add ( '9' ) ; add ( ' . ' ) ; } }
Alex-Diez/Java-TDD-Katas | public static double calculate ( String source ) { Chars chars = new Chars ( source ) ; return parseExpression ( chars ) ; }
Alex-Diez/Java-TDD-Katas | private static double parseExpression ( Chars chars ) { double term = parseTerm ( chars ) ; while ( chars . hasNext ( ) ) { char c = chars . peek ( ) ; if ( c == ' + ' ) { chars . next ( ) ; term += parseTerm ( chars ) ; } else if ( c == ' - ' ) { chars . next ( ) ; term -= parseTerm ( chars ) ; } else { break ; } } return term ; }
Alex-Diez/Java-TDD-Katas | private static double parseTerm ( Chars chars ) { double arg = parseArg ( chars ) ; while ( chars . hasNext ( ) ) { char c = chars . peek ( ) ; if ( c == ' × ' ) { chars . next ( ) ; arg *= parseArg ( chars ) ; } else if ( c == ' ÷ ' ) { chars . next ( ) ; arg /= parseArg ( chars ) ; } else { break ; } } return arg ; }
Alex-Diez/Java-TDD-Katas | private static double parseArg ( Chars chars ) { int start = chars . index ( ) ; while ( chars . hasNext ( ) && LEGAL_NUMBER_CHAR . contains ( chars . peek ( ) ) ) { chars . next ( ) ; } int end = chars . index ( ) ; return Double . parseDouble ( chars . subString ( start , end ) ) ; }
jentfoo/aws-sdk-java | public static StartSchemaExtensionRequestMarshaller getInstance ( ) { return instance ; }
DLotts/incubator-rya | public static Bytes spoFormat ( final RyaStatement triple ) throws TripleRowResolverException { checkNotNull ( triple ) ; final Map < TABLE_LAYOUT , TripleRow > serialized = TRIPLE_RESOLVER . serialize ( triple ) ; final TripleRow spoRow = serialized . get ( TABLE_LAYOUT . SPO ) ; return addTriplePrefixAndConvertToBytes ( spoRow . getRow ( ) ) ; }
PeterASteele/CodeForcesSolutions | public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; int cases = in . nextInt ( ) ; for ( int q = 0 ; q < cases ; q ++ ) { int n = in . nextInt ( ) ; int [ ] arr1 = new int [ n ] ; int [ ] arr2 = new int [ n ] ; HashSet < Integer > set = new HashSet < Integer > ( ) ; for ( int a = 0 ; a < n ; a ++ ) { arr1 [ a ] = in . nextInt ( ) ; } for ( int a = 0 ; a < n ; a ++ ) { arr2 [ a ] = in . nextInt ( ) ; } int start = 1 ; int end = 1 ; StringBuilder out = new StringBuilder ( ) ; for ( int a = 0 ; a < n ; a ++ ) { addRemoveSet ( arr1 [ a ] , set ) ; addRemoveSet ( arr2 [ a ] , set ) ; if ( set . size ( ) == 0 ) { out . append ( start + " - " + end + " ▁ " ) ; start = end + 1 ; end = start ; } else { end ++ ; } } System . out . println ( out ) ; } }
PeterASteele/CodeForcesSolutions | public static void addRemoveSet ( int i , HashSet < Integer > set ) { if ( set . contains ( i ) ) { set . remove ( i ) ; } else { set . add ( i ) ; } }
castagna/jax-rs-example | @ BeforeClass public static void setUpBeforeClass ( ) throws Exception { client = Client . create ( ) ; }
castagna/jax-rs-example | @ AfterClass public static void tearDownAfterClass ( ) throws Exception { if ( client != null ) { client . destroy ( ) ; client = null ; } }
gygesM/test | public static void main ( String [ ] args ) { PageData pd = new PageData ( ) ; pd . put ( " username " , " zhangsan " ) ; checkParam ( " registered " , pd ) ; }
gygesM/test | public static boolean checkParam ( String method , PageData pd ) { boolean result = false ; int falseCount = 0 ; String [ ] paramArray = new String [ 20 ] ; String [ ] valueArray = new String [ 20 ] ; String [ ] tempArray = new String [ 20 ] ; if ( method == " registered " ) { paramArray = Const . APP_REGISTERED_PARAM_ARRAY ; valueArray = Const . APP_REGISTERED_VALUE_ARRAY ; } else if ( method == " getAppuserByUsernmae " ) { paramArray = Const . APP_GETAPPUSER_PARAM_ARRAY ; valueArray = Const . APP_GETAPPUSER_VALUE_ARRAY ; } int size = paramArray . length ; for ( int i = 0 ; i < size ; i ++ ) { String param = paramArray [ i ] ; if ( ! pd . containsKey ( param ) ) { tempArray [ falseCount ] = valueArray [ i ] + " - - " + param ; falseCount += 1 ; } } if ( falseCount > 0 ) { logger . error ( method + " 接口 ， 请求协议中缺少 ▁ " + falseCount + " 个 ▁ 参数 " ) ; for ( int j = 1 ; j <= falseCount ; j ++ ) { logger . error ( " ▁ ▁ ▁ 第 " + j + " 个 ： " + tempArray [ j - 1 ] ) ; } } else { result = true ; } return result ; }
gygesM/test | public static PageData setPageParam ( PageData pd ) { String page_now_str = pd . get ( " page _ now " ) . toString ( ) ; int pageNowInt = Integer . parseInt ( page_now_str ) - 1 ; String page_size_str = pd . get ( " page _ size " ) . toString ( ) ; int pageSizeInt = Integer . parseInt ( page_size_str ) ; String page_now = pageNowInt + " " ; String page_start = ( pageNowInt * pageSizeInt ) + " " ; pd . put ( " page _ now " , page_now ) ; pd . put ( " page _ start " , page_start ) ; return pd ; }
gygesM/test | public static List < PageData > setListDistance ( List < PageData > list , PageData pd ) { List < PageData > listReturn = new ArrayList < PageData > ( ) ; String user_longitude = " " ; String user_latitude = " " ; try { user_longitude = pd . get ( " user _ longitude " ) . toString ( ) ; user_latitude = pd . get ( " user _ latitude " ) . toString ( ) ; } catch ( Exception e ) { logger . error ( " 缺失参数 - - user _ longitude和user _ longitude " ) ; logger . error ( " lost ▁ param ： user _ longitude ▁ and ▁ user _ longitude " ) ; } PageData pdTemp = new PageData ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { pdTemp = list . get ( i ) ; String longitude = pdTemp . get ( " longitude " ) . toString ( ) ; String latitude = pdTemp . get ( " latitude " ) . toString ( ) ; String distance = MapDistance . getDistance ( user_longitude , user_latitude , longitude , latitude ) ; pdTemp . put ( " distance " , distance ) ; pdTemp . put ( " size " , distance . length ( ) ) ; listReturn . add ( pdTemp ) ; } return listReturn ; }
gygesM/test | public static Object returnObject ( PageData pd , Map map ) { if ( pd . containsKey ( " callback " ) ) { String callback = pd . get ( " callback " ) . toString ( ) ; return new JSONPObject ( callback , map ) ; } else { return map ; } }
JSDemos/android-sdk-20 | private static boolean checkKeysEqual ( PublicKey pk1 , PublicKey pk2 ) { String format1 = pk1 . getFormat ( ) ; String format2 ; if ( ( pk2 == null ) || ( ( ( format2 = pk2 . getFormat ( ) ) != null ) ^ ( format1 != null ) ) || ( ( format1 != null ) && ! format1 . equals ( format2 ) ) ) { return false ; } return Arrays . equals ( pk1 . getEncoded ( ) , pk2 . getEncoded ( ) ) ; }
somi92/sqldbb | public static void testEntityProcessorAndQueryBuilders ( ) { ClassD d = new ClassD ( 41 , " d1" ) ; ClassC c = new ClassC ( 31 , 3 ) ; ClassB b = new ClassB ( 21 , " b1" , c ) ; ClassA a = new ClassA ( 11 , 111 , " a1" , b , d ) ; ClassF f = new ClassF ( ) ; DatabaseEntity dbe1 = EntityProcessor . createEntity ( a . getClass ( ) ) ; EntityProcessor . printEntity ( dbe1 ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; QueryBuilder qb = new QueryBuilder ( new SelectQueryBuilder ( true ) ) ; qb . buildQuery ( dbe1 ) ; Query query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new UpdateQueryBuilder ( ) ) ; qb . buildQuery ( dbe1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new InsertQueryBuilder ( ) ) ; qb . buildQuery ( dbe1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; qb = new QueryBuilder ( new DeleteQueryBuilder ( false ) ) ; qb . buildQuery ( dbe1 ) ; query = qb . getQuery ( ) ; System . out . println ( query ) ; System . out . println ( " " ) ; System . out . println ( " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = " + " = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = \n " ) ; }
somi92/sqldbb | public static void testEntityLoading ( ) throws SQLException { ClassD d = new ClassD ( ) ; d . setD1 ( 44 ) ; ClassC c = new ClassC ( ) ; c . setC1 ( 32 ) ; ClassB b = new ClassB ( ) ; b . setB1 ( 21 ) ; ClassA a = new ClassA ( ) ; a . setA1 ( 11 ) ; a . setA11 ( 111 ) ; Object [ ] loaded = new Object [ 4 ] ; loaded [ 0 ] = broker . loadEntity ( d , false ) ; loaded [ 1 ] = broker . loadEntity ( c , false ) ; loaded [ 2 ] = broker . loadEntity ( b , false ) ; loaded [ 3 ] = broker . loadEntity ( a , false ) ; System . out . println ( " " ) ; for ( Object o : loaded ) { System . out . println ( o ) ; } }
somi92/sqldbb | public static void testComplexKeys ( ) throws SQLException { ClassCD loaded = new ClassCD ( ) ; loaded . setC ( new ClassC ( 31 , 0 ) ) ; loaded . setD ( new ClassD ( 44 , null ) ) ; loaded = broker . loadEntity ( loaded , false ) ; System . out . println ( loaded ) ; }
somi92/sqldbb | public static void testInsert ( ) { try { ClassD d1 = new ClassD ( 41 , null ) ; ClassD d2 = new ClassD ( 43 , null ) ; ClassD d3 = new ClassD ( 45 , null ) ; ClassB b1 = new ClassB ( 21 , null , null ) ; ClassB b2 = new ClassB ( 23 , null , null ) ; ClassA a1 = new ClassA ( 14 , 114 , " a4 - b3 - d5" , b2 , d3 ) ; ClassA a2 = new ClassA ( 15 , 115 , " a5 - b1 - d3" , b1 , d2 ) ; ClassA a3 = new ClassA ( 16 , 116 , " a6 - b3 - d1" , b2 , d1 ) ; List < ClassA > list = new ArrayList < > ( ) ; list . add ( a1 ) ; list . add ( a2 ) ; list . add ( a3 ) ; ClassA a4 = new ClassA ( 17 , 117 , " a6 - b3 - d1" , b2 , d1 ) ; broker . insertEntity ( a4 ) ; broker . commitTransaction ( ) ; System . out . println ( " Inserting ▁ entities ▁ successful . " ) ; } catch ( SQLException ex ) { broker . rollbackTransaction ( ) ; System . out . println ( " Inserting ▁ entities ▁ - ▁ transaction ▁ rollback : ▁ " + ex . getMessage ( ) ) ; } }
somi92/sqldbb | public static void testCollections ( ) throws SQLException { ClassF f = new ClassF ( ) ; f . setF2 ( " F1" ) ; List < String > search = new ArrayList < > ( ) ; search . add ( " f2" ) ; List < ClassF > loadedF = broker . loadEntities ( f , null , true ) ; for ( ClassF fe : loadedF ) { System . out . println ( fe ) ; } }
somi92/sqldbb | public static void testTypes ( ) { try { TypesTesting tt = new TypesTesting ( ) ; tt . setL ( 1000 ) ; TypesTesting loaded = broker . loadEntity ( tt , false ) ; System . out . println ( loaded ) ; broker . commitTransaction ( ) ; System . out . println ( " Types ▁ testing ▁ - ▁ OK ! " ) ; } catch ( SQLException ex ) { broker . rollbackTransaction ( ) ; System . out . println ( " Types ▁ testing ▁ - ▁ Error : ▁ " + ex . getMessage ( ) ) ; } }
thiagosena/Halligator | public static TextureContainer < TiledTextureRegion > produce ( final Texture texture , final Context context , final String assetPath , final int texturePositionX , final int texturePositionY , final int tileColumns , final int tileRows ) { return new TextureContainer < TiledTextureRegion > ( TextureRegionFactory . createTiledFromAsset ( texture , context , assetPath , texturePositionX , texturePositionY , tileColumns , tileRows ) , getPixels ( assetPath , context , tileColumns , tileRows ) , assetPath ) ; }
thiagosena/Halligator | public static TextureContainer < TextureRegion > produce ( final Texture texture , final Context context , final String assetPath , final int texturePositionX , final int texturePositionY ) { return new TextureContainer < TextureRegion > ( TextureRegionFactory . createFromAsset ( texture , context , assetPath , texturePositionX , texturePositionY ) , getPixels ( assetPath , context , 1 , 1 ) , assetPath ) ; }
thiagosena/Halligator | private static boolean [ ] [ ] getPixels ( final String assetPath , final Context context , final int tileColumns , final int tileRows ) { final Bitmap bitmap = getBitmap ( assetPath , context ) ; if ( bitmap == null ) { return null ; } final int xOffset = bitmap . getWidth ( ) / tileColumns ; final int yOffset = bitmap . getHeight ( ) / tileRows ; final boolean [ ] [ ] pixels = new boolean [ xOffset ] [ yOffset ] ; for ( int x = 0 ; x < xOffset ; x ++ ) { for ( int y = 0 ; y < yOffset ; y ++ ) { pixels [ x ] [ y ] = bitmap . getPixel ( x , y ) == Color . TRANSPARENT ? ALPHA : PIXEL ; } } return pixels ; }
thiagosena/Halligator | private static Bitmap getBitmap ( final String assetPath , final Context context ) { InputStream stream = null ; Bitmap bitmap = null ; try { stream = context . getAssets ( ) . open ( HalligatorActivity . GRAPHIC_ASSETS_PATH + assetPath ) ; bitmap = BitmapFactory . decodeStream ( stream ) ; } catch ( IOException e ) { Log . e ( " TextureContainerProvider " , " Exception " , e ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { Log . e ( " TextureContainerProvider " , " Exception " , e ) ; } } return bitmap ; }
PrismTech/agentv | public static void insert ( org . omg . CORBA . Any a , com . prismtech . agentv . core . types . UpgradeMicrosvc that ) { org . omg . CORBA . portable . OutputStream out = a . create_output_stream ( ) ; a . type ( type ( ) ) ; write ( out , that ) ; a . read_value ( out . create_input_stream ( ) , type ( ) ) ; }
PrismTech/agentv | public static com . prismtech . agentv . core . types . UpgradeMicrosvc extract ( org . omg . CORBA . Any a ) { return read ( a . create_input_stream ( ) ) ; }
PrismTech/agentv | synchronized public static org . omg . CORBA . TypeCode type ( ) { if ( __typeCode == null ) { synchronized ( org . omg . CORBA . TypeCode . class ) { if ( __typeCode == null ) { if ( __active ) { return org . omg . CORBA . ORB . init ( ) . create_recursive_tc ( _id ) ; } __active = true ; org . omg . CORBA . StructMember [ ] _members0 = new org . omg . CORBA . StructMember [ 3 ] ; org . omg . CORBA . TypeCode _tcOf_members0 = null ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_string_tc ( 0 ) ; _members0 [ 0 ] = new org . omg . CORBA . StructMember ( " microsvc " , _tcOf_members0 , null ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . get_primitive_tc ( org . omg . CORBA . TCKind . tk_boolean ) ; _members0 [ 1 ] = new org . omg . CORBA . StructMember ( " backup " , _tcOf_members0 , null ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . get_primitive_tc ( org . omg . CORBA . TCKind . tk_octet ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_sequence_tc ( 0 , _tcOf_members0 ) ; _tcOf_members0 = org . omg . CORBA . ORB . init ( ) . create_alias_tc ( com . prismtech . agentv . core . types . ByteSeqHelper . id ( ) , " ByteSeq " , _tcOf_members0 ) ; _members0 [ 2 ] = new org . omg . CORBA . StructMember ( " payload " , _tcOf_members0 , null ) ; __typeCode = org . omg . CORBA . ORB . init ( ) . create_struct_tc ( com . prismtech . agentv . core . types . UpgradeMicrosvcHelper . id ( ) , " UpgradeMicrosvc " , _members0 ) ; __active = false ; } } } return __typeCode ; }
PrismTech/agentv | public static String id ( ) { return _id ; }
PrismTech/agentv | public static com . prismtech . agentv . core . types . UpgradeMicrosvc read ( org . omg . CORBA . portable . InputStream istream ) { com . prismtech . agentv . core . types . UpgradeMicrosvc value = new com . prismtech . agentv . core . types . UpgradeMicrosvc ( ) ; value . microsvc = istream . read_string ( ) ; value . backup = istream . read_boolean ( ) ; value . payload = com . prismtech . agentv . core . types . ByteSeqHelper . read ( istream ) ; return value ; }
PrismTech/agentv | public static void write ( org . omg . CORBA . portable . OutputStream ostream , com . prismtech . agentv . core . types . UpgradeMicrosvc value ) { ostream . write_string ( value . microsvc ) ; ostream . write_boolean ( value . backup ) ; com . prismtech . agentv . core . types . ByteSeqHelper . write ( ostream , value . payload ) ; }
emag/wildfly-swarm | public static void main ( final String [ ] args ) throws Exception { try { generateSwarmJar ( args ) ; } catch ( ExitException e ) { final String msg = e . getMessage ( ) ; if ( msg != null ) { System . err . println ( msg ) ; } if ( e . printHelp ) { if ( msg != null ) { System . err . println ( ) ; } System . err . println ( String . format ( " Usage : ▁ % s ▁ < options > ▁ artifact - path \n " , executableName ( ) ) ) ; try { OPT_PARSER . printHelpOn ( System . err ) ; } catch ( IOException ignored ) { } } System . exit ( e . status ) ; } }
emag/wildfly-swarm | protected static String executableName ( ) { String name = System . getenv ( " SWARMTOOL _ NAME " ) ; if ( name == null ) { name = " java ▁ - jar ▁ swarmtool - standalone . jar " ; } return name ; }
emag/wildfly-swarm | protected static File generateSwarmJar ( final String [ ] args ) throws Exception { OptionSet foundOptions = null ; try { foundOptions = OPT_PARSER . parse ( args ) ; } catch ( OptionException e ) { exit ( e . getMessage ( ) , true ) ; } if ( foundOptions . has ( HELP_OPT ) ) { exit ( null , 0 , true ) ; } if ( foundOptions . has ( VERSION_OPT ) ) { exit ( " swarmtool ▁ v " + VERSION , 0 ) ; } final List < File > nonOptArgs = foundOptions . valuesOf ( SOURCE_OPT ) ; if ( nonOptArgs . isEmpty ( ) ) { exit ( " No ▁ source ▁ artifact ▁ specified . " , true ) ; } if ( nonOptArgs . size ( ) > 1 ) { exit ( " Too ▁ many ▁ source ▁ artifacts ▁ provided ▁ ( " + nonOptArgs + " ) " , true ) ; } final File source = nonOptArgs . get ( 0 ) ; if ( ! source . exists ( ) ) { exit ( " File ▁ " + source . getAbsolutePath ( ) + " ▁ does ▁ not ▁ exist . " ) ; } final Properties properties = new Properties ( ) ; if ( foundOptions . has ( SYSPROPS_FILE_OPT ) ) { try ( InputStream in = new FileInputStream ( foundOptions . valueOf ( SYSPROPS_FILE_OPT ) ) ) { properties . load ( in ) ; } } foundOptions . valuesOf ( SYSPROPS_OPT ) . forEach ( prop -> { final String [ ] parts = prop . split ( " = " ) ; properties . put ( parts [ 0 ] , parts [ 1 ] ) ; } ) ; final DeclaredDependencies dependencies = new DeclaredDependencies ( ) ; foundOptions . valuesOf ( DEPENDENCIES_OPT ) . stream ( ) . map ( DeclaredDependencies :: createSpec ) . forEach ( dependencies :: add ) ; final String [ ] parts = source . getName ( ) . split ( " \\ . ( ? = [ ^ \\ . ] + $ ) " ) ; final String baseName = parts [ 0 ] ; final String type = parts [ 1 ] == null ? " jar " : parts [ 1 ] ; final String jarName = foundOptions . has ( NAME_OPT ) ? foundOptions . valueOf ( NAME_OPT ) : baseName ; final String outDir = new File ( foundOptions . valueOf ( OUTPUT_DIR_OPT ) ) . getCanonicalPath ( ) ; final String suffix = foundOptions . has ( HOLLOW_OPT ) ? " - hollow - swarm " : " - swarm " ; final BuildTool tool = new BuildTool ( getResolvingHelper ( foundOptions . valuesOf ( REPOS_OPT ) ) ) . projectArtifact ( " " , baseName , " " , type , source ) . declaredDependencies ( dependencies ) . fractionDetectionMode ( foundOptions . has ( DISABLE_AUTO_DETECT_OPT ) ? BuildTool . FractionDetectionMode . never : BuildTool . FractionDetectionMode . force ) . bundleDependencies ( ! foundOptions . has ( DISABLE_BUNDLE_DEPS_OPT ) ) . executable ( foundOptions . has ( EXECUTABLE_OPT ) ) . properties ( properties ) . hollow ( foundOptions . has ( HOLLOW_OPT ) ) ; if ( foundOptions . has ( MAIN_OPT ) ) { tool . mainClass ( foundOptions . valueOf ( MAIN_OPT ) ) ; } if ( foundOptions . has ( MODULES_OPT ) ) { tool . additionalModules ( foundOptions . valuesOf ( MODULES_OPT ) ) ; } if ( foundOptions . has ( DEBUG_LOGGING ) ) { tool . logger ( BuildTool . STD_LOGGER_WITH_DEBUG ) ; } addSwarmFractions ( tool , foundOptions . valuesOf ( FRACTIONS_OPT ) ) ; System . err . println ( String . format ( " Building ▁ % s / % s - % s . jar " , outDir , jarName , suffix ) ) ; return tool . build ( jarName , Paths . get ( outDir ) ) ; }
emag/wildfly-swarm | private static void exit ( String message ) { exit ( message , 1 ) ; }
emag/wildfly-swarm | private static void exit ( String message , boolean printHelp ) { exit ( message , 1 , printHelp ) ; }
emag/wildfly-swarm | private static void exit ( String message , int code ) { exit ( message , code , false ) ; }
emag/wildfly-swarm | private static void exit ( String message , int code , boolean printHelp ) { throw new ExitException ( code , printHelp , message ) ; }
emag/wildfly-swarm | private static ArtifactResolvingHelper getResolvingHelper ( final List < String > repos ) { final ConfigurableMavenResolverSystem resolver = Maven . configureResolver ( ) . withMavenCentralRepo ( true ) . withRemoteRepo ( MavenRemoteRepositories . createRemoteRepository ( " jboss - public - repository - group " , " https : // repository . jboss . org / nexus / content / groups / public / " , " default " ) . setChecksumPolicy ( MavenChecksumPolicy . CHECKSUM_POLICY_IGNORE ) . setUpdatePolicy ( MavenUpdatePolicy . UPDATE_POLICY_NEVER ) ) ; repos . forEach ( r -> resolver . withRemoteRepo ( MavenRemoteRepositories . createRemoteRepository ( r , r , " default " ) . setChecksumPolicy ( MavenChecksumPolicy . CHECKSUM_POLICY_IGNORE ) . setUpdatePolicy ( MavenUpdatePolicy . UPDATE_POLICY_NEVER ) ) ) ; return new ShrinkwrapArtifactResolvingHelper ( resolver ) ; }
emag/wildfly-swarm | private static void addSwarmFractions ( BuildTool tool , final List < String > deps ) { deps . stream ( ) . map ( f -> f . split ( " : " ) ) . map ( parts -> { switch ( parts . length ) { case 1 : final FractionDescriptor desc = FractionList . get ( ) . getFractionDescriptor ( " org . wildfly . swarm " , parts [ 0 ] ) ; if ( desc != null ) { return desc ; } else { System . err . println ( " Warning : ▁ Unknown ▁ fraction : ▁ " + parts [ 0 ] ) ; return null ; } case 2 : return new FractionDescriptor ( " org . wildfly . swarm " , parts [ 0 ] , parts [ 1 ] ) ; case 3 : return new FractionDescriptor ( parts [ 0 ] , parts [ 1 ] , parts [ 2 ] ) ; default : System . err . println ( " Warning : ▁ Invalid ▁ fraction ▁ specifier : ▁ " + String . join ( " : " , parts ) ) ; return null ; } } ) . filter ( f -> f != null ) . forEach ( f -> tool . fraction ( ArtifactSpec . fromFractionDescriptor ( f ) ) ) ; }
Esjob-Cloud-DevOps/elastic-job | public static void reset ( ) { completed = false ; }
aehlig/bazel | public static LabelLateBoundDefault < ? > getAndroidSdkLabel ( Label androidSdk ) { return LabelLateBoundDefault . fromTargetConfiguration ( AndroidConfiguration . class , androidSdk , ( rule , attributes , configuration ) -> configuration . getSdk ( ) ) ; }
aehlig/bazel | private static void setCrosstoolToAndroid ( BuildOptions options ) { AndroidConfiguration . Options androidOptions = options . get ( AndroidConfiguration . Options . class ) ; CppOptions cppOptions = options . get ( CppOptions . class ) ; if ( androidOptions . androidCrosstoolTop != null ) { cppOptions . crosstoolTop = androidOptions . androidCrosstoolTop ; } androidOptions . configurationDistinguisher = ConfigurationDistinguisher . ANDROID ; }
aehlig/bazel | public static boolean hasProguardSpecs ( AttributeMap rule ) { return rule . isConfigurable ( " proguard _ specs " ) || ! rule . get ( " proguard _ specs " , LABEL_LIST ) . isEmpty ( ) ; }
aehlig/bazel | public static final SafeImplicitOutputsFunction ANDROID_BINARY_IMPLICIT_OUTPUTS = new SafeImplicitOutputsFunction ( ) { @ Override public Iterable < String > getImplicitOutputs ( EventHandler eventHandler , AttributeMap rule ) { List < SafeImplicitOutputsFunction > functions = Lists . newArrayList ( ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_APK ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_UNSIGNED_APK ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_DEPLOY_JAR ) ; if ( hasProguardSpecs ( rule ) ) { functions . add ( AndroidRuleClasses . ANDROID_BINARY_PROGUARD_JAR ) ; functions . add ( JavaSemantics . JAVA_BINARY_PROGUARD_CONFIG ) ; if ( ProguardHelper . genProguardMapping ( rule ) ) { functions . add ( JavaSemantics . JAVA_BINARY_PROGUARD_MAP ) ; } } return fromFunctions ( functions ) . getImplicitOutputs ( eventHandler , rule ) ; } }
aehlig/bazel | public static final SafeImplicitOutputsFunction ANDROID_LIBRARY_IMPLICIT_OUTPUTS = new SafeImplicitOutputsFunction ( ) { @ Override public Iterable < String > getImplicitOutputs ( EventHandler eventHandler , AttributeMap attributes ) { ImmutableList . Builder < SafeImplicitOutputsFunction > implicitOutputs = ImmutableList . builder ( ) ; implicitOutputs . add ( AndroidRuleClasses . ANDROID_LIBRARY_class_JAR , AndroidRuleClasses . ANDROID_LIBRARY_SOURCE_JAR , AndroidRuleClasses . ANDROID_LIBRARY_AAR ) ; if ( AndroidResources . definesAndroidResources ( attributes ) ) { implicitOutputs . add ( AndroidRuleClasses . ANDROID_JAVA_SOURCE_JAR , AndroidRuleClasses . ANDROID_R_TXT , AndroidRuleClasses . ANDROID_RESOURCES_class_JAR ) ; } return fromFunctions ( implicitOutputs . build ( ) ) . getImplicitOutputs ( eventHandler , attributes ) ; } }
aehlig/bazel | public static MultidexMode fromValue ( String value ) { for ( MultidexMode mode : values ( ) ) { if ( mode . getAttributeValue ( ) . equals ( value ) ) { return mode ; } } return null ; }
aehlig/bazel | public static List < String > getValidValues ( ) { List < String > ans = Lists . newArrayList ( ) ; for ( MultidexMode mode : MultidexMode . values ( ) ) { ans . add ( mode . getAttributeValue ( ) ) ; } return ans ; }
Telecooperation/assistance-platform-client-sdk-android | public static void createTable ( Database db , boolean ifNotExists ) { String constraint = ifNotExists ? " IF ▁ NOT ▁ EXISTS ▁ " : " " ; db . execSQL ( " CREATE ▁ TABLE ▁ " + constraint + " \" contact _ email _ sensor \" ▁ ( " + " \" _ id \" ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT ▁ , " + " \" MAIL _ ID \" ▁ INTEGER , " + " \" ADDRESS \" ▁ TEXT , " + " \" TYPE \" ▁ TEXT , " + " \" IS _ NEW \" ▁ INTEGER , " + " \" IS _ UPDATED \" ▁ INTEGER , " + " \" IS _ DELETED \" ▁ INTEGER , " + " \" CREATED \" ▁ TEXT ▁ NOT ▁ NULL ▁ , " + " \" CONTACT _ ID \" ▁ INTEGER ▁ NOT ▁ NULL ▁ , " + " \" DEVICE _ ID \" ▁ INTEGER ▁ NOT ▁ NULL ▁ ) ; " ) ; db . execSQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ _ id ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \" _ id \" ) ; " ) ; db . execSQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ CONTACT _ ID ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \" CONTACT _ ID \" ) ; " ) ; db . execSQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ DEVICE _ ID ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \" DEVICE _ ID \" ) ; " ) ; }
Telecooperation/assistance-platform-client-sdk-android | public static void dropTable ( Database db , boolean ifExists ) { String sql = " DROP ▁ TABLE ▁ " + ( ifExists ? " IF ▁ EXISTS ▁ " : " " ) + " \" contact _ email _ sensor \" " ; db . execSQL ( sql ) ; }
codeck/XChange | public static Builder from ( KrakenUserTrade trade ) { Builder builder = new Builder ( ) . cost ( trade . getCost ( ) ) ; builder . orderId ( trade . getOrderId ( ) ) . feeAmount ( trade . getFeeAmount ( ) ) . feeCurrency ( trade . getFeeCurrency ( ) ) ; builder . type ( trade . getType ( ) ) . tradableAmount ( trade . getTradableAmount ( ) ) . currencyPair ( trade . getCurrencyPair ( ) ) . price ( trade . getPrice ( ) ) . timestamp ( trade . getTimestamp ( ) ) . id ( trade . getId ( ) ) ; return builder ; }
FHannes/intellij-community | private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor ( 0 , Integer . MAX_VALUE , 1 , TimeUnit . SECONDS , new LinkedBlockingQueue < > ( ) , new ThreadFactory ( ) { private final AtomicInteger num = new AtomicInteger ( ) ; @ NotNull @ Override public Thread newThread ( @ NotNull Runnable r ) { return new Thread ( r , " Maven ▁ Artifact ▁ Downloader ▁ " + num . getAndIncrement ( ) ) ; } }
FHannes/intellij-community | public static DownloadResult download ( @ NotNull Project project , MavenProjectsTree projectsTree , Collection < MavenProject > mavenProjects , @ Nullable Collection < MavenArtifact > artifacts , boolean downloadSources , boolean downloadDocs , MavenEmbedderWrapper embedder , MavenProgressIndicator p ) throws MavenProcessCanceledException { return new MavenArtifactDownloader ( project , projectsTree , mavenProjects , artifacts , embedder , p ) . download ( downloadSources , downloadDocs ) ; }
FHannes/intellij-community | @ TestOnly public static void awaitQuiescence ( long timeout , @ NotNull TimeUnit unit ) { ConcurrencyUtil . awaitQuiescence ( EXECUTOR , timeout , unit ) ; }
cjellick/gdapi-java-server | public static final void throwValidationError ( String code , String fieldName ) { throw new ClientVisibleException ( new ValidationErrorImpl ( code , fieldName ) ) ; }
webos21/xi | public static Long decode ( String string ) throws NumberFormatException { int length = string . length ( ) , i = 0 ; if ( length == 0 ) { throw new NumberFormatException ( ) ; } char firstDigit = string . charAt ( i ) ; boolean negative = firstDigit == ' - ' ; if ( negative ) { if ( length == 1 ) { throw new NumberFormatException ( string ) ; } firstDigit = string . charAt ( ++ i ) ; } int base = 10 ; if ( firstDigit == '0' ) { if ( ++ i == length ) { return valueOf ( 0L ) ; } if ( ( firstDigit = string . charAt ( i ) ) == ' x ' || firstDigit == ' X ' ) { if ( i == length ) { throw new NumberFormatException ( string ) ; } i ++ ; base = 16 ; } else { base = 8 ; } } else if ( firstDigit == ' # ' ) { if ( i == length ) { throw new NumberFormatException ( string ) ; } i ++ ; base = 16 ; } long result = parse ( string , i , base , negative ) ; return valueOf ( result ) ; }
webos21/xi | public static Long getLong ( String string ) { if ( string == null || string . length ( ) == 0 ) { return null ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return null ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return null ; } }
webos21/xi | public static Long getLong ( String string , long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return valueOf ( defaultValue ) ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return valueOf ( defaultValue ) ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return valueOf ( defaultValue ) ; } }
webos21/xi | public static Long getLong ( String string , Long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return defaultValue ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return defaultValue ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return defaultValue ; } }
webos21/xi | public static long parseLong ( String string ) throws NumberFormatException { return parseLong ( string , 10 ) ; }
webos21/xi | public static long parseLong ( String string , int radix ) throws NumberFormatException { if ( string == null || radix < Character . MIN_RADIX || radix > Character . MAX_RADIX ) { throw new NumberFormatException ( ) ; } int length = string . length ( ) , i = 0 ; if ( length == 0 ) { throw new NumberFormatException ( string ) ; } boolean negative = string . charAt ( i ) == ' - ' ; if ( negative && ++ i == length ) { throw new NumberFormatException ( string ) ; } return parse ( string , i , radix , negative ) ; }
webos21/xi | private static long parse ( String string , int offset , int radix , boolean negative ) { long max = Long . MIN_VALUE / radix ; long result = 0 , length = string . length ( ) ; while ( offset < length ) { int digit = Character . digit ( string . charAt ( offset ++ ) , radix ) ; if ( digit == - 1 ) { throw new NumberFormatException ( string ) ; } if ( max > result ) { throw new NumberFormatException ( string ) ; } long next = result * radix - digit ; if ( next > result ) { throw new NumberFormatException ( string ) ; } result = next ; } if ( ! negative ) { result = - result ; if ( result < 0 ) { throw new NumberFormatException ( string ) ; } } return result ; }
webos21/xi | public static String toBinaryString ( long v ) { return IntegralToString . longToBinaryString ( v ) ; }
webos21/xi | public static String toHexString ( long v ) { return IntegralToString . longToHexString ( v ) ; }
webos21/xi | public static String toOctalString ( long v ) { return IntegralToString . longToOctalString ( v ) ; }
webos21/xi | public static String toString ( long n ) { return IntegralToString . longToString ( n ) ; }
webos21/xi | public static String toString ( long v , int radix ) { return IntegralToString . longToString ( v , radix ) ; }
webos21/xi | public static Long valueOf ( String string ) throws NumberFormatException { return valueOf ( parseLong ( string ) ) ; }
webos21/xi | public static Long valueOf ( String string , int radix ) throws NumberFormatException { return valueOf ( parseLong ( string , radix ) ) ; }
webos21/xi | public static long highestOneBit ( long v ) { v |= ( v >> 1 ) ; v |= ( v >> 2 ) ; v |= ( v >> 4 ) ; v |= ( v >> 8 ) ; v |= ( v >> 16 ) ; v |= ( v >> 32 ) ; return v - ( v >>> 1 ) ; }
webos21/xi | public static long lowestOneBit ( long v ) { return v & - v ; }
webos21/xi | public static int numberOfLeadingZeros ( long v ) { if ( v < 0 ) { return 0 ; } if ( v == 0 ) { return 64 ; } int n = 1 ; int i = ( int ) ( v >>> 32 ) ; if ( i == 0 ) { n += 32 ; i = ( int ) v ; } if ( i >>> 16 == 0 ) { n += 16 ; i <<= 16 ; } if ( i >>> 24 == 0 ) { n += 8 ; i <<= 8 ; } if ( i >>> 28 == 0 ) { n += 4 ; i <<= 4 ; } if ( i >>> 30 == 0 ) { n += 2 ; i <<= 2 ; } return n - ( i >>> 31 ) ; }
webos21/xi | public static int numberOfTrailingZeros ( long v ) { int low = ( int ) v ; return low != 0 ? Integer . numberOfTrailingZeros ( low ) : 32 + Integer . numberOfTrailingZeros ( ( int ) ( v >>> 32 ) ) ; }
webos21/xi | public static int bitCount ( long v ) { v -= ( v >>> 1 ) & 0x5555555555555555L ; v = ( v & 0x3333333333333333L ) + ( ( v >>> 2 ) & 0x3333333333333333L ) ; int i = ( ( int ) ( v >>> 32 ) ) + ( int ) v ; i = ( i & 0x0F0F0F0F ) + ( ( i >>> 4 ) & 0x0F0F0F0F ) ; i += i >>> 8 ; i += i >>> 16 ; return i & 0x0000007F ; }
webos21/xi | public static long rotateLeft ( long v , int distance ) { return ( v << distance ) | ( v >>> - distance ) ; }
webos21/xi | public static long rotateRight ( long v , int distance ) { return ( v >>> distance ) | ( v << - distance ) ; }
webos21/xi | public static long reverseBytes ( long v ) { v = ( ( v >>> 8 ) & 0x00FF00FF00FF00FFL ) | ( ( v & 0x00FF00FF00FF00FFL ) << 8 ) ; v = ( ( v >>> 16 ) & 0x0000FFFF0000FFFFL ) | ( ( v & 0x0000FFFF0000FFFFL ) << 16 ) ; return ( ( v >>> 32 ) ) | ( ( v ) << 32 ) ; }
webos21/xi | public static long reverse ( long v ) { v = ( ( v >>> 1 ) & 0x5555555555555555L ) | ( ( v & 0x5555555555555555L ) << 1 ) ; v = ( ( v >>> 2 ) & 0x3333333333333333L ) | ( ( v & 0x3333333333333333L ) << 2 ) ; v = ( ( v >>> 4 ) & 0x0F0F0F0F0F0F0F0FL ) | ( ( v & 0x0F0F0F0F0F0F0F0FL ) << 4 ) ; v = ( ( v >>> 8 ) & 0x00FF00FF00FF00FFL ) | ( ( v & 0x00FF00FF00FF00FFL ) << 8 ) ; v = ( ( v >>> 16 ) & 0x0000FFFF0000FFFFL ) | ( ( v & 0x0000FFFF0000FFFFL ) << 16 ) ; return ( ( v >>> 32 ) ) | ( ( v ) << 32 ) ; }
webos21/xi | public static int signum ( long v ) { return v < 0 ? - 1 : ( v == 0 ? 0 : 1 ) ; }
webos21/xi | public static Long valueOf ( long v ) { return v >= 128 || v < - 128 ? new Long ( v ) : SMALL_VALUES [ ( ( int ) v ) + 128 ] ; }
Swrrt/Samza | public static < StreamMessageType > void containsInAnyOrder ( List < StreamMessageType > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; assertThat ( TestRunner . consumeStream ( outputDescriptor , timeout ) . entrySet ( ) . stream ( ) . flatMap ( entry -> entry . getValue ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) , IsIterableContainingInAnyOrder . containsInAnyOrder ( expected . toArray ( ) ) ) ; }
Swrrt/Samza | public static < StreamMessageType > void containsInAnyOrder ( Map < Integer , List < StreamMessageType > > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; Map < Integer , List < StreamMessageType > > actual = TestRunner . consumeStream ( outputDescriptor , timeout ) ; for ( Integer paritionId : expected . keySet ( ) ) { assertThat ( actual . get ( paritionId ) , IsIterableContainingInAnyOrder . containsInAnyOrder ( expected . get ( paritionId ) . toArray ( ) ) ) ; } }
Swrrt/Samza | public static < StreamMessageType > void containsInOrder ( List < StreamMessageType > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; assertThat ( TestRunner . consumeStream ( outputDescriptor , timeout ) . entrySet ( ) . stream ( ) . flatMap ( entry -> entry . getValue ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) , IsIterableContainingInOrder . contains ( expected . toArray ( ) ) ) ; }
Swrrt/Samza | public static < StreamMessageType > void containsInOrder ( Map < Integer , List < StreamMessageType > > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; Map < Integer , List < StreamMessageType > > actual = TestRunner . consumeStream ( outputDescriptor , timeout ) ; for ( Integer paritionId : expected . keySet ( ) ) { assertThat ( actual . get ( paritionId ) , IsIterableContainingInOrder . contains ( expected . get ( paritionId ) . toArray ( ) ) ) ; } }
GDG-Korea/holo_to_material | public static final Parcelable . Creator < Category > CREATOR = new Parcelable . Creator < Category > ( ) { public Category createFromParcel ( Parcel in ) { return new Category ( in ) ; } public Category [ ] newArray ( int size ) { return new Category [ size ] ; } }
idea4bsd/idea4bsd | @ NotNull private static String getPresentableText ( @ NotNull VcsFullCommitDetails commit , boolean withMessage ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( commit . getId ( ) . toShortString ( ) ) . append ( " ▁ " ) ; sb . append ( commit . getAuthor ( ) . getName ( ) ) ; long time = commit . getAuthorTime ( ) ; sb . append ( " ▁ on ▁ " ) . append ( DateFormatUtil . formatDate ( time ) ) . append ( " ▁ at ▁ " ) . append ( DateFormatUtil . formatTime ( time ) ) ; if ( ! Comparing . equal ( commit . getAuthor ( ) , commit . getCommitter ( ) ) ) { sb . append ( " ▁ ( committed ▁ by ▁ " ) . append ( commit . getCommitter ( ) . getName ( ) ) . append ( " ) " ) ; } if ( withMessage ) { sb . append ( " ▁ " ) . append ( commit . getSubject ( ) ) ; } return sb . toString ( ) ; }
idea4bsd/idea4bsd | public static JBColor getRootBackgroundColor ( @ NotNull VirtualFile root , @ NotNull VcsLogColorManager colorManager ) { return VcsLogColorManagerImpl . getBackgroundColor ( colorManager . getRootColor ( root ) ) ; }
TelerikAcademy/SchoolAcademy | static BigInteger fibonacci ( int n ) { if ( fib [ n ] == null ) { if ( ( n == 1 ) || ( n == 2 ) ) { fib [ n ] = BigInteger . valueOf ( 1 ) ; } else { fib [ n ] = fibonacci ( n - 1 ) . add ( fibonacci ( n - 2 ) ) ; } } return fib [ n ] ; }
TelerikAcademy/SchoolAcademy | public static void main ( String [ ] args ) { System . out . println ( fibonacci ( 10 ) ) ; System . out . println ( fibonacci ( 300 ) ) ; }
daiqiquan/framework-base | private static IConnectivityManager getService ( ) { return IConnectivityManager . Stub . asInterface ( ServiceManager . getService ( Context . CONNECTIVITY_SERVICE ) ) ; }
daiqiquan/framework-base | public static Intent prepare ( Context context ) { try { if ( getService ( ) . prepareVpn ( context . getPackageName ( ) , null , UserHandle . myUserId ( ) ) ) { return null ; } } catch ( RemoteException e ) { } return VpnConfig . getIntentForConfirmation ( ) ; }
daiqiquan/framework-base | @ SystemApi public static void prepareAndAuthorize ( Context context ) { IConnectivityManager cm = getService ( ) ; String packageName = context . getPackageName ( ) ; try { int userId = UserHandle . myUserId ( ) ; if ( ! cm . prepareVpn ( packageName , null , userId ) ) { cm . prepareVpn ( null , packageName , userId ) ; } cm . setVpnPackageAuthorization ( packageName , userId , true ) ; } catch ( RemoteException e ) { } }
daiqiquan/framework-base | private static void check ( InetAddress address , int prefixLength ) { if ( address . isLoopbackAddress ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } if ( address instanceof Inet4Address ) { if ( prefixLength < 0 || prefixLength > 32 ) { throw new IllegalArgumentException ( " Bad ▁ prefixLength " ) ; } } else if ( address instanceof Inet6Address ) { if ( prefixLength < 0 || prefixLength > 128 ) { throw new IllegalArgumentException ( " Bad ▁ prefixLength " ) ; } } else { throw new IllegalArgumentException ( " Unsupported ▁ family " ) ; } }
chrismattmann/drat | public static File unzip ( File zipped ) throws ZipException { ZipFile zipFile = new ZipFile ( zipped . getAbsolutePath ( ) ) ; zipFile . extractAll ( OUTPUT_FOLDER ) ; return new File ( OUTPUT_FOLDER ) ; }
3203317/ppp | public static void setDBType ( String dbType ) { contextHolder . set ( dbType ) ; }
3203317/ppp | public static String getDBType ( ) { return ( String ) contextHolder . get ( ) ; }
3203317/ppp | public static void clearDBType ( ) { contextHolder . remove ( ) ; }
1245816264/android-ndk | public static void setContext ( Context c ) { Log . i ( " NDKHelper " , " setContext : " + c ) ; context = c ; }
1245816264/android-ndk | public static String getNativeLibraryDirectory ( Context appContext ) { ApplicationInfo ai = context . getApplicationInfo ( ) ; Log . w ( " NDKHelper " , " ai . nativeLibraryDir : " + ai . nativeLibraryDir ) ; if ( ( ai . flags & ApplicationInfo . FLAG_UPDATED_SYSTEM_APP ) != 0 || ( ai . flags & ApplicationInfo . FLAG_SYSTEM ) == 0 ) { return ai . nativeLibraryDir ; } return " / system / lib / " ; }
triathematician/blaisemath | public static < E > NodeInGraph < E > create ( E node ) { return new NodeInGraph < > ( node , null ) ; }
StephanEwen/incubator-flink | @ BeforeClass public static void activateHBaseCluster ( ) throws IOException { prepareTables ( ) ; }
StephanEwen/incubator-flink | private static void prepareTables ( ) throws IOException { createHBaseTable1 ( ) ; createHBaseTable2 ( ) ; createHBaseTable3 ( ) ; }
StephanEwen/incubator-flink | private static void createHBaseTable1 ( ) throws IOException { TableName tableName = TableName . valueOf ( TEST_TABLE_1 ) ; createTable ( tableName , FAMILIES , SPLIT_KEYS ) ; Table table = openTable ( tableName ) ; List < Put > puts = new ArrayList < > ( ) ; puts . add ( putRow ( 1 , 10 , " Hello - 1" , 100L , 1.01 , false , " Welt - 1" , Timestamp . valueOf ( "2019-08-18 ▁ 19:00:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:00:00" ) , new BigDecimal ( "12345678.0001" ) ) ) ; puts . add ( putRow ( 2 , 20 , " Hello - 2" , 200L , 2.02 , true , " Welt - 2" , Timestamp . valueOf ( "2019-08-18 ▁ 19:01:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:01:00" ) , new BigDecimal ( "12345678.0002" ) ) ) ; puts . add ( putRow ( 3 , 30 , " Hello - 3" , 300L , 3.03 , false , " Welt - 3" , Timestamp . valueOf ( "2019-08-18 ▁ 19:02:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:02:00" ) , new BigDecimal ( "12345678.0003" ) ) ) ; puts . add ( putRow ( 4 , 40 , null , 400L , 4.04 , true , " Welt - 4" , Timestamp . valueOf ( "2019-08-18 ▁ 19:03:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:03:00" ) , new BigDecimal ( "12345678.0004" ) ) ) ; puts . add ( putRow ( 5 , 50 , " Hello - 5" , 500L , 5.05 , false , " Welt - 5" , Timestamp . valueOf ( "2019-08-19 ▁ 19:10:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:10:00" ) , new BigDecimal ( "12345678.0005" ) ) ) ; puts . add ( putRow ( 6 , 60 , " Hello - 6" , 600L , 6.06 , true , " Welt - 6" , Timestamp . valueOf ( "2019-08-19 ▁ 19:20:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:20:00" ) , new BigDecimal ( "12345678.0006" ) ) ) ; puts . add ( putRow ( 7 , 70 , " Hello - 7" , 700L , 7.07 , false , " Welt - 7" , Timestamp . valueOf ( "2019-08-19 ▁ 19:30:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:30:00" ) , new BigDecimal ( "12345678.0007" ) ) ) ; puts . add ( putRow ( 8 , 80 , null , 800L , 8.08 , true , " Welt - 8" , Timestamp . valueOf ( "2019-08-19 ▁ 19:40:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:40:00" ) , new BigDecimal ( "12345678.0008" ) ) ) ; table . put ( puts ) ; table . close ( ) ; }
StephanEwen/incubator-flink | private static void createHBaseTable2 ( ) { TableName tableName = TableName . valueOf ( TEST_TABLE_2 ) ; createTable ( tableName , FAMILIES , SPLIT_KEYS ) ; }
StephanEwen/incubator-flink | private static void createHBaseTable3 ( ) { byte [ ] [ ] families = new byte [ ] [ ] { Bytes . toBytes ( FAMILY1 ) , Bytes . toBytes ( FAMILY2 ) , Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( FAMILY4 ) , } ; TableName tableName = TableName . valueOf ( TEST_TABLE_3 ) ; createTable ( tableName , families , SPLIT_KEYS ) ; }
StephanEwen/incubator-flink | private static Put putRow ( int rowKey , int f1c1 , String f2c1 , long f2c2 , double f3c1 , boolean f3c2 , String f3c3 , Timestamp f4c1 , Date f4c2 , Time f4c3 , BigDecimal f4c4 ) { Put put = new Put ( Bytes . toBytes ( rowKey ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY1 ) , Bytes . toBytes ( F1COL1 ) , Bytes . toBytes ( f1c1 ) ) ; if ( f2c1 != null ) { put . addColumn ( Bytes . toBytes ( FAMILY2 ) , Bytes . toBytes ( F2COL1 ) , Bytes . toBytes ( f2c1 ) ) ; } put . addColumn ( Bytes . toBytes ( FAMILY2 ) , Bytes . toBytes ( F2COL2 ) , Bytes . toBytes ( f2c2 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( F3COL1 ) , Bytes . toBytes ( f3c1 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( F3COL2 ) , Bytes . toBytes ( f3c2 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( F3COL3 ) , Bytes . toBytes ( f3c3 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL1 ) , Bytes . toBytes ( timestampToInternal ( f4c1 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL2 ) , Bytes . toBytes ( dateToInternal ( f4c2 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL3 ) , Bytes . toBytes ( timeToInternal ( f4c3 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL4 ) , Bytes . toBytes ( f4c4 ) ) ; return put ; }
micmiu/bigdata-tutorial | public static synchronized SimpleHiveConnManager getInstance ( ) { if ( instance == null ) { instance = new SimpleHiveConnManager ( ) ; } clients ++ ; return instance ; }
prajesh-ananthan/java_mastery | public static void main ( String [ ] args ) { System . out . println ( " Hello ▁ World " ) ; }
wouwouwou/2017_module_8 | public static void main ( String [ ] args ) { scan ( " while ▁ do " ) ; scan ( " while ▁ while ▁ do " ) ; scan ( " whiledo ▁ done " ) ; }
wouwouwou/2017_module_8 | public static void scan ( String text ) { CharStream stream = CharStreams . fromString ( text ) ; Lexer lexer = new Example ( stream ) ; for ( Token token : lexer . getAllTokens ( ) ) { System . out . print ( token . toString ( ) + " ▁ " ) ; } System . out . println ( ) ; }
avedensky/JavaRushTasks | public static void main ( String [ ] args ) { Solution solution = new Solution ( ) ; solution . users . put ( " Hubert " , new User ( 172 , " Hubert " ) ) ; solution . users . put ( " Zapp " , new User ( 41 , " Zapp " ) ) ; Solution clone = null ; try { clone = solution . clone ( ) ; System . out . println ( solution ) ; System . out . println ( clone ) ; System . out . println ( solution . users ) ; System . out . println ( clone . users ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( System . err ) ; } }
infobip/mobile-messaging-sdk-android | public static void setState ( Context context , boolean enabled , Class componentClass ) { int state = enabled ? PackageManager . COMPONENT_ENABLED_STATE_ENABLED : PackageManager . COMPONENT_ENABLED_STATE_DISABLED ; ComponentName componentName = new ComponentName ( context , componentClass ) ; try { context . getPackageManager ( ) . setComponentEnabledSetting ( componentName , state , PackageManager . DONT_KILL_APP ) ; } catch ( Exception e ) { throw new ConfigurationException ( ConfigurationException . Reason . MISSING_REQUIRED_COMPONENT , componentClass . getCanonicalName ( ) ) ; } }
infobip/mobile-messaging-sdk-android | public static void setSynchronizationReceiverStateEnabled ( Context context , MobileMessagingSynchronizationReceiver syncReceiver , boolean enabled ) { if ( enabled ) { LocalBroadcastManager . getInstance ( context ) . registerReceiver ( syncReceiver , new IntentFilter ( LocalEvent . APPLICATION_FOREGROUND . getKey ( ) ) ) ; } else { LocalBroadcastManager . getInstance ( context ) . unregisterReceiver ( syncReceiver ) ; } }
infobip/mobile-messaging-sdk-android | public static void setConnectivityComponentsStateEnabled ( Context context , boolean enabled ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . N ) { ComponentUtil . setState ( context , enabled , MobileMessagingConnectivityReceiver . class ) ; } else { ComponentUtil . setState ( context , enabled , MobileMessagingJobService . class ) ; } }
infobip/mobile-messaging-sdk-android | public static void verifyManifestComponentsForPush ( Context context ) { verifyManifestService ( context , MobileMessagingCloudService . class ) ; verifyManifestService ( context , MobileMessagingFirebaseService . class ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { verifyManifestService ( context , MobileMessagingJobService . class ) ; } else { verifyManifestReceiver ( context , MobileMessagingConnectivityReceiver . class ) ; } }
infobip/mobile-messaging-sdk-android | public static void enableComponent ( Context context , Class componentClass ) { try { ComponentUtil . setState ( context , true , componentClass ) ; MobileMessagingLogger . w ( " Enabled ▁ " + componentClass . getName ( ) + " ▁ for ▁ compatibility ▁ reasons " ) ; } catch ( Exception e ) { MobileMessagingLogger . d ( " Cannot ▁ enable ▁ " + componentClass . getName ( ) + " : ▁ " , e ) ; } }
infobip/mobile-messaging-sdk-android | public static void enableComponent ( Context context , String fullClassName ) { try { enableComponent ( context , Class . forName ( fullClassName ) ) ; } catch ( ClassNotFoundException ignored ) { } }
infobip/mobile-messaging-sdk-android | public static void verifyManifestService ( Context context , Class < ? extends Service > cls ) { try { context . getPackageManager ( ) . getServiceInfo ( new ComponentName ( context , cls ) , PackageManager . GET_DISABLED_COMPONENTS ) ; } catch ( Exception ignored ) { reportMissingComponent ( context , cls ) ; } }
infobip/mobile-messaging-sdk-android | public static void verifyManifestReceiver ( Context context , Class < ? extends BroadcastReceiver > cls ) { try { context . getPackageManager ( ) . getReceiverInfo ( new ComponentName ( context , cls ) , PackageManager . GET_DISABLED_COMPONENTS ) ; } catch ( Exception ignored ) { reportMissingComponent ( context , cls ) ; } }
infobip/mobile-messaging-sdk-android | private static void reportMissingComponent ( Context context , Class cls ) { ConfigurationException exception = new ConfigurationException ( ConfigurationException . Reason . MISSING_REQUIRED_COMPONENT , cls . getCanonicalName ( ) ) ; if ( SoftwareInformation . isDebuggableApplicationBuild ( context ) ) { throw exception ; } else { MobileMessagingLogger . e ( exception . getMessage ( ) ) ; } }
tzvetkoff/brkt-sdk-java | static long systemNanoTime ( ) { return System . nanoTime ( ) ; }
tzvetkoff/brkt-sdk-java | static CharMatcher precomputeCharMatcher ( CharMatcher matcher ) { return matcher . precomputedInternal ( ) ; }
guoyydev/CoolWeather | public static boolean handleProvinceResponse ( String response ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray allProvinces = new JSONArray ( response ) ; for ( int i = 0 ; i < allProvinces . length ( ) ; i ++ ) { JSONObject provinceObject = allProvinces . getJSONObject ( i ) ; Province province = new Province ( ) ; province . setProvinceName ( provinceObject . getString ( " name " ) ) ; province . setProvinceCode ( provinceObject . getInt ( " id " ) ) ; province . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
guoyydev/CoolWeather | public static boolean handleCityResponse ( String response , int provinceId ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray allCities = new JSONArray ( response ) ; for ( int i = 0 ; i < allCities . length ( ) ; i ++ ) { JSONObject cityObject = allCities . getJSONObject ( i ) ; City city = new City ( ) ; city . setCityName ( cityObject . getString ( " name " ) ) ; city . setCityCode ( cityObject . getInt ( " id " ) ) ; city . setProvinceId ( provinceId ) ; city . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
guoyydev/CoolWeather | public static boolean handleCountryResponse ( String resonse , int cityId ) { if ( ! TextUtils . isEmpty ( resonse ) ) { try { JSONArray allCountries = new JSONArray ( resonse ) ; for ( int i = 0 ; i < allCountries . length ( ) ; i ++ ) { JSONObject countryObject = allCountries . getJSONObject ( i ) ; Country country = new Country ( ) ; country . setCountryName ( countryObject . getString ( " name " ) ) ; country . setWeatherId ( countryObject . getString ( " weather _ id " ) ) ; country . setCityId ( cityId ) ; country . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
guoyydev/CoolWeather | public static Weather handleWeatherResponse ( String response ) { try { JSONObject jsonObject = new JSONObject ( response ) ; JSONArray jsonArray = jsonObject . getJSONArray ( " HeWeather " ) ; String weatherContent = jsonArray . getJSONObject ( 0 ) . toString ( ) ; return new Gson ( ) . fromJson ( weatherContent , Weather . class ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; }
ratimid/SoftUni | public static void main ( String [ ] args ) { Scanner console = new Scanner ( System . in ) ; int food = Integer . parseInt ( console . nextLine ( ) ) ; int foodInGrams = food * 1000 ; String command = console . nextLine ( ) ; int eatenFood = 0 ; int totalFood = 0 ; while ( ! command . equals ( " Adopted " ) ) { eatenFood = Integer . parseInt ( command ) ; totalFood += eatenFood ; command = console . nextLine ( ) ; } if ( foodInGrams >= totalFood ) { System . out . printf ( " Food ▁ is ▁ enough ! ▁ Leftovers : ▁ % s ▁ grams . " , foodInGrams - totalFood ) ; } else { System . out . printf ( " Food ▁ is ▁ not ▁ enough . ▁ You ▁ need ▁ % s ▁ grams ▁ more . " , totalFood - foodInGrams ) ; } }
freeVM/freeVM | private static final SerializableAssert exComparator = new SerializableAssert ( ) { public void assertDeserialized ( Serializable initial , Serializable deserialized ) { SerializationTest . THROWABLE_COMPARATOR . assertDeserialized ( initial , deserialized ) ; MissingFormatWidthException initEx = ( MissingFormatWidthException ) initial ; MissingFormatWidthException desrEx = ( MissingFormatWidthException ) deserialized ; assertEquals ( " FormatSpecifier " , initEx . getFormatSpecifier ( ) , desrEx . getFormatSpecifier ( ) ) ; } }
ldionmarcil/OSRSHelper | public static List < Item > fetch ( String itemName ) { Logger . add ( TAG , " : ▁ fetch : ▁ itemName = " , itemName ) ; List < Item > itemsSearch = new ArrayList < > ( ) ; HTTPResult httpResult = NetworkStack . getInstance ( ) . performGetRequest ( String . format ( API_URL , Uri . encode ( itemName ) ) ) ; if ( httpResult . statusCode == StatusCode . FOUND ) { try { JSONObject json = new JSONObject ( httpResult . output ) . getJSONObject ( KEY_MATCHES ) ; Iterator < String > keys = json . keys ( ) ; while ( keys . hasNext ( ) ) { String itemId = keys . next ( ) ; JSONObject itemJson = json . getJSONObject ( itemId ) ; Item item = new Item ( ) ; item . id = itemId ; item . description = itemJson . getString ( KEY_DESCRIPTION ) ; item . name = itemJson . getString ( KEY_NAME ) ; item . members = TextUtils . equals ( itemJson . getString ( KEY_MEMBERS ) , VALUE_TRUE ) ; item . iconLarge = ICON_ENDPOINT + itemId ; itemsSearch . add ( item ) ; } } catch ( JSONException e ) { Logger . addException ( TAG , e ) ; } } return itemsSearch ; }
kangaroo-server/kangaroo | @ ClassRule public static final TestRule TEST_DATA_RULE = new TestDataResource ( HIBERNATE_RESOURCE ) { @ Override protected void loadTestData ( final Session session ) { Map < String , String > githubConfig = new HashMap < > ( ) ; githubConfig . put ( CLIENT_ID_KEY , " id " ) ; githubConfig . put ( CLIENT_SECRET_KEY , " secret " ) ; context = ApplicationBuilder . newApplication ( session ) . client ( ClientType . AuthorizationGrant ) . role ( " some _ role " ) . authenticator ( Github , githubConfig ) . build ( ) ; } }
jisqyv/appinventor-sources | public static < T > T cast ( Object o , Class < T > tClass , String expected ) { if ( o == null ) { return null ; } else if ( tClass . isInstance ( o ) ) { return tClass . cast ( o ) ; } else { throw new DispatchableError ( ErrorMessages . ERROR_INVALID_TYPE , o . getClass ( ) . getSimpleName ( ) , expected ) ; } }
jisqyv/appinventor-sources | public static < T > T castNotNull ( Object o , Class < T > tClass , String expected ) { if ( o == null ) { throw new DispatchableError ( ErrorMessages . ERROR_INVALID_TYPE , " null " , expected ) ; } else { return cast ( o , tClass , expected ) ; } }
jisqyv/appinventor-sources | public static < T > OptionList < T > castToEnum ( T value , Symbol className ) { String classNameStr = stripEnumSuffix ( className . getName ( ) ) ; try { Class < ? > clazz = Class . forName ( classNameStr ) ; if ( ! OptionList . class . isAssignableFrom ( clazz ) ) { throw new IllegalArgumentException ( classNameStr + " ▁ does ▁ not ▁ identify ▁ an ▁ OptionList ▁ type . " ) ; } for ( Method m : clazz . getMethods ( ) ) { if ( " fromUnderlyingValue " . equals ( m . getName ( ) ) ) { return ( OptionList < T > ) m . invoke ( clazz , value ) ; } } return null ; } catch ( ClassNotFoundException e ) { return null ; } catch ( InvocationTargetException e ) { return null ; } catch ( IllegalAccessException e ) { return null ; } }
jisqyv/appinventor-sources | private static String stripEnumSuffix ( String className ) { if ( className . endsWith ( " Enum " ) ) { return className . substring ( 0 , className . length ( ) - 4 ) ; } return className ; }
Reimerei/flatbuffers | public static Stat getRootAsStat ( ByteBuffer _bb ) { return getRootAsStat ( _bb , new Stat ( ) ) ; }
Reimerei/flatbuffers | public static Stat getRootAsStat ( ByteBuffer _bb , Stat obj ) { _bb . order ( ByteOrder . LITTLE_ENDIAN ) ; return ( obj . __init ( _bb . getInt ( _bb . position ( ) ) + _bb . position ( ) , _bb ) ) ; }
Reimerei/flatbuffers | public static int createStat ( FlatBufferBuilder builder , int id , long val , int count ) { builder . startObject ( 3 ) ; Stat . addVal ( builder , val ) ; Stat . addId ( builder , id ) ; Stat . addCount ( builder , count ) ; return Stat . endStat ( builder ) ; }
Reimerei/flatbuffers | public static void startStat ( FlatBufferBuilder builder ) { builder . startObject ( 3 ) ; }
Reimerei/flatbuffers | public static void addId ( FlatBufferBuilder builder , int idOffset ) { builder . addOffset ( 0 , idOffset , 0 ) ; }
Reimerei/flatbuffers | public static void addVal ( FlatBufferBuilder builder , long val ) { builder . addLong ( 1 , val , 0 ) ; }
Reimerei/flatbuffers | public static void addCount ( FlatBufferBuilder builder , int count ) { builder . addShort ( 2 , ( short ) ( count & 0xFFFF ) , 0 ) ; }
Reimerei/flatbuffers | public static int endStat ( FlatBufferBuilder builder ) { int o = builder . endObject ( ) ; return o ; }
yuananf/presto | private static ConnectorTableMetadata getOrdersTable ( ) { return getOrdersTable ( ImmutableMap . of ( ) ) ; }
yuananf/presto | private static ConnectorTableMetadata getOrdersTable ( Map < String , Object > properties ) { return buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " custkey " , BIGINT ) . column ( " totalprice " , DOUBLE ) . column ( " orderdate " , DATE ) ) ; }
yuananf/presto | private static ConnectorTableMetadata getLineItemsTable ( Map < String , Object > properties ) { return buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_LINEITEMS ) . column ( " orderkey " , BIGINT ) . column ( " partkey " , BIGINT ) . column ( " quantity " , DOUBLE ) . column ( " price " , DOUBLE ) ) ; }
yuananf/presto | private static ConnectorTableMetadata buildTable ( Map < String , Object > properties , TableMetadataBuilder builder ) { if ( ! properties . isEmpty ( ) ) { for ( Map . Entry < String , Object > entry : properties . entrySet ( ) ) { builder . property ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return builder . build ( ) ; }
yuananf/presto | private static void assertTableEqual ( ConnectorTableMetadata actual , ConnectorTableMetadata expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; List < ColumnMetadata > actualColumns = actual . getColumns ( ) . stream ( ) . filter ( columnMetadata -> ! columnMetadata . isHidden ( ) ) . collect ( Collectors . toList ( ) ) ; List < ColumnMetadata > expectedColumns = expected . getColumns ( ) ; assertEquals ( actualColumns . size ( ) , expectedColumns . size ( ) ) ; for ( int i = 0 ; i < actualColumns . size ( ) ; i ++ ) { ColumnMetadata actualColumn = actualColumns . get ( i ) ; ColumnMetadata expectedColumn = expectedColumns . get ( i ) ; assertEquals ( actualColumn . getName ( ) , expectedColumn . getName ( ) ) ; assertEquals ( actualColumn . getType ( ) , expectedColumn . getType ( ) ) ; } assertEquals ( actual . getProperties ( ) , expected . getProperties ( ) ) ; }
yuananf/presto | private static void assertTableColumnEqual ( TableColumn actual , TableColumn expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; assertEquals ( actual . getColumnId ( ) , expected . getColumnId ( ) ) ; assertEquals ( actual . getColumnName ( ) , expected . getColumnName ( ) ) ; assertEquals ( actual . getDataType ( ) , expected . getDataType ( ) ) ; assertEquals ( actual . getOrdinalPosition ( ) , expected . getOrdinalPosition ( ) ) ; assertEquals ( actual . getBucketOrdinal ( ) , expected . getBucketOrdinal ( ) ) ; assertEquals ( actual . getSortOrdinal ( ) , expected . getSortOrdinal ( ) ) ; assertEquals ( actual . isTemporal ( ) , expected . isTemporal ( ) ) ; }
yuananf/presto | private static void assertTableColumnsEqual ( List < TableColumn > actual , List < TableColumn > expected ) { assertEquals ( actual . size ( ) , expected . size ( ) ) ; for ( int i = 0 ; i < actual . size ( ) ; i ++ ) { assertTableColumnEqual ( actual . get ( i ) , expected . get ( i ) ) ; } }
yuananf/presto | private static void assertThrows ( String message , ThrowingRunnable runnable ) { try { runnable . run ( ) ; fail ( " expected ▁ exception " ) ; } catch ( Throwable t ) { assertEquals ( t . getMessage ( ) , message ) ; } }
anchela/jackrabbit-oak | static < T > void call ( Callable < T > callable ) throws Exception { callable . call ( ) ; }
111t8e/h2o-2 | static public void wrap ( ) { System . setErr ( new Wrapper ( System . err ) ) ; }
111t8e/h2o-2 | public static boolean flag ( Sys t ) { return t . _enable || printAll ; }
111t8e/h2o-2 | public static void setFlag ( Sys t ) { t . _enable = true ; }
111t8e/h2o-2 | public static void unsetFlag ( Sys t ) { t . _enable = false ; }
111t8e/h2o-2 | static Event make ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages ) { return make0 ( sys , kind , ouch , messages , null ) ; }
111t8e/h2o-2 | static Event make ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object message ) { return make0 ( sys , kind , ouch , null , message ) ; }
111t8e/h2o-2 | static private Event make0 ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages , Object message ) { Event result = null ; try { result = new Event ( ) ; result . init ( sys , kind , ouch , messages , message , lastGoodTimer = new Timer ( ) ) ; } catch ( OutOfMemoryError e ) { synchronized ( Event . class ) { if ( lastEvent . printMe ) { missed ++ ; return null ; } result = lastEvent ; result . init ( sys , kind , ouch , messages , null , lastGoodTimer ) ; } } return result ; }
111t8e/h2o-2 | private static void write ( Event e , boolean printOnOut , boolean logToKV ) { try { write0 ( e , printOnOut , logToKV ) ; if ( Event . lastEvent . printMe || Event . missed > 0 ) { synchronized ( Event . class ) { if ( Event . lastEvent . printMe ) { Event ev = Event . lastEvent ; write0 ( ev , true , logToKV ) ; Event . lastEvent = new Event ( ) ; } if ( Event . missed > 0 ) { if ( Event . lastEvent . printMe == false ) { Event . lastEvent . init ( Sys . WATER , Kind . WARN , null , null , " Logging ▁ framework ▁ dropped ▁ a ▁ message " , Event . lastGoodTimer ) ; Event . missed -- ; } } } } } catch ( OutOfMemoryError xe ) { synchronized ( Event . class ) { if ( Event . lastEvent . printMe == false ) Event . lastEvent = e ; else Event . missed ++ ; } } }
111t8e/h2o-2 | public static String getLogDir ( ) { if ( LOG_DIR == null ) { return " unknown - log - dir " ; } return LOG_DIR ; }
111t8e/h2o-2 | public static String getLogPathFileNameStem ( ) { String ip ; if ( H2O . SELF_ADDRESS == null ) { ip = " UnknownIP " ; } else { ip = H2O . SELF_ADDRESS . getHostAddress ( ) ; } int port = H2O . API_PORT ; String portString = Integer . toString ( port ) ; String logFileName = getLogDir ( ) + File . separator + " h2o _ " + ip + " _ " + portString ; return logFileName ; }
111t8e/h2o-2 | public static String getLogPathFileName ( ) { return getLogPathFileNameStem ( ) + " - 2 - debug . log " ; }
111t8e/h2o-2 | private static org . apache . log4j . Logger getLog4jLogger ( ) { return _logger ; }
111t8e/h2o-2 | private static void setLog4jProperties ( String logDirParent , java . util . Properties p ) { LOG_DIR = logDirParent + File . separator + " h2ologs " ; String logPathFileName = getLogPathFileNameStem ( ) ; p . setProperty ( " log4j . rootLogger " , " TRACE , ▁ R1 , ▁ R2 , ▁ R3 , ▁ R4 , ▁ R5 , ▁ R6" ) ; p . setProperty ( " log4j . appender . R1" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R1 . Threshold " , " TRACE " ) ; p . setProperty ( " log4j . appender . R1 . File " , logPathFileName + " - 1 - trace . log " ) ; p . setProperty ( " log4j . appender . R1 . MaxFileSize " , "1MB " ) ; p . setProperty ( " log4j . appender . R1 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R1 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R1 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R2" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R2 . Threshold " , " DEBUG " ) ; p . setProperty ( " log4j . appender . R2 . File " , logPathFileName + " - 2 - debug . log " ) ; p . setProperty ( " log4j . appender . R2 . MaxFileSize " , "3MB " ) ; p . setProperty ( " log4j . appender . R2 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R2 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R2 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R3" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R3 . Threshold " , " INFO " ) ; p . setProperty ( " log4j . appender . R3 . File " , logPathFileName + " - 3 - info . log " ) ; p . setProperty ( " log4j . appender . R3 . MaxFileSize " , "2MB " ) ; p . setProperty ( " log4j . appender . R3 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R3 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R3 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R4" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R4 . Threshold " , " WARN " ) ; p . setProperty ( " log4j . appender . R4 . File " , logPathFileName + " - 4 - warn . log " ) ; p . setProperty ( " log4j . appender . R4 . MaxFileSize " , "256KB " ) ; p . setProperty ( " log4j . appender . R4 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R4 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R4 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R5" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R5 . Threshold " , " ERROR " ) ; p . setProperty ( " log4j . appender . R5 . File " , logPathFileName + " - 5 - error . log " ) ; p . setProperty ( " log4j . appender . R5 . MaxFileSize " , "256KB " ) ; p . setProperty ( " log4j . appender . R5 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R5 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R5 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R6" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R6 . Threshold " , " FATAL " ) ; p . setProperty ( " log4j . appender . R6 . File " , logPathFileName + " - 6 - fatal . log " ) ; p . setProperty ( " log4j . appender . R6 . MaxFileSize " , "256KB " ) ; p . setProperty ( " log4j . appender . R6 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R6 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R6 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . logger . water . api . RequestServer " , " TRACE , ▁ HTTPD " ) ; p . setProperty ( " log4j . additivity . water . api . RequestServer " , " false " ) ; p . setProperty ( " log4j . appender . HTTPD " , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . HTTPD . Threshold " , " TRACE " ) ; p . setProperty ( " log4j . appender . HTTPD . File " , logPathFileName + " - httpd . log " ) ; p . setProperty ( " log4j . appender . HTTPD . MaxFileSize " , "1MB " ) ; p . setProperty ( " log4j . appender . HTTPD . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . HTTPD . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . HTTPD . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . logger . org . apache . http " , " WARN " ) ; p . setProperty ( " log4j . logger . com . amazonaws " , " WARN " ) ; p . setProperty ( " log4j . logger . org . apache . hadoop " , " WARN " ) ; p . setProperty ( " log4j . logger . org . jets3t . service " , " WARN " ) ; }
111t8e/h2o-2 | private static org . apache . log4j . Logger createLog4jLogger ( String logDirParent ) { synchronized ( water . util . Log . class ) { if ( _logger != null ) { return _logger ; } String log4jProperties = System . getProperty ( " log4j . properties " ) ; if ( log4jProperties != null ) { PropertyConfigurator . configure ( log4jProperties ) ; } else { java . util . Properties p = new java . util . Properties ( ) ; setLog4jProperties ( logDirParent , p ) ; PropertyConfigurator . configure ( p ) ; } _logger = LogManager . getLogger ( Log . class . getName ( ) ) ; } return _logger ; }
111t8e/h2o-2 | public static void setLogLevel ( int log_level ) throws IllegalArgumentException { Level l ; switch ( log_level ) { case 1 : l = Level . TRACE ; break ; case 2 : l = Level . DEBUG ; break ; case 3 : l = Level . INFO ; break ; case 4 : l = Level . WARN ; break ; case 5 : l = Level . ERROR ; break ; case 6 : l = Level . FATAL ; break ; default : throw new IllegalArgumentException ( " Log ▁ level ▁ " + log_level + " ▁ is ▁ invalid " ) ; } _logger . setLevel ( l ) ; System . out . println ( " Set ▁ log ▁ level ▁ to ▁ " + l ) ; _logger . info ( " Set ▁ log ▁ level ▁ to ▁ " + l ) ; }
111t8e/h2o-2 | private static void log0 ( org . apache . log4j . Logger l4j , Event e ) { if ( e . sys == Sys . HTLOG ) { e . sys = Sys . HTTPD ; String s = " tid ( " + Thread . currentThread ( ) . getId ( ) + " ) ▁ " + e . toString ( ) ; org . apache . log4j . Logger httpdLogger = LogManager . getLogger ( " water . api . RequestServer " ) ; if ( e . kind == Kind . INFO ) { httpdLogger . info ( s ) ; } else { httpdLogger . error ( s ) ; } return ; } String s = e . toString ( ) ; if ( e . kind == Kind . FATL ) { l4j . fatal ( s ) ; } else if ( e . kind == Kind . ERRR ) { l4j . error ( s ) ; } else if ( e . kind == Kind . WARN ) { l4j . warn ( s ) ; } else if ( e . kind == Kind . INFO ) { l4j . info ( s ) ; } else if ( e . kind == Kind . DEBG ) { l4j . debug ( s ) ; } else if ( e . kind == Kind . TRAC ) { l4j . trace ( s ) ; } else { l4j . error ( s ) ; } }
111t8e/h2o-2 | private static void write0 ( Event e , boolean printOnOut , boolean logToKV ) { org . apache . log4j . Logger l4j = getLog4jLogger ( ) ; if ( ( l4j == null ) && ! loggerCreateWasCalled && ! H2O . DEBUG ) { if ( H2O . SELF != null ) { File dir ; boolean windowsPath = H2O . ICE_ROOT . toString ( ) . matches ( " ^ [ a - zA - Z ] : . * " ) ; if ( windowsPath ) dir = new File ( H2O . ICE_ROOT . toString ( ) ) ; else if ( H2O . ICE_ROOT . getScheme ( ) == null || Schemes . FILE . equals ( H2O . ICE_ROOT . getScheme ( ) ) ) dir = new File ( H2O . ICE_ROOT . getPath ( ) ) ; else dir = new File ( H2O . DEFAULT_ICE_ROOT ( ) ) ; loggerCreateWasCalled = true ; l4j = createLog4jLogger ( dir . toString ( ) ) ; } } if ( l4j == null ) { e . toString ( ) ; synchronized ( startupLogEventsLock ) { if ( startupLogEvents != null ) { startupLogEvents . add ( e ) ; } else { } } } else { if ( startupLogEvents != null ) { synchronized ( startupLogEventsLock ) { for ( int i = 0 ; i < startupLogEvents . size ( ) ; i ++ ) { Event bufferedEvent = startupLogEvents . get ( i ) ; log0 ( l4j , bufferedEvent ) ; } startupLogEvents = null ; } } log0 ( l4j , e ) ; } if ( printOnOut || printAll ) unwrap ( System . out , e . toShortString ( ) ) ; e . printMe = false ; }
111t8e/h2o-2 | private static void logToKV ( final String date , final String thr , final Kind kind , final Sys sys , final String msg ) { if ( LOG_KEY == null ) if ( ! Paxos . _cloudLocked ) return ; synchronized ( Log . class ) { if ( LOG_KEY == null ) LOG_KEY = Key . make ( " Log " , ( byte ) 0 , Key . BUILT_IN_KEY ) ; } final long pid = PID ; final H2ONode h2o = H2O . SELF ; new TAtomic < LogStr > ( ) { @ Override public LogStr atomic ( LogStr l ) { return new LogStr ( l , date , h2o , pid , thr , kind , sys , msg ) ; } } . fork ( LOG_KEY ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( Sys t , String msg , T exception ) { Event e = Event . make ( t , Kind . ERRR , exception , msg ) ; write ( e , true , false ) ; return exception ; }
111t8e/h2o-2 | static public void err ( Sys t , String msg ) { Event e = Event . make ( t , Kind . ERRR , null , msg ) ; write ( e , true , false ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( String msg , T exception ) { return err ( Sys . WATER , msg , exception ) ; }
111t8e/h2o-2 | static public void err ( String msg ) { err ( Sys . WATER , msg ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( Sys t , T exception ) { return err ( t , " " , exception ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( T exception ) { return err ( Sys . WATER , " " , exception ) ; }
111t8e/h2o-2 | static public RuntimeException errRTExcept ( Throwable exception ) { return new RuntimeException ( err ( Sys . WATER , " " , exception ) ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T warn ( Sys t , String msg , T exception ) { Event e = Event . make ( t , Kind . WARN , exception , msg ) ; write ( e , true , true ) ; return exception ; }
111t8e/h2o-2 | static public Throwable warn ( Sys t , String msg ) { return warn ( t , msg , null ) ; }
111t8e/h2o-2 | static public Throwable warn ( String msg ) { return warn ( Sys . WATER , msg , null ) ; }
111t8e/h2o-2 | static public void info_no_stdout ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void info_no_DKV ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , false , false ) ; }
111t8e/h2o-2 | static public void info ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , true , true ) ; }
111t8e/h2o-2 | static public void info_no_stdout ( Object ... objects ) { info_no_stdout ( Sys . WATER , objects ) ; }
111t8e/h2o-2 | static public void info ( Object ... objects ) { info ( Sys . WATER , objects ) ; }
111t8e/h2o-2 | static public void debug ( Object ... objects ) { if ( flag ( Sys . WATER ) == false ) return ; Event e = Event . make ( Sys . WATER , Kind . DEBG , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void debug ( Sys t , Object ... objects ) { if ( flag ( t ) == false ) return ; Event e = Event . make ( t , Kind . DEBG , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void trace ( Object ... objects ) { if ( flag ( Sys . WATER ) == false ) return ; Event e = Event . make ( Sys . WATER , Kind . TRAC , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void tmp ( Object ... objects ) { info ( objects ) ; }
111t8e/h2o-2 | public static String fixedLength ( String s , int length ) { String r = padRight ( s , length ) ; if ( r . length ( ) > length ) { int a = Math . max ( r . length ( ) - length + 1 , 0 ) ; int b = Math . max ( a , r . length ( ) ) ; r = " # " + r . substring ( a , b ) ; } return r ; }
111t8e/h2o-2 | public static String padRight ( String stringToPad , int size ) { StringBuilder strb = new StringBuilder ( stringToPad ) ; while ( strb . length ( ) < size ) if ( strb . length ( ) < size ) strb . append ( ' ▁ ' ) ; return strb . toString ( ) ; }
111t8e/h2o-2 | private static long getPid ( ) { try { String n = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; int i = n . indexOf ( ' @ ' ) ; if ( i == - 1 ) return - 1 ; return Long . parseLong ( n . substring ( 0 , i ) ) ; } catch ( Throwable t ) { return - 1 ; } }
111t8e/h2o-2 | public static void die ( String s ) { System . err . println ( s ) ; if ( ! _dontDie ) H2O . exit ( - 1 ) ; }
111t8e/h2o-2 | public static void unwrap ( PrintStream stream , String s ) { if ( stream instanceof Wrapper ) ( ( Wrapper ) stream ) . printlnParent ( s ) ; else stream . println ( s ) ; }
111t8e/h2o-2 | public static PrintStream unwrap ( PrintStream stream ) { return stream instanceof Wrapper ? ( ( Wrapper ) stream ) . parent : stream ; }
111t8e/h2o-2 | public static void log ( File file , PrintStream stream ) throws Exception { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) break ; stream . println ( line ) ; } } finally { reader . close ( ) ; } }
111t8e/h2o-2 | private static String log ( Locale l , boolean nl , String format , Object ... args ) { String msg = String . format ( l , format , args ) ; Event e = Event . make ( Sys . WATER , Kind . INFO , null , msg ) ; Log . write ( e , false , true ) ; return e . toShortString ( ) + NL ; }
111t8e/h2o-2 | public static void POST ( int n , String s ) { return ; }
111t8e/h2o-2 | public static void POST ( int n , Exception e ) { if ( e . getMessage ( ) != null ) { POST ( n , e . getMessage ( ) ) ; } POST ( n , e . toString ( ) ) ; StackTraceElement [ ] els = e . getStackTrace ( ) ; for ( int i = 0 ; i < els . length ; i ++ ) { POST ( n , els [ i ] . toString ( ) ) ; } }
111t8e/h2o-2 | public static void POST ( int n ) { POST ( n , " " ) ; }
111t8e/h2o-2 | public static void main ( String [ ] args ) { Log . info ( " hi " ) ; Log . info ( " h " , " i " ) ; unwrap ( System . out , " hi " ) ; unwrap ( System . err , " hi " ) ; Log . info ( " ho ▁ " , new Object ( ) { int i ; public String toString ( ) { if ( i ++ == 0 ) throw new OutOfMemoryError ( ) ; else return super . toString ( ) ; } } ) ; Log . info ( " ha ▁ " , new Object ( ) { int i ; public String toString ( ) { if ( i ++ == 0 ) throw new OutOfMemoryError ( ) ; else return super . toString ( ) ; } } ) ; Log . info ( " hi " ) ; Log . info ( " hi " ) ; Log . info ( " hi " ) ; }
guard163/cassandra | public static synchronized < T > ListType < T > getInstance ( AbstractType < T > elements , boolean isMultiCell ) { Map < AbstractType < ? > , ListType > internMap = isMultiCell ? instances : frozenInstances ; ListType < T > t = internMap . get ( elements ) ; if ( t == null ) { t = new ListType < T > ( elements , isMultiCell ) ; internMap . put ( elements , t ) ; } return t ; }
guard163/cassandra | static int compareListOrSet ( AbstractType < ? > elementsComparator , ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) || ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? 1 : o2 . hasRemaining ( ) ? - 1 : 0 ; ByteBuffer bb1 = o1 . duplicate ( ) ; ByteBuffer bb2 = o2 . duplicate ( ) ; int size1 = CollectionSerializer . readCollectionSize ( bb1 , 3 ) ; int size2 = CollectionSerializer . readCollectionSize ( bb2 , 3 ) ; for ( int i = 0 ; i < Math . min ( size1 , size2 ) ; i ++ ) { ByteBuffer v1 = CollectionSerializer . readValue ( bb1 , 3 ) ; ByteBuffer v2 = CollectionSerializer . readValue ( bb2 , 3 ) ; int cmp = elementsComparator . compare ( v1 , v2 ) ; if ( cmp != 0 ) return cmp ; } return size1 == size2 ? 0 : ( size1 < size2 ? - 1 : 1 ) ; }
guard163/cassandra | public static String setOrListToJsonString ( ByteBuffer buffer , AbstractType elementsType , int protocolVersion ) { StringBuilder sb = new StringBuilder ( " [ " ) ; int size = CollectionSerializer . readCollectionSize ( buffer , protocolVersion ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( i > 0 ) sb . append ( " , ▁ " ) ; sb . append ( elementsType . toJSONString ( CollectionSerializer . readValue ( buffer , protocolVersion ) , protocolVersion ) ) ; } return sb . append ( " ] " ) . toString ( ) ; }
PlanetWaves/clockworkengine | public static void initialize ( ) { idRegistrations . clear ( ) ; classRegistrations . clear ( ) ; registrations . clear ( ) ; nextAvailableId = - 2 ; locked = false ; registerClassForId ( DisconnectMessage . SERIALIZER_ID , DisconnectMessage . class , new DisconnectMessage . DisconnectSerializer ( ) ) ; registerClassForId ( ClientRegistrationMessage . SERIALIZER_ID , ClientRegistrationMessage . class , new ClientRegistrationMessage . ClientRegistrationSerializer ( ) ) ; registerClass ( boolean . class , new BooleanSerializer ( ) ) ; registerClass ( byte . class , new ByteSerializer ( ) ) ; registerClass ( char . class , new CharSerializer ( ) ) ; registerClass ( short . class , new ShortSerializer ( ) ) ; registerClass ( int . class , new IntSerializer ( ) ) ; registerClass ( long . class , new LongSerializer ( ) ) ; registerClass ( float . class , new FloatSerializer ( ) ) ; registerClass ( double . class , new DoubleSerializer ( ) ) ; registerClass ( Boolean . class , new BooleanSerializer ( ) ) ; registerClass ( Byte . class , new ByteSerializer ( ) ) ; registerClass ( Character . class , new CharSerializer ( ) ) ; registerClass ( Short . class , new ShortSerializer ( ) ) ; registerClass ( Integer . class , new IntSerializer ( ) ) ; registerClass ( Long . class , new LongSerializer ( ) ) ; registerClass ( Float . class , new FloatSerializer ( ) ) ; registerClass ( Double . class , new DoubleSerializer ( ) ) ; registerClass ( String . class , new StringSerializer ( ) ) ; registerClass ( Vector3f . class , new Vector3Serializer ( ) ) ; registerClass ( Date . class , new DateSerializer ( ) ) ; registerClass ( AbstractCollection . class , new CollectionSerializer ( ) ) ; registerClass ( AbstractList . class , new CollectionSerializer ( ) ) ; registerClass ( AbstractSet . class , new CollectionSerializer ( ) ) ; registerClass ( ArrayList . class , new CollectionSerializer ( ) ) ; registerClass ( HashSet . class , new CollectionSerializer ( ) ) ; registerClass ( LinkedHashSet . class , new CollectionSerializer ( ) ) ; registerClass ( LinkedList . class , new CollectionSerializer ( ) ) ; registerClass ( TreeSet . class , new CollectionSerializer ( ) ) ; registerClass ( Vector . class , new CollectionSerializer ( ) ) ; registerClass ( AbstractMap . class , new MapSerializer ( ) ) ; registerClass ( Attributes . class , new MapSerializer ( ) ) ; registerClass ( HashMap . class , new MapSerializer ( ) ) ; registerClass ( Hashtable . class , new MapSerializer ( ) ) ; registerClass ( IdentityHashMap . class , new MapSerializer ( ) ) ; registerClass ( TreeMap . class , new MapSerializer ( ) ) ; registerClass ( WeakHashMap . class , new MapSerializer ( ) ) ; registerClass ( Enum . class , new EnumSerializer ( ) ) ; registerClass ( GZIPCompressedMessage . class , new GZIPSerializer ( ) ) ; registerClass ( ZIPCompressedMessage . class , new ZIPSerializer ( ) ) ; registerClass ( ChannelInfoMessage . class ) ; }
PlanetWaves/clockworkengine | public static void setStrictRegistration ( boolean b ) { strictRegistration = b ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClass ( Class cls ) { return registerClass ( cls , true ) ; }
PlanetWaves/clockworkengine | public static void registerClasses ( Class ... classes ) { for ( Class c : classes ) { registerClass ( c ) ; } }
PlanetWaves/clockworkengine | private static short nextId ( ) { while ( idRegistrations . containsKey ( nextAvailableId ) ) { nextAvailableId -- ; } return nextAvailableId -- ; }
PlanetWaves/clockworkengine | public static void setReadOnly ( boolean b ) { locked = b ; }
PlanetWaves/clockworkengine | public static boolean isReadOnly ( ) { return locked ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClassForId ( short id , Class cls , Serializer serializer ) { if ( locked ) { throw new RuntimeException ( " Serializer ▁ registry ▁ locked ▁ trying ▁ to ▁ register ▁ class : " + cls ) ; } SerializerRegistration reg = new SerializerRegistration ( serializer , cls , id ) ; idRegistrations . put ( id , reg ) ; classRegistrations . put ( cls , reg ) ; log . log ( Level . FINE , " Registered ▁ class [ " + id + " ] : { 0 } ▁ to : " + serializer , cls ) ; serializer . initialize ( cls ) ; registrations . add ( reg ) ; return reg ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClass ( Class cls , boolean failOnMiss ) { if ( cls . isAnnotationPresent ( Serializable . class ) ) { Serializable serializable = ( Serializable ) cls . getAnnotation ( Serializable . class ) ; Class serializerClass = serializable . serializer ( ) ; short classId = serializable . id ( ) ; if ( classId == 0 ) classId = nextId ( ) ; Serializer serializer = getSerializer ( serializerClass , false ) ; if ( serializer == null ) serializer = fieldSerializer ; SerializerRegistration existingReg = getExactSerializerRegistration ( cls ) ; if ( existingReg != null ) classId = existingReg . getId ( ) ; SerializerRegistration reg = new SerializerRegistration ( serializer , cls , classId ) ; return registerClassForId ( classId , cls , serializer ) ; } if ( failOnMiss ) { throw new IllegalArgumentException ( " Class ▁ is ▁ not ▁ marked ▁ @ Serializable : " + cls ) ; } return null ; }
PlanetWaves/clockworkengine | @ Deprecated public static SerializerRegistration [ ] registerPackage ( String pkgName ) { try { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; String path = pkgName . replace ( ' . ' , ' / ' ) ; Enumeration < URL > resources = classLoader . getResources ( path ) ; List < File > dirs = new ArrayList < File > ( ) ; while ( resources . hasMoreElements ( ) ) { URL resource = resources . nextElement ( ) ; dirs . add ( new File ( resource . getFile ( ) ) ) ; } ArrayList < Class > classes = new ArrayList < Class > ( ) ; for ( File directory : dirs ) { classes . addAll ( findClasses ( directory , pkgName ) ) ; } SerializerRegistration [ ] registeredClasses = new SerializerRegistration [ classes . size ( ) ] ; for ( int i = 0 ; i != classes . size ( ) ; ++ i ) { Class clz = classes . get ( i ) ; registeredClasses [ i ] = registerClass ( clz , false ) ; } return registeredClasses ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return new SerializerRegistration [ 0 ] ; }
PlanetWaves/clockworkengine | private static List < Class > findClasses ( File dir , String pkgName ) throws ClassNotFoundException { List < Class > classes = new ArrayList < Class > ( ) ; if ( ! dir . exists ( ) ) { return classes ; } File [ ] files = dir . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { assert ! file . getName ( ) . contains ( " . " ) ; classes . addAll ( findClasses ( file , pkgName + " . " + file . getName ( ) ) ) ; } else if ( file . getName ( ) . endsWith ( " . class " ) ) { classes . add ( Class . forName ( pkgName + ' . ' + file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - 6 ) ) ) ; } } return classes ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClass ( Class cls , Serializer serializer ) { SerializerRegistration existingReg = getExactSerializerRegistration ( cls ) ; short id ; if ( existingReg != null ) { id = existingReg . getId ( ) ; } else { id = nextId ( ) ; } return registerClassForId ( id , cls , serializer ) ; }
PlanetWaves/clockworkengine | public static Serializer getExactSerializer ( Class cls ) { return classRegistrations . get ( cls ) . getSerializer ( ) ; }
PlanetWaves/clockworkengine | public static Serializer getSerializer ( Class cls ) { return getSerializer ( cls , true ) ; }
PlanetWaves/clockworkengine | public static Serializer getSerializer ( Class cls , boolean failOnMiss ) { return getSerializerRegistration ( cls , failOnMiss ) . getSerializer ( ) ; }
PlanetWaves/clockworkengine | public static Collection < SerializerRegistration > getSerializerRegistrations ( ) { return registrations ; }
PlanetWaves/clockworkengine | public static SerializerRegistration getExactSerializerRegistration ( Class cls ) { return classRegistrations . get ( cls ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration getSerializerRegistration ( Class cls ) { return getSerializerRegistration ( cls , strictRegistration ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration getSerializerRegistration ( Class cls , boolean failOnMiss ) { SerializerRegistration reg = classRegistrations . get ( cls ) ; if ( reg != null ) return reg ; for ( Map . Entry < Class , SerializerRegistration > entry : classRegistrations . entrySet ( ) ) { if ( entry . getKey ( ) . isAssignableFrom ( Serializable . class ) ) continue ; if ( entry . getKey ( ) . isAssignableFrom ( cls ) ) return entry . getValue ( ) ; } if ( cls . isArray ( ) ) return registerClass ( cls , arraySerializer ) ; if ( Serializable . class . isAssignableFrom ( cls ) ) { return getExactSerializerRegistration ( java . io . Serializable . class ) ; } if ( cls . isAnnotationPresent ( Serializable . class ) ) { Serializable serializable = ( Serializable ) cls . getAnnotation ( Serializable . class ) ; short classId = serializable . id ( ) ; if ( classId != 0 ) { failOnMiss = false ; } } if ( failOnMiss ) { throw new IllegalArgumentException ( " Class ▁ has ▁ not ▁ been ▁ registered : " + cls ) ; } return registerClass ( cls , fieldSerializer ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration readClass ( ByteBuffer buffer ) { short classID = buffer . getShort ( ) ; if ( classID == - 1 ) return NULL_CLASS ; return idRegistrations . get ( classID ) ; }
PlanetWaves/clockworkengine | public static Object readClassAndObject ( ByteBuffer buffer ) throws IOException { SerializerRegistration reg = readClass ( buffer ) ; if ( reg == NULL_CLASS ) return null ; if ( reg == null ) throw new SerializerException ( " Class ▁ not ▁ found ▁ for ▁ buffer ▁ data . " ) ; return reg . getSerializer ( ) . readObject ( buffer , reg . getType ( ) ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration writeClass ( ByteBuffer buffer , Class type ) throws IOException { SerializerRegistration reg = getSerializerRegistration ( type ) ; if ( reg == null ) { throw new SerializerException ( " Class ▁ not ▁ registered : " + type ) ; } if ( log . isLoggable ( Level . FINER ) ) { log . log ( Level . FINER , " writing ▁ class : { 0 } ▁ with ▁ ID : { 1 } " , new Object [ ] { type , reg . getId ( ) } ) ; } buffer . putShort ( reg . getId ( ) ) ; return reg ; }
PlanetWaves/clockworkengine | public static void writeClassAndObject ( ByteBuffer buffer , Object object ) throws IOException { if ( object == null ) { buffer . putShort ( ( short ) - 1 ) ; return ; } SerializerRegistration reg = writeClass ( buffer , object . getClass ( ) ) ; if ( reg . getType ( ) != object . getClass ( ) ) { throw new IllegalArgumentException ( " Class ▁ has ▁ not ▁ been ▁ registered : " + object . getClass ( ) + " ▁ but ▁ resolved ▁ to ▁ generic ▁ serializer ▁ for : " + reg . getType ( ) ) ; } reg . getSerializer ( ) . writeObject ( buffer , object ) ; }
marktriggs/nyu-sakai-10.4 | private static SeqActivity buildActivityNode ( Node iNode , Node iColl ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " buildActivityNode " ) ; } SeqActivity act = new SeqActivity ( ) ; boolean error = false ; String tempVal = null ; act . setID ( ADLSeqUtilities . getAttribute ( iNode , " identifier " ) ) ; tempVal = ADLSeqUtilities . getAttribute ( iNode , " identifierref " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { act . setResourceID ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( iNode , " isvisible " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { act . setIsVisible ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " item " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ an ▁ < item > ▁ element " ) ; } SeqActivity nestedAct = ADLSeqUtilities . buildActivityNode ( curNode , iColl ) ; if ( nestedAct != null ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Adding ▁ child " ) ; } act . addChild ( nestedAct ) ; } else { error = true ; } } else if ( curNode . getLocalName ( ) . equals ( " title " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < title > ▁ element " ) ; } act . setTitle ( ADLSeqUtilities . getElementText ( curNode , null ) ) ; } else if ( curNode . getLocalName ( ) . equals ( " sequencing " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < sequencing > ▁ element " ) ; } Node seqInfo = curNode ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " IDRef " ) ; if ( tempVal != null ) { String search = " imsss : sequencing [ @ ID = ' " + tempVal + " ' ] " ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Looking ▁ for ▁ XPATH ▁ - - > ▁ " + search ) ; } Node seqGlobal = null ; XPathFactory pathFactory = XPathFactory . newInstance ( ) ; XPath path = pathFactory . newXPath ( ) ; try { seqGlobal = ( Node ) path . evaluate ( search , iColl , XPathConstants . NODE ) ; } catch ( Exception e ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ In ▁ transform " ) ; e . printStackTrace ( ) ; } } if ( seqGlobal != null ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ FOUND " ) ; } } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR : ▁ Not ▁ Found " ) ; } seqInfo = null ; error = true ; } if ( ! error ) { seqInfo = seqGlobal . cloneNode ( true ) ; NodeList seqChildren = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < seqChildren . getLength ( ) ; j ++ ) { Node curChild = seqChildren . item ( j ) ; if ( curChild . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Local ▁ definition " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ ▁ " + j ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ < " + curChild . getLocalName ( ) + " > " ) ; } try { seqInfo . appendChild ( curChild ) ; } catch ( org . w3c . dom . DOMException e ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR : ▁ " ) ; e . printStackTrace ( ) ; } error = true ; seqInfo = null ; } } } } } if ( seqInfo != null ) { error = ! ADLSeqUtilities . extractSeqInfo ( seqInfo , act ) ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Extracted ▁ Sequencing ▁ Info " ) ; } } } } } if ( act . getResourceID ( ) == null && ! act . hasChildren ( true ) ) { error = true ; } if ( error ) { act = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ error ▁ = = ▁ " + error ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " buildActivityNode " ) ; } return act ; }
marktriggs/nyu-sakai-10.4 | public static SeqActivityTree buildActivityTree ( Node iOrg , Node iColl ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " buildActivityTree " ) ; } SeqActivityTree tree = new SeqActivityTree ( ) ; SeqActivity root = ADLSeqUtilities . buildActivityNode ( iOrg , iColl ) ; if ( root != null ) { tree . setRoot ( root ) ; tree . setDepths ( ) ; tree . setTreeCount ( ) ; } else { tree = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " buildActivityTree " ) ; } return tree ; }
marktriggs/nyu-sakai-10.4 | public static void clearGlobalObjs ( String iLearnerID , String iScopeID , List < String > iObjList ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " clearGlobalObjs " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED : ▁ ADLSeqUtilities : clearGlobalObjs " ) ; }
marktriggs/nyu-sakai-10.4 | public static void createCourseStatus ( String iCourseID , String iLearnerID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " createCourseStatus " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iCourseID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iLearnerID ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : createCourseStatus " ) ; }
marktriggs/nyu-sakai-10.4 | public static void createGlobalObjs ( String iLearnerID , String iScopeID , List < String > iObjList ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " createGlobalObjs " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iScopeID ) ; } System . out . println ( " NOT ▁ IMPLEMENTED : ▁ ADLSeqUtilities : createGlobalObjs " ) ; }
marktriggs/nyu-sakai-10.4 | public static void deleteCourseStatus ( String iCourseID , String iLearnerID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " deleteCourseStatus " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : deleteCourseStatus " ) ; }
marktriggs/nyu-sakai-10.4 | public static void deleteGlobalObjs ( String iLearnerID , String iScopeID , List < String > iObjList ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " deleteGlobalObjs " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : deleteGlobalObjs " ) ; }
marktriggs/nyu-sakai-10.4 | public static void dumpTOC ( List < ADLTOC > iTOC ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ dumpTOC " ) ; if ( iTOC != null ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iTOC . size ( ) ) ; ADLTOC temp = null ; for ( int i = 0 ; i < iTOC . size ( ) ; i ++ ) { temp = iTOC . get ( i ) ; temp . dumpState ( ) ; } } else { System . out . println ( " ▁ ▁ : : - - > ▁ NULL " ) ; } System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ dumpTOC " ) ; } }
marktriggs/nyu-sakai-10.4 | private static boolean extractSeqInfo ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " extractSeqInfo " ) ; } boolean ok = true ; String tempVal = null ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " controlMode " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < controlMode > ▁ element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " choice " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlModeChoice ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " choiceExit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlModeChoiceExit ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " flow " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlModeFlow ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " forwardOnly " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlForwardOnly ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " useCurrentAttemptObjectiveInfo " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setUseCurObjective ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " useCurrentAttemptProgressInfo " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setUseCurProgress ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " sequencingRules " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < sequencingRules > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getSequencingRules ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " limitConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < limitConditions > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " attemptLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setAttemptLimit ( Long . valueOf ( tempVal ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " attemptAbsoluteDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setAttemptAbDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " attemptExperiencedDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setAttemptExDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " activityAbsoluteDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setActivityAbDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " activityExperiencedDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setActivityExDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " beginTimeLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setBeginTimeLimit ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " endTimeLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setEndTimeLimit ( tempVal ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " auxiliaryResources " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < auxiliaryResourcees > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getAuxResources ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " rollupRules " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < rollupRules > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getRollupRules ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " objectives " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < objectives > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getObjectives ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " randomizationControls " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < randomizationControls > ▁ element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " randomizationTiming " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRandomTiming ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " selectCount " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSelectCount ( ( Integer . valueOf ( tempVal ) ) . intValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " reorderChildren " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setReorderChildren ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " selectionTiming " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSelectionTiming ( tempVal ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " deliveryControls " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < deliveryControls > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " tracked " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setIsTracked ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " completionSetByContent " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSetCompletion ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " objectiveSetByContent " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSetObjective ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " constrainedChoiceConsiderations " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < constrainedChoiceConsiderations > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " preventActivation " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setPreventActivation ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " constrainChoice " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setConstrainChoice ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " rollupConsiderations " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < rollupConsiderations > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForSatisfied " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForSatisfied ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForNotSatisfied " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForNotSatisfied ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForCompleted " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForCompleted ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForIncomplete " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForIncomplete ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " measureSatisfactionIfActive " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSatisfactionIfActive ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } } } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + ok ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " extractSeqInfo " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static SeqConditionSet extractSeqRuleConditions ( Node iNode ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " extractSeqRuleConditions " ) ; } String tempVal = null ; SeqConditionSet condSet = new SeqConditionSet ( ) ; List < SeqCondition > conditions = new ArrayList < SeqCondition > ( ) ; tempVal = ADLSeqUtilities . getAttribute ( iNode , " conditionCombination " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { condSet . mCombination = tempVal ; } } else { condSet . mCombination = SeqConditionSet . COMBINATION_ALL ; } NodeList condInfo = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < condInfo . getLength ( ) ; i ++ ) { Node curCond = condInfo . item ( i ) ; if ( curCond . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curCond . getLocalName ( ) . equals ( " ruleCondition " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < Condition > ▁ " + " element " ) ; } SeqCondition cond = new SeqCondition ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curCond , " condition " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mCondition = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curCond , " referencedObjective " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curCond , " measureThreshold " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mThreshold = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curCond , " operator " ) ; if ( tempVal != null ) { if ( tempVal . equals ( " not " ) ) { cond . mNot = true ; } else { cond . mNot = false ; } } conditions . add ( cond ) ; } } } if ( conditions . size ( ) > 0 ) { condSet . mConditions = conditions ; } else { condSet = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " extractSeqRuleConditions " ) ; } return condSet ; }
marktriggs/nyu-sakai-10.4 | private static String getAttribute ( Node iNode , String iAttribute ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ getAttribute " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iAttribute ) ; } String value = null ; NamedNodeMap attrs = iNode . getAttributes ( ) ; if ( attrs != null ) { Node attr = attrs . getNamedItem ( iAttribute ) ; if ( attr != null ) { value = attr . getNodeValue ( ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ The ▁ attribute ▁ \" " + iAttribute + " \" ▁ does ▁ not ▁ exist . " ) ; } } } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ This ▁ node ▁ has ▁ no ▁ attributes . " ) ; } } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + value ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ - ▁ getAttribute " ) ; } return value ; }
marktriggs/nyu-sakai-10.4 | private static boolean getAuxResources ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getAuxResources " ) ; } boolean ok = true ; String tempVal = null ; List < ADLAuxiliaryResource > auxRes = new ArrayList < ADLAuxiliaryResource > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " auxiliaryResource " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < auxiliaryResource > ▁ " + " element " ) ; } ADLAuxiliaryResource res = new ADLAuxiliaryResource ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " purpose " ) ; if ( tempVal != null ) { res . mType = tempVal ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " auxiliaryResourceID " ) ; if ( tempVal != null ) { res . mResourceID = tempVal ; } auxRes . add ( res ) ; } } } ioAct . setAuxResources ( auxRes ) ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getAuxResources " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static String getElementText ( Node iNode , String iElement ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getElementText " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iElement ) ; } StringBuilder value = new StringBuilder ( ) ; Node curNode = null ; NodeList children = null ; if ( iElement != null && iNode != null ) { children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ ▁ " + i ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ < " + curNode . getLocalName ( ) + " > " ) ; } if ( curNode . getLocalName ( ) . equals ( iElement ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ < " + iElement + " > " ) ; } break ; } } } if ( curNode != null ) { String comp = curNode . getLocalName ( ) ; if ( comp != null ) { if ( ! comp . equals ( iElement ) ) { curNode = null ; } } else { curNode = null ; } } } else { curNode = iNode ; } if ( curNode != null ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Looking ▁ at ▁ children " ) ; } children = curNode . getChildNodes ( ) ; if ( children != null ) { value = new StringBuilder ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { curNode = children . item ( i ) ; if ( ( curNode . getNodeType ( ) == Node . TEXT_NODE ) || ( curNode . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) { value . append ( curNode . getNodeValue ( ) ) ; } } } } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + value ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getElementText " ) ; } return value . toString ( ) ; }
marktriggs/nyu-sakai-10.4 | public static String getGlobalObjMeasure ( String iObjID , String iLearnerID , String iScopeID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getGlobalObjMeasure " ) ; } String measure = null ; System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : getGlobalObjMeasure " ) ; return measure ; }
marktriggs/nyu-sakai-10.4 | public static String getGlobalObjSatisfied ( String iObjID , String iLearnerID , String iScopeID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getGlobalObjSatisfied " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iObjID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iScopeID ) ; } String satisfiedStatus = null ; System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : getGlobalObjSatisfied " ) ; return satisfiedStatus ; }
marktriggs/nyu-sakai-10.4 | private static List < SeqObjectiveMap > getObjectiveMaps ( Node iNode ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getObjectiveMaps " ) ; } String tempVal = null ; List < SeqObjectiveMap > maps = new ArrayList < SeqObjectiveMap > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " mapInfo " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < mapInfo > ▁ " + " element " ) ; } SeqObjectiveMap map = new SeqObjectiveMap ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " targetObjectiveID " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mGlobalObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " readSatisfiedStatus " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mReadStatus = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " readNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mReadMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " writeSatisfiedStatus " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mWriteStatus = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " writeNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mWriteMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } maps . add ( map ) ; } } } if ( maps . size ( ) == 0 ) { maps = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getObjectiveMaps " ) ; } return maps ; }
marktriggs/nyu-sakai-10.4 | private static boolean getObjectives ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getObjectives " ) ; } boolean ok = true ; String tempVal = null ; List < SeqObjective > objectives = new ArrayList < SeqObjective > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " primaryObjective " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < primaryObjective > ▁ " + " element " ) ; } SeqObjective obj = new SeqObjective ( ) ; obj . mContributesToRollup = true ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " objectiveID " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " satisfiedByMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mSatisfiedByMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = getElementText ( curNode , " minNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mMinMeasure = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } List < SeqObjectiveMap > maps = getObjectiveMaps ( curNode ) ; if ( maps != null ) { obj . mMaps = maps ; } obj . mContributesToRollup = true ; objectives . add ( obj ) ; } else if ( curNode . getLocalName ( ) . equals ( " objective " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < objective > ▁ " + " element " ) ; } SeqObjective obj = new SeqObjective ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " objectiveID " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " satisfiedByMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mSatisfiedByMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = getElementText ( curNode , " minNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mMinMeasure = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } List < SeqObjectiveMap > maps = getObjectiveMaps ( curNode ) ; if ( maps != null ) { obj . mMaps = maps ; } objectives . add ( obj ) ; } } } ioAct . setObjectives ( objectives ) ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getObjectives " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static boolean getRollupRules ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getRollupRules " ) ; } boolean ok = true ; String tempVal = null ; List < SeqRollupRule > rollupRules = new ArrayList < SeqRollupRule > ( ) ; tempVal = ADLSeqUtilities . getAttribute ( iNode , " rollupObjectiveSatisfied " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setIsObjRolledUp ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( iNode , " objectiveMeasureWeight " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setObjMeasureWeight ( ( new Double ( tempVal ) ) . doubleValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( iNode , " rollupProgressCompletion " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setIsProgressRolledUp ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " rollupRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < rollupRule > ▁ " + " element " ) ; } SeqRollupRule rule = new SeqRollupRule ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " childActivitySet " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mChildActivitySet = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " minimumCount " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mMinCount = ( Long . valueOf ( tempVal ) ) . longValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " minimumPercent " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mMinPercent = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } rule . mConditions = new SeqConditionSet ( true ) ; List < SeqCondition > conditions = new ArrayList < SeqCondition > ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < ruleInfo . getLength ( ) ; j ++ ) { Node curRule = ruleInfo . item ( j ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " rollupConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rollupConditions > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " conditionCombination " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mConditions . mCombination = tempVal ; } } else { rule . mConditions . mCombination = SeqConditionSet . COMBINATION_ANY ; } NodeList conds = curRule . getChildNodes ( ) ; for ( int k = 0 ; k < conds . getLength ( ) ; k ++ ) { Node con = conds . item ( k ) ; if ( con . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( con . getLocalName ( ) . equals ( " rollupCondition " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rollupCondition > ▁ " + " element " ) ; } SeqCondition cond = new SeqCondition ( ) ; tempVal = ADLSeqUtilities . getAttribute ( con , " condition " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mCondition = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( con , " operator " ) ; if ( tempVal != null ) { if ( tempVal . equals ( " not " ) ) { cond . mNot = true ; } else { cond . mNot = false ; } } conditions . add ( cond ) ; } } } } else if ( curRule . getLocalName ( ) . equals ( " rollupAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rollupAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . setRollupAction ( tempVal ) ; } } } } } rule . mConditions . mConditions = conditions ; rollupRules . add ( rule ) ; } } } if ( rollupRules != null ) { ISeqRollupRuleset rules = new SeqRollupRuleset ( rollupRules ) ; ioAct . setRollupRules ( rules ) ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getRollupRules " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static boolean getSequencingRules ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getSequencingRules " ) ; } boolean ok = true ; String tempVal = null ; List < ISeqRule > preRules = new ArrayList < ISeqRule > ( ) ; List < ISeqRule > exitRules = new ArrayList < ISeqRule > ( ) ; List < ISeqRule > postRules = new ArrayList < ISeqRule > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " preConditionRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < preConditionRule > ▁ " + " element " ) ; } SeqRule rule = new SeqRule ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < ruleInfo . getLength ( ) ; j ++ ) { Node curRule = ruleInfo . item ( j ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " ruleConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < ruleConditions > ▁ element " ) ; } rule . mConditions = extractSeqRuleConditions ( curRule ) ; } else if ( curRule . getLocalName ( ) . equals ( " ruleAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < ruleAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mAction = tempVal ; } } } } } if ( rule . mConditions != null && rule . mAction != null ) { preRules . add ( rule ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Invaild ▁ Pre ▁ SeqRule " ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " exitConditionRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < exitConditionRule > ▁ element " ) ; } SeqRule rule = new SeqRule ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int k = 0 ; k < ruleInfo . getLength ( ) ; k ++ ) { Node curRule = ruleInfo . item ( k ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " ruleConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < ruleConditions > ▁ element " ) ; } rule . mConditions = extractSeqRuleConditions ( curRule ) ; } else if ( curRule . getLocalName ( ) . equals ( " ruleAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < ruleAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { rule . mAction = tempVal ; } } } } if ( rule . mConditions != null && rule . mAction != null ) { exitRules . add ( rule ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Invaild ▁ Exit ▁ SeqRule " ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " postConditionRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < postConditionRule > ▁ element " ) ; } SeqRule rule = new SeqRule ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < ruleInfo . getLength ( ) ; j ++ ) { Node curRule = ruleInfo . item ( j ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " ruleConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < ruleConditions > ▁ element " ) ; } rule . mConditions = extractSeqRuleConditions ( curRule ) ; } else if ( curRule . getLocalName ( ) . equals ( " ruleAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < ruleAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { rule . mAction = tempVal ; } } } } if ( rule . mConditions != null && rule . mAction != null ) { postRules . add ( rule ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Invaild ▁ Post ▁ SeqRule " ) ; } } } } } if ( preRules . size ( ) > 0 ) { ISeqRuleset rules = new SeqRuleset ( preRules ) ; ioAct . setPreSeqRules ( rules ) ; } if ( exitRules . size ( ) > 0 ) { ISeqRuleset rules = new SeqRuleset ( exitRules ) ; ioAct . setExitSeqRules ( rules ) ; } if ( postRules . size ( ) > 0 ) { ISeqRuleset rules = new SeqRuleset ( postRules ) ; ioAct . setPostSeqRules ( rules ) ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getSequencingRules " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static boolean isEmpty ( String iValue ) { return ( StringUtils . isBlank ( iValue ) ) ; }
marktriggs/nyu-sakai-10.4 | public static boolean setCourseStatus ( String iCourseID , String iLearnerID , String iSatisfied , String iMeasure , String iCompleted ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " setCourseStatus " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iCourseID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iSatisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iMeasure ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iCompleted ) ; } boolean success = true ; if ( ! ( iSatisfied . equals ( " unknown " ) || iSatisfied . equals ( " satisfied " ) || iSatisfied . equals ( " notSatisfied " ) ) ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iSatisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setCourseStatus " ) ; } return success ; } if ( ! ( iCompleted . equals ( " unknown " ) || iCompleted . equals ( " completed " ) || iCompleted . equals ( " incomplete " ) ) ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iCompleted ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setCourseStatus " ) ; } return success ; } try { double measure = Double . parseDouble ( iMeasure ) ; if ( measure < - 1.0 || measure > 1.0 ) { success = false ; } } catch ( Exception e ) { success = false ; } if ( ! success ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iMeasure ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setCourseStatus " ) ; } return success ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : setCourseStatus " ) ; return success ; }
marktriggs/nyu-sakai-10.4 | public static boolean setGlobalObjMeasure ( String iObjID , String iLearnerID , String iScopeID , String iMeasure ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " setGlobalObjMeasure " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iObjID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iScopeID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iMeasure ) ; } boolean goodMeasure = true ; boolean success = true ; if ( ! iMeasure . equals ( " unknown " ) ) { try { Double tempMeasure = new Double ( iMeasure ) ; double range = tempMeasure . doubleValue ( ) ; if ( range < - 1.0 || range > 1.0 ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ range : ▁ ▁ " + iMeasure ) ; } goodMeasure = false ; } } catch ( NumberFormatException e ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ ▁ " + iMeasure ) ; } goodMeasure = false ; } if ( ! goodMeasure ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getGlobalObjMeasure " ) ; } return success ; } } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : setGlobalObjMeasure " ) ; return success ; }
marktriggs/nyu-sakai-10.4 | public static boolean setGlobalObjSatisfied ( String iObjID , String iLearnerID , String iScopeID , String iSatisfied ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " setGlobalObjSatisfied " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iObjID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iScopeID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iSatisfied ) ; } boolean success = true ; if ( ! ( iSatisfied . equals ( " unknown " ) || iSatisfied . equals ( " satisfied " ) || iSatisfied . equals ( " notSatisfied " ) ) ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iSatisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setSharedCompMastery " ) ; } return success ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : setGlobalObjSatisfied " ) ; return success ; }
shs96c/buck | public static Builder builder ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , ToolchainProvider toolchainProvider , BuildRuleParams params , ActionGraphBuilder graphBuilder , CellPathResolver cellPathResolver , JavaBuckConfig javaBuckConfig , JavacFactory javacFactory , JavacOptions javacOptions , CoreArg args , ConfiguredCompilerFactory compilerFactory ) { return new Builder ( buildTarget , projectFilesystem , toolchainProvider , params , graphBuilder , cellPathResolver , javaBuckConfig , javacFactory , javacOptions , args , compilerFactory ) ; }
MiracleWong/ThinkInJava | public static void main ( String [ ] args ) { ArrayList < Coffee > coffees = new ArrayList < Coffee > ( ) ; for ( Coffee c : new CoffeeGenerator ( 10 ) ) coffees . add ( c ) ; System . out . println ( coffees ) ; }
elect86/NvGlSamples | public static NvGLSLProgram createFromFiles ( GL4 gl4 , String root , String shaderName ) { return createFromFiles ( gl4 , root , shaderName , false ) ; }
elect86/NvGlSamples | public static NvGLSLProgram createFromFiles ( GL4 gl4 , String root , String shaderName , boolean strict ) { ShaderProgram shaderProgram = new ShaderProgram ( ) ; ShaderCode vertShaderCode = ShaderCode . create ( gl4 , GL_VERTEX_SHADER , NvGLSLProgram . class , root , null , shaderName , " vert " , null , true ) ; ShaderCode fragShaderCode = ShaderCode . create ( gl4 , GL_FRAGMENT_SHADER , NvGLSLProgram . class , root , null , shaderName , " frag " , null , true ) ; shaderProgram . add ( vertShaderCode ) ; shaderProgram . add ( fragShaderCode ) ; shaderProgram . init ( gl4 ) ; shaderProgram . link ( gl4 , System . out ) ; return new NvGLSLProgram ( shaderProgram . program ( ) , strict ) ; }
cybera/OpenConext-dashboard | public static PolicyBuilder of ( Policy policy ) { return new PolicyBuilder ( policy ) ; }
joewalnes/idea-community | @ Nullable public static SourcePosition getSourcePosition ( final StackFrameContext context ) { if ( context == null ) { return null ; } DebugProcessImpl debugProcess = ( DebugProcessImpl ) context . getDebugProcess ( ) ; if ( debugProcess == null ) { return null ; } final StackFrameProxy frameProxy = context . getFrameProxy ( ) ; if ( frameProxy == null ) { return null ; } Location location = null ; try { location = frameProxy . location ( ) ; } catch ( Throwable th ) { LOG . debug ( th ) ; } final CompoundPositionManager positionManager = debugProcess . getPositionManager ( ) ; if ( positionManager == null ) { return null ; } try { return positionManager . getSourcePosition ( location ) ; } catch ( IndexNotReadyException e ) { return null ; } }
joewalnes/idea-community | @ Nullable public static PsiElement getContextElement ( final StackFrameContext context ) { return getContextElement ( context , getSourcePosition ( context ) ) ; }
joewalnes/idea-community | @ Nullable protected static PsiElement getContextElement ( final StackFrameContext context , final SourcePosition position ) { if ( LOG . isDebugEnabled ( ) ) { final SourcePosition sourcePosition = getSourcePosition ( context ) ; LOG . assertTrue ( Comparing . equal ( sourcePosition , position ) ) ; } final PsiElement element = getContextElement ( position ) ; if ( element == null ) { return null ; } final StackFrameProxyImpl frameProxy = ( StackFrameProxyImpl ) context . getFrameProxy ( ) ; if ( frameProxy == null ) { return element ; } final StringBuilder buf = StringBuilderSpinAllocator . alloc ( ) ; try { List < LocalVariableProxyImpl > list = frameProxy . visibleVariables ( ) ; PsiResolveHelper resolveHelper = JavaPsiFacade . getInstance ( element . getProject ( ) ) . getResolveHelper ( ) ; buf . append ( ' { ' ) ; for ( LocalVariableProxyImpl localVariable : list ) { final String varName = localVariable . name ( ) ; if ( resolveHelper . resolveReferencedVariable ( varName , element ) == null ) { buf . append ( localVariable . getVariable ( ) . typeName ( ) ) . append ( " ▁ " ) . append ( varName ) . append ( " ; " ) ; } } buf . append ( ' } ' ) ; if ( buf . length ( ) <= 2 ) { return element ; } final PsiElementFactory elementFactory = JavaPsiFacade . getInstance ( element . getProject ( ) ) . getElementFactory ( ) ; final PsiCodeBlock codeBlockFromText = elementFactory . createCodeBlockFromText ( buf . toString ( ) , element ) ; final PsiStatement [ ] statements = codeBlockFromText . getStatements ( ) ; for ( PsiStatement statement : statements ) { if ( statement instanceof PsiDeclarationStatement ) { PsiDeclarationStatement declStatement = ( PsiDeclarationStatement ) statement ; PsiElement [ ] declaredElements = declStatement . getDeclaredElements ( ) ; for ( PsiElement declaredElement : declaredElements ) { declaredElement . putUserData ( IS_JSP_IMPLICIT , Boolean . TRUE ) ; } } } return codeBlockFromText ; } catch ( IncorrectOperationException e ) { return element ; } catch ( EvaluateException e ) { return element ; } finally { StringBuilderSpinAllocator . dispose ( buf ) ; } }
joewalnes/idea-community | @ Nullable public static PsiElement getContextElement ( final SourcePosition position ) { if ( position == null ) { return null ; } return getContextElementInText ( position . getFile ( ) , position . getLine ( ) ) ; }
joewalnes/idea-community | @ Nullable private static PsiElement getContextElementInText ( PsiFile psiFile , int lineNumber ) { if ( lineNumber < 0 ) { return psiFile ; } final Document document = PsiDocumentManager . getInstance ( psiFile . getProject ( ) ) . getDocument ( psiFile ) ; if ( document == null ) { return null ; } if ( lineNumber >= document . getLineCount ( ) ) { return psiFile ; } int startOffset = document . getLineStartOffset ( lineNumber ) ; if ( startOffset == - 1 ) { return null ; } PsiElement element ; PsiElement rootElement = psiFile ; List < PsiFile > allFiles = psiFile . getViewProvider ( ) . getAllFiles ( ) ; if ( allFiles . size ( ) > 1 ) { PsiClassOwner owner = ContainerUtil . findInstance ( allFiles , PsiClassOwner . class ) ; if ( owner != null ) { PsiClass [ ] classes = owner . getClasses ( ) ; if ( classes . length == 1 && classes [ 0 ] instanceof SyntheticElement ) { rootElement = classes [ 0 ] ; } } } while ( true ) { final CharSequence charsSequence = document . getCharsSequence ( ) ; for ( ; startOffset < charsSequence . length ( ) ; startOffset ++ ) { char c = charsSequence . charAt ( startOffset ) ; if ( c != ' ▁ ' && c != ' \t ' ) { break ; } } element = rootElement . findElementAt ( startOffset ) ; if ( element instanceof PsiComment ) { startOffset = element . getTextRange ( ) . getEndOffset ( ) + 1 ; } else { break ; } } if ( element != null && element . getParent ( ) instanceof PsiForStatement ) { return ( ( PsiForStatement ) element . getParent ( ) ) . getInitialization ( ) ; } else { return element ; } }
joewalnes/idea-community | public static boolean isJspImplicit ( PsiElement element ) { return Boolean . TRUE . equals ( element . getUserData ( IS_JSP_IMPLICIT ) ) ; }
RotaruDan/OpenLRS | public static Map < String , String > decodeAuthorization ( String authorization ) { Map < String , String > oauthParameters = new HashMap < String , String > ( ) ; if ( authorization != null ) { Matcher m = AUTHORIZATION_PATTERN . matcher ( authorization ) ; if ( m . matches ( ) ) { if ( " oauth " . equalsIgnoreCase ( m . group ( 1 ) ) ) { for ( String keyValuePair : m . group ( 2 ) . split ( " \\ s * , \\ s * " ) ) { m = KEYVALUEPAIR_PATTERN . matcher ( keyValuePair ) ; if ( m . matches ( ) ) { String key = OAuthUtils . decodePercent ( m . group ( 1 ) ) ; String value = OAuthUtils . decodePercent ( m . group ( 2 ) ) ; oauthParameters . put ( key , value ) ; } } } } } return oauthParameters ; }
RotaruDan/OpenLRS | public static String sign ( String secret , Map < String , String > oauthParameters , String algorithm , String method , String url ) { StringBuilder signatureBase = new StringBuilder ( OAuthUtils . percentEncode ( method ) ) ; signatureBase . append ( " & " ) ; signatureBase . append ( OAuthUtils . percentEncode ( url ) ) ; signatureBase . append ( " & " ) ; Map < String , String > treeMap = new TreeMap < String , String > ( oauthParameters ) ; treeMap . remove ( " oauth _ signature " ) ; treeMap . remove ( " realm " ) ; boolean first = true ; for ( Map . Entry < String , String > entry : treeMap . entrySet ( ) ) { if ( ! first ) signatureBase . append ( OAuthUtils . percentEncode ( " & " ) ) ; else first = false ; signatureBase . append ( OAuthUtils . percentEncode ( entry . getKey ( ) + " = " + entry . getValue ( ) ) ) ; } Mac mac = null ; try { SecretKeySpec secretKeySpec = new SecretKeySpec ( ( OAuthUtils . percentEncode ( secret ) + " & " ) . getBytes ( ) , algorithm ) ; mac = Mac . getInstance ( secretKeySpec . getAlgorithm ( ) ) ; mac . init ( secretKeySpec ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( " signatureBaseString : ▁ " + signatureBase . toString ( ) ) ; } byte [ ] bytes = mac . doFinal ( signatureBase . toString ( ) . getBytes ( ) ) ; byte [ ] encodedMacBytes = Base64 . encodeBase64 ( bytes ) ; return new String ( encodedMacBytes ) ; }
RotaruDan/OpenLRS | public static final String mapToJava ( String name ) { String algorithm = algorithms . get ( name ) ; if ( algorithm == null ) { throw new UnsupportedOperationException ( " Signature ▁ algorithm ▁ of ▁ " + name + " ▁ is ▁ unsupported . " ) ; } return algorithm ; }
RotaruDan/OpenLRS | private static String percentEncode ( String s ) { if ( s == null ) { return " " ; } try { return URLEncoder . encode ( s , " UTF - 8" ) . replace ( " + " , " % 20" ) . replace ( " * " , " % 2A " ) . replace ( " % 7E " , " ~ " ) ; } catch ( UnsupportedEncodingException uee ) { throw new RuntimeException ( uee . getMessage ( ) , uee ) ; } }
RotaruDan/OpenLRS | private static String decodePercent ( String s ) { try { return URLDecoder . decode ( s , " UTF - 8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
google/differential-privacy | private static BoundedSumSummary getSummary ( BoundedSum sum ) { byte [ ] nonParsedSummary = sum . getSerializableSummary ( ) ; try { return BoundedSumSummary . parseFrom ( nonParsedSummary ) ; } catch ( InvalidProtocolBufferException pbe ) { throw new IllegalArgumentException ( pbe ) ; } }
prabodhprakash/problemsolving | public static void main ( String [ ] args ) { Solution solution = new Solution ( ) ; solution . readInput ( ) ; solution . calculateLCS ( 0 , 0 ) ; solution . printLCS ( ) ; }
aws/aws-sdk-java | public static ListTagsForResourceResultJsonUnmarshaller getInstance ( ) { if ( instance == null ) instance = new ListTagsForResourceResultJsonUnmarshaller ( ) ; return instance ; }
donovanmuller/spring-cloud-dataflow | public static String getTaskPrefix ( String taskName ) { return taskName + " - " ; }
llenterak/eulers | private static int [ ] genDigitFactorials ( ) { int [ ] res = new int [ 10 ] ; res [ 0 ] = 1 ; int f = 1 ; for ( int i = 1 ; i < 10 ; i ++ ) { f *= i ; res [ i ] = f ; } return res ; }
FHannes/intellij-community | @ Nullable private static PsiElement getPsiElement ( InspectionResultsView view ) { final RefEntity [ ] selectedElements = view . getTree ( ) . getSelectedElements ( ) ; final PsiElement psiElement ; if ( selectedElements . length > 0 && selectedElements [ 0 ] instanceof RefElement ) { psiElement = ( ( RefElement ) selectedElements [ 0 ] ) . getElement ( ) ; } else { psiElement = null ; } return psiElement ; }
0359xiaodong/blink | public static Group newInstance ( ) { Group group = new Group ( ) ; group . setAttributableType ( ATTRIBUTABLE_TYPE ) ; return group ; }
0359xiaodong/blink | public static void addNewGroup ( String name , final long [ ] ids ) { final Group group = Group . newInstance ( ) ; group . setName ( name ) ; group . setState ( BlinkApp . STATE_ADDED ) ; BlinkApp . getDaoSession ( ) . getGroupDao ( ) . insert ( group ) ; Event . broadcast ( Group . KEY ) ; Event . observe ( Group . KEY , new Observer ( ) { @ Override public void update ( Observable observable , Object data ) { Event . ignore ( Group . KEY , this ) ; for ( long id : ids ) { group . addDevice ( id ) ; } } } ) ; Syncro . getInstance ( ) . syncDevices ( ) ; }
bunjlabs/jed2d | public static Vector4b create ( ) { return new Vector4b ( ) ; }
bunjlabs/jed2d | public static Vector4b create ( boolean v ) { return new Vector4b ( v ) ; }
bunjlabs/jed2d | public static Vector4b create ( boolean x1 , boolean x2 , boolean x3 , boolean x4 ) { return new Vector4b ( x1 , x2 , x3 , x4 ) ; }
bunjlabs/jed2d | public static Vector4b create ( Vector4b v ) { return new Vector4b ( v ) ; }
GunoH/intellij-community | @ NotNull protected static Promise < String > getTextToEvaluate ( DataContext dataContext , XDebugSession session ) { final Editor editor = CommonDataKeys . EDITOR . getData ( dataContext ) ; if ( editor == null ) { return Promises . resolvedPromise ( null ) ; } String text = editor . getSelectionModel ( ) . getSelectedText ( ) ; if ( text != null ) { return Promises . resolvedPromise ( StringUtil . nullize ( text , true ) ) ; } XDebuggerEvaluator evaluator = session . getDebugProcess ( ) . getEvaluator ( ) ; if ( evaluator != null ) { return XDebuggerEvaluateActionHandler . getExpressionText ( evaluator , editor . getProject ( ) , editor ) . then ( s -> StringUtil . nullize ( s , true ) ) ; } return Promises . resolvedPromise ( null ) ; }
numixproject/com.numix.calculator | public static boolean isExternalStorageWritable ( ) { return Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) ; }
numixproject/com.numix.calculator | public static boolean isExternalStorageReadable ( ) { String state = Environment . getExternalStorageState ( ) ; return Environment . MEDIA_MOUNTED . equals ( state ) || Environment . MEDIA_MOUNTED_READ_ONLY . equals ( state ) ; }
nkolban/jpigpio | public static void main ( String args [ ] ) { System . out . println ( " Test _ SocketListen " ) ; Test_SocketListen app = new Test_SocketListen ( ) ; app . run ( ) ; }
goodwinnk/intellij-community | public static boolean isEndVariable ( @ NotNull String name ) { return name . startsWith ( END_PREFIX ) ; }
dubuyuye/tetris | public static void draw_String_Value ( int rowY , Image img , int x_img , int num , int x_num , int maxNumLength , Graphics g ) { g . drawImage ( img , x_img , rowY , null ) ; NumberRenderer . drawNumber ( num , x_num , rowY , maxNumLength , g ) ; }
jexp/idea2 | public static boolean isEDT ( String name ) { return name . startsWith ( " AWT - EventQueue " ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( SIGMA sigma , float mu , int nPoints ) { float s = SIGMA . getValue ( sigma ) ; return getKernel ( s , mu , nPoints ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( float sigma , float mu , int nPoints ) { float normalization = ( float ) ( Math . pow ( sigma , 5 ) * Math . sqrt ( 2.f * Math . PI ) ) ; if ( sigma < 1 ) { int power = MiscMath . findPowerOf10 ( sigma * sigma ) ; normalization *= ( 1. / ( sigma * sigma ) ) * Math . pow ( 10 , - 1 * power ) ; } int halfWidthInPixels = nPoints >> 1 ; int start = ( int ) ( mu - halfWidthInPixels ) ; int stopExcl = ( int ) mu + halfWidthInPixels + 1 ; float d , dsq ; int count = 0 ; float [ ] yPoints = new float [ nPoints ] ; for ( int i = start ; i < stopExcl ; i ++ ) { if ( count >= nPoints ) { break ; } float x = i ; d = ( x - mu ) ; dsq = d * d ; float y = ( dsq - sigma * sigma ) * ( float ) ( Math . exp ( - 1.f * dsq / ( 2.f * sigma * sigma ) ) ) ; yPoints [ count ] = y / normalization ; count ++ ; } return yPoints ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( SIGMA sigma , float mu ) { return getKernel ( SIGMA . getValue ( sigma ) , mu ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( float sigma , float mu ) { float hwi = estimateHWZI ( sigma , 0.001f ) ; if ( hwi < 0 ) { hwi *= - 1.f ; } int halfWidthInPixels = ( int ) Math . ceil ( hwi ) ; int nPoints = 2 * halfWidthInPixels + 1 ; return getKernel ( sigma , mu , nPoints ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( float sigma ) { return getKernel ( sigma , 0 ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( SIGMA sigma ) { if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTSEVENONE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointSevenOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONE . ordinal ( ) ) { return getBinomialKernelSigmaOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOneSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWO . ordinal ( ) ) { return getBinomialKernelSigmaTwo ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFiveSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOSQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaTwoSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . THREE . ordinal ( ) ) { return getBinomialKernelSigmaThree ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . FOUR . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . FOURSQRT2 . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . EIGHT . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . EIGHT . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . EIGHTSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 87 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTEEN . ordinal ( ) ) { return getKernel ( sigma , 0 , 121 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTEENSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 171 ) ; } else if ( sigma . ordinal ( ) == SIGMA . THIRTYTWO . ordinal ( ) ) { return getKernel ( sigma , 0 , 239 ) ; } else if ( sigma . ordinal ( ) == SIGMA . THIRTYTWOSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 339 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTYFOUR . ordinal ( ) ) { return getKernel ( sigma , 0 , 477 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTYFOURSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 675 ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEHUNDREDANDTWENTYEIGHT . ordinal ( ) ) { return getKernel ( sigma , 0 , 953 ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEHUNDREDANDTWENTYEIGHTSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 1347 ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOHUNDREDANDFIFTYSIX . ordinal ( ) ) { return getKernel ( sigma , 0 , 1905 ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOHUNDREDANDFIFTYSIX . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } throw new IllegalArgumentException ( " haven ' t ▁ implemented ▁ a ▁ method ▁ for ▁ " + " ▁ sigma = " + sigma ) ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernel ( SIGMA sigma ) { if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTSEVENONE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointSevenOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONE . ordinal ( ) ) { return getBinomialKernelSigmaOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOneSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWO . ordinal ( ) ) { return getBinomialKernelSigmaTwo ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFiveSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOSQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaTwoSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . THREE . ordinal ( ) ) { return getBinomialKernelSigmaThree ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . FOUR . ordinal ( ) ) { return getBinomialKernelSigmaFour ( ) ; } else { return null ; } }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaZeroPointFive ( ) { return new float [ ] { 0.037f , - 0.074f , 0.037f } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getKernelSigmaZeroPointSevenOne ( ) { return new float [ ] { 0 , 0.0072334423f , 0.020755375f , - 0.05641896f , 0.020755375f , 0.0072334423f , 0 } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaZeroPointSevenOne ( ) { float a = 1.f / 141.8f ; return new float [ ] { a , 3 * a , - 8 * a , 3 * a , a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getKernelSigmaOne ( ) { return new float [ ] { 0.0020074535f , 0.035454787f , 0.16197291f , - 0.0f , - 0.3989423f , 0.0f , 0.16197291f , 0.035454787f , 0.0020074535f } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOne ( ) { float a = 1.f / 30.f ; return new float [ ] { a , 5 * a , 0 , - 12 * a , 0 , 5 * a , a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOneSQRT2 ( ) { float a = 1.f / 256.f ; return new float [ ] { 1 * a , 5 * a , 13 * a , 13 * a , - 14 * a , - 36 * a , - 14 * a , 13 * a , 13 * a , 5 * a , 1 * a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOnePointFive ( ) { float a = 1.f / 256.f ; return new float [ ] { 1 * a , 5 * a , 12 * a , 10 * a , - 13 * a , - 30 * a , - 13 * a , 10 * a , 12 * a , 5 * a , 1 * a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaTwo ( ) { float a = 1.f / 64000.f ; return new float [ ] { 1 * a , 14 * a , 89 * a , 336 * a , 820 * a , 1288 * a , 1092 * a , - 208 * a , - 2002 * a , - 2860 * a , - 2002 * a , - 208 * a , 1092 * a , a * 1288 , a * 820 , a * 336 , a * 89 , a * 14 , a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOnePointFiveSQRT2 ( ) { double a = 1. / 245000l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 16l * a ) , ( float ) ( 118l * a ) , ( float ) ( 528l * a ) , ( float ) ( 1581l * a ) , ( float ) ( 3264l * a ) , ( float ) ( 4488l * a ) , ( float ) ( 3264l * a ) , ( float ) ( - 1326l * a ) , ( float ) ( - 7072l * a ) , ( float ) ( - 9724l * a ) , ( float ) ( - 7072l * a ) , ( float ) ( - 1326l * a ) , ( float ) ( 3264l * a ) , ( float ) ( 4488l * a ) , ( float ) ( 3264l * a ) , ( float ) ( 1581l * a ) , ( float ) ( 528l * a ) , ( float ) ( 118l * a ) , ( float ) ( 16l * a ) , ( float ) ( 1l * a ) } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaTwoSQRT2 ( ) { double a = 1. / 4100000000l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 30l * a ) , ( float ) ( 433l * a ) , ( float ) ( 4000l * a ) , ( float ) ( 26536l * a ) , ( float ) ( 134416l * a ) , ( float ) ( 539400l * a ) , ( float ) ( 1754848l * a ) , ( float ) ( 4692780l * a ) , ( float ) ( 10378056l * a ) , ( float ) ( 18932940l * a ) , ( float ) ( 28048800l * a ) , ( float ) ( 32256120l * a ) , ( float ) ( 24812400l * a ) , ( float ) ( 2481240l * a ) , ( float ) ( - 29774880l * a ) , ( float ) ( - 58929450l * a ) , ( float ) ( - 70715340l * a ) , ( float ) ( - 58929450l * a ) , ( float ) ( - 29774880l * a ) , ( float ) ( 2481240l * a ) , ( float ) ( 24812400l * a ) , ( float ) ( 32256120l * a ) , ( float ) ( 28048800l * a ) , ( float ) ( 18932940l * a ) , ( float ) ( 10378056l * a ) , ( float ) ( 4692780l * a ) , ( float ) ( 1754848l * a ) , ( float ) ( 539400l * a ) , ( float ) ( 134416l * a ) , ( float ) ( 26536l * a ) , ( float ) ( 4000l * a ) , ( float ) ( 433l * a ) , ( float ) ( 30l * a ) , ( float ) ( 1l * a ) } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaThree ( ) { double a = 1. / 65000000000l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 34l * a ) , ( float ) ( 559l * a ) , ( float ) ( 5916l * a ) , ( float ) ( 45255l * a ) , ( float ) ( 266322l * a ) , ( float ) ( 1252713l * a ) , ( float ) ( 4829088l * a ) , ( float ) ( 15512772l * a ) , ( float ) ( 41970280l * a ) , ( float ) ( 96160636l * a ) , ( float ) ( 186574864l * a ) , ( float ) ( 304253964l * a ) , ( float ) ( 408239496l * a ) , ( float ) ( 426395700l * a ) , ( float ) ( 286097760l * a ) , ( float ) ( - 31635810l * a ) , ( float ) ( - 450345060l * a ) , ( float ) ( - 811985790l * a ) , ( float ) ( - 955277400l * a ) , ( float ) ( - 811985790l * a ) , ( float ) ( - 450345060l * a ) , ( float ) ( - 31635810l * a ) , ( float ) ( 286097760l * a ) , ( float ) ( 426395700l * a ) , ( float ) ( 408239496l * a ) , ( float ) ( 304253964l * a ) , ( float ) ( 186574864l * a ) , ( float ) ( 96160636l * a ) , ( float ) ( 41970280l * a ) , ( float ) ( 15512772l * a ) , ( float ) ( 4829088l * a ) , ( float ) ( 1252713l * a ) , ( float ) ( 266322l * a ) , ( float ) ( 45255l * a ) , ( float ) ( 5916l * a ) , ( float ) ( 559l * a ) , ( float ) ( 34l * a ) , ( float ) ( 1l * a ) } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaFour ( ) { float a = 1.f / 315.f ; return new float [ ] { ( float ) ( 0.0013496157933984045 ) * a , ( float ) ( 0.003812253148120798 ) * a , ( float ) ( 0.00985466410118652 ) * a , ( float ) ( 0.023354250937084688 ) * a , ( float ) ( 0.050793931240985246 ) * a , ( float ) ( 0.10141062660346886 ) * a , ( float ) ( 0.18571762697885447 ) * a , ( float ) ( 0.31132423871622195 ) * a , ( float ) ( 0.4757716476259789 ) * a , ( float ) ( 0.6580431670807847 ) * a , ( float ) ( 0.8130047466820091 ) * a , ( float ) ( 0.8746801742701372 ) * a , ( float ) ( 0.7727267283900054 ) * a , ( float ) ( 0.4606218146694771 ) * a , ( float ) ( 0.05400657042753325 ) * a , ( float ) ( - 0.6908945681321693 ) * a , ( float ) ( - 1.2995036536356718 ) * a , ( float ) ( - 1.682898921828288 ) * a , ( float ) ( - 1.9582123932012366 ) * a , ( float ) ( - 1.682898921828288 ) * a , ( float ) ( - 1.2995036536356718 ) * a , ( float ) ( - 0.6908945681321693 ) * a , ( float ) ( 0.05400657042753325 ) * a , ( float ) ( 0.4606218146694771 ) * a , ( float ) ( 0.7727267283900054 ) * a , ( float ) ( 0.8746801742701372 ) * a , ( float ) ( 0.8130047466820091 ) * a , ( float ) ( 0.6580431670807847 ) * a , ( float ) ( 0.4757716476259789 ) * a , ( float ) ( 0.31132423871622195 ) * a , ( float ) ( 0.18577391691321074 ) * a , ( float ) ( 0.10141612056970953 ) * a , ( float ) ( 0.050794238557124116 ) * a , ( float ) ( 0.023354255369729467 ) * a , ( float ) ( 0.00985466410118652 ) * a , ( float ) ( 0.003812253148120798 ) * a , ( float ) ( 0.0013496157933984045 ) * a } ; }
MattSi/Game2048 | public static double log2 ( int x ) { return ( Math . log ( x ) / Math . log ( 2 ) ) ; }
google/or-tools | public static void main ( String [ ] args ) throws Exception { Loader . loadNativeLibraries ( ) ; CpModel model = new CpModel ( ) ; int numVals = 3 ; IntVar x = model . newIntVar ( 0 , numVals - 1 , " x " ) ; IntVar y = model . newIntVar ( 0 , numVals - 1 , " y " ) ; IntVar z = model . newIntVar ( 0 , numVals - 1 , " z " ) ; model . addDifferent ( x , y ) ; CpSolver solver = new CpSolver ( ) ; VarArraySolutionPrinter cb = new VarArraySolutionPrinter ( new IntVar [ ] { x , y , z } ) ; solver . getParameters ( ) . setEnumerateAllSolutions ( true ) ; solver . solve ( model , cb ) ; System . out . println ( cb . getSolutionCount ( ) + " ▁ solutions ▁ found . " ) ; }
Estructuras-ITESM/Anpharos | public static void init ( ) { PApplet . main ( " anpharos . gui . Graph . GraphParent " ) ; }
Estructuras-ITESM/Anpharos | public static void main ( String [ ] args ) { GraphParent tmp = new GraphParent ( ) ; tmp . init ( ) ; }
CYDpeter/104021003 | public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int sum = 0 ; for ( int i = 13 ; i <= 1399 ; i = i + 1 ) { sum = sum + i ; } System . out . print ( " Sum = " + sum ) ; }
thedevgeek/ANDROID-APPs | public static ContentValues statusToContentValues ( Status status ) { ContentValues cv = new ContentValues ( ) ; cv . put ( C_ID , status . id ) ; cv . put ( C_CREATED_AT , status . createdAt . getTime ( ) ) ; cv . put ( C_TEXT , status . text ) ; cv . put ( C_USER , status . user . screenName ) ; return cv ; }
vsddev/Player_Glow_Sponge | public static void create ( String name , String text ) throws IOException { File dir = PlayerGlow . getInstance ( ) . getConfigDir ( ) ; dir . mkdirs ( ) ; FileWriter file = new FileWriter ( new File ( dir , name ) ) ; file . write ( text ) ; file . flush ( ) ; file . close ( ) ; }
vsddev/Player_Glow_Sponge | public static void createJson ( ) { String CreateString = " { } " ; File file = new File ( PlayerGlow . getInstance ( ) . getConfigDir ( ) , " colorData . json " ) ; if ( ! file . exists ( ) ) { try { create ( " colorData . json " , CreateString ) ; } catch ( IOException e1 ) { PlayerGlow . getInstance ( ) . getLogger ( ) . error ( " [ PlayerGlow ] ▁ Error ▁ writing ▁ config ▁ file ! " ) ; } } }
vsddev/Player_Glow_Sponge | public static void readJson ( ) { JsonParser parser = new JsonParser ( ) ; try { Object obj = parser . parse ( new FileReader ( new File ( PlayerGlow . getInstance ( ) . getConfigDir ( ) , " colorData . json " ) ) ) ; ColorData = ( JsonObject ) obj ; } catch ( IOException e2 ) { PlayerGlow . getInstance ( ) . getLogger ( ) . error ( " [ PlayerGlow ] ▁ Error ▁ reading ▁ config ▁ file ! " ) ; } }
anishek/hive | public static boolean isApplicable ( ASTNode node ) { return ( node . getToken ( ) . getType ( ) == HiveParser . TOK_REPLICATION ) ; }
anishek/hive | public static String getLastReplicatedStateFromParameters ( Map < String , String > m ) { if ( ( m != null ) && ( m . containsKey ( KEY . CURR_STATE_ID . toString ( ) ) ) ) { return m . get ( KEY . CURR_STATE_ID . toString ( ) ) ; } return null ; }
anishek/hive | public static void copyLastReplId ( Map < String , String > srcParameter , Map < String , String > destParameter ) { String lastReplId = srcParameter . get ( ReplicationSpec . KEY . CURR_STATE_ID . toString ( ) ) ; if ( lastReplId != null ) { destParameter . put ( ReplicationSpec . KEY . CURR_STATE_ID . toString ( ) , lastReplId ) ; } }
weiwenqiang/GitHub | public static VersionedGestureDetector newInstance ( Context context , OnGestureListener listener ) { final int sdkVersion = Build . VERSION . SDK_INT ; VersionedGestureDetector detector = null ; if ( sdkVersion < Build . VERSION_CODES . ECLAIR ) { detector = new CupcakeDetector ( context ) ; } else if ( sdkVersion < Build . VERSION_CODES . FROYO ) { detector = new EclairDetector ( context ) ; } else { detector = new FroyoDetector ( context ) ; } detector . mListener = listener ; return detector ; }
bclozel/spring-boot | public static void main ( String [ ] args ) { SpringApplication . run ( TestConfiguration . class , args ) ; }
udayinfy/ECommerce-Java | public static void main ( String [ ] args ) { FulfillmentClient client = new FulfillmentClient ( ) ; client . recieveMessages ( ) ; }
ebayopensource/turmeric-runtime | private static CallTrackingLogger getLogger ( ) { return logger ; }
ebayopensource/turmeric-runtime | public static boolean isEmptyString ( String str ) { return ( str == null || str . trim ( ) . length ( ) == 0 ) ; }
ebayopensource/turmeric-runtime | public static String toQualifiedClassName ( String javaFilePath ) { String filePathNoExt = null ; if ( javaFilePath == null ) { return null ; } boolean isJavaExtensionPresent = javaFilePath . endsWith ( " . java " ) ; if ( isJavaExtensionPresent ) { filePathNoExt = javaFilePath . substring ( 0 , javaFilePath . length ( ) - 5 ) ; } boolean isClassExtensionPresent = javaFilePath . endsWith ( " . class " ) ; if ( isClassExtensionPresent ) { filePathNoExt = javaFilePath . substring ( 0 , javaFilePath . length ( ) - 6 ) ; } if ( filePathNoExt == null ) filePathNoExt = javaFilePath ; return filePathNoExt . replace ( ' \ \' , ' . ' ) . replace ( ' / ' , ' . ' ) ; }
ebayopensource/turmeric-runtime | public static String getQualifiedClassName ( String javaFilePath , String srcLocation ) { int pkgStartPos = javaFilePath . indexOf ( srcLocation ) ; String qualifiedJavaFile = null ; if ( pkgStartPos > - 1 ) { String normalizedSrcLoc = CodeGenUtil . normalizePath ( srcLocation ) ; int startPos = pkgStartPos + normalizedSrcLoc . length ( ) ; qualifiedJavaFile = javaFilePath . substring ( startPos ) ; } else { qualifiedJavaFile = javaFilePath ; } return toQualifiedClassName ( qualifiedJavaFile ) ; }
ebayopensource/turmeric-runtime | public static String getPackageName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( 0 , idx ) ; }
ebayopensource/turmeric-runtime | private static String normalizePath ( String path ) { if ( path == null ) { return null ; } if ( path . endsWith ( " \ \" ) || path . endsWith ( " / " ) ) { return path ; } else { return path + File . separatorChar ; } }
ebayopensource/turmeric-runtime | public static String toOSFilePath ( String path ) { if ( path == null ) { return null ; } String normaliedOSPath = path . replace ( ' \ \' , File . separatorChar ) . replace ( ' / ' , File . separatorChar ) ; return normalizePath ( normaliedOSPath ) ; }
ebayopensource/turmeric-runtime | public static String getFilePath ( String dir , String fileName ) { if ( dir == null || fileName == null ) { return null ; } String filePath = toOSFilePath ( dir ) + fileName ; return filePath ; }
ebayopensource/turmeric-runtime | public static String toJavaSrcFilePath ( String srcDir , Class < ? > clazz ) { if ( srcDir == null || clazz == null ) { return null ; } String filePath = toJavaSrcFilePath ( srcDir , clazz . getName ( ) ) ; return filePath ; }
ebayopensource/turmeric-runtime | public static String toJavaSrcFilePath ( String srcDir , String qualifiedJavaName ) { if ( srcDir == null || qualifiedJavaName == null ) { return null ; } String filePath = toOSFilePath ( srcDir ) + convertToJavaSrcFilePath ( qualifiedJavaName ) ; return filePath ; }
ebayopensource/turmeric-runtime | private static String convertToJavaSrcFilePath ( String qualifiedJavaName ) { if ( isEmptyString ( qualifiedJavaName ) ) { return qualifiedJavaName ; } int dotJavaPos = qualifiedJavaName . lastIndexOf ( " . java " ) ; if ( dotJavaPos > - 1 ) { return convertToFilePath ( qualifiedJavaName . substring ( 0 , dotJavaPos ) , " . java " ) ; } else { return convertToFilePath ( qualifiedJavaName , " . java " ) ; } }
ebayopensource/turmeric-runtime | public static String convertToFilePath ( String qualifiedJavaName , String suffix ) { return qualifiedJavaName . replace ( ' . ' , File . separatorChar ) + suffix ; }
ebayopensource/turmeric-runtime | public static String normalizePackageName ( String packageName ) { if ( isEmptyString ( packageName ) || ! packageName . endsWith ( " . " ) ) { return packageName ; } else { return packageName . substring ( 0 , packageName . length ( ) - 1 ) ; } }
ebayopensource/turmeric-runtime | public static boolean isParameterizedType ( Type type ) { return ( type instanceof ParameterizedType ) ; }
ebayopensource/turmeric-runtime | public static boolean isWildCardType ( Type type ) { return ( type instanceof WildcardType ) ; }
ebayopensource/turmeric-runtime | public static boolean isGenericArrayType ( Type type ) { return ( type instanceof GenericArrayType ) ; }
ebayopensource/turmeric-runtime | public static String makeFirstLetterUpper ( String str ) { if ( isEmptyString ( str ) ) { return str ; } char firstChar = str . charAt ( 0 ) ; if ( Character . isLetter ( firstChar ) && Character . isLowerCase ( firstChar ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toUpperCase ( firstChar ) ; return String . valueOf ( chars ) ; } else { return str ; } }
ebayopensource/turmeric-runtime | public static String makeFirstLetterLower ( String str ) { if ( isEmptyString ( str ) ) { return str ; } char firstChar = str . charAt ( 0 ) ; if ( Character . isLetter ( firstChar ) && Character . isUpperCase ( firstChar ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toLowerCase ( firstChar ) ; return String . valueOf ( chars ) ; } else { return str ; } }
ebayopensource/turmeric-runtime | public static File getDir ( String destDir ) throws IOException { if ( destDir == null ) { return null ; } File dir = new File ( destDir ) ; if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new IOException ( destDir + " : ▁ non - existent ▁ directory " ) ; } return dir ; }
ebayopensource/turmeric-runtime | public static String genDestFolderPath ( String destLoc , String serviceName , String suffixPath ) { StringBuilder destFolderPath = new StringBuilder ( ) ; destFolderPath . append ( toOSFilePath ( destLoc ) ) ; destFolderPath . append ( toOSFilePath ( suffixPath ) ) ; destFolderPath . append ( serviceName ) ; return destFolderPath . toString ( ) ; }
ebayopensource/turmeric-runtime | public static String genDestFolderPath ( String destLoc , String suffixLoc ) { if ( isEmptyString ( destLoc ) ) { return destLoc ; } String destPath = toOSFilePath ( destLoc ) ; if ( ! isEmptyString ( suffixLoc ) ) { destPath = destPath + toOSFilePath ( suffixLoc ) ; } return destPath ; }
ebayopensource/turmeric-runtime | public static String getNSFromPackageName ( String packageName ) { StringBuffer strBuf = new StringBuffer ( ) ; int prevIndex = packageName . length ( ) ; int currentIndex = packageName . lastIndexOf ( PACKAGE_class_DELIMITER ) ; if ( currentIndex > 0 ) { strBuf . append ( HTTP ) ; } else if ( prevIndex > 0 ) { strBuf . append ( HTTP ) ; strBuf . append ( packageName ) ; return strBuf . toString ( ) ; } else if ( currentIndex == - 1 ) { return strBuf . toString ( ) ; } while ( currentIndex != - 1 ) { strBuf . append ( packageName . substring ( currentIndex + 1 , prevIndex ) ) ; prevIndex = currentIndex ; currentIndex = packageName . lastIndexOf ( PACKAGE_class_DELIMITER , prevIndex - 1 ) ; strBuf . append ( PACKAGE_class_DELIMITER ) ; if ( currentIndex == - 1 ) { strBuf . append ( packageName . substring ( 0 , prevIndex ) ) ; } } return strBuf . toString ( ) ; }
ebayopensource/turmeric-runtime | public static File createDir ( String dirPath ) throws IOException { File dir = new File ( dirPath ) ; if ( dir . exists ( ) ) { return dir ; } if ( dir . mkdirs ( ) == false ) { throw new IOException ( " Failed ▁ to ▁ create ▁ dir ( s ) ▁ : ▁ " + dirPath ) ; } return dir ; }
ebayopensource/turmeric-runtime | public static boolean isFileExists ( String filePath ) { if ( isEmptyString ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return file . exists ( ) ; }
ebayopensource/turmeric-runtime | public static boolean dirExists ( String path ) { if ( isEmptyString ( path ) ) { return false ; } File dir = new File ( path ) ; return dir . exists ( ) && dir . isDirectory ( ) ; }
ebayopensource/turmeric-runtime | public static void deleteFile ( File file ) throws IOException { if ( file == null || ! file . exists ( ) ) { return ; } if ( ! file . delete ( ) ) { throw new IOException ( " Can ' t ▁ delete ▁ file ▁ : ▁ " + file . getPath ( ) ) ; } }
ebayopensource/turmeric-runtime | public static boolean deleteDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return dir . delete ( ) ; }
ebayopensource/turmeric-runtime | public static boolean deleteContentsOfDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return true ; }
ebayopensource/turmeric-runtime | public static Writer getFileWriter ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File outputFile = new File ( dir , fileName ) ; deleteFile ( outputFile ) ; Charset defaultCharset = Charset . defaultCharset ( ) ; FileOutputStream fileOutStream = new FileOutputStream ( outputFile ) ; OutputStreamWriter bw = new OutputStreamWriter ( fileOutStream , defaultCharset ) ; Writer buffWriter = new BufferedWriter ( bw ) ; return buffWriter ; }
ebayopensource/turmeric-runtime | public static BufferedReader getFileReader ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File inFile = new File ( dir , fileName ) ; Charset defaultCharset = Charset . defaultCharset ( ) ; FileInputStream fileInStream = new FileInputStream ( inFile ) ; InputStreamReader bw = new InputStreamReader ( fileInStream , defaultCharset ) ; BufferedReader buffReader = new BufferedReader ( bw ) ; return buffReader ; }
ebayopensource/turmeric-runtime | public static OutputStream getFileOutputStream ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File outputFile = new File ( dir , fileName ) ; deleteFile ( outputFile ) ; FileOutputStream fileOutStream = new FileOutputStream ( outputFile ) ; return fileOutStream ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( InputSource inputSource ) { if ( inputSource == null ) { return ; } closeQuietly ( inputSource . getCharacterStream ( ) ) ; closeQuietly ( inputSource . getByteStream ( ) ) ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( WSDLLocator locator ) { if ( locator == null ) { return ; } locator . close ( ) ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( XMLStreamWriter writer ) { if ( writer == null ) { return ; } try { writer . close ( ) ; } catch ( XMLStreamException ignore ) { } }
ebayopensource/turmeric-runtime | public static void closeQuietly ( JarFile jarfile ) { if ( jarfile == null ) { return ; } try { jarfile . close ( ) ; } catch ( IOException ignore ) { } }
ebayopensource/turmeric-runtime | public static void closeQuietly ( FileHandler fileHandler ) { if ( fileHandler == null ) { return ; } fileHandler . close ( ) ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException ignore ) { } }
ebayopensource/turmeric-runtime | public static void flushAndCloseQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { if ( closeable instanceof Flushable ) { ( ( Flushable ) closeable ) . flush ( ) ; } } catch ( IOException e ) { } try { closeable . close ( ) ; } catch ( IOException ignore ) { } }
ebayopensource/turmeric-runtime | public static void move ( String srcFilePath , String destLoc , boolean override ) throws IOException { File srcFile = new File ( srcFilePath ) ; File destDir = createDir ( destLoc ) ; File newFile = new File ( destDir , srcFile . getName ( ) ) ; if ( newFile . exists ( ) ) { if ( override == false ) { return ; } else { deleteFile ( newFile ) ; } } boolean success = srcFile . renameTo ( newFile ) ; if ( success == false ) { throw new IOException ( " Failed ▁ to ▁ move ▁ file ▁ : ▁ " + srcFilePath + " ▁ to ▁ " + destLoc ) ; } }
ebayopensource/turmeric-runtime | public static void addAllFiles ( File dir , List < String > files ) { if ( dir . isDirectory ( ) ) { if ( ! dir . getName ( ) . equals ( " . " ) && ! dir . getName ( ) . equals ( " . . " ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { if ( children [ i ] . isDirectory ( ) ) { addAllFiles ( children [ i ] , files ) ; } else { files . add ( children [ i ] . getAbsolutePath ( ) ) ; } } } } }
ebayopensource/turmeric-runtime | public static String getTemplateContent ( String templateName ) throws IOException { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; InputStream inputStream = classLoader . getResourceAsStream ( templateName ) ; if ( inputStream == null ) { throw new IOException ( " Failed ▁ to ▁ load ▁ resource ▁ : ▁ " + templateName ) ; } String templateContent = readContent ( inputStream ) ; return templateContent ; }
ebayopensource/turmeric-runtime | private static String readContent ( InputStream input ) throws IOException { Charset defaultCharset = Charset . defaultCharset ( ) ; InputStreamReader isr = new InputStreamReader ( input , defaultCharset ) ; BufferedReader reader = new BufferedReader ( isr ) ; StringBuilder strBuff = new StringBuilder ( ) ; try { char [ ] charBuff = new char [ 512 ] ; int charsRead = - 1 ; while ( ( charsRead = reader . read ( charBuff ) ) > - 1 ) { strBuff . append ( charBuff , 0 , charsRead ) ; } } finally { reader . close ( ) ; } return strBuff . toString ( ) ; }
ebayopensource/turmeric-runtime | public static String getFileContents ( String filePath ) throws IOException { FileInputStream fileInStream = new FileInputStream ( filePath ) ; return readContent ( fileInStream ) ; }
ebayopensource/turmeric-runtime | public static void writeToFile ( String destLoc , String fileName , String contents ) throws IOException { Writer fileWriter = null ; try { fileWriter = getFileWriter ( destLoc , fileName ) ; fileWriter . write ( contents ) ; } finally { closeQuietly ( fileWriter ) ; } }
ebayopensource/turmeric-runtime | public static Map < String , String > createNS2PackageMap ( InputOptions inputOptions ) { Map < String , String > ns2PkgMap = new HashMap < String , String > ( ) ; PkgToNSMappingList pkgNsMapList = inputOptions . getPkgNSMappings ( ) ; if ( pkgNsMapList != null && ! pkgNsMapList . getPkgNsMap ( ) . isEmpty ( ) ) { for ( PkgNSMappingType pkgNsMapType : pkgNsMapList . getPkgNsMap ( ) ) { ns2PkgMap . put ( pkgNsMapType . getNamespace ( ) , pkgNsMapType . getPackage ( ) ) ; } } return ns2PkgMap ; }
ebayopensource/turmeric-runtime | public static String getJavaClassName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( idx + 1 ) ; }
ebayopensource/turmeric-runtime | public static String getFolderPathFrompackageName ( String packageName ) { if ( packageName == null ) return null ; packageName = packageName . replace ( ' . ' , File . separatorChar ) ; return toOSFilePath ( packageName ) ; }
ebayopensource/turmeric-runtime | public static File urlToFile ( URL url ) { File file = null ; try { file = new File ( url . toURI ( ) ) ; } catch ( Exception exception ) { file = new File ( url . getPath ( ) ) ; } return file ; }
ebayopensource/turmeric-runtime | public static InputStream getInputStreamForAFileFromClasspath ( String relativeFilePath , ClassLoader parentClassLoader ) { relativeFilePath = relativeFilePath . replace ( " \ \" , " / " ) ; getLogger ( ) . log ( Level . INFO , " call ▁ to ▁ getInputStreamForAFileFromClasspath ▁ for ▁ path ▁ : ▁ " + relativeFilePath ) ; InputStream inStream = null ; if ( parentClassLoader != null ) inStream = parentClassLoader . getResourceAsStream ( relativeFilePath ) ; if ( inStream == null ) { ClassLoader myClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; inStream = myClassLoader . getResourceAsStream ( relativeFilePath ) ; } if ( inStream == null ) inStream = CodeGenUtil . class . getClassLoader ( ) . getResourceAsStream ( relativeFilePath ) ; if ( inStream == null ) getLogger ( ) . log ( Level . WARNING , " Could ▁ not ▁ find ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relativeFilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInputStreamForAFileFromClasspath " ) ; else getLogger ( ) . log ( Level . INFO , " Found ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relativeFilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInputStreamForAFileFromClasspath " ) ; return inStream ; }
ebayopensource/turmeric-runtime | public static File getFileFromInputStream ( InputStream inputStream , String fileExtension ) { FileOutputStream fileOutputStream = null ; File file = null ; try { file = File . createTempFile ( " ebayCodegen " , fileExtension ) ; byte [ ] bytes = new byte [ 10000 ] ; fileOutputStream = new FileOutputStream ( file ) ; int readCount = 0 ; while ( ( readCount = inputStream . read ( bytes ) ) > 0 ) { fileOutputStream . write ( bytes , 0 , readCount ) ; } } catch ( IOException e ) { getLogger ( ) . log ( Level . INFO , " exception ▁ while ▁ trying ▁ to ▁ create ▁ the ▁ tekmp ▁ file ▁ : ▁ exception ▁ is ▁ : ▁ " + e . getMessage ( ) ) ; } finally { if ( fileOutputStream != null ) { try { fileOutputStream . close ( ) ; } catch ( IOException e ) { getLogger ( ) . log ( Level . FINE , " Exception ▁ while ▁ closing ▁ the ▁ file ▁ outut ▁ stream ▁ for ▁ the ▁ file ▁ " ) ; } } } return file ; }
ebayopensource/turmeric-runtime | public static String [ ] getServiceLocations ( Definition wsdlDefinition ) { List < String > locations = new ArrayList < String > ( ) ; Service wsdlService = ( Service ) wsdlDefinition . getServices ( ) . values ( ) . iterator ( ) . next ( ) ; Map < ? , ? > wsdlPorts = wsdlService . getPorts ( ) ; for ( Iterator < ? > it = wsdlPorts . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Port wsdlPort = ( Port ) it . next ( ) ; Iterator < ? > itElements = wsdlPort . getExtensibilityElements ( ) . iterator ( ) ; while ( itElements . hasNext ( ) ) { Object obj = itElements . next ( ) ; String wsdlURI = null ; if ( obj instanceof SOAPAddress ) { SOAPAddress address = ( SOAPAddress ) obj ; wsdlURI = address . getLocationURI ( ) ; } else if ( obj instanceof SOAP12Address ) { SOAP12Address address = ( SOAP12Address ) obj ; wsdlURI = address . getLocationURI ( ) ; } else if ( obj instanceof HTTPAddress ) { HTTPAddress address = ( HTTPAddress ) obj ; wsdlURI = address . getLocationURI ( ) ; } if ( ! isEmptyString ( wsdlURI ) ) locations . add ( wsdlURI ) ; } } String arr [ ] = new String [ locations . size ( ) ] ; locations . toArray ( arr ) ; return arr ; }
VHAINNOVATIONS/Telepathology | public static synchronized ImageExchangeApplicationContext getSingleton ( String [ ] contexts ) { if ( singleton == null && contexts == null ) throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ may ▁ not ▁ be ▁ explicitly ▁ initialized ▁ with ▁ a ▁ null ▁ context . " ) ; if ( singleton != null ) { if ( contexts . length != effectiveApplicationContext . length ) throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ may ▁ not ▁ be ▁ re - initialized ▁ with ▁ a ▁ different ▁ context . " ) ; for ( int index = 0 ; index < contexts . length ; ++ index ) if ( ! contexts [ index ] . equalsIgnoreCase ( effectiveApplicationContext [ index ] ) ) throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ may ▁ not ▁ be ▁ re - initialized ▁ with ▁ a ▁ different ▁ context . " ) ; log . warn ( " ImageExchangeApplicationContext . getSingleton ▁ was ▁ called ▁ twice ▁ with ▁ the ▁ same ▁ context . " ) ; } if ( singleton == null ) { effectiveApplicationContext = contexts ; singleton = new ImageExchangeApplicationContext ( ) ; } return singleton ; }
VHAINNOVATIONS/Telepathology | public static ImageExchangeApplicationContext getSingleton ( ) { if ( singleton == null ) { log . error ( " ImageExchangeApplicationContext ▁ was ▁ not ▁ initialized ▁ when ▁ getSingleton ( ) ▁ was ▁ called . " ) ; throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ was ▁ not ▁ initialized ▁ when ▁ getSingleton ( ) ▁ was ▁ called . " ) ; } return singleton ; }
shigengyu/Hyperion | public static < K , V > ListHashMap < K , V > newListHashMap ( ) { return new ListHashMap < K , V > ( ) ; }
asposemarketplace/Aspose-Pdf-Java | public static void main ( String [ ] args ) throws Exception { String dataDir = " src / programmersguide / workingwithasposepdffacades / workingwithtext / extracttextfromindividualpages / data / " ; com . aspose . pdf . facades . PdfExtractor pdfExtractor = new com . aspose . pdf . facades . PdfExtractor ( ) ; pdfExtractor . bindPdf ( dataDir + " Input1 . pdf " ) ; pdfExtractor . extractText ( ) ; int pageNumber = 1 ; while ( pdfExtractor . hasNextPageText ( ) ) { pdfExtractor . getNextPageText ( dataDir + " output " + pageNumber + " . txt " ) ; pageNumber ++ ; } }
Ossit/SenseBack | public static SensorDbHelper initialize ( Context context ) { if ( dbHelper == null ) { synchronized ( SensorDbHelper . class ) { if ( dbHelper == null ) { dbHelper = new SensorDbHelper ( context ) ; } } } return dbHelper ; }
Ossit/SenseBack | public static SensorDbHelper getInstance ( ) { return dbHelper ; }
Alluxio/alluxio | protected static KodoUnderFileSystem creatInstance ( AlluxioURI uri , UnderFileSystemConfiguration conf ) { String bucketName = UnderFileSystemUtils . getBucketName ( uri ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_ACCESS_KEY ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_ACCESS_KEY ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_SECRET_KEY ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_SECRET_KEY ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_DOWNLOAD_HOST ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_DOWNLOAD_HOST ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_ENDPOINT ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_ENDPOINT ) ; String accessKey = conf . getString ( PropertyKey . KODO_ACCESS_KEY ) ; String secretKey = conf . getString ( PropertyKey . KODO_SECRET_KEY ) ; String endPoint = conf . getString ( PropertyKey . KODO_ENDPOINT ) ; String souceHost = conf . getString ( PropertyKey . KODO_DOWNLOAD_HOST ) ; Auth auth = Auth . create ( accessKey , secretKey ) ; Configuration configuration = new Configuration ( ) ; OkHttpClient . Builder okHttpBuilder = initializeKodoClientConfig ( conf ) ; OkHttpClient okHttpClient = okHttpBuilder . build ( ) ; KodoClient kodoClient = new KodoClient ( auth , bucketName , souceHost , endPoint , configuration , okHttpClient ) ; return new KodoUnderFileSystem ( uri , kodoClient , conf ) ; }
Alluxio/alluxio | private static Builder initializeKodoClientConfig ( UnderFileSystemConfiguration conf ) { OkHttpClient . Builder builder = new OkHttpClient . Builder ( ) ; Dispatcher dispatcher = new Dispatcher ( ) ; dispatcher . setMaxRequests ( conf . getInt ( PropertyKey . UNDERFS_KODO_REQUESTS_MAX ) ) ; builder . connectTimeout ( conf . getMs ( PropertyKey . UNDERFS_KODO_CONNECT_TIMEOUT ) , TimeUnit . SECONDS ) ; return builder ; }
onders86/camel | protected static BraintreeApiName getApiName ( Class < ? extends ApiMethod > apiMethod ) { return BraintreeApiCollection . getCollection ( ) . getApiName ( apiMethod ) ; }
onders86/camel | protected static String getApiNameAsString ( Class < ? extends ApiMethod > apiMethod ) { return getApiName ( apiMethod ) . getName ( ) ; }
EnigmaCurry/cassandra | private static void setScores ( DynamicEndpointSnitch dsnitch , int rounds , List < InetAddress > hosts , Integer ... scores ) throws InterruptedException { for ( int round = 0 ; round < rounds ; round ++ ) { for ( int i = 0 ; i < hosts . size ( ) ; i ++ ) dsnitch . receiveTiming ( hosts . get ( i ) , scores [ i ] ) ; } Thread . sleep ( 150 ) ; }
benchakalaka/DrawingMagic | public static void showWithFontAwesomeImage ( Activity activity , String message , String fatImageString , NotificationType type ) { switch ( type ) { case SUCCESS : SimpleToast . ok ( activity , message , fatImageString ) ; break ; case ERROR : SimpleToast . error ( activity , message , fatImageString ) ; break ; case MUTED : SimpleToast . muted ( activity , message , fatImageString ) ; break ; case WARNING : SimpleToast . warning ( activity , message , fatImageString ) ; break ; case INFO : SimpleToast . info ( activity , message , fatImageString ) ; break ; } }
benchakalaka/DrawingMagic | public static void showMuted ( Activity activity , String message ) { SimpleToast . muted ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showMuted ( Activity activity , int message ) { SimpleToast . muted ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showWarning ( Activity activity , String message ) { SimpleToast . warning ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showWarning ( Activity activity , int message ) { SimpleToast . warning ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showError ( Activity activity , String message ) { SimpleToast . error ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showError ( Activity activity , int message ) { SimpleToast . error ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showSuccess ( Activity activity , String message ) { SimpleToast . ok ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showSuccess ( Activity activity , int message ) { SimpleToast . ok ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showInfo ( Activity activity , String message ) { SimpleToast . info ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showInfo ( Activity activity , int message ) { SimpleToast . info ( activity , activity . getResources ( ) . getString ( message ) ) ; }
osinstom/onos | static PiFieldMatch translateCriterion ( Criterion criterion , PiMatchFieldId fieldId , PiMatchType matchType , int bitWidth ) throws PiTranslationException { if ( ! TRANSLATORS . containsKey ( criterion . getClass ( ) ) ) { throw new PiTranslationException ( format ( " Translation ▁ of ▁ criterion ▁ class ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . getClass ( ) . getSimpleName ( ) ) ) ; } CriterionTranslator translator = TRANSLATORS . get ( criterion . getClass ( ) ) ; try { translator . init ( criterion , bitWidth ) ; switch ( matchType ) { case EXACT : return new PiExactFieldMatch ( fieldId , translator . exactMatch ( ) ) ; case TERNARY : Pair < ImmutableByteSequence , ImmutableByteSequence > tp = translator . ternaryMatch ( ) ; return new PiTernaryFieldMatch ( fieldId , tp . getLeft ( ) , tp . getRight ( ) ) ; case LPM : Pair < ImmutableByteSequence , Integer > lp = translator . lpmMatch ( ) ; return new PiLpmFieldMatch ( fieldId , lp . getLeft ( ) , lp . getRight ( ) ) ; default : throw new PiTranslationException ( format ( " Translation ▁ of ▁ criterion ▁ % s ▁ ( % s ▁ class ) ▁ to ▁ match ▁ type ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . type ( ) . name ( ) , criterion . getClass ( ) . getSimpleName ( ) , matchType . name ( ) ) ) ; } } catch ( ByteSequenceTrimException e ) { throw new PiTranslationException ( format ( " Size ▁ mismatch ▁ for ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } catch ( CriterionTranslatorException e ) { throw new PiTranslationException ( format ( " Unable ▁ to ▁ translate ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } }
Rikkola/drools | private static ProcessRuntimeFactoryService initializeProvider ( ) { return ServiceRegistry . getInstance ( ) . get ( ProcessRuntimeFactoryService . class ) ; }
Rikkola/drools | public static synchronized void reInitializeProvider ( ) { provider = initializeProvider ( ) ; }
Rikkola/drools | public static InternalProcessRuntime newProcessRuntime ( StatefulKnowledgeSessionImpl workingMemory ) { return provider == null ? null : provider . newProcessRuntime ( workingMemory ) ; }
Rikkola/drools | public static void setProcessRuntimeFactoryService ( ProcessRuntimeFactoryService provider ) { ProcessRuntimeFactory . provider = provider ; }
Rikkola/drools | public static ProcessRuntimeFactoryService getProcessRuntimeFactoryService ( ) { return provider ; }
simplaapliko/Trips | public static Intent getCallingIntent ( Context context , long tripId ) { Intent callingIntent = new Intent ( context , TripActivity . class ) ; callingIntent . putExtra ( TRIP_ID_KEY , tripId ) ; return callingIntent ; }
BladeRunnerJS/closure-compiler | public static char toBase64 ( int value ) { assert ( value <= 63 && value >= 0 ) : " value ▁ out ▁ of ▁ range : " + value ; return BASE64_MAP . charAt ( value ) ; }
BladeRunnerJS/closure-compiler | public static int fromBase64 ( char c ) { int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - 1 ) : " invalid ▁ char " ; return BASE64_DECODE_MAP [ c ] ; }
BladeRunnerJS/closure-compiler | public static String base64EncodeInt ( int value ) { char [ ] c = new char [ 6 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { c [ i ] = Base64 . toBase64 ( ( value >> ( 26 - i * 6 ) ) & 0x3f ) ; } c [ 5 ] = Base64 . toBase64 ( ( value << 4 ) & 0x3f ) ; return new String ( c ) ; }
alect/Puzzledice | public static DatabaseModel createModelFromXML ( File xmlFile ) { DatabaseModel model = new DatabaseModel ( ) ; DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; try { DocumentBuilder builder = dbf . newDocumentBuilder ( ) ; Document dom = builder . parse ( xmlFile ) ; Element docElement = dom . getDocumentElement ( ) ; NodeList propertyGroups = docElement . getElementsByTagName ( " Properties " ) ; if ( propertyGroups . getLength ( ) == 0 ) return null ; for ( int i = 0 ; i < propertyGroups . getLength ( ) ; i ++ ) { Element propertyList = ( Element ) propertyGroups . item ( i ) ; NodeList properties = propertyList . getChildNodes ( ) ; for ( int j = 0 ; j < properties . getLength ( ) ; j ++ ) { if ( properties . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element propertyElem = ( Element ) properties . item ( j ) ; DatabaseProperty propertyTemplate = parsePropertyTemplate ( propertyElem ) ; model . addPropertyToDatabase ( propertyTemplate ) ; } } NodeList itemGroups = docElement . getElementsByTagName ( " Items " ) ; if ( itemGroups . getLength ( ) == 0 ) return null ; Map < String , DatabaseItem > itemMap = new HashMap < String , DatabaseItem > ( ) ; for ( int i = 0 ; i < itemGroups . getLength ( ) ; i ++ ) { Element itemList = ( Element ) itemGroups . item ( i ) ; NodeList items = itemList . getChildNodes ( ) ; for ( int j = 0 ; j < items . getLength ( ) ; j ++ ) { if ( items . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element itemElem = ( Element ) items . item ( j ) ; DatabaseItem item = parseItem ( itemElem ) ; model . addItemToDatabase ( item ) ; itemMap . put ( item . getName ( ) , item ) ; } } for ( DatabaseItem item : model . getItemList ( ) ) { item . resolveNamesToItems ( itemMap ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return model ; }
alect/Puzzledice | private static DatabaseItem parseItem ( Element itemElem ) { String itemName = itemElem . getAttribute ( " name " ) ; DatabaseItem item = new DatabaseItem ( itemName ) ; NodeList itemProperties = itemElem . getChildNodes ( ) ; for ( int i = 0 ; i < itemProperties . getLength ( ) ; i ++ ) { if ( itemProperties . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element propertyElem = ( Element ) itemProperties . item ( i ) ; DatabaseProperty property = parseFullProperty ( propertyElem ) ; item . addProperty ( property . getName ( ) , property ) ; } return item ; }
alect/Puzzledice | private static DatabaseProperty parseFullProperty ( Element propertyElem ) { String propertyName = propertyElem . getAttribute ( " name " ) ; DatabaseProperty property ; String propertyType = propertyElem . getTagName ( ) ; if ( propertyType . equals ( " BooleanProperty " ) ) { property = new BooleanDatabaseProperty ( propertyName ) ; boolean value = propertyElem . getAttribute ( " value " ) . equals ( " true " ) ; ( ( BooleanDatabaseProperty ) property ) . setValue ( value ) ; } else if ( propertyType . equals ( " IntegerProperty " ) ) { property = new IntegerDatabaseProperty ( propertyName ) ; int value = Integer . parseInt ( propertyElem . getAttribute ( " value " ) ) ; ( ( IntegerDatabaseProperty ) property ) . setValue ( value ) ; } else if ( propertyType . equals ( " TextProperty " ) ) { property = new TextDatabaseProperty ( propertyName ) ; String text = propertyElem . getAttribute ( " text " ) ; ( ( TextDatabaseProperty ) property ) . setText ( text ) ; } else if ( propertyType . equals ( " ItemListProperty " ) ) { property = new ItemListDatabaseProperty ( propertyName ) ; NodeList itemRefs = propertyElem . getElementsByTagName ( " ItemReference " ) ; for ( int i = 0 ; i < itemRefs . getLength ( ) ; i ++ ) { Element itemRef = ( Element ) itemRefs . item ( i ) ; String itemName = itemRef . getAttribute ( " name " ) ; ( ( ItemListDatabaseProperty ) property ) . addItemName ( itemName ) ; } } else if ( propertyType . equals ( " StringListProperty " ) ) { property = new StringListDatabaseProperty ( propertyName ) ; NodeList stringRefs = propertyElem . getElementsByTagName ( " String " ) ; String [ ] stringList = new String [ stringRefs . getLength ( ) ] ; for ( int i = 0 ; i < stringRefs . getLength ( ) ; i ++ ) { Element stringRef = ( Element ) stringRefs . item ( i ) ; stringList [ i ] = stringRef . getAttribute ( " string " ) ; } ( ( StringListDatabaseProperty ) property ) . setStringList ( stringList ) ; } else if ( propertyType . equals ( " StringPairListProperty " ) ) { property = new StringPairListDatabaseProperty ( propertyName ) ; NodeList pairRefs = propertyElem . getElementsByTagName ( " StringPair " ) ; StringPair [ ] pairList = new StringPair [ pairRefs . getLength ( ) ] ; for ( int i = 0 ; i < pairRefs . getLength ( ) ; i ++ ) { Element pairRef = ( Element ) pairRefs . item ( i ) ; String string1 = pairRef . getAttribute ( " string1" ) ; String string2 = pairRef . getAttribute ( " string2" ) ; pairList [ i ] = new StringPair ( string1 , string2 ) ; } ( ( StringPairListDatabaseProperty ) property ) . setStringPairs ( pairList ) ; } else if ( propertyType . equals ( " CustomProperty " ) ) { NodeList subPropertyElems = propertyElem . getChildNodes ( ) ; List < DatabaseProperty > subProperties = new ArrayList < DatabaseProperty > ( ) ; for ( int i = 0 ; i < subPropertyElems . getLength ( ) ; i ++ ) { if ( subPropertyElems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element subPropertyElem = ( Element ) subPropertyElems . item ( i ) ; subProperties . add ( parseFullProperty ( subPropertyElem ) ) ; } DatabaseProperty [ ] subPropertyArray = new DatabaseProperty [ subProperties . size ( ) ] ; property = new CustomProperty ( propertyName , subProperties . toArray ( subPropertyArray ) ) ; } else property = null ; return property ; }
alect/Puzzledice | private static DatabaseProperty parsePropertyTemplate ( Element propertyElem ) { String propertyName = propertyElem . getAttribute ( " name " ) ; DatabaseProperty property ; String propertyType = propertyElem . getTagName ( ) ; if ( propertyType . equals ( " BooleanProperty " ) ) property = new BooleanDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " IntegerProperty " ) ) property = new IntegerDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " TextProperty " ) ) property = new TextDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " ItemListProperty " ) ) property = new ItemListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " StringListProperty " ) ) property = new StringListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " StringPairListProperty " ) ) property = new StringPairListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " CustomProperty " ) ) { NodeList subPropertyElems = propertyElem . getChildNodes ( ) ; List < DatabaseProperty > subProperties = new ArrayList < DatabaseProperty > ( ) ; for ( int i = 0 ; i < subPropertyElems . getLength ( ) ; i ++ ) { if ( subPropertyElems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element subPropertyElem = ( Element ) subPropertyElems . item ( i ) ; subProperties . add ( parsePropertyTemplate ( subPropertyElem ) ) ; } DatabaseProperty [ ] subPropertyArray = new DatabaseProperty [ subProperties . size ( ) ] ; property = new CustomProperty ( propertyName , subProperties . toArray ( subPropertyArray ) ) ; } else property = null ; return property ; }
dagnir/aws-sdk-java | public static StartLambdaFunctionFailedEventAttributesMarshaller getInstance ( ) { return instance ; }
AlanJinTS/zstack | public static NetworkServiceType valueOf ( String typeName ) { NetworkServiceType type = types . get ( typeName ) ; if ( type == null ) { throw new IllegalArgumentException ( " NetworkServiceType ▁ type : ▁ " + typeName + " ▁ was ▁ not ▁ provided ▁ by ▁ any ▁ NetworkServiceProvider " ) ; } return type ; }
ZhernakovMikhail/fax4j | public static ProcessOutput executeProcess ( ConfigurationHolder configurationHolder , String command ) { String className = configurationHolder . getConfigurationValue ( ProcessExecutor . PROCESS_EXECUTER_class_NAME_PROPERTY_KEY ) ; if ( className == null ) { className = DefaultProcessExecutor . class . getName ( ) ; } ProcessExecutor processExecutor = ProcessExecutorHelper . PROCESS_EXECUTERS . get ( className ) ; if ( processExecutor == null ) { processExecutor = ( ProcessExecutor ) ReflectionHelper . createInstance ( className ) ; ProcessExecutorHelper . PROCESS_EXECUTERS . put ( className , processExecutor ) ; } ProcessOutput processOutput = null ; try { processOutput = processExecutor . executeProcess ( configurationHolder , command ) ; } catch ( RuntimeException exception ) { throw exception ; } catch ( Exception exception ) { throw new FaxException ( " Error ▁ while ▁ invoking ▁ process , ▁ command : ▁ " + command , exception ) ; } return processOutput ; }
AdamPD/drill | public static Schema < DrillServiceInstance > getSchema ( ) { return DEFAULT_INSTANCE ; }
AdamPD/drill | public static DrillServiceInstance getDefaultInstance ( ) { return DEFAULT_INSTANCE ; }
jrbeaumont/workcraft | @ BeforeClass public static void init ( ) { final Framework framework = Framework . getInstance ( ) ; framework . init ( ) ; }
sameyasu/simplejdbc | public static final void open ( String directoryPath ) { String osName = System . getProperty ( " os . name " ) ; System . out . println ( " os . name ▁ = ▁ " + osName ) ; if ( osName != null && osName . startsWith ( " Windows " ) ) { Runtime runtime = Runtime . getRuntime ( ) ; String command = " explorer . exe ▁ " + EXPLORER_OPTION + convPath ( directoryPath ) ; System . out . println ( command ) ; try { runtime . exec ( command ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( " エクスプローラ起動しない 。 " ) ; } }
sameyasu/simplejdbc | private static final String convPath ( String slashPath ) { return " \" " + slashPath . replaceAll ( " \\ / " , " \\ \ \" ) + " \" " ; }
Mikuz/Boarder | public static void init ( Context context ) { settings = context . getSharedPreferences ( GLOBAL_SETTINGS_NAME , 0 ) ; }
Mikuz/Boarder | public static int getFadeInDuration ( ) { return settings . getInt ( GLOBAL_SETTING_FADE_IN_DURATION , 0 ) ; }
Mikuz/Boarder | public static void setFadeInDuration ( int fadeInDuration ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putInt ( GLOBAL_SETTING_FADE_IN_DURATION , fadeInDuration ) ; editor . commit ( ) ; }
Mikuz/Boarder | public static int getFadeOutDuration ( ) { return settings . getInt ( GLOBAL_SETTING_FADE_OUT_DURATION , 0 ) ; }
Mikuz/Boarder | public static void setFadeOutDuration ( int fadeOutDuration ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putInt ( GLOBAL_SETTING_FADE_OUT_DURATION , fadeOutDuration ) ; editor . commit ( ) ; }
Mikuz/Boarder | public static boolean getSensitiveLogging ( ) { return settings . getBoolean ( GLOBAL_SETTING_SENSITIVE_LOGGING , false ) ; }
Mikuz/Boarder | public static void setSensitiveLogging ( boolean sensitiveLogging ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putBoolean ( GLOBAL_SETTING_SENSITIVE_LOGGING , sensitiveLogging ) ; editor . commit ( ) ; }
droolsjbpm/droolsjbpm-integration | @ BeforeClass public static void loadKieContainer ( ) { kieContainer = KIE_SERVICES . newKieContainer ( RELEASE_ID ) ; }
Dooooooooo21/HFUT | public static void addActivity ( Activity activity ) { activities . add ( activity ) ; }
Dooooooooo21/HFUT | public static void removeActivity ( Activity activity ) { activities . remove ( activity ) ; }
Dooooooooo21/HFUT | public static void finishAll ( ) { for ( Activity activity : activities ) { if ( ! activity . isFinishing ( ) ) { activity . finish ( ) ; } } }
yafengguo/Apache-beam | static < T > BoundedSourceShard < T > of ( BoundedSource < T > source ) { return new AutoValue_BoundedReadEvaluatorFactory_BoundedSourceShard < > ( source ) ; }
pac4j/pac4j | public static Authenticator getAuthenticator ( final LdapAuthenticationProperties l ) { if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . AD ) { LOGGER . debug ( " Creating ▁ active ▁ directory ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getActiveDirectoryAuthenticator ( l ) ; } if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . DIRECT ) { LOGGER . debug ( " Creating ▁ direct - bind ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getDirectBindAuthenticator ( l ) ; } if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . SASL ) { LOGGER . debug ( " Creating ▁ SASL ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getSaslAuthenticator ( l ) ; } if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . AUTHENTICATED ) { LOGGER . debug ( " Creating ▁ authenticated ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getAuthenticatedOrAnonSearchAuthenticator ( l ) ; } LOGGER . debug ( " Creating ▁ anonymous ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getAuthenticatedOrAnonSearchAuthenticator ( l ) ; }
pac4j/pac4j | private static Authenticator getSaslAuthenticator ( final LdapAuthenticationProperties l ) { final var resolver = new SearchDnResolver ( ) ; resolver . setBaseDn ( l . getBaseDn ( ) ) ; resolver . setSubtreeSearch ( l . isSubtreeSearch ( ) ) ; resolver . setAllowMultipleDns ( l . isAllowMultipleDns ( ) ) ; resolver . setConnectionFactory ( newPooledConnectionFactory ( l ) ) ; resolver . setUserFilter ( l . getUserFilter ( ) ) ; return new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; }
pac4j/pac4j | private static Authenticator getAuthenticatedOrAnonSearchAuthenticator ( final LdapAuthenticationProperties l ) { final var resolver = new SearchDnResolver ( ) ; resolver . setBaseDn ( l . getBaseDn ( ) ) ; resolver . setSubtreeSearch ( l . isSubtreeSearch ( ) ) ; resolver . setAllowMultipleDns ( l . isAllowMultipleDns ( ) ) ; resolver . setConnectionFactory ( newPooledConnectionFactory ( l ) ) ; resolver . setUserFilter ( l . getUserFilter ( ) ) ; final Authenticator auth ; if ( CommonHelper . isBlank ( l . getPrincipalAttributePassword ( ) ) ) { auth = new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; } else { auth = new Authenticator ( resolver , getPooledCompareAuthenticationHandler ( l ) ) ; } if ( l . isEnhanceWithEntryResolver ( ) ) { auth . setEntryResolver ( newSearchEntryResolver ( l ) ) ; } return auth ; }
pac4j/pac4j | private static Authenticator getDirectBindAuthenticator ( final LdapAuthenticationProperties l ) { if ( CommonHelper . isBlank ( l . getDnFormat ( ) ) ) { throw new IllegalArgumentException ( " Dn ▁ format ▁ cannot ▁ be ▁ empty / blank ▁ for ▁ direct ▁ bind ▁ authentication " ) ; } final var resolver = new FormatDnResolver ( l . getDnFormat ( ) ) ; final var authenticator = new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; if ( l . isEnhanceWithEntryResolver ( ) ) { authenticator . setEntryResolver ( newSearchEntryResolver ( l ) ) ; } return authenticator ; }
pac4j/pac4j | private static Authenticator getActiveDirectoryAuthenticator ( final LdapAuthenticationProperties l ) { if ( CommonHelper . isBlank ( l . getDnFormat ( ) ) ) { throw new IllegalArgumentException ( " Dn ▁ format ▁ cannot ▁ be ▁ empty / blank ▁ for ▁ active ▁ directory ▁ authentication " ) ; } final var resolver = new FormatDnResolver ( l . getDnFormat ( ) ) ; final var authn = new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; if ( l . isEnhanceWithEntryResolver ( ) ) { authn . setEntryResolver ( newSearchEntryResolver ( l ) ) ; } return authn ; }
pac4j/pac4j | private static SimpleBindAuthenticationHandler getPooledBindAuthenticationHandler ( final LdapAuthenticationProperties l ) { final var handler = new SimpleBindAuthenticationHandler ( newPooledConnectionFactory ( l ) ) ; handler . setAuthenticationControls ( new PasswordPolicyControl ( ) ) ; return handler ; }
pac4j/pac4j | private static CompareAuthenticationHandler getPooledCompareAuthenticationHandler ( final LdapAuthenticationProperties l ) { final var handler = new CompareAuthenticationHandler ( newPooledConnectionFactory ( l ) ) ; handler . setPasswordAttribute ( l . getPrincipalAttributePassword ( ) ) ; return handler ; }
pac4j/pac4j | public static EntryResolver newSearchEntryResolver ( final LdapAuthenticationProperties l ) { final var entryResolver = new SearchEntryResolver ( ) ; entryResolver . setBaseDn ( l . getBaseDn ( ) ) ; entryResolver . setUserFilter ( l . getUserFilter ( ) ) ; entryResolver . setSubtreeSearch ( l . isSubtreeSearch ( ) ) ; entryResolver . setConnectionFactory ( LdaptiveAuthenticatorBuilder . newPooledConnectionFactory ( l ) ) ; return entryResolver ; }
pac4j/pac4j | public static ConnectionConfig newConnectionConfig ( final AbstractLdapProperties l ) { final var cc = new ConnectionConfig ( ) ; final var urls = Arrays . stream ( l . getLdapUrl ( ) . split ( " , " ) ) . collect ( Collectors . joining ( " ▁ " ) ) ; LOGGER . debug ( " Transformed ▁ LDAP ▁ urls ▁ from ▁ [ { } ] ▁ to ▁ [ { } ] " , l . getLdapUrl ( ) , urls ) ; cc . setLdapUrl ( urls ) ; cc . setUseStartTLS ( l . isUseStartTls ( ) ) ; cc . setConnectTimeout ( newDuration ( l . getConnectTimeout ( ) ) ) ; if ( l . getTrustCertificates ( ) != null ) { final var cfg = new X509CredentialConfig ( ) ; cfg . setTrustCertificates ( l . getTrustCertificates ( ) ) ; cc . setSslConfig ( new SslConfig ( cfg ) ) ; } else if ( l . getKeystore ( ) != null ) { final var cfg = new KeyStoreCredentialConfig ( ) ; cfg . setKeyStore ( l . getKeystore ( ) ) ; cfg . setKeyStorePassword ( l . getKeystorePassword ( ) ) ; cfg . setKeyStoreType ( l . getKeystoreType ( ) ) ; cc . setSslConfig ( new SslConfig ( cfg ) ) ; } else { cc . setSslConfig ( new SslConfig ( ) ) ; } if ( l . getSaslMechanism ( ) != null ) { final var bc = new BindConnectionInitializer ( ) ; final SaslConfig sc ; switch ( l . getSaslMechanism ( ) ) { case DIGEST_MD5 : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . DIGEST_MD5 ) . realm ( l . getSaslRealm ( ) ) . build ( ) ; break ; case CRAM_MD5 : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . CRAM_MD5 ) . build ( ) ; break ; case EXTERNAL : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . EXTERNAL ) . build ( ) ; break ; case GSSAPI : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . GSSAPI ) . realm ( l . getSaslRealm ( ) ) . build ( ) ; break ; default : throw new IllegalArgumentException ( " Unknown ▁ SASL ▁ mechanism ▁ " + l . getSaslMechanism ( ) . name ( ) ) ; } sc . setAuthorizationId ( l . getSaslAuthorizationId ( ) ) ; sc . setMutualAuthentication ( l . getSaslMutualAuth ( ) ) ; sc . setQualityOfProtection ( l . getSaslQualityOfProtection ( ) ) ; sc . setSecurityStrength ( l . getSaslSecurityStrength ( ) ) ; bc . setBindSaslConfig ( sc ) ; cc . setConnectionInitializers ( bc ) ; } else if ( CommonHelper . areEquals ( l . getBindCredential ( ) , " * " ) && CommonHelper . areEquals ( l . getBindDn ( ) , " * " ) ) { cc . setConnectionInitializers ( new FastBindConnectionInitializer ( ) ) ; } else if ( CommonHelper . isNotBlank ( l . getBindDn ( ) ) && CommonHelper . isNotBlank ( l . getBindCredential ( ) ) ) { cc . setConnectionInitializers ( new BindConnectionInitializer ( l . getBindDn ( ) , new Credential ( l . getBindCredential ( ) ) ) ) ; } return cc ; }
pac4j/pac4j | public static PooledConnectionFactory newPooledConnectionFactory ( final AbstractLdapProperties l ) { final var cc = newConnectionConfig ( l ) ; final var cf = new PooledConnectionFactory ( cc ) ; cf . setBlockWaitTime ( newDuration ( l . getBlockWaitTime ( ) ) ) ; cf . setMinPoolSize ( l . getMinPoolSize ( ) ) ; cf . setMaxPoolSize ( l . getMaxPoolSize ( ) ) ; cf . setValidateOnCheckOut ( l . isValidateOnCheckout ( ) ) ; cf . setValidatePeriodically ( l . isValidatePeriodically ( ) ) ; final var strategy = new IdlePruneStrategy ( ) ; strategy . setIdleTime ( newDuration ( l . getIdleTime ( ) ) ) ; strategy . setPrunePeriod ( newDuration ( l . getPrunePeriod ( ) ) ) ; cf . setPruneStrategy ( strategy ) ; cf . setFailFastInitialize ( l . isFailFast ( ) ) ; final var validator = new SearchConnectionValidator ( ) ; validator . setValidatePeriod ( newDuration ( l . getValidatePeriod ( ) ) ) ; cf . setValidator ( validator ) ; if ( CommonHelper . isNotBlank ( l . getPoolPassivator ( ) ) ) { final var pass = AbstractLdapProperties . LdapConnectionPoolPassivator . valueOf ( l . getPoolPassivator ( ) . toUpperCase ( ) ) ; switch ( pass ) { case CLOSE : cf . setPassivator ( conn -> { conn . close ( ) ; return true ; } ) ; break ; case BIND : LOGGER . debug ( " Creating ▁ a ▁ bind ▁ passivator ▁ instance ▁ for ▁ the ▁ connection ▁ pool " ) ; final var bindRequest = new SimpleBindRequest ( l . getBindDn ( ) , new Credential ( l . getBindCredential ( ) ) ) ; cf . setPassivator ( new BindConnectionPassivator ( bindRequest ) ) ; break ; default : break ; } } LOGGER . debug ( " Initializing ▁ ldap ▁ connection ▁ pool ▁ for ▁ { } ▁ and ▁ bindDn ▁ { } " , l . getLdapUrl ( ) , l . getBindDn ( ) ) ; cf . initialize ( ) ; return cf ; }
pac4j/pac4j | public static Duration newDuration ( final long length ) { return Duration . ofSeconds ( length ) ; }
pac4j/pac4j | public static SearchRequest newSearchRequest ( final String baseDn , final FilterTemplate filter ) { final var sr = new SearchRequest ( baseDn , filter ) ; sr . setReturnAttributes ( ReturnAttributes . ALL_USER . value ( ) ) ; sr . setSearchScope ( SearchScope . SUBTREE ) ; return sr ; }
pac4j/pac4j | public static FilterTemplate newSearchFilter ( final String filterQuery , final String ... params ) { final var filter = new FilterTemplate ( ) ; filter . setFilter ( filterQuery ) ; if ( params != null ) { for ( var i = 0 ; i < params . length ; i ++ ) { if ( filter . getFilter ( ) . contains ( " { " + i + " } " ) ) { filter . setParameter ( i , params [ i ] ) ; } else { filter . setParameter ( " user " , params [ i ] ) ; } } } LOGGER . debug ( " Constructed ▁ LDAP ▁ search ▁ filter ▁ [ { } ] " , filter . format ( ) ) ; return filter ; }
pac4j/pac4j | public static SearchOperation newSearchOperation ( final String baseDn , final String filterQuery , final String ... params ) { final var operation = new SearchOperation ( ) ; operation . setRequest ( SearchRequest . builder ( ) . dn ( baseDn ) . filter ( newSearchFilter ( filterQuery , params ) ) . returnAttributes ( ReturnAttributes . ALL . value ( ) ) . scope ( SearchScope . SUBTREE ) . build ( ) ) ; return operation ; }
Xylus/pinpoint | private static byte [ ] checkBytes ( byte [ ] bytes ) { if ( bytes == null ) { throw new NullPointerException ( " bytes " ) ; } return bytes ; }
Scottmitch/netty | static void runInChannel ( Channel channel , final Http2Runnable runnable ) { channel . eventLoop ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Http2Exception e ) { throw new RuntimeException ( e ) ; } } } ) ; }
Scottmitch/netty | public static byte [ ] randomBytes ( ) { return randomBytes ( 100 ) ; }
Scottmitch/netty | public static byte [ ] randomBytes ( int size ) { byte [ ] data = new byte [ size ] ; new Random ( ) . nextBytes ( data ) ; return data ; }
Scottmitch/netty | public static AsciiString randomString ( ) { return new AsciiString ( randomBytes ( ) ) ; }
Scottmitch/netty | public static CharSequence of ( String s ) { return s ; }
Scottmitch/netty | public static Http2Stream getOrCreateStream ( Http2Connection connection , int streamId , boolean halfClosed ) throws Http2Exception { if ( connection != null ) { Http2Stream stream = connection . stream ( streamId ) ; if ( stream == null ) { if ( connection . isServer ( ) && streamId % 2 == 0 || ! connection . isServer ( ) && streamId % 2 != 0 ) { stream = connection . local ( ) . createStream ( streamId , halfClosed ) ; } else { stream = connection . remote ( ) . createStream ( streamId , halfClosed ) ; } } return stream ; } return null ; }
hovsepm/azure-sdk-for-java | private static void validateMultiCreation ( String database2Name , String database1InEPName , String database2InEPName , String elasticPool1Name , String elasticPool2Name , String elasticPool3Name , SqlServer sqlServer , boolean deleteUsingUpdate ) { validateSqlServer ( sqlServer ) ; validateSqlServer ( sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ) ; validateSqlDatabase ( sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) , SQL_DATABASE_NAME ) ; validateSqlFirewallRule ( sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) , SQL_FIREWALLRULE_NAME ) ; List < SqlFirewallRule > firewalls = sqlServer . firewallRules ( ) . list ( ) ; Assert . assertEquals ( 3 , firewalls . size ( ) ) ; int startIPAddress = 0 ; int endIPAddress = 0 ; for ( SqlFirewallRule firewall : firewalls ) { if ( ! firewall . name ( ) . equalsIgnoreCase ( SQL_FIREWALLRULE_NAME ) ) { Assert . assertEquals ( firewall . startIPAddress ( ) , START_IPADDRESS ) ; if ( firewall . endIPAddress ( ) . equalsIgnoreCase ( START_IPADDRESS ) ) { startIPAddress ++ ; } else if ( firewall . endIPAddress ( ) . equalsIgnoreCase ( END_IPADDRESS ) ) { endIPAddress ++ ; } } } Assert . assertEquals ( startIPAddress , 1 ) ; Assert . assertEquals ( endIPAddress , 1 ) ; Assert . assertNotNull ( sqlServer . databases ( ) . get ( database2Name ) ) ; Assert . assertNotNull ( sqlServer . databases ( ) . get ( database1InEPName ) ) ; Assert . assertNotNull ( sqlServer . databases ( ) . get ( database2InEPName ) ) ; SqlElasticPool ep1 = sqlServer . elasticPools ( ) . get ( elasticPool1Name ) ; validateSqlElasticPool ( ep1 , elasticPool1Name ) ; SqlElasticPool ep2 = sqlServer . elasticPools ( ) . get ( elasticPool2Name ) ; Assert . assertNotNull ( ep2 ) ; Assert . assertEquals ( ep2 . edition ( ) , ElasticPoolEditions . PREMIUM ) ; Assert . assertEquals ( ep2 . listDatabases ( ) . size ( ) , 2 ) ; Assert . assertNotNull ( ep2 . getDatabase ( database1InEPName ) ) ; Assert . assertNotNull ( ep2 . getDatabase ( database2InEPName ) ) ; SqlElasticPool ep3 = sqlServer . elasticPools ( ) . get ( elasticPool3Name ) ; Assert . assertNotNull ( ep3 ) ; Assert . assertEquals ( ep3 . edition ( ) , ElasticPoolEditions . STANDARD ) ; if ( ! deleteUsingUpdate ) { sqlServer . databases ( ) . delete ( database2Name ) ; sqlServer . databases ( ) . delete ( database1InEPName ) ; sqlServer . databases ( ) . delete ( database2InEPName ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( ep1 . listDatabases ( ) . size ( ) , 0 ) ; Assert . assertEquals ( ep2 . listDatabases ( ) . size ( ) , 0 ) ; Assert . assertEquals ( ep3 . listDatabases ( ) . size ( ) , 0 ) ; sqlServer . elasticPools ( ) . delete ( elasticPool1Name ) ; sqlServer . elasticPools ( ) . delete ( elasticPool2Name ) ; sqlServer . elasticPools ( ) . delete ( elasticPool3Name ) ; firewalls = sqlServer . firewallRules ( ) . list ( ) ; for ( SqlFirewallRule firewallRule : firewalls ) { firewallRule . delete ( ) ; } } else { sqlServer . update ( ) . withoutDatabase ( database2Name ) . withoutElasticPool ( elasticPool1Name ) . withoutElasticPool ( elasticPool2Name ) . withoutElasticPool ( elasticPool3Name ) . withoutElasticPool ( elasticPool1Name ) . withoutDatabase ( database1InEPName ) . withoutDatabase ( SQL_DATABASE_NAME ) . withoutDatabase ( database2InEPName ) . withoutFirewallRule ( SQL_FIREWALLRULE_NAME ) . apply ( ) ; Assert . assertEquals ( sqlServer . elasticPools ( ) . list ( ) . size ( ) , 0 ) ; firewalls = sqlServer . firewallRules ( ) . list ( ) ; Assert . assertEquals ( firewalls . size ( ) , 2 ) ; for ( SqlFirewallRule firewallRule : firewalls ) { firewallRule . delete ( ) ; } } Assert . assertEquals ( sqlServer . elasticPools ( ) . list ( ) . size ( ) , 0 ) ; Assert . assertEquals ( sqlServer . databases ( ) . list ( ) . size ( ) , 1 ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlFirewallRuleNotFound ( ) { Assert . assertNull ( sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlElasticPoolNotFound ( SqlServer sqlServer , String elasticPoolName ) { Assert . assertNull ( sqlServer . elasticPools ( ) . get ( elasticPoolName ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlDatabaseNotFound ( String newDatabase ) { Assert . assertNull ( sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) . databases ( ) . get ( newDatabase ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlServerNotFound ( SqlServer sqlServer ) { Assert . assertNull ( sqlServerManager . sqlServers ( ) . getById ( sqlServer . id ( ) ) ) ; }
hovsepm/azure-sdk-for-java | private static SqlServer createSqlServer ( ) { return createSqlServer ( SQL_SERVER_NAME ) ; }
hovsepm/azure-sdk-for-java | private static SqlServer createSqlServer ( String SQL_SERVER_NAME ) { return sqlServerManager . sqlServers ( ) . define ( SQL_SERVER_NAME ) . withRegion ( Region . US_CENTRAL ) . withNewResourceGroup ( RG_NAME ) . withAdministratorLogin ( " userName " ) . withAdministratorPassword ( " P @ ssword ~ 1" ) . create ( ) ; }
hovsepm/azure-sdk-for-java | private static void validateListSqlFirewallRule ( List < SqlFirewallRule > sqlFirewallRules ) { boolean found = false ; for ( SqlFirewallRule firewallRule : sqlFirewallRules ) { if ( firewallRule . name ( ) . equals ( SQL_FIREWALLRULE_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlFirewallRule ( SqlFirewallRule sqlFirewallRule , String firewallName ) { Assert . assertNotNull ( sqlFirewallRule ) ; Assert . assertEquals ( firewallName , sqlFirewallRule . name ( ) ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlFirewallRule . sqlServerName ( ) ) ; Assert . assertEquals ( START_IPADDRESS , sqlFirewallRule . startIPAddress ( ) ) ; Assert . assertEquals ( END_IPADDRESS , sqlFirewallRule . endIPAddress ( ) ) ; Assert . assertEquals ( RG_NAME , sqlFirewallRule . resourceGroupName ( ) ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlFirewallRule . sqlServerName ( ) ) ; Assert . assertEquals ( Region . US_CENTRAL , sqlFirewallRule . region ( ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateListSqlElasticPool ( List < SqlElasticPool > sqlElasticPools ) { boolean found = false ; for ( SqlElasticPool elasticPool : sqlElasticPools ) { if ( elasticPool . name ( ) . equals ( SQL_ELASTIC_POOL_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlElasticPool ( SqlElasticPool sqlElasticPool ) { validateSqlElasticPool ( sqlElasticPool , SQL_ELASTIC_POOL_NAME ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlElasticPool ( SqlElasticPool sqlElasticPool , String elasticPoolName ) { Assert . assertNotNull ( sqlElasticPool ) ; Assert . assertEquals ( RG_NAME , sqlElasticPool . resourceGroupName ( ) ) ; Assert . assertEquals ( elasticPoolName , sqlElasticPool . name ( ) ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlElasticPool . sqlServerName ( ) ) ; Assert . assertEquals ( ElasticPoolEditions . STANDARD , sqlElasticPool . edition ( ) ) ; Assert . assertNotNull ( sqlElasticPool . creationDate ( ) ) ; Assert . assertNotEquals ( 0 , sqlElasticPool . databaseDtuMax ( ) ) ; Assert . assertNotEquals ( 0 , sqlElasticPool . dtu ( ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateListSqlDatabase ( List < SqlDatabase > sqlDatabases ) { boolean found = false ; for ( SqlDatabase database : sqlDatabases ) { if ( database . name ( ) . equals ( SQL_DATABASE_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlServer ( SqlServer sqlServer ) { Assert . assertNotNull ( sqlServer ) ; Assert . assertEquals ( RG_NAME , sqlServer . resourceGroupName ( ) ) ; Assert . assertNotNull ( sqlServer . fullyQualifiedDomainName ( ) ) ; Assert . assertEquals ( ServerVersion . ONE_TWO_FULL_STOP_ZERO , sqlServer . version ( ) ) ; Assert . assertEquals ( " userName " , sqlServer . administratorLogin ( ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlDatabase ( SqlDatabase sqlDatabase , String databaseName ) { Assert . assertNotNull ( sqlDatabase ) ; Assert . assertEquals ( sqlDatabase . name ( ) , databaseName ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlDatabase . sqlServerName ( ) ) ; Assert . assertEquals ( sqlDatabase . collation ( ) , COLLATION ) ; Assert . assertEquals ( sqlDatabase . edition ( ) , DatabaseEditions . STANDARD ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlDatabaseWithElasticPool ( SqlDatabase sqlDatabase , String databaseName ) { validateSqlDatabase ( sqlDatabase , databaseName ) ; Assert . assertEquals ( SQL_ELASTIC_POOL_NAME , sqlDatabase . elasticPoolName ( ) ) ; }
hazendaz/assertj-core | private static boolean [ ] toPrimitiveBooleanArray ( Boolean [ ] values ) { boolean [ ] booleans = new boolean [ values . length ] ; range ( 0 , values . length ) . forEach ( i -> booleans [ i ] = values [ i ] ) ; return booleans ; }
anilgursel/squbs | static Optional < SSLContext > sslContext ( String store , String pw ) { try { char [ ] password = pw . toCharArray ( ) ; KeyStore ks = KeyStore . getInstance ( " JKS " ) ; InputStream keystore = ClientFlowHttpsTest . class . getClassLoader ( ) . getResourceAsStream ( " ClientFlowHttpsSpec / " + store ) ; assert keystore != null ; ks . load ( keystore , password ) ; KeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( " SunX509" ) ; keyManagerFactory . init ( ks , password ) ; TrustManagerFactory tmf = TrustManagerFactory . getInstance ( " SunX509" ) ; tmf . init ( ks ) ; SSLContext sslContext = SSLContext . getInstance ( " TLS " ) ; sslContext . init ( keyManagerFactory . getKeyManagers ( ) , tmf . getTrustManagers ( ) , new SecureRandom ( ) ) ; return Optional . of ( sslContext ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return Optional . empty ( ) ; } }
anilgursel/squbs | @ AfterClass public static void afterAll ( ) { serverBinding . unbind ( ) . thenAccept ( u -> system . terminate ( ) ) ; }
intrack/BoofCV-master | public static void main ( String args [ ] ) { ShowLensDistortion < ImageUInt8 > app = new ShowLensDistortion < ImageUInt8 > ( ImageUInt8 . class ) ; List < PathLabel > inputs = new ArrayList < PathLabel > ( ) ; inputs . add ( new PathLabel ( " shapes " , " . . / data / evaluation / shapes01 . png " ) ) ; inputs . add ( new PathLabel ( " beach " , " . . / data / evaluation / scale / beach02 . jpg " ) ) ; inputs . add ( new PathLabel ( " sunflowers " , " . . / data / evaluation / sunflowers . png " ) ) ; app . setInputList ( inputs ) ; while ( ! app . getHasProcessedImage ( ) ) { Thread . yield ( ) ; } ShowImages . showWindow ( app , " Lens ▁ Distortion " ) ; }
ivakegg/accumulo | @ Parameters public static Object [ ] [ ] parameters ( ) { IteratorTestInput input = getIteratorInput ( ) ; IteratorTestOutput output = getIteratorOutput ( ) ; List < IteratorTestCase > tests = IteratorTestCaseFinder . findAllTestCases ( ) ; return BaseJUnit4IteratorTest . createParameters ( input , output , tests ) ; }
ivakegg/accumulo | private static TreeMap < Key , Value > createInputData ( ) { TreeMap < Key , Value > data = new TreeMap < > ( ) ; data . put ( new Key ( "1" , " a " , " a " , 1 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " a " , 5 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " a " , 10 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " b " , 1 ) , new Value ( bytes ( "5" ) ) ) ; data . put ( new Key ( "1" , " a " , " b " , 5 ) , new Value ( bytes ( "2" ) ) ) ; data . put ( new Key ( "1" , " a " , " f " , 1 ) , new Value ( bytes ( "0" ) ) ) ; data . put ( new Key ( "1" , " a " , " g " , 5 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " g " , 10 ) , new Value ( bytes ( " - 11" ) ) ) ; data . put ( new Key ( "1" , " b " , " d " , 10 ) , new Value ( bytes ( " - 5" ) ) ) ; data . put ( new Key ( "1" , " b " , " e " , 10 ) , new Value ( bytes ( Long . toString ( Long . MAX_VALUE ) ) ) ) ; data . put ( new Key ( "1" , " d " , " d " , 10 ) , new Value ( bytes ( Long . toString ( Long . MIN_VALUE ) ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 1 ) , new Value ( bytes ( "5" ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 5 ) , new Value ( bytes ( "10" ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 10 ) , new Value ( bytes ( "15" ) ) ) ; return data ; }
ivakegg/accumulo | private static final byte [ ] bytes ( String value ) { return requireNonNull ( value ) . getBytes ( UTF_8 ) ; }
ivakegg/accumulo | private static TreeMap < Key , Value > createOutputData ( ) { TreeMap < Key , Value > data = new TreeMap < > ( ) ; Key lastKey = null ; long sum = 0 ; for ( Entry < Key , Value > entry : INPUT_DATA . entrySet ( ) ) { if ( null == lastKey ) { lastKey = entry . getKey ( ) ; sum += Long . parseLong ( entry . getValue ( ) . toString ( ) ) ; } else { if ( 0 != lastKey . compareTo ( entry . getKey ( ) , PartialKey . ROW_COLFAM_COLQUAL_COLVIS ) ) { data . put ( lastKey , new Value ( Long . toString ( sum ) ) ) ; lastKey = entry . getKey ( ) ; sum = 0 ; } sum += Long . parseLong ( entry . getValue ( ) . toString ( ) ) ; } } data . put ( lastKey , new Value ( Long . toString ( sum ) ) ) ; return data ; }
ivakegg/accumulo | private static IteratorTestInput getIteratorInput ( ) { IteratorSetting setting = new IteratorSetting ( 50 , SummingCombiner . class ) ; LongCombiner . setEncodingType ( setting , LongCombiner . Type . STRING ) ; Combiner . setCombineAllColumns ( setting , true ) ; return new IteratorTestInput ( SummingCombiner . class , setting . getOptions ( ) , new Range ( ) , INPUT_DATA ) ; }
ivakegg/accumulo | private static IteratorTestOutput getIteratorOutput ( ) { return new IteratorTestOutput ( OUTPUT_DATA ) ; }
mingjian2049/zstack | public static void generateDocTemplate ( String path , DocumentGenerator . DocMode mode ) { DocumentGenerator rg = GroovyUtils . newInstance ( " scripts / RestDocumentationGenerator . groovy " ) ; rg . generateDocTemplates ( path , mode ) ; }
mingjian2049/zstack | public static void generateMarkdownDoc ( String path ) { DocumentGenerator rg = GroovyUtils . newInstance ( " scripts / RestDocumentationGenerator . groovy " ) ; rg . generateMarkDown ( path , PathUtil . join ( System . getProperty ( " user . home " ) , " zstack - markdown " ) ) ; }
mingjian2049/zstack | public static void generateJavaSdk ( ) { String path = PathUtil . join ( System . getProperty ( " user . home " ) , " zstack - sdk / java " ) ; File folder = new File ( path ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } try { Class clz = GroovyUtils . getClass ( " scripts / SdkApiTemplate . groovy " , RestServer . class . getClassLoader ( ) ) ; Set < Class < ? > > apiClasses = Platform . getReflections ( ) . getTypesAnnotatedWith ( RestRequest . class ) . stream ( ) . filter ( it -> it . isAnnotationPresent ( RestRequest . class ) ) . collect ( Collectors . toSet ( ) ) ; List < SdkFile > allFiles = new ArrayList < > ( ) ; for ( Class apiClz : apiClasses ) { if ( Modifier . isAbstract ( apiClz . getModifiers ( ) ) ) { continue ; } SdkTemplate tmp = ( SdkTemplate ) clz . getConstructor ( Class . class ) . newInstance ( apiClz ) ; allFiles . addAll ( tmp . generate ( ) ) ; } SdkTemplate tmp = GroovyUtils . newInstance ( " scripts / SdkDataStructureGenerator . groovy " , RestServer . class . getClassLoader ( ) ) ; allFiles . addAll ( tmp . generate ( ) ) ; for ( SdkFile f : allFiles ) { String fpath = PathUtil . join ( path , f . getFileName ( ) ) ; FileUtils . writeStringToFile ( new File ( fpath ) , f . getContent ( ) ) ; } } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; throw new CloudRuntimeException ( e ) ; } }
PG85/OpenTerrainGenerator | static PlottedChunksRegion getFilledRegion ( ) { boolean [ ] [ ] plottedChunks = new boolean [ Constants . REGION_SIZE ] [ Constants . REGION_SIZE ] ; for ( int i = 0 ; i < Constants . REGION_SIZE ; i ++ ) { Arrays . fill ( plottedChunks [ i ] , true ) ; } return new PlottedChunksRegion ( plottedChunks ) ; }
vam-google/google-cloud-java | public static void main ( String args [ ] ) { Logger . getLogger ( " " ) . setLevel ( Level . WARNING ) ; try { executeNoCatch ( getProjectId ( ) ) ; System . out . println ( " OK " ) ; } catch ( Exception e ) { System . err . println ( " Failed ▁ with ▁ exception : " ) ; e . printStackTrace ( System . err ) ; System . exit ( 1 ) ; } }
vam-google/google-cloud-java | public static void executeNoCatch ( String projectId ) throws Exception { try ( ClusterControllerClient client = ClusterControllerClient . create ( ) ) { String projectId2 = projectId ; String region = " global " ; ListClustersPagedResponse pagedResponse = client . listClusters ( projectId2 , region ) ; } }
vam-google/google-cloud-java | private static String getProjectId ( ) { String projectId = System . getProperty ( PROJECT_ENV_NAME , System . getenv ( PROJECT_ENV_NAME ) ) ; if ( projectId == null ) { projectId = System . getProperty ( LEGACY_PROJECT_ENV_NAME , System . getenv ( LEGACY_PROJECT_ENV_NAME ) ) ; } Preconditions . checkArgument ( projectId != null , " A ▁ project ▁ ID ▁ is ▁ required . " ) ; return projectId ; }
suntion/suns_build | private static final byte [ ] getByteKey ( Serializable sessionId ) { String keys = ConstantsShiro . SHIRO_CACHE_SESSION + " : " + sessionId . toString ( ) ; return keys . getBytes ( ) ; }
suntion/suns_build | private static final String getStringKey ( byte [ ] keyByte ) { try { return new String ( keyByte , " UTF - 8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return null ; }
suntion/suns_build | private static final String getHourMinuteSecend ( long l ) { long secend = l / 1000 ; long hour = secend / 3600 ; long minute = ( secend - ( 3600 * hour ) ) / 60 ; secend = secend - ( hour * 60 * 60 ) - ( minute * 60 ) ; return " [ ▁ " + hour + " ▁ hour , ▁ " + minute + " ▁ minute , ▁ " + secend + " ▁ secend ▁ ] " ; }
thorinii/PacAndroid | public static Level makeBlankLevel ( ) { Level l = new Level ( ) ; fillGrid ( l . getGrid ( ) , Grid . GRID_WALL ) ; return l ; }
thorinii/PacAndroid | private static void fillGrid ( Grid g , int type ) { for ( int i = 0 ; i < g . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < g . getHeight ( ) ; j ++ ) { g . set ( i , j , type ) ; } } }
glameyzhou/training | public static void main ( String [ ] args ) { TreeNode tree = generate ( ) ; int [ ] postOrder = getPostOrder ( tree ) ; boolean verifyBSTPostOrder = verifyBSTPostOrder ( postOrder ) ; System . out . println ( verifyBSTPostOrder ) ; }
glameyzhou/training | private static TreeNode generate ( ) { TreeNode t6 = new TreeNode ( 6 ) ; TreeNode t9 = new TreeNode ( 9 ) ; TreeNode t8 = new TreeNode ( 8 ) ; t8 . left = t6 ; t8 . right = t9 ; TreeNode t13 = new TreeNode ( 13 ) ; TreeNode t11 = new TreeNode ( 11 ) ; t11 . right = t13 ; TreeNode root = new TreeNode ( 10 ) ; root . left = t8 ; root . right = t11 ; return root ; }
glameyzhou/training | private static int [ ] getPostOrder ( TreeNode root ) { List < Integer > list = new ArrayList < > ( ) ; getPostOrderByRecursion ( root , list ) ; return list . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; }
glameyzhou/training | private static void getPostOrderByRecursion ( TreeNode root , List < Integer > list ) { if ( root == null ) { return ; } getPostOrderByRecursion ( root . left , list ) ; getPostOrderByRecursion ( root . right , list ) ; list . add ( root . val ) ; }
glameyzhou/training | private static boolean verifyBSTPostOrder ( int [ ] nums ) { if ( nums == null || nums . length == 0 ) { return false ; } if ( nums . length == 1 ) { return true ; } return process ( nums , 0 , nums . length - 1 ) ; }
glameyzhou/training | private static boolean process ( int [ ] nums , int start , int end ) { if ( start >= end ) { return true ; } int rootVal = nums [ end ] ; int i = start ; while ( nums [ i ] < rootVal ) { i ++ ; } int j = end - 1 ; while ( nums [ j ] > rootVal ) { j ++ ; } return process ( nums , start , i - 1 ) && process ( nums , j , end - 1 ) ; }
BadWaka/SmallDianPing | public static void init ( Context context ) { if ( cameraManager == null ) { cameraManager = new CameraManager ( context ) ; } }
BadWaka/SmallDianPing | public static CameraManager get ( ) { return cameraManager ; }
lwd1815/Transition | public static FourFragment getInstance ( ) { FourFragment fragment = new FourFragment ( ) ; Bundle args = new Bundle ( ) ; fragment . setArguments ( args ) ; return fragment ; }
artem-aliev/tinkerpop | private static GraphTraversal < Vertex , Long > getTraversalWithLambda ( final GraphTraversalSource g ) { assumeThat ( " This ▁ test ▁ is ▁ not ▁ enabled ▁ for ▁ this ▁ ScriptEngine : ▁ " + ENGINE_TO_TEST , ENGINE_TO_TEST , anyOf ( is ( " gremlin - python " ) , is ( " gremlin - jython " ) , is ( " gremlin - groovy " ) ) ) ; if ( ENGINE_TO_TEST . equals ( " gremlin - groovy " ) ) return g . V ( ) . out ( " created " ) . map ( Lambda . function ( " { x ▁ - > ▁ x . get ( ) . values ( ' name ' ) } " ) ) . count ( ) ; else if ( ENGINE_TO_TEST . equals ( " gremlin - python " ) || ENGINE_TO_TEST . equals ( " gremlin - jython " ) ) return g . V ( ) . out ( " created " ) . map ( Lambda . function ( " x ▁ : ▁ x . get ( ) . values ( ' name ' ) " ) ) . count ( ) ; else throw new RuntimeException ( " The ▁ " + ENGINE_TO_TEST + " ▁ ScriptEngine ▁ is ▁ not ▁ supported ▁ by ▁ this ▁ test " ) ; }
artem-aliev/tinkerpop | private static void assertTraversals ( final GraphTraversal t , final Traversal evald ) { final List < Step > steps = t . asAdmin ( ) . getSteps ( ) ; for ( int ix = 0 ; ix < steps . size ( ) ; ix ++ ) { assertEquals ( steps . get ( ix ) . getClass ( ) , evald . asAdmin ( ) . getSteps ( ) . get ( ix ) . getClass ( ) ) ; } }
flipkart-incubator/Poseidon | public static void main ( String [ ] args ) { try { final String customValidatorClass = System . getProperty ( " poseidon . validator . block . custom " ) ; CustomBlocksValidator customValidator = null ; if ( StringUtils . isNotEmpty ( customValidatorClass ) ) { try { final Class < ? > aClass = Class . forName ( customValidatorClass ) ; final Object constructedInstance = aClass . newInstance ( ) ; if ( constructedInstance instanceof CustomBlocksValidator ) { customValidator = ( CustomBlocksValidator ) constructedInstance ; } else { throw new IllegalArgumentException ( " Wrong ▁ class ▁ supplied " ) ; } } catch ( Exception e ) { logger . error ( " Wrong ▁ CustomBlockValidator ▁ passed " , e ) ; System . exit ( - 1 ) ; } } Set < ClassPath . ClassInfo > classInfos = ClassPathHelper . getPackageClasses ( Thread . currentThread ( ) . getContextClassLoader ( ) , Arrays . asList ( args ) ) ; System . out . println ( " Classes ▁ in ▁ ClassLoader : ▁ " + classInfos . size ( ) ) ; Map < String , List < String > > errors = new HashMap < > ( ) ; for ( ClassPath . ClassInfo classInfo : classInfos ) { Class < ? extends DataSource < ? > > clazz = ( Class < ? extends DataSource < ? > > ) Class . forName ( classInfo . getName ( ) ) ; if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) ) { continue ; } final List < String > classErrors = new ArrayList < > ( ) ; if ( DataSource . class . isAssignableFrom ( clazz ) ) { classErrors . addAll ( AnnotationValidator . validateDataSource ( clazz ) ) ; classErrors . addAll ( DatasourceValidator . validate ( clazz ) ) ; if ( customValidator != null ) { classErrors . addAll ( customValidator . validateDatasource ( clazz ) ) ; } } if ( ! classErrors . isEmpty ( ) ) { errors . put ( clazz . getName ( ) , classErrors ) ; } } if ( ! errors . isEmpty ( ) ) { logger . error ( ValidatorUtils . getFormattedErrorMessages ( errors ) ) ; System . exit ( - 1 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
facebook/presto | public static TestingPrivilege privilege ( String entityName , TestingPrivilegeType type ) { return new TestingPrivilege ( Optional . empty ( ) , entityName , type ) ; }
facebook/presto | public static TestingPrivilege privilege ( String userName , String entityName , TestingPrivilegeType type ) { return new TestingPrivilege ( Optional . of ( userName ) , entityName , type ) ; }
KiviMao/kivi | public static void createTestJar ( File file ) throws Exception { createTestJar ( file , false ) ; }
KiviMao/kivi | public static void createTestJar ( File file , boolean unpackNested ) throws Exception { FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; try ( JarOutputStream jarOutputStream = new JarOutputStream ( fileOutputStream ) ) { writeManifest ( jarOutputStream , " j1" ) ; writeEntry ( jarOutputStream , "1 . dat " , 1 ) ; writeEntry ( jarOutputStream , "2 . dat " , 2 ) ; writeDirEntry ( jarOutputStream , " d / " ) ; writeEntry ( jarOutputStream , " d / 9 . dat " , 9 ) ; writeDirEntry ( jarOutputStream , " special / " ) ; writeEntry ( jarOutputStream , " special / \u00EB . dat " , ' \u00EB ' ) ; writeNestedEntry ( " nested . jar " , unpackNested , jarOutputStream ) ; writeNestedEntry ( " another - nested . jar " , unpackNested , jarOutputStream ) ; } }
KiviMao/kivi | private static byte [ ] getNestedJarData ( ) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; JarOutputStream jarOutputStream = new JarOutputStream ( byteArrayOutputStream ) ; writeManifest ( jarOutputStream , " j2" ) ; writeEntry ( jarOutputStream , "3 . dat " , 3 ) ; writeEntry ( jarOutputStream , "4 . dat " , 4 ) ; writeEntry ( jarOutputStream , " \u00E4 . dat " , ' \u00E4' ) ; jarOutputStream . close ( ) ; return byteArrayOutputStream . toByteArray ( ) ; }
KiviMao/kivi | private static void writeManifest ( JarOutputStream jarOutputStream , String name ) throws Exception { writeDirEntry ( jarOutputStream , " META - INF / " ) ; Manifest manifest = new Manifest ( ) ; manifest . getMainAttributes ( ) . putValue ( " Built - By " , name ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . MANIFEST_VERSION , "1.0" ) ; jarOutputStream . putNextEntry ( new ZipEntry ( " META - INF / MANIFEST . MF " ) ) ; manifest . write ( jarOutputStream ) ; jarOutputStream . closeEntry ( ) ; }
KiviMao/kivi | private static void writeDirEntry ( JarOutputStream jarOutputStream , String name ) throws IOException { jarOutputStream . putNextEntry ( new JarEntry ( name ) ) ; jarOutputStream . closeEntry ( ) ; }
KiviMao/kivi | private static void writeEntry ( JarOutputStream jarOutputStream , String name , int data ) throws IOException { jarOutputStream . putNextEntry ( new JarEntry ( name ) ) ; jarOutputStream . write ( new byte [ ] { ( byte ) data } ) ; jarOutputStream . closeEntry ( ) ; }
markzhai/InterestingTitleBar | public static String get ( String key , String defValue ) { if ( TextUtils . isEmpty ( key ) ) { return defValue ; } String value = getWithReflect ( key , null ) ; if ( TextUtils . isEmpty ( value ) ) { value = getWithCmd ( key , null ) ; } if ( TextUtils . isEmpty ( value ) ) { value = defValue ; } return value ; }
markzhai/InterestingTitleBar | public static String getQuickly ( String key , String defValue ) { if ( TextUtils . isEmpty ( key ) ) { return defValue ; } return getWithReflect ( key , defValue ) ; }
markzhai/InterestingTitleBar | private static String getWithReflect ( String key , String defValue ) { if ( sClassSystemProperties == null || sMethodGetString == null ) { return defValue ; } String value = defValue ; try { value = ( String ) sMethodGetString . invoke ( sClassSystemProperties , key , defValue ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } return value ; }
markzhai/InterestingTitleBar | private static String getWithCmd ( String key , String defValue ) { String value = defValue ; try { Process process = Runtime . getRuntime ( ) . exec ( CMD_GET_PROP + " ▁ " + key ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; StringBuilder builder = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { builder . append ( line ) ; } String readValue = builder . toString ( ) ; if ( ! TextUtils . isEmpty ( readValue ) ) { value = readValue ; } } catch ( IOException e ) { } finally { if ( reader != null ) { reader . close ( ) ; } } process . destroy ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } return value ; }
11xor6/presto | public static String getSimplifiedDomainString ( long low , long high , int rangeCount , Type type ) { String formattedValues ; if ( rangeCount == 1 ) { formattedValues = format ( " { [ % d ] } " , low ) ; } else if ( rangeCount == 2 ) { formattedValues = LongStream . of ( low , high ) . mapToObj ( value -> " [ " + value + " ] " ) . collect ( Collectors . joining ( " , ▁ " , " { " , " } " ) ) ; } else { formattedValues = format ( " { [ % d ] , ▁ . . . , ▁ [ % d ] } " , low , high ) ; } return " [ ▁ " + new StringJoiner ( " , ▁ " , SortedRangeSet . class . getSimpleName ( ) + " [ " , " ] " ) . add ( " type = " + type ) . add ( " ranges = " + rangeCount ) . add ( formattedValues ) + " ▁ ] " ; }
FAU-Inf2/spongycastle | public static OCSPResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; }
FAU-Inf2/spongycastle | public static OCSPResponse getInstance ( Object obj ) { if ( obj instanceof OCSPResponse ) { return ( OCSPResponse ) obj ; } else if ( obj != null ) { return new OCSPResponse ( ASN1Sequence . getInstance ( obj ) ) ; } return null ; }
JIGAsoftSTP/NICON | public static ArrayList < String > likeStart ( List < String > list , String like ) { if ( like == null || list == null ) return null ; ArrayList < String > likeList = new ArrayList < > ( ) ; if ( like . length ( ) == 0 ) { likeList . addAll ( list ) ; return likeList ; } String aux ; for ( String s : list ) { aux = s ; if ( s . length ( ) >= like . length ( ) ) { s = s . substring ( 0 , like . length ( ) ) ; if ( s . toUpperCase ( ) . contains ( like . toUpperCase ( ) ) ) { likeList . add ( aux ) ; } } } return likeList ; }
x-meta/xworker | public static void doAction ( ActionContext actionContext ) throws IOException { World world = World . getInstance ( ) ; HttpServletRequest request = ( HttpServletRequest ) actionContext . get ( " request " ) ; String dataObjectPath = request . getParameter ( " dataObjectPath " ) ; Thing dataObjectConfig = world . getThing ( dataObjectPath ) ; if ( ! SecurityManager . doCheck ( " WEB " , PermissionConstants . XWORKER_DATAOBJECT , " read " , dataObjectPath , actionContext ) ) { return ; } String record = " { } " ; Map < String , Object > result = UtilMap . toMap ( new Object [ ] { " success " , " true " , " msg " , " " } ) ; actionContext . peek ( ) . put ( " result " , result ) ; if ( dataObjectConfig == null ) { result . put ( " success " , " false " ) ; result . put ( " msg " , " 数据对象定义不存在 ， dataObject = " + request . getParameter ( " dataObjectPath " ) ) ; } else { try { DataObject theData = new DataObject ( dataObjectConfig ) ; Thing keyThing = ( Thing ) theData . getKeyAndDatas ( ) [ 0 ] [ 0 ] ; theData . put ( keyThing . getString ( " name " ) , request . getParameter ( " id " ) ) ; theData . doAction ( " load " , actionContext ) ; Thing jsonFactory = world . getThing ( " xworker . text . JsonDataFormat " ) ; record = ( String ) jsonFactory . doAction ( " format " , actionContext , UtilMap . toMap ( new Object [ ] { " data " , theData } ) ) ; if ( result . get ( " msg " ) == null ) { result . put ( " msg " , " 数据读取成功 " ) ; } } catch ( Exception e ) { Executor . error ( TAG , " 数据读取失败 " , e ) ; result . put ( " success " , " false " ) ; result . put ( " msg " , JsonFormator . formatString ( ExceptionUtil . getRootMessage ( e ) ) ) ; } } HttpServletResponse response = ( HttpServletResponse ) actionContext . get ( " response " ) ; if ( ServletFileUpload . isMultipartContent ( request ) ) { response . setContentType ( " text / html ; ▁ charset = utf - 8" ) ; } else { response . setContentType ( " text / plain ; ▁ charset = utf - 8" ) ; } String code = " { \n " + " \" success \" : " + result . get ( " success " ) + " , \n " + " \" msg \" : \" " + result . get ( " msg " ) + " \" , \n " + " \" data \" : " + record + " \n " + " } " ; response . getWriter ( ) . println ( code ) ; }
Venryx/LucidLink | public static int [ ] readBioData ( byte [ ] decobbed ) { int [ ] bioBytes = new int [ 2 ] ; if ( decobbed . length > 1 ) { bioBytes [ 0 ] = decobbed [ 0 ] & MotionEventCompat . ACTION_MASK ; bioBytes [ 0 ] = bioBytes [ 0 ] | ( ( decobbed [ 1 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ; if ( decobbed . length > 3 ) { bioBytes [ 1 ] = decobbed [ 2 ] & MotionEventCompat . ACTION_MASK ; bioBytes [ 1 ] = ( decobbed [ 3 ] & MotionEventCompat . ACTION_MASK ) << 8 ; } } return bioBytes ; }
Venryx/LucidLink | public static int [ ] [ ] readBioData ( byte [ ] decobbed , int packetSize ) { int [ ] [ ] tempChannelData = ( int [ ] [ ] ) Array . newInstance ( Integer . TYPE , new int [ ] { 2 , packetSize - 8 } ) ; int indexSamples = 0 ; int nrBytesToIgnore = 0 ; for ( int j = decobbed . length - 1 ; j >= 0 ; j -- ) { nrBytesToIgnore ++ ; if ( decobbed [ j ] != ( byte ) 0 ) { break ; } } int i = 0 ; while ( i < decobbed . length - nrBytesToIgnore ) { int bioMQValue = 0 ; try { int bioMIValue = ( decobbed [ i ] & MotionEventCompat . ACTION_MASK ) | ( ( decobbed [ i + 1 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ; if ( decobbed . length > i + 2 && decobbed . length > i + 3 ) { bioMQValue = ( decobbed [ i + 2 ] & MotionEventCompat . ACTION_MASK ) | ( ( decobbed [ i + 3 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ; } tempChannelData [ 0 ] [ indexSamples ] = bioMIValue ; tempChannelData [ 1 ] [ indexSamples ] = bioMQValue ; if ( ! ( bioMIValue == BIO_IGNORE_PATTERN || bioMQValue == BIO_IGNORE_PATTERN ) ) { indexSamples ++ ; } } catch ( ArrayIndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } i += 4 ; } int [ ] [ ] validSamples = ( int [ ] [ ] ) Array . newInstance ( Integer . TYPE , new int [ ] { 2 , indexSamples } ) ; for ( i = 0 ; i < indexSamples ; i ++ ) { validSamples [ 0 ] [ i ] = tempChannelData [ 0 ] [ i ] ; validSamples [ 1 ] [ i ] = tempChannelData [ 1 ] [ i ] ; } return validSamples ; }
Venryx/LucidLink | public static int getStoreLocalEnv ( byte [ ] bytes ) { if ( bytes . length > 7 ) { return ( ( ( bytes [ 4 ] & MotionEventCompat . ACTION_MASK ) | ( ( bytes [ 5 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ) | ( ( bytes [ 6 ] & MotionEventCompat . ACTION_MASK ) << 16 ) ) | ( ( bytes [ 7 ] & MotionEventCompat . ACTION_MASK ) << 24 ) ; } return 0 ; }
Venryx/LucidLink | public static int getStoreLocalBio ( byte [ ] bytes ) { if ( bytes . length > 7 ) { return ( ( ( bytes [ 0 ] & MotionEventCompat . ACTION_MASK ) | ( ( bytes [ 1 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ) | ( ( bytes [ 2 ] & MotionEventCompat . ACTION_MASK ) << 16 ) ) | ( ( bytes [ 3 ] & MotionEventCompat . ACTION_MASK ) << 24 ) ; } return 0 ; }
Venryx/LucidLink | public static int readIlluminanceValue ( byte [ ] bytes ) { if ( bytes . length < 2 ) { return 0 ; } return decompress_light ( bytes [ 1 ] & MotionEventCompat . ACTION_MASK ) ; }
Venryx/LucidLink | public static float readTemperatureValue ( byte [ ] bytes ) { if ( bytes . length > 0 ) { return ( ( float ) ( bytes [ 0 ] & MotionEventCompat . ACTION_MASK ) ) / 4.0f ; } return 0.0f ; }
Venryx/LucidLink | public static float [ ] readTemperatureValues ( byte [ ] bytes ) { List < Byte > bList = new ArrayList ( ) ; int i = 0 ; while ( i < bytes . length ) { if ( i % 2 == 0 && ( bytes [ i ] & MotionEventCompat . ACTION_MASK ) != 250 ) { bList . add ( Byte . valueOf ( bytes [ i ] ) ) ; } i ++ ; } float [ ] bArray = new float [ bList . size ( ) ] ; for ( int x = 0 ; x < bList . size ( ) ; x ++ ) { bArray [ x ] = ( ( float ) ( ( ( Byte ) bList . get ( x ) ) . byteValue ( ) & MotionEventCompat . ACTION_MASK ) ) / 4.0f ; } return bArray ; }
Venryx/LucidLink | public static int [ ] readIlluminanceValues ( byte [ ] bytes ) { List < Byte > bList = new ArrayList ( ) ; int i = 0 ; while ( i < bytes . length ) { if ( ! ( i % 2 == 0 || ( bytes [ i ] & MotionEventCompat . ACTION_MASK ) == 250 ) ) { bList . add ( Byte . valueOf ( bytes [ i ] ) ) ; } i ++ ; } int [ ] bArray = new int [ bList . size ( ) ] ; for ( int x = 0 ; x < bList . size ( ) ; x ++ ) { bArray [ x ] = Math . round ( ( float ) ( ( ( Byte ) bList . get ( x ) ) . byteValue ( ) & MotionEventCompat . ACTION_MASK ) ) ; } return bArray ; }
Venryx/LucidLink | public static void saveToEDF ( byte [ ] decobbed , FileOutputStream output ) { try { output . write ( decobbed ) ; output . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
Venryx/LucidLink | public static int decompress_light ( int input ) { if ( input < 64 ) { return input ; } if ( input < 96 ) { return ( ( input - 64 ) * 2 ) + 64 ; } if ( input < 128 ) { return ( ( input - 96 ) * 4 ) + 128 ; } if ( input < 160 ) { return ( ( input - 128 ) * 8 ) + 256 ; } if ( input < 192 ) { return ( ( input - 160 ) * 16 ) + 512 ; } if ( input < 240 ) { return ( ( input - 192 ) * 64 ) + 1024 ; } if ( input < 255 ) { return ( ( input - 240 ) * 128 ) + 4096 ; } return 6000 ; }
Nexmo/nexmo-java-sdk | public static PricingResponse fromJson ( String json ) { try { return new ObjectMapper ( ) . readValue ( json , PricingResponse . class ) ; } catch ( IOException jpe ) { throw new VonageUnexpectedException ( " Failed ▁ to ▁ produce ▁ PricingResponse ▁ from ▁ json . " , jpe ) ; } }
cdeange/WKRPTapp | private static < T > T get ( final RequestFuture < T > future ) throws IOException { T response ; try { response = future . get ( ) ; } catch ( final Exception e ) { throw new IOException ( e ) ; } return response ; }
eschwert/ontop | public static void main ( String [ ] args ) { try { ABoxMaterializerExample example = new ABoxMaterializerExample ( ) ; example . generateTriples ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
jjculber/defcoinj | public static synchronized TestNet3Params get ( ) { if ( instance == null ) { instance = new TestNet3Params ( ) ; } return instance ; }
kiall/ExoPlayer | @ SuppressLint ( " InlinedApi " ) @ TargetApi ( 16 ) private static void testConversionToFrameworkMediaFormatV16 ( Format in ) { MediaFormat out = in . getFrameworkMediaFormatV16 ( ) ; assertThat ( out . getString ( MediaFormat . KEY_MIME ) ) . isEqualTo ( in . sampleMimeType ) ; assertOptionalV16 ( out , MediaFormat . KEY_LANGUAGE , in . language ) ; assertOptionalV16 ( out , MediaFormat . KEY_MAX_INPUT_SIZE , in . maxInputSize ) ; assertOptionalV16 ( out , MediaFormat . KEY_WIDTH , in . width ) ; assertOptionalV16 ( out , MediaFormat . KEY_HEIGHT , in . height ) ; assertOptionalV16 ( out , MediaFormat . KEY_CHANNEL_COUNT , in . channelCount ) ; assertOptionalV16 ( out , MediaFormat . KEY_SAMPLE_RATE , in . sampleRate ) ; assertOptionalV16 ( out , MediaFormat . KEY_FRAME_RATE , in . frameRate ) ; for ( int i = 0 ; i < in . initializationData . size ( ) ; i ++ ) { byte [ ] originalData = in . initializationData . get ( i ) ; ByteBuffer frameworkBuffer = out . getByteBuffer ( " csd - " + i ) ; byte [ ] frameworkData = Arrays . copyOf ( frameworkBuffer . array ( ) , frameworkBuffer . limit ( ) ) ; assertThat ( frameworkData ) . isEqualTo ( originalData ) ; } }
kiall/ExoPlayer | @ TargetApi ( 16 ) private static void assertOptionalV16 ( MediaFormat format , String key , String value ) { if ( value == null ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getString ( key ) ) . isEqualTo ( value ) ; } }
kiall/ExoPlayer | @ TargetApi ( 16 ) private static void assertOptionalV16 ( MediaFormat format , String key , int value ) { if ( value == Format . NO_VALUE ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getInteger ( key ) ) . isEqualTo ( value ) ; } }
kiall/ExoPlayer | @ TargetApi ( 16 ) private static void assertOptionalV16 ( MediaFormat format , String key , float value ) { if ( value == Format . NO_VALUE ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getFloat ( key ) ) . isEqualTo ( value ) ; } }
jk1/intellij-community | @ NotNull private static Collection < FoldingDescriptor > getCustomFoldingDescriptors ( @ NotNull Editor editor , @ NotNull Project project ) { Set < FoldingDescriptor > foldingDescriptors = new HashSet < > ( ) ; final Document document = editor . getDocument ( ) ; PsiDocumentManager documentManager = PsiDocumentManager . getInstance ( project ) ; PsiFile file = documentManager != null ? documentManager . getPsiFile ( document ) : null ; if ( file != null ) { final FileViewProvider viewProvider = file . getViewProvider ( ) ; for ( final Language language : viewProvider . getLanguages ( ) ) { final PsiFile psi = viewProvider . getPsi ( language ) ; final FoldingBuilder foldingBuilder = LanguageFolding . INSTANCE . forLanguage ( language ) ; if ( psi != null ) { for ( FoldingDescriptor descriptor : LanguageFolding . buildFoldingDescriptors ( foldingBuilder , psi , document , false ) ) { CustomFoldingBuilder customFoldingBuilder = getCustomFoldingBuilder ( foldingBuilder , descriptor ) ; if ( customFoldingBuilder != null ) { if ( customFoldingBuilder . isCustomRegionStart ( descriptor . getElement ( ) ) ) { foldingDescriptors . add ( descriptor ) ; } } } } } } return foldingDescriptors ; }
jk1/intellij-community | @ Nullable private static CustomFoldingBuilder getCustomFoldingBuilder ( FoldingBuilder builder , FoldingDescriptor descriptor ) { if ( builder instanceof CustomFoldingBuilder ) return ( CustomFoldingBuilder ) builder ; FoldingBuilder originalBuilder = descriptor . getElement ( ) . getUserData ( CompositeFoldingBuilder . FOLDING_BUILDER ) ; if ( originalBuilder instanceof CustomFoldingBuilder ) return ( CustomFoldingBuilder ) originalBuilder ; return null ; }
jk1/intellij-community | private static void notifyCustomRegionsUnavailable ( @ NotNull Editor editor , @ NotNull Project project ) { final JBPopupFactory popupFactory = JBPopupFactory . getInstance ( ) ; Balloon balloon = popupFactory . createHtmlTextBalloonBuilder ( IdeBundle . message ( " goto . custom . region . message . unavailable " ) , MessageType . INFO , null ) . setFadeoutTime ( 2000 ) . setHideOnClickOutside ( true ) . setHideOnKeyOutside ( true ) . createBalloon ( ) ; Disposer . register ( project , balloon ) ; balloon . show ( popupFactory . guessBestPopupLocation ( editor ) , Balloon . Position . below ) ; }
JuntaoZhang/myhadoop-2.2.0 | @ BeforeClass public static void createOriginalFSImage ( ) throws IOException { MiniDFSCluster cluster = null ; try { Configuration conf = new HdfsConfiguration ( ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY , 10000 ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY , 5000 ) ; conf . setBoolean ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY , true ) ; conf . set ( CommonConfigurationKeysPublic . HADOOP_SECURITY_AUTH_TO_LOCAL , " RULE : [2 : $ 1 @ $ 0 ] ( JobTracker @ . * FOO . COM ) s / @ . * // " + " DEFAULT " ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 4 ) . build ( ) ; cluster . waitActive ( ) ; FileSystem hdfs = cluster . getFileSystem ( ) ; int filesize = 256 ; for ( int i = 0 ; i < NUM_DIRS ; i ++ ) { Path dir = new Path ( " / dir " + i ) ; hdfs . mkdirs ( dir ) ; writtenFiles . put ( dir . toString ( ) , pathToFileEntry ( hdfs , dir . toString ( ) ) ) ; for ( int j = 0 ; j < FILES_PER_DIR ; j ++ ) { Path file = new Path ( dir , " file " + j ) ; FSDataOutputStream o = hdfs . create ( file ) ; o . write ( new byte [ filesize ++ ] ) ; o . close ( ) ; writtenFiles . put ( file . toString ( ) , pathToFileEntry ( hdfs , file . toString ( ) ) ) ; } } Token < ? > [ ] delegationTokens = hdfs . addDelegationTokens ( TEST_RENEWER , null ) ; for ( Token < ? > t : delegationTokens ) { LOG . debug ( " got ▁ token ▁ " + t ) ; } cluster . getNameNodeRpc ( ) . setSafeMode ( SafeModeAction . SAFEMODE_ENTER , false ) ; cluster . getNameNodeRpc ( ) . saveNamespace ( ) ; originalFsimage = FSImageTestUtil . findLatestImageFile ( FSImageTestUtil . getFSImage ( cluster . getNameNode ( ) ) . getStorage ( ) . getStorageDir ( 0 ) ) ; if ( originalFsimage == null ) { throw new RuntimeException ( " Didn ' t ▁ generate ▁ or ▁ can ' t ▁ find ▁ fsimage " ) ; } LOG . debug ( " original ▁ FS ▁ image ▁ file ▁ is ▁ " + originalFsimage ) ; } finally { if ( cluster != null ) cluster . shutdown ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ AfterClass public static void deleteOriginalFSImage ( ) throws IOException { if ( originalFsimage != null && originalFsimage . exists ( ) ) { originalFsimage . delete ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | private static FileStatus pathToFileEntry ( FileSystem hdfs , String file ) throws IOException { return hdfs . getFileStatus ( new Path ( file ) ) ; }
xiwc/thymeleaf.test | public static boolean isNumber ( String str ) { if ( isEmpty ( str ) ) { return false ; } else { try { Double . parseDouble ( str ) ; return true ; } catch ( Exception e ) { return false ; } } }
xiwc/thymeleaf.test | public static String limitLength ( String str , int i ) { if ( isEmpty ( str ) ) { return " " ; } else { if ( str . length ( ) <= i ) { return str ; } else { return str . substring ( 0 , i - 3 ) + " . . . " ; } } }
xiwc/thymeleaf.test | public static String replace ( String tpl , Object ... vals ) { if ( tpl != null ) { for ( int i = 1 ; i <= vals . length ; i ++ ) { tpl = tpl . replace ( " { ? " + i + " } " , String . valueOf ( vals [ i - 1 ] ) ) ; } } return tpl ; }
xiwc/thymeleaf.test | public static String replaceByMap ( String tpl , Map < String , Object > map ) { if ( tpl != null && map != null && map . size ( ) > 0 ) { for ( String key : map . keySet ( ) ) { tpl = tpl . replace ( " { " + key + " } " , String . valueOf ( map . get ( key ) ) ) ; } } return tpl ; }
xiwc/thymeleaf.test | public static String replaceByKV ( String tpl , Object ... vals ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < vals . length ; i += 2 ) { if ( i + 1 < vals . length ) { map . put ( String . valueOf ( vals [ i ] ) , vals [ i + 1 ] ) ; } } return replaceByMap ( tpl , map ) ; }
xiwc/thymeleaf.test | public static String join ( String connector , Object ... objects ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( Object object : objects ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String join ( String connector , String [ ] arr ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( Object object : arr ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String join2 ( String connector , String ... strs ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( Object object : strs ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String join ( String connector , List < String > objects ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( String object : objects ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String toString ( Object object ) { return object == null ? EMPTY : object . toString ( ) ; }
xiwc/thymeleaf.test | public static String getString ( Map < String , Object > map , String key ) { if ( map == null || ! map . containsKey ( key ) ) { return null ; } return toString ( map . get ( key ) ) ; }
xiwc/thymeleaf.test | public static String getNotNullString ( Map < String , Object > map , String key ) { if ( map == null || ! map . containsKey ( key ) ) { return EMPTY ; } return toString ( map . get ( key ) ) ; }
xiwc/thymeleaf.test | public static boolean isEmpty ( Object str ) { return str == null || str . equals ( EMPTY ) ; }
xiwc/thymeleaf.test | public static boolean isNotEmpty ( Object str ) { return ! isEmpty ( str ) ; }
xiwc/thymeleaf.test | public static boolean isValid ( String str ) { return ! isEmpty ( str ) ; }
xiwc/thymeleaf.test | public static List < String > array2List ( String ... values ) { List < String > list = new ArrayList < String > ( ) ; for ( String value : values ) { list . add ( value ) ; } return list ; }
xiwc/thymeleaf.test | public static Map < String , Object > array2Map ( Object ... values ) { Map < String , Object > map = new HashMap < > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i += 2 ) { if ( i + 1 < values . length ) { map . put ( String . valueOf ( values [ i ] ) , values [ i + 1 ] ) ; } } } return map ; }
xiwc/thymeleaf.test | public static Map < String , String > stringArr2Map ( String ... values ) { Map < String , String > map = new HashMap < > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i += 2 ) { if ( i + 1 < values . length ) { map . put ( values [ i ] , values [ i + 1 ] ) ; } } } return map ; }
xiwc/thymeleaf.test | public static String [ ] split ( String val , String decollator ) { if ( ! isEmpty ( val ) ) { return val . split ( decollator ) ; } return null ; }
xiwc/thymeleaf.test | public static String [ ] getValues ( Map < String , String > map , String ... keyArr ) { String [ ] objArr = new String [ keyArr . length ] ; if ( keyArr . length > 0 && map != null && map . size ( ) > 0 ) { int i = 0 ; for ( String key : keyArr ) { objArr [ i ++ ] = map . get ( key ) ; } } return objArr ; }
xiwc/thymeleaf.test | public static String html ( String content ) { if ( content == null ) { return " " ; } String html = content ; html = html . replace ( " ' " , " & apos ; " ) ; html = html . replace ( " \" " , " & quot ; " ) ; html = html . replace ( " \t " , " & nbsp ; & nbsp ; " ) ; html = html . replace ( " < " , " & lt ; " ) ; html = html . replace ( " > " , " & gt ; " ) ; return html ; }
scouter-project/scouter | public static String getCountryName ( String code ) { return table . get ( code ) ; }
scouter-project/scouter | public static void main ( String [ ] args ) { System . out . println ( load ( ) ) ; }
scouter-project/scouter | private static Map < String , String > load ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; InputStream in = null ; try { in = CountryCode . class . getResourceAsStream ( " countrycode . txt " ) ; if ( in == null ) return map ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { String name = line . substring ( 0 , 48 ) . trim ( ) ; String [ ] cd = StringUtil . tokenizer ( line . substring ( 48 ) , " ▁ \t " ) ; map . put ( cd [ 0 ] , name ) ; line = reader . readLine ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { FileUtil . close ( in ) ; } return map ; }
Muyangmin/Android-PLog | static String parseActualPath ( Context context , String path ) throws IllegalStateException { String [ ] supportedPath = new String [ ] { DIR_EXT_ROOT , DIR_EXT_FILES , DIR_INT_FILES } ; for ( String s : supportedPath ) { String regex = " ^ " + s . replace ( " $ " , " \\ $ " ) . replace ( " { " , " \\ { " ) . replace ( " } " , " \\ } " ) ; Matcher matcher = Pattern . compile ( regex ) . matcher ( path ) ; if ( ! matcher . find ( ) ) { continue ; } String param = matcher . group ( ) ; String actualPath = null ; switch ( param ) { case DIR_EXT_ROOT : File root = Environment . getExternalStorageDirectory ( ) ; if ( ( ! Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) ) || root == null ) { throw new IllegalStateException ( " External ▁ storage ▁ is ▁ not ▁ available ! " ) ; } actualPath = matcher . replaceFirst ( root . getAbsolutePath ( ) ) ; break ; case DIR_EXT_FILES : File filesDir = context . getExternalFilesDir ( null ) ; if ( filesDir == null ) { throw new IllegalStateException ( " External ▁ storage ▁ is ▁ not ▁ available ! " ) ; } actualPath = matcher . replaceFirst ( filesDir . getAbsolutePath ( ) ) ; break ; case DIR_INT_FILES : actualPath = matcher . replaceFirst ( context . getFilesDir ( ) . getAbsolutePath ( ) ) ; break ; } return actualPath ; } return path ; }
Muyangmin/Android-PLog | @ Nullable static File resolveDirOrCreate ( @ NonNull String path ) throws SecurityException { File file = new File ( path ) ; if ( ! file . exists ( ) && ! file . mkdirs ( ) ) { return null ; } if ( ! file . isDirectory ( ) ) { return null ; } if ( ! file . canRead ( ) || ! file . canWrite ( ) ) { return null ; } return file ; }
Cangol/Cangol-appcore | public static DownloadHttpClient build ( String group ) { return build ( group , true ) ; }
Cangol/Cangol-appcore | public static DownloadHttpClient build ( String group , boolean safe ) { return new DownloadHttpClient ( group , safe ) ; }
Cangol/Cangol-appcore | public static void setThreadPool ( PoolManager . Pool pool ) { threadPool = pool ; }
gfyoung/elasticsearch | private static void validateAliasFilter ( XContentParser parser , QueryShardContext queryShardContext ) throws IOException { QueryBuilder parseInnerQueryBuilder = parseInnerQueryBuilder ( parser ) ; QueryBuilder queryBuilder = Rewriteable . rewrite ( parseInnerQueryBuilder , queryShardContext , true ) ; queryBuilder . toFilter ( queryShardContext ) ; }
whiskeysierra/riptide | private static MappingJackson2HttpMessageConverter createJsonConverter ( ) { final MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter ( ) ; converter . setObjectMapper ( new ObjectMapper ( ) . findAndRegisterModules ( ) . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ) ; return converter ; }
samuelfac/portalunico.siscomex.gov.br | private static String toIndentedString ( java . lang . Object o ) { if ( o == null ) { return " null " ; } return o . toString ( ) . replace ( " \n " , " \n ▁ ▁ ▁ ▁ " ) ; }
apache/incubator-asterixdb | private static String getComponentFileName ( ) { final String sequence = String . valueOf ( COMPONENT_SEQUENCE ++ ) ; return sequence + ' _ ' + sequence ; }
jasonstack/cassandra | public static < V , F extends Function < V , EncodingStats > > EncodingStats merge ( List < V > values , F function ) { if ( values . size ( ) == 1 ) return function . apply ( values . get ( 0 ) ) ; Collector collector = new Collector ( ) ; for ( int i = 0 , isize = values . size ( ) ; i < isize ; i ++ ) { V v = values . get ( i ) ; EncodingStats stats = function . apply ( v ) ; if ( stats . minTimestamp != TIMESTAMP_EPOCH ) collector . updateTimestamp ( stats . minTimestamp ) ; if ( stats . minLocalDeletionTime != DELETION_TIME_EPOCH ) collector . updateLocalDeletionTime ( stats . minLocalDeletionTime ) ; if ( stats . minTTL != TTL_EPOCH ) collector . updateTTL ( stats . minTTL ) ; } return collector . get ( ) ; }
jasonstack/cassandra | public static EncodingStats collect ( Row staticRow , Iterator < Row > rows , DeletionInfo deletionInfo ) { Collector collector = new Collector ( ) ; deletionInfo . collectStats ( collector ) ; if ( ! staticRow . isEmpty ( ) ) Rows . collectStats ( staticRow , collector ) ; while ( rows . hasNext ( ) ) Rows . collectStats ( rows . next ( ) , collector ) ; return collector . get ( ) ; }
jmockit/jmockit2 | @ Nonnull private static String getGenericClassSignature ( @ Nonnull Type mockedType ) { StringBuilder signature = new StringBuilder ( 100 ) ; if ( mockedType instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) mockedType ; Type [ ] typeArguments = parameterizedType . getActualTypeArguments ( ) ; if ( typeArguments . length > 0 ) { signature . append ( ' < ' ) ; for ( Type typeArg : typeArguments ) { if ( typeArg instanceof Class < ? > ) { Class < ? > classArg = ( Class < ? > ) typeArg ; signature . append ( ' L ' ) . append ( classArg . getName ( ) . replace ( ' . ' , ' / ' ) ) . append ( ' ; ' ) ; } else { signature . append ( ' * ' ) ; } } signature . append ( ' > ' ) ; } } signature . append ( ' ; ' ) ; return signature . toString ( ) ; }
giraudsa/serialisation | public static < U > ActionAbstrait < U > getInstance ( ) { return ( ActionAbstrait < U > ) new ActionJsonSimpleComportement < > ( Object . class , null ) ; }
aws/aws-sdk-java | public static boolean isMetricAdminMBeanRegistered ( ) { SdkMBeanRegistry registry = SdkMBeanRegistry . Factory . getMBeanRegistry ( ) ; return registeredAdminMbeanName != null && registry . isMBeanRegistered ( registeredAdminMbeanName ) ; }
aws/aws-sdk-java | public static String getRegisteredAdminMbeanName ( ) { return registeredAdminMbeanName ; }
aws/aws-sdk-java | public static boolean registerMetricAdminMBean ( ) { SdkMBeanRegistry registry = SdkMBeanRegistry . Factory . getMBeanRegistry ( ) ; synchronized ( AwsSdkMetrics . class ) { if ( registeredAdminMbeanName != null ) return false ; boolean registered = registry . registerMetricAdminMBean ( MBEAN_OBJECT_NAME ) ; if ( registered ) { registeredAdminMbeanName = MBEAN_OBJECT_NAME ; } else { String mbeanName = MBEAN_OBJECT_NAME ; int count = 0 ; while ( registry . isMBeanRegistered ( mbeanName ) ) { mbeanName = MBEAN_OBJECT_NAME + " / " + ++ count ; } registered = registry . registerMetricAdminMBean ( mbeanName ) ; if ( registered ) registeredAdminMbeanName = mbeanName ; } if ( registered ) log . debug ( " Admin ▁ mbean ▁ registered ▁ under ▁ " + registeredAdminMbeanName ) ; return registered ; } }
aws/aws-sdk-java | public static boolean unregisterMetricAdminMBean ( ) { SdkMBeanRegistry registry = SdkMBeanRegistry . Factory . getMBeanRegistry ( ) ; synchronized ( AwsSdkMetrics . class ) { if ( registeredAdminMbeanName == null ) return true ; boolean success = registry . unregisterMBean ( registeredAdminMbeanName ) ; if ( success ) registeredAdminMbeanName = null ; return success ; } }
aws/aws-sdk-java | public static < T extends RequestMetricCollector > T getRequestMetricCollector ( ) { if ( mc == null ) { if ( isDefaultMetricsEnabled ( ) ) enableDefaultMetrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? RequestMetricCollector . NONE : mc . getRequestMetricCollector ( ) ) ; return t ; }
aws/aws-sdk-java | public static < T extends ServiceMetricCollector > T getServiceMetricCollector ( ) { if ( mc == null ) { if ( isDefaultMetricsEnabled ( ) ) enableDefaultMetrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? ServiceMetricCollector . NONE : mc . getServiceMetricCollector ( ) ) ; return t ; }
aws/aws-sdk-java | static MetricCollector getInternalMetricCollector ( ) { return mc ; }
aws/aws-sdk-java | public static < T extends MetricCollector > T getMetricCollector ( ) { if ( mc == null ) { if ( isDefaultMetricsEnabled ( ) ) enableDefaultMetrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? MetricCollector . NONE : mc ) ; return t ; }
aws/aws-sdk-java | public static synchronized void setMetricCollector ( MetricCollector mc ) { MetricCollector old = AwsSdkMetrics . mc ; AwsSdkMetrics . mc = mc ; if ( old != null ) { old . stop ( ) ; } }
aws/aws-sdk-java | public static void setMachineMetricsExcluded ( boolean excludeMachineMetrics ) { AwsSdkMetrics . machineMetricsExcluded = excludeMachineMetrics ; }
aws/aws-sdk-java | public static void setPerHostMetricsIncluded ( boolean includePerHostMetrics ) { AwsSdkMetrics . perHostMetricsIncluded = includePerHostMetrics ; }
aws/aws-sdk-java | public static void enableHttpSocketReadMetric ( ) { AwsSdkMetrics . httpSocketReadMetricEnabled = true ; }
aws/aws-sdk-java | public static boolean isDefaultMetricsEnabled ( ) { return defaultMetricsEnabled ; }
aws/aws-sdk-java | public static boolean isSingleMetricNamespace ( ) { return singleMetricNamespace ; }
aws/aws-sdk-java | public static void setSingleMetricNamespace ( boolean singleMetricNamespace ) { AwsSdkMetrics . singleMetricNamespace = singleMetricNamespace ; }
aws/aws-sdk-java | public static boolean isMetricsEnabled ( ) { MetricCollector mc = AwsSdkMetrics . mc ; return mc != null && mc . isEnabled ( ) ; }
aws/aws-sdk-java | public static boolean isMachineMetricExcluded ( ) { return machineMetricsExcluded ; }
aws/aws-sdk-java | public static boolean isPerHostMetricIncluded ( ) { return perHostMetricsIncluded ; }
aws/aws-sdk-java | public static boolean isPerHostMetricEnabled ( ) { if ( perHostMetricsIncluded ) return true ; String host = hostMetricName ; host = host == null ? " " : host . trim ( ) ; return host . length ( ) > 0 ; }
aws/aws-sdk-java | public static boolean isHttpSocketReadMetricEnabled ( ) { return httpSocketReadMetricEnabled ; }
aws/aws-sdk-java | public static synchronized boolean enableDefaultMetrics ( ) { if ( mc == null || ! mc . isEnabled ( ) ) { if ( dirtyEnabling ) { throw new IllegalStateException ( " Reentrancy ▁ is ▁ not ▁ allowed " ) ; } dirtyEnabling = true ; try { Class < ? > c = Class . forName ( DEFAULT_METRIC_COLLECTOR_FACTORY ) ; MetricCollector . Factory f = ( MetricCollector . Factory ) c . newInstance ( ) ; MetricCollector instance = f . getInstance ( ) ; if ( instance != null ) { setMetricCollector ( instance ) ; return true ; } } catch ( Exception e ) { LogFactory . getLog ( AwsSdkMetrics . class ) . warn ( " Failed ▁ to ▁ enable ▁ the ▁ default ▁ metrics " , e ) ; } finally { dirtyEnabling = false ; } } return false ; }
aws/aws-sdk-java | public static void disableMetrics ( ) { setMetricCollector ( MetricCollector . NONE ) ; }
aws/aws-sdk-java | public static boolean add ( MetricType type ) { return type == null ? false : registry . addMetricType ( type ) ; }
aws/aws-sdk-java | public static < T extends MetricType > boolean addAll ( Collection < T > types ) { return types == null || types . size ( ) == 0 ? false : registry . addMetricTypes ( types ) ; }
aws/aws-sdk-java | public static < T extends MetricType > void set ( Collection < T > types ) { registry . setMetricTypes ( types ) ; }
aws/aws-sdk-java | public static boolean remove ( MetricType type ) { return type == null ? false : registry . removeMetricType ( type ) ; }
aws/aws-sdk-java | public static Set < MetricType > getPredefinedMetrics ( ) { return registry . predefinedMetrics ( ) ; }
aws/aws-sdk-java | public static AWSCredentialsProvider getCredentialProvider ( ) { StackTraceElement [ ] e = Thread . currentThread ( ) . getStackTrace ( ) ; for ( int i = 0 ; i < e . length ; i ++ ) { if ( e [ i ] . getClassName ( ) . equals ( DEFAULT_METRIC_COLLECTOR_FACTORY ) ) { return credentialProvider ; } } SecurityException ex = new SecurityException ( ) ; LogFactory . getLog ( AwsSdkMetrics . class ) . warn ( " Illegal ▁ attempt ▁ to ▁ access ▁ the ▁ credential ▁ provider " , ex ) ; throw ex ; }
aws/aws-sdk-java | public static synchronized void setCredentialProvider ( AWSCredentialsProvider provider ) { credentialProvider = provider ; }
aws/aws-sdk-java | public static Regions getRegion ( ) throws IllegalArgumentException { return Regions . fromName ( region . getName ( ) ) ; }
aws/aws-sdk-java | public static String getRegionName ( ) { return region == null ? null : region . getName ( ) ; }
aws/aws-sdk-java | public static void setRegion ( Regions region ) { AwsSdkMetrics . region = RegionUtils . getRegion ( region . getName ( ) ) ; }
aws/aws-sdk-java | public static void setRegion ( String region ) { AwsSdkMetrics . region = RegionUtils . getRegion ( region ) ; }
aws/aws-sdk-java | @ Deprecated public static String getCredentailFile ( ) { return credentialFile ; }
aws/aws-sdk-java | public static String getCredentialFile ( ) { return credentialFile ; }
aws/aws-sdk-java | public static Integer getMetricQueueSize ( ) { return metricQueueSize ; }
aws/aws-sdk-java | public static void setMetricQueueSize ( Integer size ) { metricQueueSize = size ; }
aws/aws-sdk-java | public static Long getQueuePollTimeoutMilli ( ) { return queuePollTimeoutMilli ; }
aws/aws-sdk-java | public static void setQueuePollTimeoutMilli ( Long timeoutMilli ) { queuePollTimeoutMilli = timeoutMilli ; }
aws/aws-sdk-java | public static String getMetricNameSpace ( ) { return metricNameSpace ; }
aws/aws-sdk-java | public static void setMetricNameSpace ( String metricNameSpace ) { if ( metricNameSpace == null || metricNameSpace . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( ) ; AwsSdkMetrics . metricNameSpace = metricNameSpace ; }
aws/aws-sdk-java | public static String getJvmMetricName ( ) { return jvmMetricName ; }
aws/aws-sdk-java | public static void setJvmMetricName ( String jvmMetricName ) { AwsSdkMetrics . jvmMetricName = jvmMetricName ; }
aws/aws-sdk-java | public static String getHostMetricName ( ) { return hostMetricName ; }
aws/aws-sdk-java | public static void setHostMetricName ( String hostMetricName ) { AwsSdkMetrics . hostMetricName = hostMetricName ; }
linkedin/PalDB | public static StoreReader createReader ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new ReaderImpl ( config , file ) ; }
linkedin/PalDB | public static StoreReader createReader ( InputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ stream , ▁ copying ▁ into ▁ temp ▁ folder " ) ; try { File file = TempUtils . copyIntoTempFile ( " paldbtempreader " , stream ) ; LOGGER . log ( Level . INFO , " Copied ▁ stream ▁ into ▁ temp ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new ReaderImpl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
linkedin/PalDB | public static StoreWriter createWriter ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } try { LOGGER . log ( Level . INFO , " Initialize ▁ writer ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; File parent = file . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( parent . mkdirs ( ) ) { LOGGER . log ( Level . INFO , " Creating ▁ directories ▁ for ▁ path ▁ { 0 } " , file . getName ( ) ) ; } else { throw new RuntimeException ( String . format ( " Couldn ' t ▁ create ▁ directory ▁ % s " , parent ) ) ; } } return new WriterImpl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
linkedin/PalDB | public static StoreWriter createWriter ( OutputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . info ( " Initialize ▁ writer ▁ from ▁ stream " ) ; return new WriterImpl ( config , stream ) ; }
jamalgithub/workdev | public static void main ( String [ ] args ) { boolean gameOver = true ; int score = 800 ; int levelCompleted = 5 ; int bonus = 100 ; int highScore = calculateScore ( gameOver , score , levelCompleted , bonus ) ; System . out . println ( " Your ▁ final ▁ score ▁ was ▁ " + highScore ) ; score = 10000 ; levelCompleted = 8 ; bonus = 200 ; highScore = calculateScore ( gameOver , score , levelCompleted , bonus ) ; System . out . println ( " Your ▁ final ▁ score ▁ was ▁ " + highScore ) ; int highScorePosition = calculateHighScorePosition ( 1500 ) ; displayHighScorePosition ( " Tim " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 900 ) ; displayHighScorePosition ( " Bob " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 400 ) ; displayHighScorePosition ( " Percy " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 50 ) ; displayHighScorePosition ( " Gilbert " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 1000 ) ; displayHighScorePosition ( " Louise " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 500 ) ; displayHighScorePosition ( " Carol " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 100 ) ; displayHighScorePosition ( " Frank " , highScorePosition ) ; }
jamalgithub/workdev | public static void displayHighScorePosition ( String playerName , int highScorePosition ) { System . out . println ( playerName + " ▁ managed ▁ to ▁ get ▁ into ▁ position ▁ " + highScorePosition + " ▁ on ▁ the ▁ high ▁ score ▁ table " ) ; }
jamalgithub/workdev | public static int calculateHighScorePosition ( int playerScore ) { int position = 4 ; if ( playerScore >= 1000 ) { position = 1 ; } else if ( playerScore >= 500 ) { position = 2 ; } else if ( playerScore >= 100 ) { position = 3 ; } return position ; }
jamalgithub/workdev | public static int calculateScore ( boolean gameOver , int score , int levelCompleted , int bonus ) { if ( gameOver ) { int finalScore = score + ( levelCompleted * bonus ) ; finalScore += 2000 ; return finalScore ; } return - 1 ; }
ZiglioNZ/construct | public static byte [ ] int_to_bin ( int number ) { return int_to_bin ( number , 32 ) ; }
ZiglioNZ/construct | public static byte [ ] int_to_bin ( int number , int width ) { if ( number < 0 ) { number += ( 1 << width ) ; } int i = width - 1 ; byte [ ] bits = new byte [ width ] ; while ( i >= 0 ) { bits [ i ] = ( byte ) ( number & 1 ) ; number >>= 1 ; i -= 1 ; } return bits ; }
ZiglioNZ/construct | public static int bin_to_int ( byte [ ] bits ) { return bin_to_int ( bits , false ) ; }
ZiglioNZ/construct | public static int bin_to_int ( byte [ ] bits , boolean signed ) { int number = 0 ; int bias = 0 ; int i = 0 ; if ( bits . length == 0 ) return 0 ; if ( signed && bits [ 0 ] == ( byte ) 1 ) { i ++ ; bias = 1 << ( bits . length - 1 ) ; } for ( int j = i ; j < bits . length ; j ++ ) { number <<= 1 ; number |= bits [ j ] ; } return number - bias ; }
ZiglioNZ/construct | public static byte [ ] swap_bytes ( byte [ ] bits ) { return swap_bytes ( bits , 8 ) ; }
ZiglioNZ/construct | public static byte [ ] swap_bytes ( byte [ ] bits , int bytesize ) { final int L = bits . length ; byte [ ] output = new byte [ L ] ; int j = L - bytesize ; for ( int i = 0 ; i < L ; i ++ , j ++ ) { if ( j == L ) { j = 0 ; } output [ j ] = bits [ i ] ; } return output ; }
ZiglioNZ/construct | public static Encoder BinaryEncoder ( ) { return data -> decode_bin ( data . getBytes ( ) ) ; }
ZiglioNZ/construct | public static Decoder BinaryDecoder ( ) { return data -> encode_bin ( data ) ; }
ZiglioNZ/construct | public static byte [ ] encode_bin ( byte [ ] data ) { byte [ ] out = new byte [ 8 * data . length ] ; for ( int i = 0 ; i < data . length ; i ++ ) { int ch = ( int ) data [ i ] ; if ( ch < 0 ) ch = 256 + ch ; byte [ ] conv = _char_to_bin [ ch ] ; System . arraycopy ( conv , 0 , out , i * 8 , 8 ) ; } return out ; }
ZiglioNZ/construct | public static byte [ ] decode_bin ( byte [ ] data ) { if ( ( data . length & 7 ) != 0 ) throw new ValueError ( " Data ▁ length ▁ must ▁ be ▁ a ▁ multiple ▁ of ▁ 8" ) ; byte [ ] sb = new byte [ data . length / 8 ] ; for ( int i = 0 ; i < data . length ; i += 8 ) { byte ch = 0 ; for ( int j = 0 ; j < 8 ; j ++ ) { ch = ( byte ) ( ch << 1 ) ; ch |= data [ i + j ] ; } sb [ i / 8 ] = ch ; } return sb ; }
ZiglioNZ/construct | public static byte [ ] hexStringToByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i += 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) << 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; }
ZiglioNZ/construct | public static String byteArrayToHexString ( byte [ ] raw , int linesize ) { if ( raw == null ) return null ; final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; hex . append ( ' \n ' ) ; int i = 0 ; for ( final byte b : raw ) { hex . append ( HEXES [ ( b >> 4 ) & 0xF ] ) . append ( HEXES [ ( b ) & 0xF ] ) ; i ++ ; hex . append ( ' ▁ ' ) ; if ( i == linesize ) { hex . append ( ' \n ' ) ; i = 0 ; } } hex . append ( ' \n ' ) ; return hex . toString ( ) ; }
ZiglioNZ/construct | public static String byteArrayToHexString ( byte [ ] raw ) { if ( raw == null ) return null ; final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; for ( final byte b : raw ) { hex . append ( HEXES [ ( b >> 4 ) & 0xF ] ) . append ( HEXES [ ( b ) & 0xF ] ) ; } return hex . toString ( ) ; }
issei-m/idea-php-symfony2-plugin | static public List < ResolveResult > getClassInterfaceResolveResult ( Project project , String fqnClassOrInterfaceName ) { if ( ! fqnClassOrInterfaceName . startsWith ( " \ \" ) ) { fqnClassOrInterfaceName = " \ \" + fqnClassOrInterfaceName ; } List < ResolveResult > results = new ArrayList < ResolveResult > ( ) ; for ( PhpClass phpClass : PhpIndex . getInstance ( project ) . getAnyByFQN ( fqnClassOrInterfaceName ) ) { results . add ( new PsiElementResolveResult ( phpClass ) ) ; } return results ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Collection < String > getArrayCreationKeys ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { return getArrayCreationKeyMap ( arrayCreationExpression ) . keySet ( ) ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Map < String , PsiElement > getArrayCreationKeyMap ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { Map < String , PsiElement > keys = new HashMap < String , PsiElement > ( ) ; for ( ArrayHashElement arrayHashElement : arrayCreationExpression . getHashElements ( ) ) { PhpPsiElement child = arrayHashElement . getKey ( ) ; if ( child instanceof StringLiteralExpression ) { keys . put ( ( ( StringLiteralExpression ) child ) . getContents ( ) , child ) ; } } return keys ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Set < String > getArrayValuesAsString ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { return getArrayValuesAsMap ( arrayCreationExpression ) . keySet ( ) ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Map < String , PsiElement > getArrayValuesAsMap ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { List < PsiElement > arrayValues = PhpPsiUtil . getChildren ( arrayCreationExpression , new Condition < PsiElement > ( ) { @ Override public boolean value ( PsiElement psiElement ) { return psiElement . getNode ( ) . getElementType ( ) == PhpElementTypes . ARRAY_VALUE ; } } ) ; if ( arrayValues == null ) { return Collections . emptyMap ( ) ; } Map < String , PsiElement > keys = new HashMap < String , PsiElement > ( ) ; for ( PsiElement child : arrayValues ) { String stringValue = PhpElementsUtil . getStringValue ( child . getFirstChild ( ) ) ; if ( stringValue != null && StringUtils . isNotBlank ( stringValue ) ) { keys . put ( stringValue , child ) ; } } return keys ; }
issei-m/idea-php-symfony2-plugin | static public HashMap < String , String > getArrayKeyValueMap ( ArrayCreationExpression arrayCreationExpression ) { HashMap < String , String > keys = new HashMap < String , String > ( ) ; for ( ArrayHashElement arrayHashElement : arrayCreationExpression . getHashElements ( ) ) { PhpPsiElement child = arrayHashElement . getKey ( ) ; if ( child != null && ( ( child instanceof StringLiteralExpression ) || PhpPatterns . psiElement ( PhpElementTypes . NUMBER ) . accepts ( child ) ) ) { String key ; if ( child instanceof StringLiteralExpression ) { key = ( ( StringLiteralExpression ) child ) . getContents ( ) ; } else { key = child . getText ( ) ; } String value = null ; if ( arrayHashElement . getValue ( ) instanceof StringLiteralExpression ) { value = ( ( StringLiteralExpression ) arrayHashElement . getValue ( ) ) . getContents ( ) ; } keys . put ( key , value ) ; } } return keys ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpPsiElement getArrayValue ( ArrayCreationExpression arrayCreationExpression , String name ) { for ( ArrayHashElement arrayHashElement : arrayCreationExpression . getHashElements ( ) ) { PhpPsiElement child = arrayHashElement . getKey ( ) ; if ( child instanceof StringLiteralExpression ) { if ( ( ( StringLiteralExpression ) child ) . getContents ( ) . equals ( name ) ) { return arrayHashElement . getValue ( ) ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayValueString ( ArrayCreationExpression arrayCreationExpression , String name ) { PhpPsiElement phpPsiElement = getArrayValue ( arrayCreationExpression , name ) ; if ( phpPsiElement == null ) { return null ; } if ( phpPsiElement instanceof StringLiteralExpression ) { return ( ( StringLiteralExpression ) phpPsiElement ) . getContents ( ) ; } return null ; }
issei-m/idea-php-symfony2-plugin | static public PsiElement [ ] getPsiElementsBySignature ( Project project , @ Nullable String signature ) { if ( signature == null ) { return new PsiElement [ 0 ] ; } Collection < ? extends PhpNamedElement > phpNamedElementCollections = PhpIndex . getInstance ( project ) . getBySignature ( signature , null , 0 ) ; return phpNamedElementCollections . toArray ( new PsiElement [ phpNamedElementCollections . size ( ) ] ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PsiElement getPsiElementsBySignatureSingle ( Project project , @ Nullable String signature ) { PsiElement [ ] psiElements = getPsiElementsBySignature ( project , signature ) ; if ( psiElements . length == 0 ) { return null ; } return psiElements [ 0 ] ; }
issei-m/idea-php-symfony2-plugin | @ Deprecated static public PsiElement [ ] getClassInterfacePsiElements ( Project project , String FQNClassOrInterfaceName ) { List < PsiElement > results = new ArrayList < PsiElement > ( ) ; for ( ResolveResult result : getClassInterfaceResolveResult ( project , FQNClassOrInterfaceName ) ) { results . add ( result . getElement ( ) ) ; } return results . toArray ( new PsiElement [ results . size ( ) ] ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public Method getClassMethod ( PhpClass phpClass , String methodName ) { return phpClass . findMethodByName ( methodName ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public Method getClassMethod ( Project project , String phpClassName , String methodName ) { for ( PhpClass phpClass : PhpIndex . getInstance ( project ) . getClassesByFQN ( phpClassName ) ) { Method method = getClassMethod ( phpClass , methodName ) ; if ( method != null ) { return method ; } } return null ; }
issei-m/idea-php-symfony2-plugin | static public boolean isMethodWithFirstString ( PsiElement psiElement , String ... methodName ) { if ( ! PlatformPatterns . psiElement ( PhpElementTypes . METHOD_REFERENCE ) . withChild ( PlatformPatterns . psiElement ( PhpElementTypes . PARAMETER_LIST ) . withFirstChild ( PlatformPatterns . psiElement ( PhpElementTypes . STRING ) ) ) . accepts ( psiElement ) ) { return false ; } String methodRefName = ( ( MethodReference ) psiElement ) . getName ( ) ; return null != methodRefName && Arrays . asList ( methodName ) . contains ( methodRefName ) ; }
issei-m/idea-php-symfony2-plugin | static public boolean isMethodWithFirstStringOrFieldReference ( PsiElement psiElement , String ... methodName ) { if ( ! PlatformPatterns . psiElement ( PhpElementTypes . METHOD_REFERENCE ) . withChild ( PlatformPatterns . psiElement ( PhpElementTypes . PARAMETER_LIST ) . withFirstChild ( PlatformPatterns . or ( PlatformPatterns . psiElement ( PhpElementTypes . STRING ) , PlatformPatterns . psiElement ( PhpElementTypes . FIELD_REFERENCE ) , PlatformPatterns . psiElement ( PhpElementTypes . class_CONSTANT_REFERENCE ) ) ) ) . accepts ( psiElement ) ) { return false ; } String methodRefName = ( ( MethodReference ) psiElement ) . getName ( ) ; return null != methodRefName && Arrays . asList ( methodName ) . contains ( methodRefName ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < StringLiteralExpression > methodWithFirstStringPattern ( ) { return PlatformPatterns . psiElement ( StringLiteralExpression . class ) . withParent ( PlatformPatterns . psiElement ( PhpElementTypes . PARAMETER_LIST ) . withFirstChild ( PlatformPatterns . psiElement ( PhpElementTypes . STRING ) ) . withParent ( PlatformPatterns . psiElement ( PhpElementTypes . METHOD_REFERENCE ) ) ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < PsiElement > getClassNamePattern ( ) { return PlatformPatterns . psiElement ( PhpTokenTypes . IDENTIFIER ) . afterLeafSkipping ( PlatformPatterns . psiElement ( PsiWhiteSpace . class ) , PlatformPatterns . psiElement ( PhpTokenTypes . kwCLASS ) ) . withParent ( PhpClass . class ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < PsiElement > getActionMethodPattern ( ) { return PlatformPatterns . psiElement ( PhpTokenTypes . IDENTIFIER ) . withText ( PlatformPatterns . string ( ) . endsWith ( " Action " ) ) . afterLeafSkipping ( PlatformPatterns . psiElement ( PsiWhiteSpace . class ) , PlatformPatterns . psiElement ( PhpTokenTypes . kwFUNCTION ) ) . inside ( Method . class ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < StringLiteralExpression > getMethodReturnPattern ( ) { return PlatformPatterns . psiElement ( StringLiteralExpression . class ) . withParent ( PlatformPatterns . psiElement ( PhpReturn . class ) . inside ( Method . class ) ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getMethodReturnAsString ( @ NotNull PhpClass phpClass , @ NotNull String methodName ) { Method method = phpClass . findMethodByName ( methodName ) ; if ( method == null ) { return null ; } final Set < String > values = new HashSet < String > ( ) ; method . acceptChildren ( new PsiRecursiveElementWalkingVisitor ( ) { @ Override public void visitElement ( PsiElement element ) { if ( PhpElementsUtil . getMethodReturnPattern ( ) . accepts ( element ) ) { String value = PhpElementsUtil . getStringValue ( element ) ; if ( value != null && StringUtils . isNotBlank ( value ) ) { values . add ( value ) ; } } super . visitElement ( element ) ; } } ) ; if ( values . size ( ) == 0 ) { return null ; } return values . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getClass ( Project project , String className ) { return getClass ( PhpIndex . getInstance ( project ) , className ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getClass ( PhpIndex phpIndex , String className ) { Collection < PhpClass > classes = phpIndex . getClassesByFQN ( className ) ; return classes . isEmpty ( ) ? null : classes . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getInterface ( PhpIndex phpIndex , String className ) { if ( ! className . startsWith ( " \ \" ) ) { className = " \ \" + className ; } Collection < PhpClass > classes = phpIndex . getInterfacesByFQN ( className ) ; return classes . isEmpty ( ) ? null : classes . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getClassInterface ( Project project , @ NotNull String className ) { if ( ! className . startsWith ( " \ \" ) ) { className = " \ \" + className ; } Collection < PhpClass > phpClasses = PhpIndex . getInstance ( project ) . getAnyByFQN ( className ) ; return phpClasses . size ( ) == 0 ? null : phpClasses . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | static public Collection < PhpClass > getClassesInterface ( Project project , @ NotNull String className ) { if ( ! className . startsWith ( " \ \" ) ) { className = " \ \" + className ; } return PhpIndex . getInstance ( project ) . getAnyByFQN ( className ) ; }
issei-m/idea-php-symfony2-plugin | static public void addClassPublicMethodCompletion ( CompletionResultSet completionResultSet , PhpClass phpClass ) { for ( Method method : getClassPublicMethod ( phpClass ) ) { completionResultSet . addElement ( new PhpLookupElement ( method ) ) ; } }
issei-m/idea-php-symfony2-plugin | static public ArrayList < Method > getClassPublicMethod ( PhpClass phpClass ) { ArrayList < Method > methods = new ArrayList < Method > ( ) ; for ( Method method : phpClass . getMethods ( ) ) { if ( method . getAccess ( ) . isPublic ( ) && ! method . getName ( ) . startsWith ( " _ _ " ) ) { methods . add ( method ) ; } } return methods ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayHashValue ( ArrayCreationExpression arrayCreationExpression , String keyName ) { ArrayHashElement translationArrayHashElement = PsiElementUtils . getChildrenOfType ( arrayCreationExpression , PlatformPatterns . psiElement ( ArrayHashElement . class ) . withFirstChild ( PlatformPatterns . psiElement ( PhpElementTypes . ARRAY_KEY ) . withText ( PlatformPatterns . string ( ) . oneOf ( " ' " + keyName + " ' " , " \" " + keyName + " \" " ) ) ) ) ; if ( translationArrayHashElement == null ) { return null ; } if ( ! ( translationArrayHashElement . getValue ( ) instanceof StringLiteralExpression ) ) { return null ; } StringLiteralExpression valueString = ( StringLiteralExpression ) translationArrayHashElement . getValue ( ) ; if ( valueString == null ) { return null ; } return valueString . getContents ( ) ; }
issei-m/idea-php-symfony2-plugin | static public boolean isEqualMethodReferenceName ( MethodReference methodReference , String methodName ) { String name = methodReference . getName ( ) ; return name != null && name . equals ( methodName ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElement findArrayKeyValueInsideReference ( PsiElement psiElement , String methodReferenceName , String keyName ) { if ( psiElement == null ) { return null ; } Collection < MethodReference > tests = PsiTreeUtil . findChildrenOfType ( psiElement , MethodReference . class ) ; for ( MethodReference methodReference : tests ) { if ( PhpElementsUtil . isEqualMethodReferenceName ( methodReference , methodReferenceName ) ) { PsiElement [ ] parameters = methodReference . getParameters ( ) ; if ( parameters . length > 0 && parameters [ 0 ] instanceof ArrayCreationExpression ) { PsiElement keyValue = PhpElementsUtil . getArrayValue ( ( ArrayCreationExpression ) parameters [ 0 ] , keyName ) ; if ( keyValue != null ) { return keyValue ; } } } } return null ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayKeyValueInsideSignature ( PsiElement psiElementInsideClass , String callTo , String methodName , String keyName ) { return getArrayKeyValueInsideSignature ( psiElementInsideClass , new String [ ] { callTo } , methodName , keyName ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayKeyValueInsideSignature ( PsiElement psiElementInsideClass , String callTo [ ] , String methodName , String keyName ) { PhpClass phpClass = PsiTreeUtil . getParentOfType ( psiElementInsideClass , PhpClass . class ) ; if ( phpClass == null ) { return null ; } String className = phpClass . getPresentableFQN ( ) ; if ( className == null ) { return null ; } for ( String s : callTo ) { String arrayKeyValueInsideSignature = PhpElementsUtil . getArrayKeyValueInsideSignature ( psiElementInsideClass . getProject ( ) , " # M # C\ \" + className + " . " + s , methodName , keyName ) ; if ( arrayKeyValueInsideSignature != null ) { return arrayKeyValueInsideSignature ; } } return null ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayKeyValueInsideSignature ( Project project , String signature , String methodName , String keyName ) { PsiElement psiElement = PhpElementsUtil . getPsiElementsBySignatureSingle ( project , signature ) ; if ( psiElement == null ) { return null ; } for ( MethodReference methodReference : PsiTreeUtil . findChildrenOfType ( psiElement , MethodReference . class ) ) { if ( PhpElementsUtil . isEqualMethodReferenceName ( methodReference , methodName ) ) { PsiElement [ ] parameters = methodReference . getParameters ( ) ; if ( parameters . length > 0 && parameters [ 0 ] instanceof ArrayCreationExpression ) { return PhpElementsUtil . getArrayValueString ( ( ArrayCreationExpression ) parameters [ 0 ] , keyName ) ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | public static Method [ ] getImplementedMethods ( @ NotNull Method method ) { ArrayList < Method > items = getImplementedMethods ( method . getContainingClass ( ) , method , new ArrayList < Method > ( ) ) ; return items . toArray ( new Method [ items . size ( ) ] ) ; }
issei-m/idea-php-symfony2-plugin | private static ArrayList < Method > getImplementedMethods ( @ Nullable PhpClass phpClass , @ NotNull Method method , ArrayList < Method > implementedMethods ) { if ( phpClass == null ) { return implementedMethods ; } Method [ ] methods = phpClass . getOwnMethods ( ) ; for ( Method ownMethod : methods ) { if ( PhpLangUtil . equalsMethodNames ( ownMethod . getName ( ) , method . getName ( ) ) ) { implementedMethods . add ( ownMethod ) ; } } for ( PhpClass interfaceClass : phpClass . getImplementedInterfaces ( ) ) { getImplementedMethods ( interfaceClass , method , implementedMethods ) ; } getImplementedMethods ( phpClass . getSuperClass ( ) , method , implementedMethods ) ; return implementedMethods ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static String getStringValue ( @ Nullable PsiElement psiElement ) { return getStringValue ( psiElement , 0 ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable private static String getStringValue ( @ Nullable PsiElement psiElement , int depth ) { if ( psiElement == null || ++ depth > 5 ) { return null ; } if ( psiElement instanceof StringLiteralExpression ) { String resolvedString = ( ( StringLiteralExpression ) psiElement ) . getContents ( ) ; if ( StringUtils . isEmpty ( resolvedString ) ) { return null ; } return resolvedString ; } if ( psiElement instanceof Field ) { return getStringValue ( ( ( Field ) psiElement ) . getDefaultValue ( ) , depth ) ; } if ( psiElement instanceof PhpReference ) { PsiReference psiReference = psiElement . getReference ( ) ; if ( psiReference == null ) { return null ; } PsiElement ref = psiReference . resolve ( ) ; if ( ref instanceof PhpReference ) { return getStringValue ( psiElement , depth ) ; } if ( ref instanceof Field ) { PsiElement resolved = ( ( Field ) ref ) . getDefaultValue ( ) ; if ( resolved instanceof StringLiteralExpression ) { return ( ( StringLiteralExpression ) resolved ) . getContents ( ) ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | public static String getPrevSiblingAsTextUntil ( PsiElement psiElement , ElementPattern pattern , boolean includeMatching ) { String prevText = " " ; for ( PsiElement child = psiElement . getPrevSibling ( ) ; child != null ; child = child . getPrevSibling ( ) ) { if ( pattern . accepts ( child ) ) { if ( includeMatching ) { return child . getText ( ) + prevText ; } return prevText ; } else { prevText = child . getText ( ) + prevText ; } } return prevText ; }
issei-m/idea-php-symfony2-plugin | public static String getPrevSiblingAsTextUntil ( PsiElement psiElement , ElementPattern pattern ) { return getPrevSiblingAsTextUntil ( psiElement , pattern , false ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static ArrayCreationExpression getCompletableArrayCreationElement ( PsiElement psiElement ) { if ( PhpPatterns . psiElement ( PhpElementTypes . ARRAY_KEY ) . accepts ( psiElement . getContext ( ) ) ) { PsiElement arrayKey = psiElement . getContext ( ) ; if ( arrayKey != null ) { PsiElement arrayHashElement = arrayKey . getContext ( ) ; if ( arrayHashElement instanceof ArrayHashElement ) { PsiElement arrayCreationExpression = arrayHashElement . getContext ( ) ; if ( arrayCreationExpression instanceof ArrayCreationExpression ) { return ( ArrayCreationExpression ) arrayCreationExpression ; } } } } if ( PhpPatterns . psiElement ( PhpElementTypes . ARRAY_VALUE ) . accepts ( psiElement . getContext ( ) ) ) { PsiElement arrayKey = psiElement . getContext ( ) ; if ( arrayKey != null ) { PsiElement arrayCreationExpression = arrayKey . getContext ( ) ; if ( arrayCreationExpression instanceof ArrayCreationExpression ) { return ( ArrayCreationExpression ) arrayCreationExpression ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | public static Collection < PhpClass > getClassFromPhpTypeSet ( Project project , Set < String > types ) { PhpType phpType = new PhpType ( ) ; phpType . add ( types ) ; List < PhpClass > phpClasses = new ArrayList < PhpClass > ( ) ; for ( String typeName : PhpIndex . getInstance ( project ) . completeType ( project , phpType , new HashSet < String > ( ) ) . getTypes ( ) ) { if ( typeName . startsWith ( " \ \" ) ) { PhpClass phpClass = PhpElementsUtil . getClassInterface ( project , typeName ) ; if ( phpClass != null ) { phpClasses . add ( phpClass ) ; } } } return phpClasses ; }
issei-m/idea-php-symfony2-plugin | public static Collection < PhpClass > getClassFromPhpTypeSetArrayClean ( Project project , Set < String > types ) { PhpType phpType = new PhpType ( ) ; phpType . add ( types ) ; ArrayList < PhpClass > phpClasses = new ArrayList < PhpClass > ( ) ; for ( String typeName : PhpIndex . getInstance ( project ) . completeType ( project , phpType , new HashSet < String > ( ) ) . getTypes ( ) ) { if ( typeName . startsWith ( " \ \" ) ) { if ( typeName . endsWith ( " [ ] " ) ) { typeName = typeName . substring ( 0 , typeName . length ( ) - 2 ) ; } PhpClass phpClass = PhpElementsUtil . getClassInterface ( project , typeName ) ; if ( phpClass != null ) { phpClasses . add ( phpClass ) ; } } } return phpClasses ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static PhpClass getFirstClassFromFile ( PhpFile phpFile ) { Collection < PhpClass > phpClasses = PsiTreeUtil . collectElementsOfType ( phpFile , PhpClass . class ) ; return phpClasses . size ( ) == 0 ? null : phpClasses . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | public static boolean isEqualClassName ( @ Nullable PhpClass phpClass , @ Nullable String ... compareClassNames ) { for ( String className : compareClassNames ) { if ( isEqualClassName ( phpClass , className ) ) { return true ; } } return false ; }
issei-m/idea-php-symfony2-plugin | public static boolean isEqualClassName ( @ NotNull PhpClass phpClass , @ NotNull PhpClass compareClassName ) { return isEqualClassName ( phpClass , compareClassName . getPresentableFQN ( ) ) ; }
issei-m/idea-php-symfony2-plugin | public static boolean isEqualClassName ( @ Nullable PhpClass phpClass , @ Nullable String compareClassName ) { if ( phpClass == null || compareClassName == null ) { return false ; } String phpClassName = phpClass . getPresentableFQN ( ) ; if ( phpClassName == null ) { return false ; } if ( phpClassName . startsWith ( " \ \" ) ) { phpClassName = phpClassName . substring ( 1 ) ; } if ( compareClassName . startsWith ( " \ \" ) ) { compareClassName = compareClassName . substring ( 1 ) ; } return phpClassName . equals ( compareClassName ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static PsiElement [ ] getMethodParameterReferences ( Method method , int parameterIndex ) { Parameter [ ] parameters = method . getParameters ( ) ; if ( parameters . length == 0 || parameterIndex >= parameters . length ) { return null ; } final String tempVariableName = parameters [ parameterIndex ] . getName ( ) ; return PsiTreeUtil . collectElements ( method . getLastChild ( ) , new PsiElementFilter ( ) { @ Override public boolean isAccepted ( PsiElement element ) { return element instanceof Variable && tempVariableName . equals ( ( ( Variable ) element ) . getName ( ) ) ; } } ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static MethodReferenceBag getMethodParameterReferenceBag ( PsiElement psiElement , int wantIndex ) { PsiElement variableContext = psiElement . getContext ( ) ; if ( ! ( variableContext instanceof ParameterList ) ) { return null ; } ParameterList parameterList = ( ParameterList ) variableContext ; if ( ! ( parameterList . getContext ( ) instanceof MethodReference ) ) { return null ; } ParameterBag currentIndex = PsiElementUtils . getCurrentParameterIndex ( psiElement ) ; if ( currentIndex == null ) { return null ; } if ( wantIndex >= 0 && currentIndex . getIndex ( ) != wantIndex ) { return null ; } return new MethodReferenceBag ( parameterList , ( MethodReference ) parameterList . getContext ( ) , currentIndex ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static MethodReferenceBag getMethodParameterReferenceBag ( PsiElement psiElement ) { return getMethodParameterReferenceBag ( psiElement , - 1 ) ; }
issei-m/idea-php-symfony2-plugin | public static List < Variable > getVariableReferencesInScope ( final Variable variable , final boolean includeSelf ) { final List < Variable > variables = new ArrayList < Variable > ( ) ; Variable variableDecl = null ; if ( ! variable . isDeclaration ( ) ) { PsiElement psiElement = variable . resolve ( ) ; if ( psiElement instanceof Variable ) { variableDecl = ( Variable ) psiElement ; } } else { variableDecl = variable ; } if ( variableDecl == null ) { return variables ; } Method method = PsiTreeUtil . getParentOfType ( variable , Method . class ) ; PhpPsiUtil . hasReferencesInSearchScope ( method . getUseScope ( ) , variableDecl , new CommonProcessors . FindProcessor < PsiReference > ( ) { @ Override protected boolean accept ( PsiReference psiReference ) { PsiElement variableRef = psiReference . getElement ( ) ; if ( variableRef instanceof Variable ) { if ( includeSelf ) { variables . add ( ( Variable ) variableRef ) ; } else { if ( ! variableRef . equals ( variable ) ) { variables . add ( ( Variable ) variableRef ) ; } } } return false ; } } ) ; return variables ; }
issei-m/idea-php-symfony2-plugin | public static void visitNamespaceClassForCompletion ( PsiElement psiElement , int cursorOffset , ClassForCompletionVisitor visitor ) { int cursorOffsetClean = cursorOffset - psiElement . getTextOffset ( ) ; if ( cursorOffsetClean < 1 ) { return ; } String content = psiElement . getText ( ) ; int length = content . length ( ) ; if ( ! ( length >= cursorOffsetClean ) ) { return ; } String beforeCursor = content . substring ( 0 , cursorOffsetClean ) ; boolean isValid ; String namespace = beforeCursor ; int lastSlash = beforeCursor . lastIndexOf ( " \ \" ) ; if ( lastSlash <= 0 ) { isValid = PhpIndexUtil . hasNamespace ( psiElement . getProject ( ) , beforeCursor ) ; } else { isValid = true ; namespace = beforeCursor . substring ( 0 , lastSlash ) ; } if ( ! isValid ) { return ; } String prefix = " " ; if ( namespace . startsWith ( " \ \" ) ) { prefix = " \ \" ; } else { namespace = " \ \" + namespace ; } for ( PhpClass phpClass : PhpIndexUtil . getPhpClassInsideNamespace ( psiElement . getProject ( ) , namespace ) ) { String presentableFQN = phpClass . getPresentableFQN ( ) ; if ( presentableFQN != null && fr . adrienbrault . idea . symfony2plugin . util . StringUtils . startWithEqualClassname ( presentableFQN , beforeCursor ) ) { visitor . visit ( phpClass , presentableFQN , prefix ) ; } } }
issei-m/idea-php-symfony2-plugin | @ Nullable private static PhpClass getNewExpressionPhpClass ( @ NotNull NewExpression newExpression ) { ClassReference classReference = newExpression . getClassReference ( ) ; if ( classReference != null ) { String fqn = classReference . getFQN ( ) ; if ( fqn != null ) { return PhpElementsUtil . getClass ( newExpression . getProject ( ) , fqn ) ; } } return null ; }
issei-m/idea-php-symfony2-plugin | public static PhpClass getNewExpressionPhpClassWithInstance ( @ NotNull NewExpression newExpression , @ NotNull String instance ) { PhpClass phpClass = getNewExpressionPhpClass ( newExpression ) ; if ( phpClass != null && new Symfony2InterfacesUtil ( ) . isInstanceOf ( phpClass , instance ) ) { return phpClass ; } return null ; }
issei-m/idea-php-symfony2-plugin | public static boolean isNewExpressionPhpClassWithInstance ( @ NotNull NewExpression newExpression , @ NotNull String instance ) { return getNewExpressionPhpClassWithInstance ( newExpression , instance ) != null ; }
issei-m/idea-php-symfony2-plugin | @ NotNull public static Collection < PsiElement > collectMethodElementsWithParents ( final @ NotNull Method method , @ NotNull final Processor < PsiElement > processor ) { Collection < PsiElement > elements = new HashSet < PsiElement > ( ) ; collectMethodElementsWithParents ( method , 3 , elements , processor ) ; return elements ; }
issei-m/idea-php-symfony2-plugin | private static void collectMethodElementsWithParents ( final @ NotNull Method method , final int depth , @ NotNull final Collection < PsiElement > elements , @ NotNull final Processor < PsiElement > processor ) { method . acceptChildren ( new PsiRecursiveElementWalkingVisitor ( ) { @ Override public void visitElement ( PsiElement psiElement ) { if ( processor . process ( psiElement ) ) { elements . add ( psiElement ) ; } if ( psiElement instanceof MethodReference && ( ( MethodReference ) psiElement ) . getReferenceType ( ) == PhpModifier . State . PARENT && method . getName ( ) . equals ( ( ( MethodReference ) psiElement ) . getName ( ) ) ) { PsiElement resolve = ( ( MethodReference ) psiElement ) . resolve ( ) ; if ( depth > 0 && resolve instanceof Method ) { collectMethodElementsWithParents ( ( Method ) resolve , depth - 1 , elements , processor ) ; } } super . visitElement ( psiElement ) ; } } ) ; }
issei-m/idea-php-symfony2-plugin | @ NotNull public static Parameter [ ] getFunctionRequiredParameter ( @ NotNull Function function ) { Parameter [ ] parameters = function . getParameters ( ) ; if ( parameters . length == 0 ) { return new Parameter [ 0 ] ; } int last = - 1 ; for ( int i = parameters . length - 1 ; i >= 0 ; i -- ) { if ( ! parameters [ i ] . isOptional ( ) ) { last = i ; break ; } } if ( last == - 1 ) { return new Parameter [ 0 ] ; } return Arrays . copyOfRange ( parameters , 0 , last + 1 ) ; }
issei-m/idea-php-symfony2-plugin | public static boolean isTestClass ( @ NotNull PhpClass phpClass ) { if ( PhpUnitUtil . isTestClass ( phpClass ) ) { return true ; } String fqn = phpClass . getPresentableFQN ( ) ; if ( fqn == null ) { return false ; } return fqn . contains ( " \\ Test\ \" ) || fqn . contains ( " \\ Tests\ \" ) ; }
jjhaggar/libGDX-flixel-test-autogenerated | public static void main ( String [ ] args ) { new FlxDesktopApplication ( new com . yourname . flixelgame . examples . bloom . FlxBloom ( ) , 640 , 480 ) ; }
username115/FRCScouting | public static String getSavedPassword ( Context context ) { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " passPref " , " " ) ; }
username115/FRCScouting | public static String getScoutingURL ( Context context ) { String ret = PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " databaseURLPref " , URL ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } return ret ; }
username115/FRCScouting | public static String getScoutingURLNoDefault ( Context context ) { String ret = PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " databaseURLPref " , " " ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } return ret ; }
username115/FRCScouting | public static String getEvent ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " eventPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getRobotPicPref ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " robotPicPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getPracticeMatch ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " practiceMatchPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static String getDefaultTeamNumber ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " teamPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getAutoSync ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " enableSyncPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static String getPosition ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " positionPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static Boolean getRedLeft ( Context context , Boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " redLeft " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static void setRedLeft ( Context context , boolean redLeft ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( " redLeft " , redLeft ) ; editor . apply ( ) ; }
username115/FRCScouting | public static int getMilliSecondsBetweenSyncs ( Context context , final int defaultValue ) { try { String val = PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " syncFreqPref " , " " ) ; int secs ; if ( val == null || val . length ( ) == 0 ) return defaultValue ; try { secs = Integer . parseInt ( val . split ( " ▁ " ) [ 0 ] ) * 60 * 1000 ; } catch ( NumberFormatException e ) { return defaultValue ; } return secs ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getDontPrompt ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " doNotAskURL " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static void setDontPrompt ( Context context , boolean dontPrompt ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( " doNotAskURL " , dontPrompt ) ; editor . apply ( ) ; }
username115/FRCScouting | public static String getDeviceName ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " deviceName " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
jk1/intellij-community | public static boolean match ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull TypeEvalContext context ) { return match ( expected , actual , new MatchContext ( context , new HashMap < > ( ) ) ) . orElse ( true ) ; }
jk1/intellij-community | public static boolean match ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull TypeEvalContext context , @ NotNull Map < PyGenericType , PyType > substitutions ) { return match ( expected , actual , new MatchContext ( context , substitutions ) ) . orElse ( true ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull MatchContext context ) { final Pair < PyType , PyType > types = Pair . create ( expected , actual ) ; if ( context . matching . contains ( types ) ) return Optional . of ( true ) ; context . matching . add ( types ) ; final Optional < Boolean > result = matchImpl ( expected , actual , context ) ; context . matching . remove ( types ) ; return result ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > matchImpl ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull MatchContext context ) { if ( expected instanceof PyClassType ) { Optional < Boolean > match = matchObject ( ( PyClassType ) expected , actual ) ; if ( match . isPresent ( ) ) { return match ; } } if ( expected instanceof PyInstantiableType && actual instanceof PyInstantiableType ) { Optional < Boolean > match = match ( ( PyInstantiableType ) expected , ( PyInstantiableType ) actual , context ) ; if ( match . isPresent ( ) ) { return match ; } } if ( expected instanceof PyGenericType ) { return Optional . of ( match ( ( PyGenericType ) expected , actual , context ) ) ; } if ( expected == null || actual == null || isUnknown ( actual , context . context ) ) { return Optional . of ( true ) ; } if ( actual instanceof PyUnionType ) { return Optional . of ( match ( expected , ( PyUnionType ) actual , context ) ) ; } if ( expected instanceof PyUnionType ) { return Optional . of ( match ( ( PyUnionType ) expected , actual , context ) ) ; } if ( expected instanceof PyClassType && actual instanceof PyClassType ) { Optional < Boolean > match = match ( ( PyClassType ) expected , ( PyClassType ) actual , context ) ; if ( match . isPresent ( ) ) { return match ; } } if ( actual instanceof PyStructuralType && ( ( PyStructuralType ) actual ) . isInferredFromUsages ( ) ) { return Optional . of ( true ) ; } if ( expected instanceof PyStructuralType ) { return Optional . of ( match ( ( PyStructuralType ) expected , actual , context . context ) ) ; } if ( actual instanceof PyStructuralType && expected instanceof PyClassType ) { final Set < String > expectedAttributes = ( ( PyClassType ) expected ) . getMemberNames ( true , context . context ) ; return Optional . of ( expectedAttributes . containsAll ( ( ( PyStructuralType ) actual ) . getAttributeNames ( ) ) ) ; } if ( actual instanceof PyCallableType && expected instanceof PyCallableType ) { final PyCallableType expectedCallable = ( PyCallableType ) expected ; final PyCallableType actualCallable = ( PyCallableType ) actual ; final Optional < Boolean > match = match ( expectedCallable , actualCallable , context ) ; if ( match . isPresent ( ) ) { return match ; } } return Optional . of ( matchNumericTypes ( expected , actual ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > matchObject ( @ NotNull PyClassType expected , @ Nullable PyType actual ) { if ( ArrayUtil . contains ( expected . getName ( ) , PyNames . OBJECT , PyNames . TYPE ) ) { final PyBuiltinCache builtinCache = PyBuiltinCache . getInstance ( expected . getPyClass ( ) ) ; if ( expected . equals ( builtinCache . getObjectType ( ) ) ) { return Optional . of ( true ) ; } if ( expected . equals ( builtinCache . getTypeType ( ) ) && actual instanceof PyInstantiableType && ( ( PyInstantiableType ) actual ) . isDefinition ( ) ) { return Optional . of ( true ) ; } } return Optional . empty ( ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyInstantiableType expected , @ NotNull PyInstantiableType actual , @ NotNull MatchContext context ) { if ( expected instanceof PyGenericType && typeVarAcceptsBothClassAndInstanceTypes ( ( PyGenericType ) expected ) ) { return Optional . empty ( ) ; } if ( expected . isDefinition ( ) ^ actual . isDefinition ( ) ) { if ( actual . isDefinition ( ) && actual instanceof PyClassLikeType && matchClassObjectAndMetaclass ( expected , ( PyClassLikeType ) actual , context ) ) { return Optional . of ( true ) ; } return Optional . of ( false ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyGenericType expected , @ Nullable PyType actual , @ NotNull MatchContext context ) { final PyType substitution = context . substitutions . get ( expected ) ; PyType bound = expected . getBound ( ) ; if ( expected . isDefinition ( ) && bound instanceof PyInstantiableType ) { bound = ( ( PyInstantiableType ) bound ) . toClass ( ) ; } Optional < Boolean > match = match ( bound , actual , context ) ; if ( match . isPresent ( ) && ! match . get ( ) ) { return false ; } if ( substitution != null ) { if ( expected . equals ( actual ) || substitution . equals ( expected ) ) { return true ; } if ( context . recursive ) { Optional < Boolean > recursiveMatch = match ( substitution , actual , context . notRecursive ( ) ) ; if ( recursiveMatch . isPresent ( ) ) { return recursiveMatch . get ( ) ; } } return false ; } if ( actual != null ) { context . substitutions . put ( expected , actual ) ; } else if ( bound != null ) { context . substitutions . put ( expected , bound ) ; } return true ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyType expected , @ NotNull PyUnionType actual , @ NotNull MatchContext context ) { if ( expected instanceof PyTupleType ) { Optional < Boolean > match = match ( ( PyTupleType ) expected , actual , context ) ; if ( match . isPresent ( ) ) { return match . get ( ) ; } } return StreamEx . of ( actual . getMembers ( ) ) . anyMatch ( type -> match ( expected , type , context ) . orElse ( false ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyTupleType expected , @ NotNull PyUnionType actual , @ NotNull MatchContext context ) { final int elementCount = expected . getElementCount ( ) ; if ( ! expected . isHomogeneous ( ) && consistsOfSameElementNumberTuples ( actual , elementCount ) ) { return Optional . of ( substituteExpectedElementsWithUnions ( expected , elementCount , actual , context ) ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyUnionType expected , @ NotNull PyType actual , @ NotNull MatchContext context ) { return StreamEx . of ( expected . getMembers ( ) ) . anyMatch ( type -> match ( type , actual , context ) . orElse ( true ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyClassType expected , @ NotNull PyClassType actual , @ NotNull MatchContext context ) { if ( expected . equals ( actual ) ) { return Optional . of ( true ) ; } if ( expected instanceof PyTupleType && actual instanceof PyTupleType ) { return match ( ( PyTupleType ) expected , ( PyTupleType ) actual , context ) ; } final PyClass superClass = expected . getPyClass ( ) ; final PyClass subClass = actual . getPyClass ( ) ; final boolean matchClasses = matchClasses ( superClass , subClass , context . context ) ; if ( PyProtocolsKt . isProtocol ( expected , context . context ) && ! matchClasses ) { if ( expected instanceof PyCollectionType && ! matchGenerics ( ( PyCollectionType ) expected , actual , context ) ) { return Optional . of ( false ) ; } for ( kotlin . Pair < PyTypedElement , List < RatedResolveResult > > pair : inspectProtocolSubclass ( expected , actual , context . context ) ) { final List < RatedResolveResult > subclassElements = pair . getSecond ( ) ; if ( ContainerUtil . isEmpty ( subclassElements ) ) { return Optional . of ( false ) ; } final PyType protocolElementType = context . context . getType ( pair . getFirst ( ) ) ; final boolean elementResult = StreamEx . of ( subclassElements ) . map ( ResolveResult :: getElement ) . select ( PyTypedElement . class ) . map ( context . context :: getType ) . anyMatch ( subclassElementType -> match ( protocolElementType , subclassElementType , context ) . orElse ( true ) ) ; if ( ! elementResult ) { return Optional . of ( false ) ; } } final PyType originalProtocolGenericType = StreamEx . of ( Extensions . getExtensions ( PyTypeProvider . EP_NAME ) ) . map ( provider -> provider . getGenericType ( superClass , context . context ) ) . findFirst ( Objects :: nonNull ) . orElse ( null ) ; match ( expected , originalProtocolGenericType , context ) ; return Optional . of ( true ) ; } if ( expected instanceof PyCollectionType ) { return Optional . of ( match ( ( PyCollectionType ) expected , actual , context ) ) ; } if ( matchClasses ) { if ( expected instanceof PyTypingNewType && ! expected . equals ( actual ) && superClass . equals ( subClass ) ) { return Optional . of ( actual . getAncestorTypes ( context . context ) . contains ( expected ) ) ; } return Optional . of ( true ) ; } if ( expected . equals ( actual ) ) { return Optional . of ( true ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyTupleType expected , @ NotNull PyTupleType actual , @ NotNull MatchContext context ) { if ( ! expected . isHomogeneous ( ) && ! actual . isHomogeneous ( ) ) { if ( expected . getElementCount ( ) != actual . getElementCount ( ) ) { return Optional . of ( false ) ; } for ( int i = 0 ; i < expected . getElementCount ( ) ; i ++ ) { if ( ! match ( expected . getElementType ( i ) , actual . getElementType ( i ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } return Optional . of ( true ) ; } if ( expected . isHomogeneous ( ) && ! actual . isHomogeneous ( ) ) { final PyType expectedElementType = expected . getIteratedItemType ( ) ; for ( int i = 0 ; i < actual . getElementCount ( ) ; i ++ ) { if ( ! match ( expectedElementType , actual . getElementType ( i ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } return Optional . of ( true ) ; } if ( ! expected . isHomogeneous ( ) && actual . isHomogeneous ( ) ) { return Optional . of ( false ) ; } return match ( expected . getIteratedItemType ( ) , actual . getIteratedItemType ( ) , context ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyCollectionType expected , @ NotNull PyClassType actual , @ NotNull MatchContext context ) { if ( actual instanceof PyTupleType ) { return match ( expected , ( PyTupleType ) actual , context ) ; } final PyClass superClass = expected . getPyClass ( ) ; final PyClass subClass = actual . getPyClass ( ) ; return matchClasses ( superClass , subClass , context . context ) && matchGenerics ( expected , actual , context ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyCollectionType expected , @ NotNull PyTupleType actual , @ NotNull MatchContext context ) { if ( ! matchClasses ( expected . getPyClass ( ) , actual . getPyClass ( ) , context . context ) ) { return false ; } final PyType superElementType = expected . getIteratedItemType ( ) ; final PyType subElementType = actual . getIteratedItemType ( ) ; if ( ! match ( superElementType , subElementType , context ) . orElse ( true ) ) { return false ; } return true ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyStructuralType expected , @ NotNull PyType actual , @ NotNull TypeEvalContext context ) { if ( actual instanceof PyStructuralType ) { return match ( expected , ( PyStructuralType ) actual ) ; } if ( actual instanceof PyClassType ) { return match ( expected , ( PyClassType ) actual , context ) ; } if ( actual instanceof PyModuleType ) { final PyFile module = ( ( PyModuleType ) actual ) . getModule ( ) ; if ( module . getLanguageLevel ( ) . isAtLeast ( LanguageLevel . PYTHON37 ) && definesGetAttr ( module , context ) ) { return true ; } } final PyResolveContext resolveContext = PyResolveContext . noImplicits ( ) . withTypeEvalContext ( context ) ; return StreamEx . of ( expected . getAttributeNames ( ) ) . noneMatch ( attribute -> ContainerUtil . isEmpty ( actual . resolveMember ( attribute , null , AccessDirection . READ , resolveContext ) ) ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyStructuralType expected , @ NotNull PyStructuralType actual ) { if ( expected . isInferredFromUsages ( ) ) { return true ; } return expected . getAttributeNames ( ) . containsAll ( actual . getAttributeNames ( ) ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyStructuralType expected , @ NotNull PyClassType actual , @ NotNull TypeEvalContext context ) { if ( overridesGetAttr ( actual . getPyClass ( ) , context ) ) { return true ; } final Set < String > actualAttributes = actual . getMemberNames ( true , context ) ; return actualAttributes . containsAll ( expected . getAttributeNames ( ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyCallableType expected , @ NotNull PyCallableType actual , @ NotNull MatchContext context ) { if ( expected . isCallable ( ) && actual . isCallable ( ) ) { final List < PyCallableParameter > expectedParameters = expected . getParameters ( context . context ) ; final List < PyCallableParameter > actualParameters = actual . getParameters ( context . context ) ; if ( expectedParameters != null && actualParameters != null ) { final int size = Math . min ( expectedParameters . size ( ) , actualParameters . size ( ) ) ; for ( int i = 0 ; i < size ; i ++ ) { final PyCallableParameter expectedParam = expectedParameters . get ( i ) ; final PyCallableParameter actualParam = actualParameters . get ( i ) ; if ( ! match ( expectedParam . getType ( context . context ) , actualParam . getType ( context . context ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } } if ( ! match ( expected . getReturnType ( context . context ) , actual . getReturnType ( context . context ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } return Optional . of ( true ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | private static boolean matchClassObjectAndMetaclass ( @ NotNull PyType expected , @ NotNull PyClassLikeType actual , @ NotNull MatchContext context ) { if ( ! actual . isDefinition ( ) ) { return false ; } final PyClassLikeType metaClass = actual . getMetaClassType ( context . context , true ) ; return metaClass != null && match ( expected , metaClass , context ) . orElse ( true ) ; }
jk1/intellij-community | private static boolean typeVarAcceptsBothClassAndInstanceTypes ( @ NotNull PyGenericType typeVar ) { return ! typeVar . isDefinition ( ) && typeVar . getBound ( ) == null ; }
jk1/intellij-community | private static boolean consistsOfSameElementNumberTuples ( @ NotNull PyUnionType unionType , int elementCount ) { for ( PyType type : unionType . getMembers ( ) ) { if ( type instanceof PyTupleType ) { final PyTupleType tupleType = ( PyTupleType ) type ; if ( ! tupleType . isHomogeneous ( ) && elementCount != tupleType . getElementCount ( ) ) { return false ; } } else { return false ; } } return true ; }
jk1/intellij-community | private static boolean substituteExpectedElementsWithUnions ( @ NotNull PyTupleType expected , int elementCount , @ NotNull PyUnionType actual , @ NotNull MatchContext context ) { for ( int i = 0 ; i < elementCount ; i ++ ) { final int currentIndex = i ; final PyType elementType = PyUnionType . union ( StreamEx . of ( actual . getMembers ( ) ) . select ( PyTupleType . class ) . map ( type -> type . getElementType ( currentIndex ) ) . toList ( ) ) ; if ( ! match ( expected . getElementType ( i ) , elementType , context ) . orElse ( true ) ) { return false ; } } return true ; }
jk1/intellij-community | private static boolean matchGenerics ( @ NotNull PyCollectionType expected , @ NotNull PyType actual , @ NotNull MatchContext context ) { final List < PyType > superElementTypes = expected . getElementTypes ( ) ; final PyCollectionType actualCollectionType = as ( actual , PyCollectionType . class ) ; final List < PyType > subElementTypes = actualCollectionType != null ? actualCollectionType . getElementTypes ( ) : Collections . emptyList ( ) ; for ( int i = 0 ; i < superElementTypes . size ( ) ; i ++ ) { final PyType subElementType = i < subElementTypes . size ( ) ? subElementTypes . get ( i ) : null ; if ( ! match ( superElementTypes . get ( i ) , subElementType , context ) . orElse ( true ) ) { return false ; } } return true ; }
jk1/intellij-community | private static boolean matchNumericTypes ( PyType expected , PyType actual ) { final String superName = expected . getName ( ) ; final String subName = actual . getName ( ) ; final boolean subIsBool = " bool " . equals ( subName ) ; final boolean subIsInt = PyNames . TYPE_INT . equals ( subName ) ; final boolean subIsLong = PyNames . TYPE_LONG . equals ( subName ) ; final boolean subIsFloat = " float " . equals ( subName ) ; final boolean subIsComplex = " complex " . equals ( subName ) ; if ( superName == null || subName == null || superName . equals ( subName ) || ( PyNames . TYPE_INT . equals ( superName ) && subIsBool ) || ( ( PyNames . TYPE_LONG . equals ( superName ) || PyNames . ABC_INTEGRAL . equals ( superName ) ) && ( subIsBool || subIsInt ) ) || ( ( " float " . equals ( superName ) || PyNames . ABC_REAL . equals ( superName ) ) && ( subIsBool || subIsInt || subIsLong ) ) || ( ( " complex " . equals ( superName ) || PyNames . ABC_COMPLEX . equals ( superName ) ) && ( subIsBool || subIsInt || subIsLong || subIsFloat ) ) || ( PyNames . ABC_NUMBER . equals ( superName ) && ( subIsBool || subIsInt || subIsLong || subIsFloat || subIsComplex ) ) ) { return true ; } return false ; }
jk1/intellij-community | public static boolean isUnknown ( @ Nullable PyType type , @ NotNull TypeEvalContext context ) { return isUnknown ( type , true , context ) ; }
jk1/intellij-community | public static boolean isUnknown ( @ Nullable PyType type , boolean genericsAreUnknown , @ NotNull TypeEvalContext context ) { if ( type == null || ( genericsAreUnknown && type instanceof PyGenericType ) ) { return true ; } if ( type instanceof PyFunctionType ) { final PyCallable callable = ( ( PyFunctionType ) type ) . getCallable ( ) ; if ( callable instanceof PyDecoratable && PyKnownDecoratorUtil . hasUnknownOrChangingReturnTypeDecorator ( ( PyDecoratable ) callable , context ) ) { return true ; } } if ( type instanceof PyUnionType ) { final PyUnionType union = ( PyUnionType ) type ; for ( PyType t : union . getMembers ( ) ) { if ( isUnknown ( t , genericsAreUnknown , context ) ) { return true ; } } } return false ; }
jk1/intellij-community | @ Nullable public static PyType toNonWeakType ( @ Nullable PyType type , @ NotNull TypeEvalContext context ) { if ( type instanceof PyUnionType ) { final PyUnionType unionType = ( PyUnionType ) type ; if ( unionType . isWeak ( ) ) { return unionType . excludeNull ( context ) ; } } return type ; }
jk1/intellij-community | public static boolean hasGenerics ( @ Nullable PyType type , @ NotNull TypeEvalContext context ) { final Set < PyGenericType > collected = new HashSet < > ( ) ; collectGenerics ( type , context , collected , new HashSet < > ( ) ) ; return ! collected . isEmpty ( ) ; }
jk1/intellij-community | private static void collectGenerics ( @ Nullable PyType type , @ NotNull TypeEvalContext context , @ NotNull Set < PyGenericType > collected , @ NotNull Set < PyType > visited ) { if ( visited . contains ( type ) ) { return ; } visited . add ( type ) ; if ( type instanceof PyGenericType ) { collected . add ( ( PyGenericType ) type ) ; } else if ( type instanceof PyUnionType ) { final PyUnionType union = ( PyUnionType ) type ; for ( PyType t : union . getMembers ( ) ) { collectGenerics ( t , context , collected , visited ) ; } } else if ( type instanceof PyTupleType ) { final PyTupleType tuple = ( PyTupleType ) type ; final int n = tuple . isHomogeneous ( ) ? 1 : tuple . getElementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { collectGenerics ( tuple . getElementType ( i ) , context , collected , visited ) ; } } else if ( type instanceof PyCollectionType ) { final PyCollectionType collection = ( PyCollectionType ) type ; for ( PyType elementType : collection . getElementTypes ( ) ) { collectGenerics ( elementType , context , collected , visited ) ; } } else if ( type instanceof PyCallableType ) { final PyCallableType callable = ( PyCallableType ) type ; final List < PyCallableParameter > parameters = callable . getParameters ( context ) ; if ( parameters != null ) { for ( PyCallableParameter parameter : parameters ) { if ( parameter != null ) { collectGenerics ( parameter . getType ( context ) , context , collected , visited ) ; } } } collectGenerics ( callable . getReturnType ( context ) , context , collected , visited ) ; } }
jk1/intellij-community | @ Nullable public static PyType substitute ( @ Nullable PyType type , @ NotNull Map < PyGenericType , PyType > substitutions , @ NotNull TypeEvalContext context ) { if ( hasGenerics ( type , context ) ) { if ( type instanceof PyGenericType ) { final PyGenericType typeVar = ( PyGenericType ) type ; PyType substitution = substitutions . get ( typeVar ) ; if ( substitution == null ) { if ( ! typeVar . isDefinition ( ) ) { final PyInstantiableType < ? > classType = as ( substitutions . get ( typeVar . toClass ( ) ) , PyInstantiableType . class ) ; if ( classType != null ) { substitution = classType . toInstance ( ) ; } } else { final PyInstantiableType < ? > instanceType = as ( substitutions . get ( typeVar . toInstance ( ) ) , PyInstantiableType . class ) ; if ( instanceType != null ) { substitution = instanceType . toClass ( ) ; } } } if ( substitution instanceof PyGenericType && ! typeVar . equals ( substitution ) && substitutions . containsKey ( substitution ) ) { return substitute ( substitution , substitutions , context ) ; } return substitution ; } else if ( type instanceof PyUnionType ) { final PyUnionType union = ( PyUnionType ) type ; final List < PyType > results = new ArrayList < > ( ) ; for ( PyType t : union . getMembers ( ) ) { final PyType subst = substitute ( t , substitutions , context ) ; results . add ( subst ) ; } return PyUnionType . union ( results ) ; } else if ( type instanceof PyCollectionTypeImpl ) { final PyCollectionTypeImpl collection = ( PyCollectionTypeImpl ) type ; final List < PyType > elementTypes = collection . getElementTypes ( ) ; final List < PyType > substitutes = new ArrayList < > ( ) ; for ( PyType elementType : elementTypes ) { substitutes . add ( substitute ( elementType , substitutions , context ) ) ; } return new PyCollectionTypeImpl ( collection . getPyClass ( ) , collection . isDefinition ( ) , substitutes ) ; } else if ( type instanceof PyTupleType ) { final PyTupleType tupleType = ( PyTupleType ) type ; final PyClass tupleClass = tupleType . getPyClass ( ) ; final List < PyType > oldElementTypes = tupleType . isHomogeneous ( ) ? Collections . singletonList ( tupleType . getIteratedItemType ( ) ) : tupleType . getElementTypes ( ) ; final List < PyType > newElementTypes = ContainerUtil . map ( oldElementTypes , elementType -> substitute ( elementType , substitutions , context ) ) ; return new PyTupleType ( tupleClass , newElementTypes , tupleType . isHomogeneous ( ) ) ; } else if ( type instanceof PyCallableType ) { final PyCallableType callable = ( PyCallableType ) type ; List < PyCallableParameter > substParams = null ; final List < PyCallableParameter > parameters = callable . getParameters ( context ) ; if ( parameters != null ) { substParams = new ArrayList < > ( ) ; for ( PyCallableParameter parameter : parameters ) { final PyType substType = substitute ( parameter . getType ( context ) , substitutions , context ) ; final PyParameter psi = parameter . getParameter ( ) ; final PyCallableParameter subst = psi != null ? PyCallableParameterImpl . psi ( psi , substType ) : PyCallableParameterImpl . nonPsi ( parameter . getName ( ) , substType , parameter . getDefaultValue ( ) ) ; substParams . add ( subst ) ; } } final PyType substResult = substitute ( callable . getReturnType ( context ) , substitutions , context ) ; return new PyCallableTypeImpl ( substParams , substResult ) ; } } return type ; }
jk1/intellij-community | @ Nullable public static Map < PyGenericType , PyType > unifyGenericCall ( @ Nullable PyExpression receiver , @ NotNull Map < PyExpression , PyCallableParameter > arguments , @ NotNull TypeEvalContext context ) { final Map < PyGenericType , PyType > substitutions = unifyReceiver ( receiver , context ) ; for ( Map . Entry < PyExpression , PyCallableParameter > entry : getRegularMappedParameters ( arguments ) . entrySet ( ) ) { final PyCallableParameter paramWrapper = entry . getValue ( ) ; PyType actualType = context . getType ( entry . getKey ( ) ) ; if ( paramWrapper . isSelf ( ) ) { final PyParameter param = paramWrapper . getParameter ( ) ; final PyFunction function = as ( ScopeUtil . getScopeOwner ( param ) , PyFunction . class ) ; if ( function != null && function . getModifier ( ) == PyFunction . Modifier . CLASSMETHOD ) { final StreamEx < PyType > types ; if ( actualType instanceof PyUnionType ) { types = StreamEx . of ( ( ( PyUnionType ) actualType ) . getMembers ( ) ) ; } else { types = StreamEx . of ( actualType ) ; } actualType = types . select ( PyClassLikeType . class ) . map ( PyClassLikeType :: toClass ) . select ( PyType . class ) . foldLeft ( PyUnionType :: union ) . orElse ( actualType ) ; } } final PyType expectedType = paramWrapper . getArgumentType ( context ) ; if ( ! match ( expectedType , actualType , context , substitutions ) ) { return null ; } } if ( ! matchContainer ( getMappedPositionalContainer ( arguments ) , getArgumentsMappedToPositionalContainer ( arguments ) , substitutions , context ) ) { return null ; } if ( ! matchContainer ( getMappedKeywordContainer ( arguments ) , getArgumentsMappedToKeywordContainer ( arguments ) , substitutions , context ) ) { return null ; } return substitutions ; }
jk1/intellij-community | private static boolean matchContainer ( @ Nullable PyCallableParameter container , @ NotNull List < PyExpression > arguments , @ NotNull Map < PyGenericType , PyType > substitutions , @ NotNull TypeEvalContext context ) { if ( container == null ) { return true ; } final List < PyType > types = ContainerUtil . map ( arguments , context :: getType ) ; return match ( container . getArgumentType ( context ) , PyUnionType . union ( types ) , context , substitutions ) ; }
jk1/intellij-community | @ NotNull public static Map < PyGenericType , PyType > unifyReceiver ( @ Nullable PyExpression receiver , @ NotNull TypeEvalContext context ) { final Map < PyGenericType , PyType > substitutions = new LinkedHashMap < > ( ) ; final Set < PyGenericType > generics = new LinkedHashSet < > ( ) ; final PyType qualifierType = receiver != null ? context . getType ( receiver ) : null ; collectGenerics ( qualifierType , context , generics , new HashSet < > ( ) ) ; for ( PyGenericType t : generics ) { substitutions . put ( t , t ) ; } if ( qualifierType != null ) { for ( PyClassType type : toPossibleClassTypes ( qualifierType ) ) { for ( PyTypeProvider provider : Extensions . getExtensions ( PyTypeProvider . EP_NAME ) ) { final PyType genericType = provider . getGenericType ( type . getPyClass ( ) , context ) ; final Set < PyGenericType > providedTypeGenerics = new LinkedHashSet < > ( ) ; if ( genericType != null ) { match ( genericType , type , context , substitutions ) ; collectGenerics ( genericType , context , providedTypeGenerics , new HashSet < > ( ) ) ; } for ( Map . Entry < PyType , PyType > entry : provider . getGenericSubstitutions ( type . getPyClass ( ) , context ) . entrySet ( ) ) { final PyGenericType genericKey = as ( entry . getKey ( ) , PyGenericType . class ) ; final PyType value = entry . getValue ( ) ; if ( genericKey != null && value != null && ! substitutions . containsKey ( genericKey ) && ! providedTypeGenerics . contains ( genericKey ) ) { substitutions . put ( genericKey , value ) ; } } } } } replaceUnresolvedGenericsWithAny ( substitutions ) ; return substitutions ; }
jk1/intellij-community | @ NotNull private static List < PyClassType > toPossibleClassTypes ( @ NotNull PyType type ) { final PyClassType classType = as ( type , PyClassType . class ) ; if ( classType != null ) { return Collections . singletonList ( classType ) ; } final PyUnionType unionType = as ( type , PyUnionType . class ) ; if ( unionType != null ) { return StreamEx . of ( unionType . getMembers ( ) ) . nonNull ( ) . flatMap ( t -> toPossibleClassTypes ( t ) . stream ( ) ) . toList ( ) ; } return Collections . emptyList ( ) ; }
jk1/intellij-community | private static void replaceUnresolvedGenericsWithAny ( @ NotNull Map < PyGenericType , PyType > substitutions ) { final List < PyType > unresolvedGenerics = ContainerUtil . filter ( substitutions . values ( ) , type -> type instanceof PyGenericType && ! substitutions . containsKey ( type ) ) ; for ( PyType unresolvedGeneric : unresolvedGenerics ) { substitutions . put ( ( PyGenericType ) unresolvedGeneric , null ) ; } }
jk1/intellij-community | private static boolean matchClasses ( @ Nullable PyClass superClass , @ Nullable PyClass subClass , @ NotNull TypeEvalContext context ) { if ( superClass == null || subClass == null || subClass . isSubclass ( superClass , context ) || PyABCUtil . isSubclass ( subClass , superClass , context ) || isStrUnicodeMatch ( subClass , superClass ) || isBytearrayBytesStringMatch ( subClass , superClass ) || PyUtil . hasUnresolvedAncestors ( subClass , context ) ) { return true ; } else { final String superName = superClass . getName ( ) ; return superName != null && superName . equals ( subClass . getName ( ) ) ; } }
jk1/intellij-community | private static boolean isStrUnicodeMatch ( @ NotNull PyClass subClass , @ NotNull PyClass superClass ) { return PyNames . TYPE_STR . equals ( subClass . getName ( ) ) && PyNames . TYPE_UNICODE . equals ( superClass . getName ( ) ) ; }
jk1/intellij-community | private static boolean isBytearrayBytesStringMatch ( @ NotNull PyClass subClass , @ NotNull PyClass superClass ) { if ( ! PyNames . TYPE_BYTEARRAY . equals ( subClass . getName ( ) ) ) return false ; final PsiFile subClassFile = subClass . getContainingFile ( ) ; final boolean isPy2 = subClassFile instanceof PyiFile ? PyBuiltinCache . getInstance ( subClass ) . getObjectType ( PyNames . TYPE_UNICODE ) != null : LanguageLevel . forElement ( subClass ) . isPython2 ( ) ; final String superClassName = superClass . getName ( ) ; return isPy2 && PyNames . TYPE_STR . equals ( superClassName ) || ! isPy2 && PyNames . TYPE_BYTES . equals ( superClassName ) ; }
jk1/intellij-community | @ Nullable public static Boolean isCallable ( @ Nullable PyType type ) { if ( type == null ) { return null ; } if ( type instanceof PyUnionType ) { return isUnionCallable ( ( PyUnionType ) type ) ; } if ( type instanceof PyCallableType ) { return ( ( PyCallableType ) type ) . isCallable ( ) ; } if ( type instanceof PyStructuralType && ( ( PyStructuralType ) type ) . isInferredFromUsages ( ) ) { return true ; } return false ; }
jk1/intellij-community | @ Nullable private static Boolean isUnionCallable ( @ NotNull final PyUnionType type ) { for ( final PyType member : type . getMembers ( ) ) { final Boolean callable = isCallable ( member ) ; if ( callable == null ) { return null ; } if ( callable ) { return true ; } } return false ; }
jk1/intellij-community | public static boolean definesGetAttr ( @ NotNull PyFile file , @ NotNull TypeEvalContext context ) { if ( file instanceof PyTypedElement ) { final PyType type = context . getType ( ( PyTypedElement ) file ) ; if ( type != null ) { return resolveTypeMember ( type , PyNames . GETATTR , context ) != null ; } } return false ; }
jk1/intellij-community | public static boolean overridesGetAttr ( @ NotNull PyClass cls , @ NotNull TypeEvalContext context ) { final PyType type = context . getType ( cls ) ; if ( type != null ) { if ( resolveTypeMember ( type , PyNames . GETATTR , context ) != null ) { return true ; } final PsiElement method = resolveTypeMember ( type , PyNames . GETATTRIBUTE , context ) ; if ( method != null && ! PyBuiltinCache . getInstance ( cls ) . isBuiltin ( method ) ) { return true ; } } return false ; }
jk1/intellij-community | @ Nullable private static PsiElement resolveTypeMember ( @ NotNull PyType type , @ NotNull String name , @ NotNull TypeEvalContext context ) { final PyResolveContext resolveContext = PyResolveContext . noImplicits ( ) . withTypeEvalContext ( context ) ; final List < ? extends RatedResolveResult > results = type . resolveMember ( name , null , AccessDirection . READ , resolveContext ) ; return ! ContainerUtil . isEmpty ( results ) ? results . get ( 0 ) . getElement ( ) : null ; }
jk1/intellij-community | @ Nullable public static PyType getTargetTypeFromTupleAssignment ( @ NotNull PyTargetExpression target , @ NotNull PyTupleExpression parentTuple , @ NotNull PyType assignedType , @ NotNull TypeEvalContext context ) { if ( assignedType instanceof PyTupleType ) { return getTargetTypeFromTupleAssignment ( target , parentTuple , ( PyTupleType ) assignedType ) ; } else if ( assignedType instanceof PyClassLikeType ) { return StreamEx . of ( ( ( PyClassLikeType ) assignedType ) . getAncestorTypes ( context ) ) . select ( PyNamedTupleType . class ) . findFirst ( ) . map ( t -> getTargetTypeFromTupleAssignment ( target , parentTuple , t ) ) . orElse ( null ) ; } return null ; }
jk1/intellij-community | @ Nullable public static PyType getTargetTypeFromTupleAssignment ( @ NotNull PyTargetExpression target , @ NotNull PyTupleExpression parentTuple , @ NotNull PyTupleType assignedTupleType ) { final int count = assignedTupleType . getElementCount ( ) ; final PyExpression [ ] elements = parentTuple . getElements ( ) ; if ( elements . length == count || assignedTupleType . isHomogeneous ( ) ) { final int index = ArrayUtil . indexOf ( elements , target ) ; if ( index >= 0 ) { return assignedTupleType . getElementType ( index ) ; } for ( int i = 0 ; i < count ; i ++ ) { PyExpression element = elements [ i ] ; while ( element instanceof PyParenthesizedExpression ) { element = ( ( PyParenthesizedExpression ) element ) . getContainedExpression ( ) ; } if ( element instanceof PyTupleExpression ) { final PyType elementType = assignedTupleType . getElementType ( i ) ; if ( elementType instanceof PyTupleType ) { final PyType result = getTargetTypeFromTupleAssignment ( target , ( PyTupleExpression ) element , ( PyTupleType ) elementType ) ; if ( result != null ) { return result ; } } } } } return null ; }
ButterflyNetwork/bazel | public static final ActionCache AMNESIAC_CACHE = new ActionCache ( ) { @ Override public void put ( String fingerprint , Entry entry ) { } @ Override public Entry get ( String fingerprint ) { return null ; } @ Override public void remove ( String key ) { } @ Override public long save ( ) { return - 1 ; } @ Override public void clear ( ) { } @ Override public void dump ( PrintStream out ) { } @ Override public void accountHit ( ) { } @ Override public void accountMiss ( MissReason reason ) { } @ Override public void mergeIntoActionCacheStatistics ( ActionCacheStatistics . Builder builder ) { } @ Override public void resetStatistics ( ) { } }
orioncode/orionplatform | public static synchronized int run ( Vector x ) { VectorRules . isValid ( x ) ; int n = x . getDimensions ( ) ; int length = 1 ; int numberOfIncreasingElements = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( x . get ( i ) . isLessThan ( x . get ( i + 1 ) ) ) { numberOfIncreasingElements += 1 ; if ( i == n - 2 ) { length = getUpdatedLength ( length , numberOfIncreasingElements ) ; } continue ; } else { length = getUpdatedLength ( length , numberOfIncreasingElements ) ; numberOfIncreasingElements = 1 ; } } return length ; }
orioncode/orionplatform | private static synchronized int getUpdatedLength ( int length , int numberOfIncreasingElements ) { if ( numberOfIncreasingElements > length ) { return numberOfIncreasingElements ; } else { return length ; } }
rvillablanca/java-notes | public static void alimentarAnimales ( Jaula < ? extends Animal > jaulaAnimales ) { List < ? extends Animal > listaAnimales = jaulaAnimales . getLista ( ) ; for ( Animal a : listaAnimales ) a . alimentar ( ) ; System . out . println ( " \n " ) ; }
rvillablanca/java-notes | public static void main ( String [ ] args ) { Jaula < Animal > jaulaAnimales = new Jaula < Animal > ( ) ; Jaula < Leon > jaulaLeon = new Jaula < Leon > ( ) ; Jaula < Mariposa > jaulaMariposa = new Jaula < Mariposa > ( ) ; Animal animal = new Animal ( ) ; Leon leon = new Leon ( ) ; Mariposa mariposa = new Mariposa ( ) ; jaulaAnimales . add ( animal ) ; jaulaAnimales . add ( leon ) ; jaulaAnimales . add ( mariposa ) ; jaulaLeon . add ( leon ) ; jaulaMariposa . add ( mariposa ) ; Jaula < ? extends Animal > jaulaAnimalesGenerica ; jaulaAnimalesGenerica = jaulaAnimales ; jaulaAnimalesGenerica = jaulaLeon ; jaulaAnimalesGenerica = jaulaMariposa ; PruebaGenerics . alimentarAnimales ( jaulaAnimales ) ; PruebaGenerics . alimentarAnimales ( jaulaMariposa ) ; PruebaGenerics . alimentarAnimales ( jaulaLeon ) ; PruebaGenerics . alimentarAnimales ( jaulaAnimalesGenerica ) ; }
chooco13/scribejava | public static ForceTypeOfHttpRequest getForceTypeOfHttpRequests ( ) { return forceTypeOfHttpRequests ; }
chooco13/scribejava | public static void setForceTypeOfHttpRequests ( ForceTypeOfHttpRequest forceTypeOfHttpRequests ) { ScribeJavaConfig . forceTypeOfHttpRequests = forceTypeOfHttpRequests ; }
aqiu202/qiu-commons | public static String getSecurityCode ( ) { return getSecurityCode ( 4 , SecurityCodeLevel . Medium , false ) ; }
aqiu202/qiu-commons | public static String getSecurityCode ( int length , SecurityCodeLevel level , boolean isCanRepeat ) { int len = length ; char [ ] codes = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , ' i ' , ' j ' , ' k ' , ' m ' , ' n ' , ' p ' , ' q ' , ' r ' , ' s ' , ' t ' , ' u ' , ' v ' , ' w ' , ' x ' , ' y ' , ' z ' , ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' , ' G ' , ' H ' , ' I ' , ' J ' , ' K ' , ' L ' , ' M ' , ' N ' , ' P ' , ' Q ' , ' R ' , ' S ' , ' T ' , ' U ' , ' V ' , ' W ' , ' X ' , ' Y ' , ' Z ' } ; if ( level == SecurityCodeLevel . Simple ) { codes = Arrays . copyOfRange ( codes , 0 , 9 ) ; } else if ( level == SecurityCodeLevel . Medium ) { codes = Arrays . copyOfRange ( codes , 0 , 33 ) ; } int n = codes . length ; if ( len > n && isCanRepeat == false ) { throw new RuntimeException ( String . format ( " 调用SecurityCode . getSecurityCode ( %1 $ s , %2 $ s , %3 $ s ) 出现异常 ， " + " 当isCanRepeat为 % 3 $ s时 ， 传入参数 % 1 $ s不能大于 % 4 $ s " , len , level , isCanRepeat , n ) ) ; } char [ ] result = new char [ len ] ; if ( isCanRepeat ) { for ( int i = 0 ; i < result . length ; i ++ ) { int r = ( int ) ( Math . random ( ) * n ) ; result [ i ] = codes [ r ] ; } } else { for ( int i = 0 ; i < result . length ; i ++ ) { int r = ( int ) ( Math . random ( ) * n ) ; result [ i ] = codes [ r ] ; codes [ r ] = codes [ -- n ] ; } } return String . valueOf ( result ) ; }
aqiu202/qiu-commons | public static void main ( String [ ] ag ) { String resultCode = getSecurityCode ( 6 , SecurityCodeLevel . Medium , true ) ; System . out . println ( resultCode ) ; }
jennyqujy/GitHubApp | public static void setRepo ( Repo newRepo ) { repo = newRepo ; }
1yvT0s/buck | private static final TypeReference < List < TestResultSummary > > SUMMARIES_REFERENCE = new TypeReference < List < TestResultSummary > > ( ) { }
jixieshi999/juahya | public static void addIFlateViewAdapter ( IJuahyaFlateViewInFlaterAdapter ifl ) { if ( null == list ) list = new ArrayList < IJuahyaFlateViewInFlaterAdapter > ( ) ; if ( ! list . contains ( ifl ) ) list . add ( ifl ) ; }
GJL/flink | private static MemorySegment [ ] listToArray ( List < MemorySegment > list ) { if ( list != null ) { return list . toArray ( new MemorySegment [ 0 ] ) ; } return null ; }
GJL/flink | private static int getBucketBuffersByRowCount ( long rowCount , int maxSegs , int segmentSize ) { int minNumBuckets = ( int ) Math . ceil ( ( rowCount / 0.5 ) ) ; Preconditions . checkArgument ( segmentSize % 16 == 0 ) ; return MathUtils . roundDownToPowerOf2 ( ( int ) Math . max ( 1 , Math . min ( maxSegs , Math . ceil ( ( ( double ) minNumBuckets ) * 16 / segmentSize ) ) ) ) ; }
GJL/flink | private static long toAddrAndLen ( long address , int size ) { return ( address << SIZE_BITS ) | size ; }
GJL/flink | private static long toAddress ( long addrAndLen ) { return addrAndLen >>> SIZE_BITS ; }
GJL/flink | private static int toLength ( long addrAndLen ) { return ( int ) ( addrAndLen & SIZE_MASK ) ; }
GJL/flink | private static boolean shouldAdvance ( int available , BinaryRowDataSerializer serializer ) { return available < 8 + serializer . getFixedLengthPartSize ( ) ; }
GJL/flink | static void deserializeFromPages ( BinaryRowData reuse , ChannelReaderInputView inView , BinaryRowDataSerializer buildSideSerializer ) throws IOException { if ( shouldAdvance ( inView . getCurrentSegmentLimit ( ) - inView . getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { inView . advance ( ) ; } MemorySegment segment = ( reuse . getSegments ( ) != null ) ? reuse . getSegments ( ) [ 0 ] : null ; int length = toLength ( inView . getCurrentSegment ( ) . getLong ( inView . getCurrentPositionInSegment ( ) ) ) ; inView . skipBytesToRead ( 8 ) ; if ( segment == null || segment . size ( ) < length ) { segment = MemorySegmentFactory . wrap ( new byte [ length ] ) ; } inView . readFully ( segment . getHeapMemory ( ) , 0 , length ) ; reuse . pointTo ( segment , 0 , length ) ; }
OpenHFT/Chronicle-Wire | " ) public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { WireType . TEXT } , { WireType . BINARY } } ) ; }
guard163/cassandra | public static RowIndexEntry < IndexHelper . IndexInfo > create ( long position , DeletionTime deletionTime , ColumnIndex index ) { assert index != null ; assert deletionTime != null ; if ( index . columnsIndex . size ( ) > 1 ) return new IndexedEntry ( position , deletionTime , index . partitionHeaderLength , index . columnsIndex ) ; else return new RowIndexEntry < > ( position ) ; }
guard163/cassandra | public static long readPosition ( DataInputPlus in , Version version ) throws IOException { return version . storeRows ( ) ? in . readUnsignedVInt ( ) : in . readLong ( ) ; }
guard163/cassandra | public static void skip ( DataInputPlus in , Version version ) throws IOException { readPosition ( in , version ) ; skipPromotedIndex ( in , version ) ; }
guard163/cassandra | private static void skipPromotedIndex ( DataInputPlus in , Version version ) throws IOException { int size = version . storeRows ( ) ? ( int ) in . readUnsignedVInt ( ) : in . readInt ( ) ; if ( size <= 0 ) return ; FileUtils . skipBytesFully ( in , size ) ; }
aborg0/hits | private static String [ ] [ ] [ ] readAnnotations ( final int plateCount , final int rows , final int cols , final String annotationFileName ) throws IOException { final String [ ] [ ] [ ] ret = new String [ plateCount ] [ rows * cols ] [ 2 ] ; if ( annotationFileName . isEmpty ( ) ) { return ret ; } InputStream stream ; try { stream = OpenStream . open ( OpenStream . convertURI ( annotationFileName ) ) ; } catch ( final URISyntaxException e ) { throw new RuntimeException ( e ) ; } try { final Reader fileReader = new InputStreamReader ( stream ) ; try { final BufferedReader br = new BufferedReader ( fileReader ) ; try { String line = null ; while ( ( line = br . readLine ( ) ) != null ) { final int [ ] indices = getIndices ( line , rows , cols ) ; if ( indices != null ) { try { final String [ ] parts = line . split ( " \t " ) ; ret [ indices [ 0 ] ] [ indices [ 1 ] ] [ 0 ] = parts . length > 2 ? parts [ 2 ] : null ; ret [ indices [ 0 ] ] [ indices [ 1 ] ] [ 1 ] = line . substring ( line . lastIndexOf ( ' \t ' ) + 1 ) ; } catch ( final RuntimeException e ) { } } } return ret ; } finally { br . close ( ) ; } } finally { fileReader . close ( ) ; } } finally { stream . close ( ) ; } }
aborg0/hits | private static @ Nullable int [ ] getIndices ( final String line , final int rows , final int cols ) { if ( line == null ) { return null ; } final String [ ] parts = line . split ( " \t " ) ; if ( parts . length < 3 ) { return null ; } try { final String well = parts [ 1 ] ; final int wellIndex = getIndex ( well , rows , cols ) ; if ( wellIndex == - 1 ) { return null ; } return new int [ ] { Integer . parseInt ( parts [ 0 ] ) - 1 , wellIndex } ; } catch ( final RuntimeException e ) { return null ; } }
aborg0/hits | private static int getIndex ( final String well , final int rows , final int cols ) { final int row = Character . toLowerCase ( well . charAt ( 0 ) ) - ' a ' ; final int col = Integer . parseInt ( well . substring ( 1 ) ) - 1 ; final int wellIndex = row < 0 || row >= rows || col < 0 || col >= cols ? - 1 : row * cols + col ; return wellIndex ; }
chicagozer/rheosoft | @ BeforeClass public static void startService ( ) { Object implementor = new GreeterImpl ( ) ; String address = " http : // localhost : " + port1 + " / SoapContext / SoapPort " ; endpoint = Endpoint . publish ( address , implementor ) ; }
FHannes/intellij-community | private static void doTest ( Map < String , String > graph , String ... expectedPaths ) { doTest ( graph , 10 , expectedPaths ) ; }
FHannes/intellij-community | private static void doTest ( Map < String , String > graph , final int k , String ... expectedPaths ) { doTest ( graph , " s " , " t " , k , expectedPaths ) ; }
FHannes/intellij-community | private static void doTest ( Map < String , String > graph , final String start , final String finish , final int k , String ... expectedPaths ) { Graph < String > generator = initGraph ( graph ) ; List < List < String > > paths = getAlgorithmsInstance ( ) . findKShortestPaths ( generator , start , finish , k , new EmptyProgressIndicator ( ModalityState . NON_MODAL ) ) ; List < String > pathStrings = new ArrayList < > ( ) ; Set < Integer > sizes = new HashSet < > ( ) ; for ( List < String > path : paths ) { pathStrings . add ( StringUtil . join ( path , " " ) ) ; sizes . add ( path . size ( ) ) ; } if ( sizes . size ( ) != paths . size ( ) ) { UsefulTestCase . assertSameElements ( pathStrings , expectedPaths ) ; } else { UsefulTestCase . assertOrderedEquals ( pathStrings , expectedPaths ) ; } }
dextorer/BuildingForAndroidTV | public static String getCount ( ) { return Integer . toString ( sCount ) ; }
dextorer/BuildingForAndroidTV | public static void incrementCount ( ) { sCount ++ ; }
dextorer/BuildingForAndroidTV | public static final Parcelable . Creator CREATOR = new Parcelable . Creator ( ) { public Movie createFromParcel ( Parcel in ) { return new Movie ( in ) ; } public Movie [ ] newArray ( int size ) { return new Movie [ size ] ; } }
marlenech/PontChabanDelmas | public static boolean connectivity ( Context c ) { if ( c != null ) { ConnectivityManager connec = ( ConnectivityManager ) c . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; try { android . net . NetworkInfo wifi = connec . getNetworkInfo ( ConnectivityManager . TYPE_WIFI ) ; android . net . NetworkInfo mobile = connec . getNetworkInfo ( ConnectivityManager . TYPE_MOBILE ) ; if ( wifi . isConnected ( ) || mobile . isConnected ( ) ) return true ; else if ( wifi . isConnected ( ) && mobile . isConnected ( ) ) return true ; else return false ; } catch ( NullPointerException e ) { Log . d ( " ConStatus " , " No ▁ Active ▁ Connection " ) ; return false ; } } else { Log . v ( " utils - - " , " null " ) ; return false ; } }
coolcrowd/ObjectService | public static void registerAllExtensions ( com . google . protobuf . ExtensionRegistry registry ) { }
coolcrowd/ObjectService | public static com . google . protobuf . Descriptors . FileDescriptor getDescriptor ( ) { return descriptor ; }
