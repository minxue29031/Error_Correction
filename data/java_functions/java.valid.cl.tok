 @ Before public void init ( ) throws IOException { configurationFile = Files . createTempFile ( " " , " " ) ; jcdk2Installation = new Jcdk2Installation ( JCDK2_PATH ) ; jcdk3Installation = new Jcdk3Installation ( JCDK3_PATH ) ; jcdkInstallation = jcdk3Installation ; jcdkWrongPath = Files . createTempDirectory ( " " ) ; jcdkInstallationWrongPath = new Jcdk3Installation ( jcdkWrongPath ) ; jcdkWrapper = new JcdkWrapperImpl ( jcdkInstallation , configurationFile ) ; }
 @ Test public void NothingYet_Test ( ) { }
 public void writeToNBT ( NBTTagCompound tagCompound ) { NBTTagList itemList = new NBTTagList ( ) ; for ( int i = 0 ; i < this . inv . length ; i ++ ) { ItemStack stack = this . inv [ i ] ; if ( stack != null ) { NBTTagCompound tag = new NBTTagCompound ( ) ; tag . setByte ( " Slot " , ( byte ) i ) ; stack . writeToNBT ( tag ) ; itemList . appendTag ( tag ) ; } } tagCompound . setTag ( " Inventory " , itemList ) ; }
 public void setUseInlineAttachments ( boolean useInlineAttachments ) { this . useInlineAttachments = useInlineAttachments ; }
 public Statement getStatement ( ) { return _statement ; }
 protected void reportMetricsIfNeeded ( ) { if ( getGatherPerformanceMetrics ( ) ) { if ( ( System . currentTimeMillis ( ) - this . metricsLastReportedMs ) > getReportMetricsIntervalMillis ( ) ) { reportMetrics ( ) ; } } }
 public boolean isIgnoreUriScheme ( ) { return ignoreUriScheme ; }
 public void registerStatement ( Statement stmt ) { this . openStatements . addIfAbsent ( stmt ) ; }
 public java . sql . PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return prepareStatement ( sql , resultSetType , resultSetConcurrency ) ; }
 public boolean setInputFormat ( Instances instanceInfo ) throws Exception { super . setInputFormat ( new Instances ( instanceInfo , 0 ) ) ; m_ClassAttribute = instanceInfo . classAttribute ( ) ; m_Random = new Random ( m_Seed ) ; m_Converter = null ; int numClasses = instanceInfo . numClasses ( ) ; m_ClassCounts = new double [ numClasses ] ; return false ; }
 private String normalizeHost ( String hostname ) { if ( hostname == null || StringUtils . isEmptyOrWhitespaceOnly ( hostname ) ) { return " localhost " ; } return hostname ; }
 public ListHashMap < K , V > addAll ( Iterable < V > values , Function < V , K > keySelector ) { for ( V value : values ) { K key = keySelector . apply ( value ) ; addItem ( key , value ) ; } return this ; }
 public void setVersionNo ( java . lang . Integer versionNo ) { set ( " version _ no " , versionNo ) ; }
 @ Inject public TestingAccessControlManager ( TransactionManager transactionManager ) { super ( transactionManager ) ; setSystemAccessControl ( AllowAllSystemAccessControl . NAME , ImmutableMap . of ( ) ) ; }
 @ Test public void testTransactions ( ) throws Exception { User user ; Group group ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; userId = user . getId ( ) ; user . setName ( " testUser " ) ; user . setLogin ( " testLogin " ) ; user . setGroup ( em . find ( Group . class , UUID . fromString ( "0fa2b1a5-1d68-4d69-9fbd - dff348347f93" ) ) ) ; em . persist ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . find ( User . class , userId ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; Query query = em . createQuery ( " select ▁ u ▁ from ▁ sec $ User ▁ u ▁ where ▁ u . id ▁ = ▁ ? 1" ) . setParameter ( 1 , userId ) ; user = ( User ) query . getFirstResult ( ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( group ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; user . setName ( " changed ▁ name " ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . merge ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
 public long getIdleFor ( ) { synchronized ( getConnectionMutex ( ) ) { if ( this . lastQueryFinishedTime == 0 ) { return 0 ; } long now = System . currentTimeMillis ( ) ; long idleTime = now - this . lastQueryFinishedTime ; return idleTime ; } }
 private boolean characterSetNamesMatches ( String mysqlEncodingName ) { return ( mysqlEncodingName != null && mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ client " ) ) && mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ connection " ) ) ) ; }
 @ Override public ValidatorContext usingContext ( ) { return null ; }
 if ( ! fields . defaulted ( " blargh " ) ) { throw new Error ( ) ; }
 @ Override public Object getValueAt ( int row , int col ) { Material m = dataList . get ( row ) ; switch ( col ) { case 0 : return m . getItem ( ) . getName ( ) ; case 1 : return m . getAmount ( ) ; case 2 : return m . canBeManufactured ( ) ? m . isProduced ( ) : null ; case 3 : return m . getManufactureQuote ( ) == null ? null : m . getManufactureQuote ( ) . getManuCost ( ) ; case 4 : return m . getPrice ( ) ; case 5 : return m . isProduced ( ) ? m . getManufactureQuote ( ) . getManuCost ( ) * m . getAmount ( ) : m . getPrice ( ) * m . getAmount ( ) ; default : return null ; } }
 @ Override public void eUnset ( int featureID ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : setThermalGeneratingUnit ( ( ThermalGeneratingUnit ) null ) ; return ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : setIsNetGrossP ( IS_NET_GROSS_P_EDEFAULT ) ; return ; } super . eUnset ( featureID ) ; }
 @ Test public void onIsBlankValues ( ) { assertTrue ( StringUtils . isBlank ( null ) ) ; assertTrue ( StringUtils . isBlank ( " " ) ) ; assertTrue ( StringUtils . isBlank ( " ▁ " ) ) ; assertFalse ( StringUtils . isBlank ( " crnk " ) ) ; assertFalse ( StringUtils . isBlank ( " ▁ ▁ crnk ▁ ▁ " ) ) ; }
 public Configuration traversableResolver ( TraversableResolver resolver ) { return null ; }
 protected < T > T createException ( Class < T > classObject , Object exceptionMessage , Throwable exceptionCause ) throws Exception { Class < ? > [ ] parameterTypes = new Class < ? > [ 2 ] ; parameterTypes [ 0 ] = String . class ; parameterTypes [ 1 ] = Throwable . class ; Constructor < ? > constructor = classObject . getConstructor ( parameterTypes ) ; Assert . notNull ( constructor , " Constructor ▁ not ▁ found ▁ for : ▁ " + classObject . getName ( ) ) ; @ SuppressWarnings ( " unchecked " ) T instance = ( T ) constructor . newInstance ( exceptionMessage , exceptionCause ) ; return instance ; }
 public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Mammal other = ( Mammal ) obj ; if ( Float . floatToIntBits ( normalBodyTemperature ) != Float . floatToIntBits ( other . normalBodyTemperature ) ) return false ; return true ; }
 public FooValidationProvider ( ) { createdValidationProviders . add ( new SoftReference < FooValidationProvider > ( this ) ) ; }
 @ Test public void testRenameTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; SchemaTableName renamedTable = new SchemaTableName ( raptorTableHandle . getSchemaName ( ) , " orders _ renamed " ) ; metadata . renameTable ( SESSION , raptorTableHandle , renamedTable ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableHandle renamedTableHandle = metadata . getTableHandle ( SESSION , renamedTable ) ; assertNotNull ( renamedTableHandle ) ; assertEquals ( ( ( RaptorTableHandle ) renamedTableHandle ) . getTableName ( ) , renamedTable . getTableName ( ) ) ; }
 @ Bean public Ref mockGossipTransportRef ( ) { return RefUtils . localTransportRef ( " gossip " ) ; }
 @ Test public void testMarshalDomainObjectTwice ( ) throws Exception { MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 2 ) ; PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; template . sendBody ( " direct : in " , order ) ; template . sendBody ( " direct : in " , order ) ; mock . assertIsSatisfied ( ) ; String body1 = mock . getExchanges ( ) . get ( 0 ) . getIn ( ) . getBody ( String . class ) ; String body2 = mock . getExchanges ( ) . get ( 1 ) . getIn ( ) . getBody ( String . class ) ; assertEquals ( " The ▁ body ▁ should ▁ marshalled ▁ to ▁ the ▁ same " , body1 , body2 ) ; }
 public void testProtobuf ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo p = filledZoo ( ) ; byte [ ] data = ProtobufIOUtil . toByteArray ( p , schema , buf ( ) ) ; Zoo p2 = new Zoo ( ) ; ProtobufIOUtil . mergeFrom ( data , p2 , schema ) ; assertEquals ( p , p2 ) ; List < Zoo > list = new ArrayList < Zoo > ( ) ; list . add ( p ) ; list . add ( p2 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ProtobufIOUtil . writeListTo ( out , list , schema , buf ( ) ) ; byte [ ] listData = out . toByteArray ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( listData ) ; List < Zoo > parsedList = ProtobufIOUtil . parseListFrom ( in , schema ) ; assertEquals ( list , parsedList ) ; }
 public void setSessionMaxRows ( int max ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . sessionMaxRows != max ) { this . sessionMaxRows = max ; execSQL ( null , " SET ▁ SQL _ SELECT _ LIMIT = " + ( this . sessionMaxRows == - 1 ? " DEFAULT " : this . sessionMaxRows ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } }
 @ Override public Void visitUnion ( Union union , FieldList value ) { for ( LogicalOperator o : union . getInputs ( ) ) { o . accept ( this , value . clone ( ) ) ; } return null ; }
 public void setVarStatements ( List < IVarStatement > varStmts ) { _varStmts = varStmts ; }
 protected void setup ( int numSortChannels , int totalChannels , int numMergeSources , int pagesCount ) { types = nCopies ( totalChannels , BIGINT ) ; sortChannels = new ArrayList < > ( ) ; for ( int i = 0 ; i < numSortChannels ; i ++ ) { sortChannels . add ( i ) ; } sortTypes = nCopies ( numSortChannels , BIGINT ) ; sortOrders = nCopies ( numSortChannels , ASC_NULLS_FIRST ) ; outputChannels = new ArrayList < > ( ) ; for ( int i = 0 ; i < totalChannels ; i ++ ) { outputChannels . add ( i ) ; } createPages ( totalChannels , pagesCount ) ; createPageProducers ( numMergeSources ) ; }
 @ Test public void testTransactionRollback_new ( ) throws Exception { User user = null ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; userId = user . getId ( ) ; cont . persistence ( ) . getEntityManager ( ) . persist ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; fail ( ) ; } catch ( Exception e ) { } finally { tx . end ( ) ; } assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
 public java . util . Date getEndDate ( ) { return get ( " end _ date " ) ; }
 public void initializeExtension ( Extension ex ) throws SQLException { ex . init ( this , this . props ) ; }
 @ Override public int getHeight ( ) { return HEIGHT ; }
 public DatabaseProperty [ ] getPropertyList ( ) { DatabaseProperty [ ] properties = new DatabaseProperty [ _properties . values ( ) . size ( ) ] ; return _properties . values ( ) . toArray ( properties ) ; }
 public void setJavaMailProperties ( Properties javaMailProperties ) { this . javaMailProperties = javaMailProperties ; }
 @ Override public Set < SchemaPath > visitSchemaPath ( SchemaPath path , Void value ) { Set < SchemaPath > set = Sets . newHashSet ( ) ; set . add ( path ) ; return set ; }
 " , method = RequestMethod . GET ) public ResponseEntity < Client > findById ( @ PathVariable ( " id " ) String id ) { Client entity = clientService . findById ( id ) ; return ackEntity ( entity ) ; }
 public boolean check ( float x , float y ) { if ( isEnabled && GameHelper . tapPointInsideRectangle ( x , y , sprite . getX ( ) , sprite . getY ( ) + sprite . getHeight ( ) , sprite . getWidth ( ) , sprite . getHeight ( ) ) ) { onClick ( ) ; return true ; } return false ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { return clientPrepareStatement ( sql , resultSetType , resultSetConcurrency , true ) ; }
 @ Override public int size ( ) { return map . size ( ) ; }
 private boolean isQueryCacheEnabled ( ) { return " ON " . equalsIgnoreCase ( this . serverVariables . get ( " query _ cache _ type " ) ) && ! "0" . equalsIgnoreCase ( this . serverVariables . get ( " query _ cache _ size " ) ) ; }
 @ Test public void testListTableColumnsFiltering ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; Map < SchemaTableName , List < ColumnMetadata > > filterCatalog = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( ) ) ; Map < SchemaTableName , List < ColumnMetadata > > filterSchema = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( " test " ) ) ; Map < SchemaTableName , List < ColumnMetadata > > filterTable = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( " test " , " orders " ) ) ; assertEquals ( filterCatalog , filterSchema ) ; assertEquals ( filterCatalog , filterTable ) ; }
 public long getSeed ( ) { return m_Seed ; }
 protected HeatRateCurveImpl ( ) { super ( ) ; }
 @ Test public void convertCannotFindClassFailure ( ) throws Exception { exception . expect ( ConvertionException . class ) ; exception . expectMessage ( " Error ▁ during ▁ execution ▁ of ▁ JCDK ▁ converter ▁ ( see ▁ output ▁ for ▁ details ) . " ) ; jcdkWrapper . convert ( ) ; }
 public Properties getJavaMailProperties ( ) { return javaMailProperties ; }
 public Session getSession ( ) { return session ; }
 public java . sql . PreparedStatement serverPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return serverPrepareStatement ( sql , resultSetType , resultSetConcurrency ) ; }
 public String getStatementComment ( ) { return this . statementComment ; }
 @ Override public boolean hasCustomInventoryName ( ) { return true ; }
 public String getHost ( ) { return host ; }
 public java . sql . PreparedStatement prepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
 public void transactionBegun ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . transactionBegun ( ) ; } } ; iter . doForAll ( ) ; } } }
 @ Override public Iterator < Entry < K , List < V > > > iterator ( ) { return map . entrySet ( ) . iterator ( ) ; }
 @ Override void leaveEnclosingElement ( ) throws IOException { }
 @ Override protected ServiceName getParentServiceName ( PathAddress parentAddress ) { return RhqMetricsService . SERVICE_NAME . append ( parentAddress . getLastElement ( ) . getValue ( ) ) ; }
 public ValidatorFactory buildValidatorFactory ( ConfigurationState configurationState ) { return new DummyValidatorFactory ( ) ; }
 @ Override public ConstraintValidatorFactory getConstraintValidatorFactory ( ) { return null ; }
 public java . util . Date getUpdated ( ) { return get ( " updated " ) ; }
 public JavaMailSender getJavaMailSender ( ) { return javaMailSender ; }
 protected DownloadRetryHandler getDownloadRetryHandler ( ) { return downloadRetryHandler ; }
 @ Test public void testTransactionInsert ( ) { long transactionId = 1 ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; ConnectorInsertTableHandle insertHandle = metadata . beginInsert ( SESSION , tableHandle ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishInsert ( SESSION , insertHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
 public boolean isServerTzUTC ( ) { return this . isServerTzUTC ; }
 public void setAlternativeBodyHeader ( String alternativeBodyHeader ) { this . alternativeBodyHeader = alternativeBodyHeader ; }
 public synchronized boolean deleteTripShare ( TripShare tripShare ) { int result = - 1 ; try { final SQLiteDatabase db = dbHelper . getWritableDatabase ( ) ; result = db . delete ( TripShare . TABLE_NAME , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { String . valueOf ( tripShare . id ) } ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } boolean success = false ; if ( result > 0 ) { success = true ; } return success ; }
 public Calendar getUtcCalendar ( ) { return this . utcCalendar ; }
 @ Override public void markDirty ( ) { NBTTagCompound tagCompound = StackUtils . getNBT ( this . cellphone ) ; this . writeToNBT ( tagCompound ) ; this . cellphone . setTagCompound ( tagCompound ) ; }
 public boolean isReadInfoMsgEnabled ( ) { return this . readInfoMsg ; }
 @ Override public String getInventoryName ( ) { return this . cellphone . getDisplayName ( ) ; }
 @ Override public Validator getValidator ( ) { return null ; }
 @ After public void tearDown ( ) throws Exception { }
 public void mergeFrom ( Input input , DrillServiceInstance message ) throws IOException { for ( int number = input . readFieldNumber ( this ) ; ; number = input . readFieldNumber ( this ) ) { switch ( number ) { case 0 : return ; case 1 : message . id = input . readString ( ) ; break ; case 2 : message . registrationTimeUTC = input . readInt64 ( ) ; break ; case 3 : message . endpoint = input . mergeObject ( message . endpoint , DrillbitEndpoint . getSchema ( ) ) ; break ; default : input . handleUnknownField ( number , this ) ; } } }
 public String [ ] getOptions ( ) { String [ ] options = new String [ 4 ] ; int current = 0 ; options [ current ++ ] = " - R " ; options [ current ++ ] = " " + m_Seed ; options [ current ++ ] = " - C " ; options [ current ++ ] = " " + m_ClassOrder ; while ( current < options . length ) { options [ current ++ ] = " " ; } return options ; }
 @ RequestMapping ( value = " / " , method = RequestMethod . POST ) @ CrossOrigin public ResponseEntity < Client > create ( @ RequestBody Client input ) throws ContextedException { Client entity = clientService . save ( input ) ; return ackEntity ( entity ) ; }
 public TimeZone getDefaultTimeZone ( ) { return getCacheDefaultTimezone ( ) ? this . defaultTimeZone : TimeUtil . getDefaultTimeZone ( false ) ; }
 public MessageInterpolator getDefaultMessageInterpolator ( ) { return null ; }
 InteractionActivityType getInteractionActivityType ( ) { JsonNode subNode = json . get ( " interactivityActivityType " ) ; if ( subNode == null ) { return InteractionActivityType . LocallyPresentedHtml ; } String textValue = subNode . textValue ( ) ; if ( textValue == null ) { return InteractionActivityType . LocallyPresentedHtml ; } if ( " VelocityTemplate " . equals ( textValue ) ) { return InteractionActivityType . VelocityTemplate ; } return InteractionActivityType . LocallyPresentedHtml ; }
 public void setAdditionalJavaMailProperties ( Properties additionalJavaMailProperties ) { this . additionalJavaMailProperties = additionalJavaMailProperties ; }
 public RecommendMovieAdapter ( RecyclerView view , Collection < SimpleSubjectBean > datas ) { super ( view , datas , R . layout . item_simple_movie_layout ) ; setOnItemClickListener ( ( View v , Object data , int position ) -> { if ( mCallback != null ) { SimpleSubjectBean bean = ( SimpleSubjectBean ) data ; String url = ImageUtil . getDisplayImage ( mContext , bean . images ) ; mCallback . onItemClick ( bean . id , url , true ) ; } } ) ; }
 public int getFetchSize ( ) { return fetchSize ; }
 @ Test public void testDirectConnectionZeroConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 0" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
 public void setLoginTime ( java . util . Date loginTime ) { set ( " login _ time " , loginTime ) ; }
 public void setUp ( ) throws Exception { isRequestExpected = true ; isAbortExpected = false ; }
 private boolean isAutoCommitNonDefaultOnServer ( ) throws SQLException { boolean overrideDefaultAutocommit = false ; String initConnectValue = this . serverVariables . get ( " init _ connect " ) ; if ( versionMeetsMinimum ( 4 , 1 , 2 ) && initConnectValue != null && initConnectValue . length ( ) > 0 ) { if ( ! getElideSetAutoCommits ( ) ) { java . sql . ResultSet rs = null ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( " SELECT ▁ @ @ session . autocommit " ) ; if ( rs . next ( ) ) { this . autoCommit = rs . getBoolean ( 1 ) ; if ( this . autoCommit != true ) { overrideDefaultAutocommit = true ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException sqlEx ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlEx ) { } } } } else { if ( this . getIO ( ) . isSetNeededForAutoCommitMode ( true ) ) { this . autoCommit = false ; overrideDefaultAutocommit = true ; } } } return overrideDefaultAutocommit ; }
 private final SpeechService . Listener mSpeechServiceListener = new SpeechService . Listener ( ) { @ Override public void onSpeechRecognized ( final String text , final boolean isFinal ) { if ( isFinal ) { mVoiceRecorder . dismiss ( ) ; } if ( mText != null && ! TextUtils . isEmpty ( text ) ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { if ( isFinal ) { mVoiceRecorder . stop ( ) ; String responseBody = bob . getResponseBody ( ) ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( " message / rfc822" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { " all @ typeform . com " } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , " Rate ▁ the ▁ Challenge ! " ) ; intent . setPackage ( " com . google . android . gm " ) ; intent . putExtra ( Intent . EXTRA_TEXT , responseBody ) ; if ( intent . resolveActivity ( getPackageManager ( ) ) != null ) startActivity ( intent ) ; } else { } } } ) ; } } }
 public Optional < String > getTarget ( ) { return target ; }
 public java . sql . PreparedStatement serverPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; return ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , resultSetType , resultSetConcurrency ) ; }
 public void addReferenced ( Collection < SchemaPath > paths ) { referenced . addAll ( paths ) ; }
 private void createInitialHistogram ( long [ ] breakpoints , long lowerBound , long upperBound ) { double bucketSize = ( ( ( double ) upperBound - ( double ) lowerBound ) / HISTOGRAM_BUCKETS ) * 1.25 ; if ( bucketSize < 1 ) { bucketSize = 1 ; } for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { breakpoints [ i ] = lowerBound ; lowerBound += bucketSize ; } }
 @ Override public void onUpgrade ( SQLiteDatabase db , int oldVersion , int newVersion ) { if ( oldVersion < 2 ) { String addAsDirectoryColumn = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . PATH_AS_DIRECTORY + " ▁ TINYINT ( 1 ) ▁ DEFAULT ▁ 0" ; db . execSQL ( addAsDirectoryColumn ) ; String addFilenameColumn = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . FILENAME + " ▁ VARCHAR " ; db . execSQL ( addFilenameColumn ) ; } if ( oldVersion < 3 ) { final String addConnectionCount = " ALTER ▁ TABLE ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ▁ ADD ▁ COLUMN ▁ " + FileDownloadModel . CONNECTION_COUNT + " ▁ INTEGER ▁ DEFAULT ▁ 1" ; db . execSQL ( addConnectionCount ) ; db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . CONNECTION_TABLE_NAME + " ( ▁ " + ConnectionModel . ID + " ▁ INTEGER , ▁ " + ConnectionModel . INDEX + " ▁ INTEGER , ▁ " + ConnectionModel . START_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . CURRENT_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . END_OFFSET + " ▁ INTEGER , ▁ " + " PRIMARY ▁ KEY ▁ ( ▁ " + ConnectionModel . ID + " , ▁ " + ConnectionModel . INDEX + " ▁ ) " + " ) " ) ; } }
 public SingleByteCharsetConverter getCharsetConverter ( String javaEncodingName ) throws SQLException { if ( javaEncodingName == null ) { return null ; } if ( this . usePlatformCharsetConverters ) { return null ; } SingleByteCharsetConverter converter = null ; synchronized ( this . charsetConverterMap ) { Object asObject = this . charsetConverterMap . get ( javaEncodingName ) ; if ( asObject == CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) { return null ; } converter = ( SingleByteCharsetConverter ) asObject ; if ( converter == null ) { try { converter = SingleByteCharsetConverter . getInstance ( javaEncodingName , this ) ; if ( converter == null ) { this . charsetConverterMap . put ( javaEncodingName , CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) ; } else { this . charsetConverterMap . put ( javaEncodingName , converter ) ; } } catch ( UnsupportedEncodingException unsupEncEx ) { this . charsetConverterMap . put ( javaEncodingName , CHARSET_CONVERTER_NOT_AVAILABLE_MARKER ) ; converter = null ; } } } return converter ; }
 public int getFieldNumber ( String name ) { final Integer number = __fieldMap . get ( name ) ; return number == null ? 0 : number . intValue ( ) ; }
 protected int getNonFilteredCount ( ) { return adapter . getNonFilteredCount ( ) ; }
 catch ( Exception e ) { throw new RuntimeException ( " Failed ▁ to ▁ load ▁ version . properties " , e ) ; }
 public void init ( Connection conn , Properties properties ) throws SQLException { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( ExceptionInterceptor ) iter . next ( ) ) . init ( conn , properties ) ; } } }
 public synchronized Connection getConnection ( ) { Connection con = null ; if ( freeConnections . size ( ) > 0 ) { con = ( Connection ) freeConnections . firstElement ( ) ; freeConnections . removeElementAt ( 0 ) ; try { if ( con . isClosed ( ) ) { log ( " 从连接池 " + name + " 删除一个无效连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; con = getConnection ( ) ; } } catch ( SQLException e ) { log ( " 从连接池 " + name + " 删除一个无效连接 " ) ; con = getConnection ( ) ; } } else if ( maxConn == 0 || checkedOut < maxConn ) { con = createNewConnection ( ) ; } if ( con != null ) { checkedOut ++ ; log ( " 从连接池 " + name + " 被占用的链接数 " + checkedOut ) ; } return con ; }
 public long getMaxInputSizeHopID ( ) { long id = - 1 ; double max = 0 ; for ( Entry < Long , Double > e : inSizes . entrySet ( ) ) if ( max < e . getValue ( ) ) { id = e . getKey ( ) ; max = e . getValue ( ) ; } return id ; }
 ImmutableMapKeySet ( ImmutableMap < K , V > map ) { this . map = map ; }
 @ Override public NotificationChain eInverseAdd ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : if ( thermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) thermalGeneratingUnit ) . eInverseRemove ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; return basicSetThermalGeneratingUnit ( ( ThermalGeneratingUnit ) otherEnd , msgs ) ; } return super . eInverseAdd ( otherEnd , featureID , msgs ) ; }
 private void reportMetrics ( ) { if ( getGatherPerformanceMetrics ( ) ) { StringBuilder logMessage = new StringBuilder ( 256 ) ; logMessage . append ( " * * ▁ Performance ▁ Metrics ▁ Report ▁ * * \n " ) ; logMessage . append ( " \n Longest ▁ reported ▁ query : ▁ " + this . longestQueryTimeMs + " ▁ ms " ) ; logMessage . append ( " \n Shortest ▁ reported ▁ query : ▁ " + this . shortestQueryTimeMs + " ▁ ms " ) ; logMessage . append ( " \n Average ▁ query ▁ execution ▁ time : ▁ " + ( this . totalQueryTimeMs / this . numberOfQueriesIssued ) + " ▁ ms " ) ; logMessage . append ( " \n Number ▁ of ▁ statements ▁ executed : ▁ " + this . numberOfQueriesIssued ) ; logMessage . append ( " \n Number ▁ of ▁ result ▁ sets ▁ created : ▁ " + this . numberOfResultSetsCreated ) ; logMessage . append ( " \n Number ▁ of ▁ statements ▁ prepared : ▁ " + this . numberOfPrepares ) ; logMessage . append ( " \n Number ▁ of ▁ prepared ▁ statement ▁ executions : ▁ " + this . numberOfPreparedExecutes ) ; if ( this . perfMetricsHistBreakpoints != null ) { logMessage . append ( " \n \n \tTiming ▁ Histogram : \n " ) ; int maxNumPoints = 20 ; int highestCount = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS ) ; i ++ ) { if ( this . perfMetricsHistCounts [ i ] > highestCount ) { highestCount = this . perfMetricsHistCounts [ i ] ; } } if ( highestCount == 0 ) { highestCount = 1 ; } for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS - 1 ) ; i ++ ) { if ( i == 0 ) { logMessage . append ( " \n \tless ▁ than ▁ " + this . perfMetricsHistBreakpoints [ i + 1 ] + " ▁ ms : ▁ \t " + this . perfMetricsHistCounts [ i ] ) ; } else { logMessage . append ( " \n \tbetween ▁ " + this . perfMetricsHistBreakpoints [ i ] + " ▁ and ▁ " + this . perfMetricsHistBreakpoints [ i + 1 ] + " ▁ ms : ▁ \t " + this . perfMetricsHistCounts [ i ] ) ; } logMessage . append ( " \t " ) ; int numPointsToGraph = ( int ) ( maxNumPoints * ( ( double ) this . perfMetricsHistCounts [ i ] / ( double ) highestCount ) ) ; for ( int j = 0 ; j < numPointsToGraph ; j ++ ) { logMessage . append ( " * " ) ; } if ( this . longestQueryTimeMs < this . perfMetricsHistCounts [ i + 1 ] ) { break ; } } if ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] < this . longestQueryTimeMs ) { logMessage . append ( " \n \tbetween ▁ " ) ; logMessage . append ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] ) ; logMessage . append ( " ▁ and ▁ " ) ; logMessage . append ( this . perfMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 1 ] ) ; logMessage . append ( " ▁ ms : ▁ \t " ) ; logMessage . append ( this . perfMetricsHistCounts [ HISTOGRAM_BUCKETS - 1 ] ) ; } } if ( this . numTablesMetricsHistBreakpoints != null ) { logMessage . append ( " \n \n \tTable ▁ Join ▁ Histogram : \n " ) ; int maxNumPoints = 20 ; int highestCount = Integer . MIN_VALUE ; for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS ) ; i ++ ) { if ( this . numTablesMetricsHistCounts [ i ] > highestCount ) { highestCount = this . numTablesMetricsHistCounts [ i ] ; } } if ( highestCount == 0 ) { highestCount = 1 ; } for ( int i = 0 ; i < ( HISTOGRAM_BUCKETS - 1 ) ; i ++ ) { if ( i == 0 ) { logMessage . append ( " \n \t " + this . numTablesMetricsHistBreakpoints [ i + 1 ] + " ▁ tables ▁ or ▁ less : ▁ \t\t " + this . numTablesMetricsHistCounts [ i ] ) ; } else { logMessage . append ( " \n \tbetween ▁ " + this . numTablesMetricsHistBreakpoints [ i ] + " ▁ and ▁ " + this . numTablesMetricsHistBreakpoints [ i + 1 ] + " ▁ tables : ▁ \t " + this . numTablesMetricsHistCounts [ i ] ) ; } logMessage . append ( " \t " ) ; int numPointsToGraph = ( int ) ( maxNumPoints * ( ( double ) this . numTablesMetricsHistCounts [ i ] / ( double ) highestCount ) ) ; for ( int j = 0 ; j < numPointsToGraph ; j ++ ) { logMessage . append ( " * " ) ; } if ( this . maximumNumberTablesAccessed < this . numTablesMetricsHistBreakpoints [ i + 1 ] ) { break ; } } if ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] < this . maximumNumberTablesAccessed ) { logMessage . append ( " \n \tbetween ▁ " ) ; logMessage . append ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 2 ] ) ; logMessage . append ( " ▁ and ▁ " ) ; logMessage . append ( this . numTablesMetricsHistBreakpoints [ HISTOGRAM_BUCKETS - 1 ] ) ; logMessage . append ( " ▁ tables : ▁ " ) ; logMessage . append ( this . numTablesMetricsHistCounts [ HISTOGRAM_BUCKETS - 1 ] ) ; } } this . log . logInfo ( logMessage ) ; this . metricsLastReportedMs = System . currentTimeMillis ( ) ; } }
 @ Test public void testKlass ( ) { assertEquals ( Histogram . class , MetricType . HISTOGRAM_BIASED . getKlass ( ) ) ; }
 @ Override public ItemStack decrStackSize ( int slot , int amount ) { ItemStack itemStack = this . getStackInSlot ( slot ) ; if ( itemStack != null ) { if ( itemStack . stackSize <= amount ) { this . setInventorySlotContents ( slot , null ) ; } else { itemStack = itemStack . splitStack ( amount ) ; if ( itemStack . stackSize == 0 ) { this . setInventorySlotContents ( slot , null ) ; } } } return itemStack ; }
 public List < StatementInterceptorV2 > getStatementInterceptorsInstances ( ) { return this . statementInterceptors ; }
 public Timer getCancelTimer ( ) { synchronized ( getConnectionMutex ( ) ) { if ( this . cancelTimer == null ) { boolean createdNamedTimer = false ; try { Constructor < Timer > ctr = Timer . class . getConstructor ( new Class [ ] { String . class , Boolean . TYPE } ) ; this . cancelTimer = ctr . newInstance ( new Object [ ] { " MySQL ▁ Statement ▁ Cancellation ▁ Timer " , Boolean . TRUE } ) ; createdNamedTimer = true ; } catch ( Throwable t ) { createdNamedTimer = false ; } if ( ! createdNamedTimer ) { this . cancelTimer = new Timer ( true ) ; } } return this . cancelTimer ; } }
 public FunctionRegistry getRegistry ( ) { return registry ; }
 @ Override public void checkCanDropColumn ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DROP_COLUMN ) ) { denyDropColumn ( tableName . toString ( ) ) ; } super . checkCanDropColumn ( transactionId , identity , context , tableName ) ; }
 @ Test public void taskGeneratorTest ( ) { var msgQueue = new MessageQueue ( ) ; var taskRunnable = new TaskGenerator ( msgQueue , 1 ) ; var taskGenThr = new Thread ( taskRunnable ) ; taskGenThr . start ( ) ; var srvRunnable = new ServiceExecutor ( msgQueue ) ; var srvExeThr = new Thread ( srvRunnable ) ; srvExeThr . start ( ) ; }
 public void incrementNumberOfResultSetsCreated ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfResultSetsCreated ++ ; } }
 @ Bean public Service gossipService ( ) { final List < ServicePresenceListener > servicePresenceListeners = Lists . newArrayList ( ) ; if ( serviceRegistry instanceof DefaultServiceRegistry ) { servicePresenceListeners . add ( ( ServicePresenceListener ) serviceRegistry ) ; } servicePresenceListeners . add ( testPresenceListener ( ) ) ; return new GossipService ( gossipMessageFactory ( ) , gossipServiceRef ( ) , servicePresenceListeners ) ; }
 @ Deprecated public void setPreferSlaveDuringFailover ( boolean flag ) { }
 public Configuration parameterNameProvider ( ParameterNameProvider parameterNameProvider ) { return null ; }
 public int getNetBufferLength ( ) { return this . netBufferLength ; }
 public CostVector ( double outputSize ) { ID = COST_ID . getNextID ( ) ; outSize = outputSize ; }
 public InventoryCommand ( GameManager gameManager ) { super ( gameManager , validTriggers , description , correctUsage ) ; }
 public void setPlayerNo ( String playerNo ) { this . playerNo = playerNo ; }
 @ Override public List < String > getInvalidateWebsudoSessionExcludeList ( ) { return null ; }
 public java . sql . PreparedStatement serverPrepareStatement ( String sql ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; return ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
 public int getMaxDefinitionLevel ( String ... path ) { return getMaxDefinitionLevel ( path , 0 ) - 1 ; }
 public String getCharacterSetMetadata ( ) { synchronized ( getConnectionMutex ( ) ) { return this . characterSetMetadata ; } }
 public void setExternalCompilerMemory ( int myExternalCompilerMemory ) { this . myExternalCompilerMemory = myExternalCompilerMemory ; }
 private void setSessionVariables ( ) throws SQLException { if ( this . versionMeetsMinimum ( 4 , 0 , 0 ) && getSessionVariables ( ) != null ) { List < String > variablesToSet = StringUtils . split ( getSessionVariables ( ) , " , " , " \" ' " , " \" ' " , false ) ; int numVariablesToSet = variablesToSet . size ( ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; for ( int i = 0 ; i < numVariablesToSet ; i ++ ) { String variableValuePair = variablesToSet . get ( i ) ; if ( variableValuePair . startsWith ( " @ " ) ) { stmt . executeUpdate ( " SET ▁ " + variableValuePair ) ; } else { stmt . executeUpdate ( " SET ▁ SESSION ▁ " + variableValuePair ) ; } } } finally { if ( stmt != null ) { stmt . close ( ) ; } } } }
 public void setClassOrder ( int order ) { m_ClassOrder = order ; }
 public java . sql . Savepoint setSavepoint ( ) throws SQLException { MysqlSavepoint savepoint = new MysqlSavepoint ( getExceptionInterceptor ( ) ) ; setSavepoint ( savepoint ) ; return savepoint ; }
 private void startVoiceRecorder ( ) { if ( ActivityCompat . checkSelfPermission ( this , Manifest . permission . RECORD_AUDIO ) == PackageManager . PERMISSION_GRANTED ) { if ( mVoiceRecorder != null ) { mVoiceRecorder . stop ( ) ; } mVoiceRecorder = new VoiceRecorder ( mVoiceCallback ) ; mVoiceRecorder . start ( ) ; } }
 @ Test public void testZKSuccessfulConnectionGreaterThanConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = 7" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
 public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Animal other = ( Animal ) obj ; if ( properName == null ) { if ( other . properName != null ) return false ; } else if ( ! properName . equals ( other . properName ) ) return false ; return true ; }
 @ Override public void checkCanDropSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , DROP_SCHEMA ) ) { denyDropSchema ( schemaName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropSchema ( transactionId , identity , context , schemaName ) ; } }
 public int getColumnIndex ( String columnName ) { Integer index = columnIndexes . get ( columnName ) ; checkArgument ( index != null , " Column ▁ % s ▁ not ▁ found " , columnName ) ; return index ; }
 protected RouteBuilder createRouteBuilder ( ) throws Exception { return new RouteBuilder ( ) { public void configure ( ) throws Exception { from ( " direct : in " ) . marshal ( ) . xstream ( ) . to ( " mock : result " ) ; from ( " direct : marshal " ) . marshal ( ) . xstream ( " UTF - 8" ) ; from ( " direct : reverse " ) . unmarshal ( ) . xstream ( " UTF - 8" ) . to ( " mock : reverse " ) ; } } ; }
 public void error ( final String message ) { status . setText ( message ) ; }
 public void realClose ( boolean calledExplicitly , boolean issueRollback , boolean skipLocalTeardown , Throwable reason ) throws SQLException { SQLException sqlEx = null ; if ( this . isClosed ( ) ) { return ; } this . forceClosedReason = reason ; try { if ( ! skipLocalTeardown ) { if ( ! getAutoCommit ( ) && issueRollback ) { try { rollback ( ) ; } catch ( SQLException ex ) { sqlEx = ex ; } } reportMetrics ( ) ; if ( getUseUsageAdvisor ( ) ) { if ( ! calledExplicitly ) { String message = " Connection ▁ implicitly ▁ closed ▁ by ▁ Driver . ▁ You ▁ should ▁ call ▁ Connection . close ( ) ▁ from ▁ your ▁ code ▁ to ▁ free ▁ resources ▁ more ▁ efficiently ▁ and ▁ avoid ▁ resource ▁ leaks . " ; this . eventSink . consumeEvent ( new ProfilerEvent ( ProfilerEvent . TYPE_WARN , " " , this . getCatalog ( ) , this . getId ( ) , - 1 , - 1 , System . currentTimeMillis ( ) , 0 , Constants . MILLIS_I18N , null , this . pointOfOrigin , message ) ) ; } long connectionLifeTime = System . currentTimeMillis ( ) - this . connectionCreationTimeMillis ; if ( connectionLifeTime < 500 ) { String message = " Connection ▁ lifetime ▁ of ▁ < ▁ . 5 ▁ seconds . ▁ You ▁ might ▁ be ▁ un - necessarily ▁ creating ▁ short - lived ▁ connections ▁ and ▁ should ▁ investigate ▁ connection ▁ pooling ▁ to ▁ be ▁ more ▁ efficient . " ; this . eventSink . consumeEvent ( new ProfilerEvent ( ProfilerEvent . TYPE_WARN , " " , this . getCatalog ( ) , this . getId ( ) , - 1 , - 1 , System . currentTimeMillis ( ) , 0 , Constants . MILLIS_I18N , null , this . pointOfOrigin , message ) ) ; } } try { closeAllOpenStatements ( ) ; } catch ( SQLException ex ) { sqlEx = ex ; } if ( this . io != null ) { try { this . io . quit ( ) ; } catch ( Exception e ) { } } } else { this . io . forceClose ( ) ; } if ( this . statementInterceptors != null ) { for ( int i = 0 ; i < this . statementInterceptors . size ( ) ; i ++ ) { this . statementInterceptors . get ( i ) . destroy ( ) ; } } if ( this . exceptionInterceptor != null ) { this . exceptionInterceptor . destroy ( ) ; } } finally { this . openStatements . clear ( ) ; if ( this . io != null ) { this . io . releaseResources ( ) ; this . io = null ; } this . statementInterceptors = null ; this . exceptionInterceptor = null ; ProfilerEventHandlerFactory . removeInstance ( this ) ; synchronized ( getConnectionMutex ( ) ) { if ( this . cancelTimer != null ) { this . cancelTimer . cancel ( ) ; } } this . isClosed = true ; } if ( sqlEx != null ) { throw sqlEx ; } }
 public void createNewIO ( boolean isForReconnect ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { Properties mergedProps = exposeAsProperties ( this . props ) ; if ( ! getHighAvailability ( ) ) { connectOneTryOnly ( isForReconnect , mergedProps ) ; return ; } connectWithRetries ( isForReconnect , mergedProps ) ; } }
 @ Override public int getHeight ( ) { return bufImg . getHeight ( ) ; }
 @ Override protected void compile ( ) { GroovyClassLoader gcl = createClassLoader ( ) ; JavaStubCompilationUnit cu = new JavaStubCompilationUnit ( config , gcl , destdir ) ; int count = 0 ; String [ ] list = src . list ( ) ; for ( int i = 0 ; i < list . length ; i ++ ) { File basedir = getProject ( ) . resolveFile ( list [ i ] ) ; if ( ! basedir . exists ( ) ) { throw new BuildException ( " Source ▁ directory ▁ does ▁ not ▁ exist : ▁ " + basedir , getLocation ( ) ) ; } DirectoryScanner scanner = getDirectoryScanner ( basedir ) ; String [ ] includes = scanner . getIncludedFiles ( ) ; log . debug ( " Including ▁ files ▁ from : ▁ " + basedir ) ; for ( int j = 0 ; j < includes . length ; j ++ ) { log . debug ( " ▁ ▁ ▁ ▁ " + includes [ j ] ) ; File file = new File ( basedir , includes [ j ] ) ; cu . addSource ( file ) ; if ( ! includes [ j ] . endsWith ( " . java " ) ) { count ++ ; } } } if ( count > 0 ) { log . info ( " Generating ▁ " + count + " ▁ Java ▁ stub " + ( count > 1 ? " s " : " " ) + " ▁ to ▁ " + destdir ) ; cu . compile ( ) ; log . info ( " Generated ▁ " + cu . getStubCount ( ) + " ▁ Java ▁ stub ( s ) " ) ; } else { log . info ( " No ▁ sources ▁ found ▁ for ▁ stub ▁ generation " ) ; } }
 @ Override protected EClass eStaticClass ( ) { return ProductionPackage . Literals . HEAT_RATE_CURVE ; }
 @ Override public Context getApplicationContext ( ) { return context ; }
 private PushButton newSetMinutesButton ( final int minutes , final String label ) { final PushButton button = new PushButton ( label ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { @ SuppressWarnings ( { " deprecation " } ) Date d = box . getValue ( ) ; if ( d == null ) { d = new Date ( ) ; } d . setMinutes ( minutes ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
 public DefaultDatabaseOpenHelper ( final Context context ) { super ( context , DATABASE_NAME , null , DATABASE_VERSION ) ; }
 public Type getType ( String ... path ) { return getType ( path , 0 ) ; }
 protected T getNonFilteredItem ( int position ) { return adapter . getNonFilteredItem ( position ) ; }
 public DatabaseModel ( ) { _items = new HashMap < String , DatabaseItem > ( ) ; _properties = new HashMap < String , DatabaseProperty > ( ) ; }
 @ Test public void test ( ) { App . main ( new String [ ] { } ) ; }
 public Expression getExpression ( ) { return _expression ; }
 @ Override public void updateComponentServices ( final ServiceProto . ComponentRef componentRef , final Multimap < ServiceProto . ServiceRef , String > services , final Multimap < ServiceProto . ServiceRef , Integer > serviceFlags ) { LOGGER . info ( " counter ▁ now ▁ at ▁ { } . " , counter . incrementAndGet ( ) ) ; }
 protected void initFromFile ( ByteSequence bytes , boolean wide ) throws IOException { index = bytes . readInt ( ) ; length = 5 ; }
 public InteractionActivity ( final CredentialManager credentialManager , final InteractionRecorder interactionRecorder , final InteractionUtils interactionUtils , final InteractionJetty interactionJetty , final InteractionPreference interactionPreference , final ResponseFeedListener responseFeedListener , final InteractionVelocity interactionVelocity ) { this . credentialManager = credentialManager ; this . interactionRecorder = interactionRecorder ; this . interactionUtils = interactionUtils ; this . interactionJetty = interactionJetty ; this . interactionPreference = interactionPreference ; this . responseFeedListener = responseFeedListener ; this . interactionVelocity = interactionVelocity ; this . json = null ; }
 public java . lang . String getPassword ( ) { return get ( " password " ) ; }
 @ Deprecated public void clearHasTriedMaster ( ) { this . hasTriedMasterFlag = false ; }
 @ Override public void closeInventory ( ) { }
 public void testBackCompat ( ) throws Exception { assertEquals ( " \uDF05\uD866\uDF05\uD866" , ReverseStringFilter . reverse ( " 𩬅𩬅 " ) ) ; }
 @ Test public void blockchainUnspentTest ( ) { AddressUnspentsProvider uns = new BlockChainHTTPClient ( ) ; AddressTransactions tr = uns . getAddressUnspents ( "1G8sGKyw4wFGQXBZxk4df6uvCxGb1jR5sJ " ) ; System . out . println ( tr ) ; assertNotNull ( tr ) ; }
 public boolean containsPath ( String [ ] path ) { return containsPath ( path , 0 ) ; }
 @ Test public void testTransactionRollback_loaded ( ) { User user ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { user = cont . persistence ( ) . getEntityManager ( ) . find ( User . class , TestSupport . ADMIN_USER_ID ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
 public String getValue ( ) { return value ; }
 public ByteCodeNode generateCall ( FunctionInfo function , List < ByteCodeNode > arguments ) { Binding binding = callSiteBinder . bind ( function . getMethodHandle ( ) ) ; return generateInvocation ( scope , function , arguments , binding ) ; }
 public Scope getScope ( ) { return scope ; }
 public Authenticator getAuthenticator ( ) { return new Authenticator ( ) { protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( getUsername ( ) , getPassword ( ) ) ; } } ; }
 public String seedTipText ( ) { return " Specify ▁ the ▁ seed ▁ of ▁ randomization ▁ of ▁ the ▁ class ▁ order " ; }
 public void addProjected ( Collection < SchemaPath > paths ) { projected . addAll ( paths ) ; }
 public Enumeration listOptions ( ) { Vector newVector = new Vector ( 1 ) ; newVector . addElement ( new Option ( " \tSpecify ▁ the ▁ seed ▁ of ▁ randomization \n " + " \tused ▁ to ▁ randomize ▁ the ▁ class \n " + " \torder ▁ ( default : ▁ 1 ) " , " R " , 1 , " - R ▁ < seed > " ) ) ; newVector . addElement ( new Option ( " \tSpecify ▁ the ▁ class ▁ order ▁ to ▁ be \n " + " \tsorted , ▁ could ▁ be ▁ 0 : ▁ ascending \n " + " \t1 : ▁ descending ▁ and ▁ 2 : ▁ random . ( default : ▁ 0 ) " , " C " , 1 , " - C ▁ < order > " ) ) ; return newVector . elements ( ) ; }
 public StatusBarFooter ( final ApplicationWindow parent ) { this ( parent , SWT . BORDER | SWT . SHADOW_OUT ) ; }
 protected Main ( ) { }
 @ Override public int getAutoLoginCookieAge ( ) { return 0 ; }
 public SQLException interceptException ( SQLException sqlEx , Connection conn ) { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { sqlEx = ( ( ExceptionInterceptor ) iter . next ( ) ) . interceptException ( sqlEx , ConnectionImpl . this ) ; } } return sqlEx ; }
 public BootstrapConfiguration getBootstrapConfiguration ( ) { return null ; }
 @ Override protected void onStop ( ) { stopVoiceRecorder ( ) ; mSpeechService = null ; super . onStop ( ) ; }
 @ JsonProperty ( " codigoProduto " ) public Long getCodigoProduto ( ) { return codigoProduto ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { return clientPrepareStatement ( sql , resultSetType , resultSetConcurrency , true ) ; }
 public void setSubject ( String subject ) { this . subject = subject ; }
 public void setDefaultEncoding ( String defaultEncoding ) { this . defaultEncoding = defaultEncoding ; }
 public BaseFilter ( int highlightColor ) throws AssertionError { setHighlightColor ( highlightColor ) ; }
 public void insert ( final FluoClient fluo , final RyaStatement triple , final Optional < String > visibility ) { insert ( fluo , Collections . singleton ( triple ) , visibility ) ; }
 @ Override protected void recreateParentService ( OperationContext context , PathAddress parentAddress , ModelNode parentModel , ServiceVerificationHandler verificationHandler ) throws OperationFailedException { }
 public BaseFilter ( @ NonNull Context context ) throws AssertionError { highlightColor = ContextCompat . getColor ( context , R . color . colorAccent ) ; }
 @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " class ▁ RegimeEspecialIntegracaoDTO ▁ { \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ seq : ▁ " ) . append ( toIndentedString ( seq ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ codigoProduto : ▁ " ) . append ( toIndentedString ( codigoProduto ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ cpfCnpjRaiz : ▁ " ) . append ( toIndentedString ( cpfCnpjRaiz ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ numeroAto : ▁ " ) . append ( toIndentedString ( numeroAto ) ) . append ( " \n " ) ; sb . append ( " ▁ ▁ ▁ ▁ numeroItem : ▁ " ) . append ( toIndentedString ( numeroItem ) ) . append ( " \n " ) ; sb . append ( " } " ) ; return sb . toString ( ) ; }
 public double [ ] getClassCounts ( ) { if ( m_ClassAttribute . isNominal ( ) ) return m_ClassCounts ; else return null ; }
 @ Test public void testTransactionDelete ( ) { long transactionId = 1 ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; tableHandle = metadata . beginDelete ( SESSION , tableHandle ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; assertEquals ( raptorTableHandle . getTransactionId ( ) , OptionalLong . of ( transactionId ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . rollback ( ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertFalse ( transactionSuccessful ( transactionId ) ) ; transactionId ++ ; tableHandle = metadata . beginDelete ( SESSION , tableHandle ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishDelete ( SESSION , tableHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
 @ Override public void checkCanSetCatalogSessionProperty ( TransactionId transactionId , Identity identity , AccessControlContext context , String catalogName , String propertyName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , catalogName + " . " + propertyName , SET_SESSION ) ) { denySetCatalogSessionProperty ( catalogName , propertyName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetCatalogSessionProperty ( transactionId , identity , context , catalogName , propertyName ) ; } }
 public GameButton ( TextureRegion region , float x , float y ) { this ( region , x , y , 1.0f , 0.98f ) ; }
 public java . lang . String getLoginIp ( ) { return get ( " login _ ip " ) ; }
 public RegionMonitoringScannerImpl ( ContextProvider contextProvider , BeaconManager beaconManager , MonitoringListener monitoringListener , BeaconsController beaconsController , BeaconRegionAndroidMapper regionMapper ) { this . beaconManager = beaconManager ; this . beaconsController = beaconsController ; this . context = contextProvider . getApplicationContext ( ) ; this . monitoringListener = monitoringListener ; this . regionMapper = regionMapper ; this . beaconManager . setMonitorNotifier ( this ) ; }
 public DateTimeBox ( ) { super ( new DateTimePicker ( ) , null , DATE_FORMAT ) ; ( ( DateTimePicker ) getDatePicker ( ) ) . setDateTimeBox ( this ) ; final TextBox textbox = getTextBox ( ) ; textbox . setVisibleLength ( 19 + 2 ) ; textbox . setMaxLength ( 19 ) ; }
 public String xmlDigest ( ) { String xml = " < Database > \n < Properties > \n " ; for ( DatabaseProperty property : _properties . values ( ) ) { xml += property . toXML ( ) + " \n " ; } xml += " < / Properties > \n < Items > \n " ; for ( DatabaseItem item : _items . values ( ) ) { xml += item . toXML ( ) + " \n " ; } xml += " < / Items > \n < / Database > " ; return xml ; }
 private void addToHistogram ( int [ ] histogramCounts , long [ ] histogramBreakpoints , long value , int numberOfTimes , long currentLowerBound , long currentUpperBound ) { if ( histogramCounts == null ) { createInitialHistogram ( histogramBreakpoints , currentLowerBound , currentUpperBound ) ; } else { for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { if ( histogramBreakpoints [ i ] >= value ) { histogramCounts [ i ] += numberOfTimes ; break ; } } } }
 public String getServerCharset ( ) { if ( this . io . versionMeetsMinimum ( 4 , 1 , 0 ) ) { String charset = null ; if ( this . indexToCustomMysqlCharset != null ) { charset = this . indexToCustomMysqlCharset . get ( this . io . serverCharsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetNameForCollationIndex ( this . io . serverCharsetIndex ) ; } return charset != null ? charset : this . serverVariables . get ( " character _ set _ server " ) ; } return this . serverVariables . get ( " character _ set " ) ; }
 public ExceptionHandlerConstantVisitor ( ConstantVisitor constantVisitor ) { this . constantVisitor = constantVisitor ; }
 @ Override public < T > T unwrap ( Class < T > type ) { return null ; }
 @ Test public void testAddColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; metadata . addColumn ( SESSION , raptorTableHandle , new ColumnMetadata ( " new _ col " , BIGINT ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , raptorTableHandle ) . get ( " new _ col " ) ) ; }
 public java . sql . PreparedStatement serverPrepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) serverPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
 @ Test public void testCreateBucketedTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " custkey " , " orderkey " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 1 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; metadata . createTable ( SESSION , ordersTable , false ) ; tableId = ( ( RaptorTableHandle ) metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) . getTableId ( ) ; assertEquals ( tableId , 2 ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 2 ) ) ; }
 @ Override protected void setup ( ) { final HorizontalPanel panel = new HorizontalPanel ( ) ; initWidget ( panel ) ; setStyleName ( panel . getElement ( ) , " gwt - DatePicker " ) ; { final VerticalPanel vbox = new VerticalPanel ( ) ; setStyleName ( " gwt - DatePicker " ) ; vbox . add ( super . getMonthSelector ( ) ) ; vbox . add ( super . getView ( ) ) ; panel . add ( vbox ) ; } { final VerticalPanel vbox = new VerticalPanel ( ) ; setStyleName ( vbox . getElement ( ) , " datePickerMonthSelector " ) ; final PushButton now = new PushButton ( " now " ) ; now . setStyleName ( " datePickerNextButton " ) ; now . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { box . setValue ( new Date ( ) ) ; } } ) ; { final Grid grid = new Grid ( 2 , 9 ) ; grid . setWidget ( 0 , 0 , newShiftDateButton ( - 3600 , "1h " ) ) ; grid . setWidget ( 0 , 1 , newShiftDateButton ( - 600 , "10m " ) ) ; grid . setWidget ( 0 , 2 , newShiftDateButton ( - 60 , "1m " ) ) ; grid . setWidget ( 0 , 3 , new InlineHTML ( " & lsaquo ; " ) ) ; grid . setWidget ( 0 , 4 , now ) ; grid . setWidget ( 0 , 5 , new InlineHTML ( " & rsaquo ; " ) ) ; grid . setWidget ( 0 , 6 , newShiftDateButton ( + 60 , "1m " ) ) ; grid . setWidget ( 0 , 7 , newShiftDateButton ( + 600 , "10m " ) ) ; grid . setWidget ( 0 , 8 , newShiftDateButton ( + 3600 , "1h " ) ) ; grid . setWidget ( 1 , 0 , newShiftDateButton ( - 86400 * 30 , "30d " ) ) ; grid . setWidget ( 1 , 1 , newShiftDateButton ( - 86400 * 7 , "1w " ) ) ; grid . setWidget ( 1 , 2 , newShiftDateButton ( - 86400 , "1d " ) ) ; grid . setWidget ( 1 , 3 , new InlineHTML ( " & laquo ; " ) ) ; grid . setWidget ( 1 , 4 , new InlineHTML ( " & nbsp ; " ) ) ; grid . setWidget ( 1 , 5 , new InlineHTML ( " & raquo ; " ) ) ; grid . setWidget ( 1 , 6 , newShiftDateButton ( + 86400 , "1d " ) ) ; grid . setWidget ( 1 , 7 , newShiftDateButton ( + 86400 * 7 , "1w " ) ) ; grid . setWidget ( 1 , 8 , newShiftDateButton ( + 86400 * 30 , "30d " ) ) ; final CellFormatter formatter = grid . getCellFormatter ( ) ; formatter . setWidth ( 0 , 4 , "100 % " ) ; formatter . setWidth ( 1 , 4 , "100 % " ) ; vbox . add ( grid ) ; } { hours_minutes = new Grid ( 4 , 8 ) ; setupAmUI ( ) ; hours_minutes . setWidget ( 0 , 0 , new InlineLabel ( " HH " ) ) ; final PushButton set_am = new PushButton ( " AM " ) ; set_am . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { setupAmUI ( ) ; } } ) ; hours_minutes . setWidget ( 0 , 7 , set_am ) ; final PushButton set_pm = new PushButton ( " PM " ) ; set_pm . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { setupPmUI ( ) ; } } ) ; hours_minutes . setWidget ( 1 , 7 , set_pm ) ; hours_minutes . setWidget ( 2 , 0 , new InlineLabel ( " MM " ) ) ; hours_minutes . setWidget ( 2 , 1 , newSetMinutesButton ( 0 , "00" ) ) ; hours_minutes . setWidget ( 2 , 2 , newSetMinutesButton ( 10 , "10" ) ) ; hours_minutes . setWidget ( 2 , 3 , newSetMinutesButton ( 20 , "20" ) ) ; hours_minutes . setWidget ( 2 , 4 , newSetMinutesButton ( 30 , "30" ) ) ; hours_minutes . setWidget ( 2 , 5 , newSetMinutesButton ( 40 , "40" ) ) ; hours_minutes . setWidget ( 2 , 6 , newSetMinutesButton ( 50 , "50" ) ) ; vbox . add ( hours_minutes ) ; } { final HorizontalPanel hbox = new HorizontalPanel ( ) ; hbox . add ( new InlineLabel ( " UNIX ▁ timestamp : " ) ) ; final ValidatedTextBox ts = new ValidatedTextBox ( ) ; ts . setValidationRegexp ( " ^ ( | [ 1-9 ] [ 0-9 ] { 0,9 } ) $ " ) ; ts . setVisibleLength ( 10 ) ; ts . setMaxLength ( 10 ) ; final EventsHandler handler = new EventsHandler ( ) { protected < H extends EventHandler > void onEvent ( final DomEvent < H > event ) { final Date d = new Date ( Integer . parseInt ( ts . getValue ( ) ) * 1000L ) ; box . setValue ( d , true ) ; } } ; ts . addBlurHandler ( handler ) ; ts . addKeyPressHandler ( handler ) ; hbox . add ( ts ) ; vbox . add ( hbox ) ; } vbox . setHeight ( "100 % " ) ; panel . add ( vbox ) ; panel . setCellHeight ( vbox , "100 % " ) ; } }
 public InventoryCellphone ( ItemStack cellphone ) { if ( cellphone == null || ! ( cellphone . getItem ( ) instanceof ItemCellphone ) ) { throw new IllegalArgumentException ( " Invalid ▁ ItemStack ▁ when ▁ creating ▁ a ▁ " + this . getClass ( ) . getSimpleName ( ) + " ▁ instance " ) ; } this . cellphone = cellphone ; this . readFromNBT ( StackUtils . getNBT ( cellphone ) ) ; }
 public Connection getConnection ( String name ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { return pool . getConnection ( ) ; } return null ; }
 public java . sql . CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } CallableStatement cStmt = ( com . mysql . jdbc . CallableStatement ) prepareCall ( sql , resultSetType , resultSetConcurrency ) ; return cStmt ; }
 public boolean isSameResource ( Connection otherConnection ) { synchronized ( getConnectionMutex ( ) ) { if ( otherConnection == null ) { return false ; } boolean directCompare = true ; String otherHost = ( ( ConnectionImpl ) otherConnection ) . origHostToConnectTo ; String otherOrigDatabase = ( ( ConnectionImpl ) otherConnection ) . origDatabaseToConnectTo ; String otherCurrentCatalog = ( ( ConnectionImpl ) otherConnection ) . database ; if ( ! nullSafeCompare ( otherHost , this . origHostToConnectTo ) ) { directCompare = false ; } else if ( otherHost != null && otherHost . indexOf ( ' , ' ) == - 1 && otherHost . indexOf ( ' : ' ) == - 1 ) { directCompare = ( ( ( ConnectionImpl ) otherConnection ) . origPortToConnectTo == this . origPortToConnectTo ) ; } if ( directCompare ) { if ( ! nullSafeCompare ( otherOrigDatabase , this . origDatabaseToConnectTo ) || ! nullSafeCompare ( otherCurrentCatalog , this . database ) ) { directCompare = false ; } } if ( directCompare ) { return true ; } String otherResourceId = ( ( ConnectionImpl ) otherConnection ) . getResourceId ( ) ; String myResourceId = getResourceId ( ) ; if ( otherResourceId != null || myResourceId != null ) { directCompare = nullSafeCompare ( otherResourceId , myResourceId ) ; if ( directCompare ) { return true ; } } return false ; } }
 List < Type > getTypes ( ) { return types ; }
 private String varStatementsToString ( ) { String s = " " ; for ( IVarStatement varStmt : getVarStatements ( ) ) { if ( s . length ( ) == 0 ) { s += varStmt . toString ( ) ; } else { s += " , ▁ " ; } } return s ; }
 public RecyclerView . AdapterDataObserver getAdapterDataObserver ( ) { return adapterDataObserver ; }
 public int getMaxRepetitionLevel ( String ... path ) { return getMaxRepetitionLevel ( path , 0 ) - 1 ; }
 @ Test public void testDirectConnectionConnectTriesEqualsDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; " + " tries = 2" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
 public void setIsNetGrossP ( boolean newIsNetGrossP ) { boolean oldIsNetGrossP = isNetGrossP ; isNetGrossP = newIsNetGrossP ; if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P , oldIsNetGrossP , isNetGrossP ) ) ; }
 public PeerSpaceReclaiming ( BackupSystem bs ) { super ( bs . Comm . MC . Publisher ) ; _bs = bs ; start ( new MessageFilter ( Message . Type . REMOVED ) ) ; }
 @ Test public void testCreateViewWithReplace ( ) { SchemaTableName test = new SchemaTableName ( " test " , " test _ view " ) ; metadata . createView ( SESSION , test , " aaa " , true ) ; metadata . createView ( SESSION , test , " bbb " , true ) ; assertEquals ( metadata . getViews ( SESSION , test . toSchemaTablePrefix ( ) ) . get ( test ) . getViewData ( ) , " bbb " ) ; }
 public void registerResources ( String alias , String name , HttpContext context ) throws NamespaceException { if ( ! isNameValid ( name ) ) { throw new IllegalArgumentException ( " Malformed ▁ resource ▁ name ▁ [ " + name + " ] " ) ; } try { Servlet servlet = new ResourceServlet ( name ) ; registerServlet ( alias , servlet , null , context ) ; } catch ( ServletException e ) { SystemLogger . error ( " Failed ▁ to ▁ register ▁ resources " , e ) ; } }
 @ Deprecated public String getCharsetNameForIndex ( int charsetIndex ) throws SQLException { return getEncodingForIndex ( charsetIndex ) ; }
 @ Before public void init ( ) { }
 @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { this . execCommand ( ctx , e , ( ) -> { List < ItemInstance > inventory = player . getInventory ( ) ; if ( inventory == null ) { write ( " You ▁ aren ' t ▁ carrying ▁ anything . " ) ; return ; } StringBuilder inventoryString = new StringBuilder ( ) ; inventoryString . append ( " You ▁ are ▁ carrying : \r \n " ) ; inventoryString . append ( RESET ) ; String join = StringUtils . join ( player . getRolledUpIntentory ( ) . toArray ( ) , " \r \n " ) ; inventoryString . append ( join ) ; write ( inventoryString . toString ( ) ) ; } ) ; }
 public RegimeEspecialIntegracaoDTO codigoProduto ( Long codigoProduto ) { this . codigoProduto = codigoProduto ; return this ; }
 public void testPipe ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Pipe . Schema < Zoo > pipeSchema = ( ( MappedSchema < Zoo > ) schema ) . pipeSchema ; Zoo p = filledZoo ( ) ; ProtostuffPipeTest . roundTrip ( p , schema , pipeSchema ) ; }
 public void setChildrenSet ( Set childrenSet ) { this . childrenSet = childrenSet ; }
 private void log ( String msg ) { log . println ( new Date ( ) + " : ▁ " + msg ) ; }
 private void createAndAddMultiAggPlans ( CPlanMemoTable memo , ArrayList < Hop > roots ) { HashSet < Long > fullAggs = new HashSet < > ( ) ; Hop . resetVisitStatus ( roots ) ; for ( Hop hop : roots ) rCollectFullAggregates ( hop , fullAggs ) ; Hop . resetVisitStatus ( roots ) ; fullAggs . removeIf ( p -> memo . contains ( p , TemplateType . MAGG ) ) ; if ( fullAggs . size ( ) <= 1 ) return ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Found ▁ across - partition ▁ ua ( RC ) ▁ aggregations : ▁ " + Arrays . toString ( fullAggs . toArray ( new Long [ 0 ] ) ) ) ; } List < AggregateInfo > aggInfos = new ArrayList < > ( ) ; for ( Long hopID : fullAggs ) { Hop aggHop = memo . getHopRefs ( ) . get ( hopID ) ; AggregateInfo tmp = new AggregateInfo ( aggHop ) ; for ( int i = 0 ; i < aggHop . getInput ( ) . size ( ) ; i ++ ) { Hop c = HopRewriteUtils . isMatrixMultiply ( aggHop ) && i == 0 ? aggHop . getInput ( ) . get ( 0 ) . getInput ( ) . get ( 0 ) : aggHop . getInput ( ) . get ( i ) ; rExtractAggregateInfo ( memo , c , tmp , TemplateType . CELL ) ; } if ( tmp . _fusedInputs . isEmpty ( ) ) { if ( HopRewriteUtils . isMatrixMultiply ( aggHop ) ) { tmp . addFusedInput ( aggHop . getInput ( ) . get ( 0 ) . getInput ( ) . get ( 0 ) . getHopID ( ) ) ; tmp . addFusedInput ( aggHop . getInput ( ) . get ( 1 ) . getHopID ( ) ) ; } else tmp . addFusedInput ( aggHop . getInput ( ) . get ( 0 ) . getHopID ( ) ) ; } aggInfos . add ( tmp ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Extracted ▁ across - partition ▁ ua ( RC ) ▁ aggregation ▁ info : ▁ " ) ; for ( AggregateInfo info : aggInfos ) LOG . trace ( info ) ; } aggInfos = aggInfos . stream ( ) . sorted ( Comparator . comparing ( a -> a . _inputAggs . size ( ) ) ) . collect ( Collectors . toList ( ) ) ; boolean converged = false ; while ( ! converged ) { AggregateInfo merged = null ; for ( int i = 0 ; i < aggInfos . size ( ) ; i ++ ) { AggregateInfo current = aggInfos . get ( i ) ; for ( int j = i + 1 ; j < aggInfos . size ( ) ; j ++ ) { AggregateInfo that = aggInfos . get ( j ) ; if ( current . isMergable ( that ) ) { merged = current . merge ( that ) ; aggInfos . remove ( j ) ; j -- ; } } } converged = ( merged == null ) ; } if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( " Merged ▁ across - partition ▁ ua ( RC ) ▁ aggregation ▁ info : ▁ " ) ; for ( AggregateInfo info : aggInfos ) LOG . trace ( info ) ; } for ( AggregateInfo info : aggInfos ) { if ( info . _aggregates . size ( ) <= 1 ) continue ; Long [ ] aggs = info . _aggregates . keySet ( ) . toArray ( new Long [ 0 ] ) ; MemoTableEntry me = new MemoTableEntry ( TemplateType . MAGG , aggs [ 0 ] , aggs [ 1 ] , ( aggs . length > 2 ) ? aggs [ 2 ] : - 1 , aggs . length ) ; for ( int i = 0 ; i < aggs . length ; i ++ ) { memo . add ( memo . getHopRefs ( ) . get ( aggs [ i ] ) , me ) ; addBestPlan ( aggs [ i ] , me ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Added ▁ multiagg * ▁ plan : ▁ " + aggs [ i ] + " ▁ " + me ) ; } } }
 @ Test public void generateCommandJcdkWithWrongJcdkPathFailure ( ) throws Exception { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Provided ▁ JCDK ▁ path ▁ is ▁ not ▁ valid : ▁ " + jcdkWrongPath ) ; JcdkWrapperImpl . generateCommand ( jcdkInstallationWrongPath , configurationFile ) ; }
 @ Override public String getLinkLoginURL ( ) { return null ; }
 private void addToTablesAccessedHistogram ( long value , int numberOfTimes ) { checkAndCreateTablesAccessedHistogram ( ) ; addToHistogram ( this . numTablesMetricsHistCounts , this . numTablesMetricsHistBreakpoints , value , numberOfTimes , this . minimumNumberTablesAccessed == Long . MAX_VALUE ? 0 : this . minimumNumberTablesAccessed , this . maximumNumberTablesAccessed ) ; }
 private void readLsLine ( String line , HashMap < String , LsElements > fileContents ) { String elements [ ] = line . split ( " \\ s + " ) ; assertEquals ( " Not ▁ enough ▁ elements ▁ in ▁ ls ▁ output " , 8 , elements . length ) ; LsElements lsLine = new LsElements ( ) ; lsLine . dir = elements [ 0 ] . charAt ( 0 ) ; lsLine . perms = elements [ 0 ] . substring ( 1 ) ; lsLine . replication = elements [ 1 ] . equals ( " - " ) ? 0 : Integer . valueOf ( elements [ 1 ] ) ; lsLine . username = elements [ 2 ] ; lsLine . groupname = elements [ 3 ] ; lsLine . filesize = Long . valueOf ( elements [ 4 ] ) ; String path = elements [ 7 ] ; assertFalse ( " LS ▁ file ▁ had ▁ duplicate ▁ file ▁ entries " , fileContents . containsKey ( path ) ) ; fileContents . put ( path , lsLine ) ; }
 public Properties getProperties ( ) { return this . props ; }
 public void setReturn ( String value ) { this . _return = value ; }
 @ Override public TraversableResolver getTraversableResolver ( ) { return null ; }
 public Calendar getCalendarInstanceForSessionOrNew ( ) { if ( getDynamicCalendars ( ) ) { return Calendar . getInstance ( ) ; } return getSessionLockedCalendar ( ) ; }
 private ScanFieldDeterminer ( ) { }
 @ Override public ItemStack getStackInSlotOnClosing ( int slot ) { ItemStack itemStack = this . getStackInSlot ( slot ) ; if ( itemStack != null ) { this . setInventorySlotContents ( slot , null ) ; } return itemStack ; }
 public void addReferenced ( SchemaPath path ) { referenced . add ( path ) ; }
 public TimeZone getServerTimezoneTZ ( ) { return this . serverTimezoneTZ ; }
 public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + Float . floatToIntBits ( normalBodyTemperature ) ; return result ; }
 public String extractSqlFromPacket ( String possibleSqlQuery , Buffer queryPacket , int endOfQueryPacketPosition ) throws SQLException { String extractedSql = null ; if ( possibleSqlQuery != null ) { if ( possibleSqlQuery . length ( ) > getMaxQuerySizeToLog ( ) ) { StringBuilder truncatedQueryBuf = new StringBuilder ( possibleSqlQuery . substring ( 0 , getMaxQuerySizeToLog ( ) ) ) ; truncatedQueryBuf . append ( Messages . getString ( " MysqlIO . 25" ) ) ; extractedSql = truncatedQueryBuf . toString ( ) ; } else { extractedSql = possibleSqlQuery ; } } if ( extractedSql == null ) { int extractPosition = endOfQueryPacketPosition ; boolean truncated = false ; if ( endOfQueryPacketPosition > getMaxQuerySizeToLog ( ) ) { extractPosition = getMaxQuerySizeToLog ( ) ; truncated = true ; } extractedSql = StringUtils . toString ( queryPacket . getByteBuffer ( ) , 5 , ( extractPosition - 5 ) ) ; if ( truncated ) { extractedSql += Messages . getString ( " MysqlIO . 25" ) ; } } return extractedSql ; }
 public int maxSatisfied ( int [ ] customers , int [ ] grumpy , int X ) { int [ ] dp = new int [ customers . length + 1 ] ; int [ ] zoreDp = new int [ customers . length + 1 ] ; int max = X > customers . length ? customers . length : X ; int sum = 0 ; for ( int i = 0 ; i < customers . length ; i ++ ) { if ( i < X ) { dp [ i + 1 ] = sum += customers [ i ] ; } zoreDp [ i + 1 ] = ( grumpy [ i ] == 0 ) ? customers [ i ] + zoreDp [ i ] : zoreDp [ i ] ; } int retMax = dp [ max ] + zoreDp [ customers . length ] - zoreDp [ max ] ; for ( int i = X ; i < customers . length ; i ++ ) { dp [ i + 1 ] = dp [ i ] - customers [ i - X ] + customers [ i ] ; int otherZore = zoreDp [ customers . length ] - zoreDp [ i + 1 ] + zoreDp [ i - X + 1 ] ; retMax = Math . max ( retMax , dp [ i + 1 ] + otherZore ) ; } return retMax ; }
 public synchronized void release ( ) { if ( -- clients != 0 ) { return ; } Enumeration allPools = pools . elements ( ) ; while ( allPools . hasMoreElements ( ) ) { ConnPool pool = ( ConnPool ) allPools . nextElement ( ) ; pool . release ( ) ; } Enumeration allDrivers = drivers . elements ( ) ; while ( allDrivers . hasMoreElements ( ) ) { Driver driver = ( Driver ) allDrivers . nextElement ( ) ; try { DriverManager . deregisterDriver ( driver ) ; log ( " 撤销JDBC驱动程序 ▁ " + driver . getClass ( ) . getName ( ) + " 的注册 " ) ; } catch ( SQLException e ) { log ( e , " 无法撤销下列JDBC驱动程序的注册 : ▁ " + driver . getClass ( ) . getName ( ) ) ; } } }
 public void close ( ) { threadPool . close ( false ) ; }
 public int getStoredPearls ( ) { ItemStack pearls = this . getStackInSlot ( 0 ) ; return pearls != null ? pearls . stackSize : 0 ; }
 public void testFilterWithMark ( ) throws Exception { TokenStream stream = new MockTokenizer ( new StringReader ( " Do ▁ have ▁ a ▁ nice ▁ day " ) , MockTokenizer . WHITESPACE , false ) ; ReverseStringFilter filter = new ReverseStringFilter ( TEST_VERSION_CURRENT , stream , ' \u0001' ) ; assertTokenStreamContents ( filter , new String [ ] { " \u0001oD " , " \u0001evah " , " \u0001a " , " \u0001ecin " , " \u0001yad " } ) ; }
 public RegimeEspecialIntegracaoDTO numeroAto ( String numeroAto ) { this . numeroAto = numeroAto ; return this ; }
 public void setContentType ( String contentType ) { this . contentType = contentType ; }
 @ Override public void checkCanCreateViewWithSelectFromColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , Set < String > columnNames ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , CREATE_VIEW_WITH_SELECT_COLUMNS ) ) { denyCreateViewWithSelect ( tableName . toString ( ) , identity ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateViewWithSelectFromColumns ( transactionId , identity , context , tableName , columnNames ) ; } }
 @ Test public final void test_that_a_Comments_value_cannot_be_NULL ( ) { try { new Comments ( null ) ; fail ( " Expected ▁ a ▁ NullPointerException . " ) ; } catch ( final NullPointerException e ) { assertEquals ( " Missing ▁ ' value ' . " , e . getMessage ( ) ) ; } }
 private void addToPerformanceHistogram ( long value , int numberOfTimes ) { checkAndCreatePerformanceHistogram ( ) ; addToHistogram ( this . perfMetricsHistCounts , this . perfMetricsHistBreakpoints , value , numberOfTimes , this . shortestQueryTimeMs == Long . MAX_VALUE ? 0 : this . shortestQueryTimeMs , this . longestQueryTimeMs ) ; }
 public DatabaseProperty getPropertyValue ( String propertyName ) { return _properties . get ( propertyName ) ; }
 public void initializeResultsMetadataFromCache ( String sql , CachedResultSetMetaData cachedMetaData , ResultSetInternalMethods resultSet ) throws SQLException { if ( cachedMetaData == null ) { cachedMetaData = new CachedResultSetMetaData ( ) ; resultSet . buildIndexMapping ( ) ; resultSet . initializeWithMetadata ( ) ; if ( resultSet instanceof UpdatableResultSet ) { ( ( UpdatableResultSet ) resultSet ) . checkUpdatability ( ) ; } resultSet . populateCachedMetaData ( cachedMetaData ) ; this . resultSetMetadataCache . put ( sql , cachedMetaData ) ; } else { resultSet . initializeFromCachedMetaData ( cachedMetaData ) ; resultSet . initializeWithMetadata ( ) ; if ( resultSet instanceof UpdatableResultSet ) { ( ( UpdatableResultSet ) resultSet ) . checkUpdatability ( ) ; } } }
 public double getMaxInputSize ( ) { return inSizes . values ( ) . stream ( ) . mapToDouble ( d -> d . doubleValue ( ) ) . max ( ) . orElse ( 0 ) ; }
 @ Test public void testTableProperties ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) , TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , true ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , Long . valueOf ( 4 ) ) ; assertFalse ( metadataDao . getTableInformation ( tableId ) . isOrganized ( ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
 public List getChildrenList ( ) { return childrenList ; }
 private boolean isFamilyBudgetEnough ( BigDecimal familyBudget , Offer offer ) { BigDecimal finalPrice = offer . getApartmentRent ( ) . add ( offer . getAgencyCommission ( ) . divide ( new BigDecimal ( 100 ) ) . multiply ( offer . getApartmentRent ( ) ) ) ; return familyBudget . compareTo ( finalPrice ) >= 0 ; }
 @ Override public AuthenticationContext getAuthenticationContext ( ) { return null ; }
 public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someBearField == null ) ? 0 : someBearField . hashCode ( ) ) ; return result ; }
 private int parsePortNumber ( String portAsString ) throws SQLException { int portNumber = 3306 ; try { portNumber = Integer . parseInt ( portAsString ) ; } catch ( NumberFormatException nfe ) { throw SQLError . createSQLException ( " Illegal ▁ connection ▁ port ▁ value ▁ ' " + portAsString + " ' " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } return portNumber ; }
 public void setOnItemClickListener ( OnItemClickListener listener ) { mCallback = listener ; }
 @ Test public void outputOfFileDistributionVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; File outputFile = new File ( ROOT , " / fileDistributionCheckOutput " ) ; int totalFiles = 0 ; BufferedReader reader = null ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; ImageVisitor v = new FileDistributionVisitor ( outputFile . getPath ( ) , 0 , 0 ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; oiv . go ( ) ; reader = new BufferedReader ( new FileReader ( outputFile ) ) ; String line = reader . readLine ( ) ; assertEquals ( line , " Size\tNumFiles " ) ; while ( ( line = reader . readLine ( ) ) != null ) { String [ ] row = line . split ( " \t " ) ; assertEquals ( row . length , 2 ) ; totalFiles += Integer . parseInt ( row [ 1 ] ) ; } } finally { if ( reader != null ) { reader . close ( ) ; } if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } assertEquals ( totalFiles , NUM_DIRS * FILES_PER_DIR ) ; }
 @ Override public void executeAsynch ( final Map < String , T2Reference > inputs , final AsynchronousActivityCallback callback ) { final InteractionRequestor requestor = new InteractionCallbackRequestor ( this , callback , inputs ) ; callback . requestRun ( new InteractionActivityRunnable ( requestor , this . presentationTemplate , this . credentialManager , this . interactionRecorder , this . interactionUtils , this . interactionJetty , this . interactionPreference , this . responseFeedListener , this . interactionVelocity ) ) ; }
 public void setExternalToIncrementalCompiler ( int myExternalToIncrementalCompiler ) { this . myExternalToIncrementalCompiler = myExternalToIncrementalCompiler ; }
 public MonitorWriteAttributeHandler ( AttributeDefinition ... definitions ) { super ( MonitorDefinition . MONITOR , definitions ) ; }
 @ Bean public TestPresenceListener testPresenceListener ( ) { return new TestPresenceListener ( ) ; }
 public Class < DrillServiceInstance > typeClass ( ) { return DrillServiceInstance . class ; }
 public List < Region > obtainRegionsInRange ( ) { return regionsInEnter ; }
 List < Integer > getOutputChannels ( ) { return outputChannels ; }
 public int getServerMajorVersion ( ) { return this . io . getServerMajorVersion ( ) ; }
 public void testProtostuff ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo p = filledZoo ( ) ; byte [ ] data = ProtostuffIOUtil . toByteArray ( p , schema , buf ( ) ) ; Zoo p2 = new Zoo ( ) ; ProtostuffIOUtil . mergeFrom ( data , 0 , data . length , p2 , schema ) ; assertEquals ( p , p2 ) ; List < Zoo > list = new ArrayList < Zoo > ( ) ; list . add ( p ) ; list . add ( p2 ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( ) ; ProtostuffIOUtil . writeListTo ( out , list , schema , buf ( ) ) ; byte [ ] listData = out . toByteArray ( ) ; ByteArrayInputStream in = new ByteArrayInputStream ( listData ) ; List < Zoo > parsedList = ProtostuffIOUtil . parseListFrom ( in , schema ) ; assertEquals ( list , parsedList ) ; }
 private boolean configureClientCharacterSet ( boolean dontCheckServerMatch ) throws SQLException { String realJavaEncoding = getEncoding ( ) ; boolean characterSetAlreadyConfigured = false ; try { if ( versionMeetsMinimum ( 4 , 1 , 0 ) ) { characterSetAlreadyConfigured = true ; setUseUnicode ( true ) ; configureCharsetProperties ( ) ; realJavaEncoding = getEncoding ( ) ; try { if ( this . props != null && this . props . getProperty ( " com . mysql . jdbc . faultInjection . serverCharsetIndex " ) != null ) { this . io . serverCharsetIndex = Integer . parseInt ( this . props . getProperty ( " com . mysql . jdbc . faultInjection . serverCharsetIndex " ) ) ; } String serverEncodingToSet = CharsetMapping . getJavaEncodingForCollationIndex ( this . io . serverCharsetIndex ) ; if ( serverEncodingToSet == null || serverEncodingToSet . length ( ) == 0 ) { if ( realJavaEncoding != null ) { setEncoding ( realJavaEncoding ) ; } else { throw SQLError . createSQLException ( " Unknown ▁ initial ▁ character ▁ set ▁ index ▁ ' " + this . io . serverCharsetIndex + " ' ▁ received ▁ from ▁ server . ▁ Initial ▁ client ▁ character ▁ set ▁ can ▁ be ▁ forced ▁ via ▁ the ▁ ' characterEncoding ' ▁ property . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } if ( versionMeetsMinimum ( 4 , 1 , 0 ) && " ISO8859_1" . equalsIgnoreCase ( serverEncodingToSet ) ) { serverEncodingToSet = " Cp1252" ; } if ( " UnicodeBig " . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 16" . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 16LE " . equalsIgnoreCase ( serverEncodingToSet ) || " UTF - 32" . equalsIgnoreCase ( serverEncodingToSet ) ) { serverEncodingToSet = " UTF - 8" ; } setEncoding ( serverEncodingToSet ) ; } catch ( ArrayIndexOutOfBoundsException outOfBoundsEx ) { if ( realJavaEncoding != null ) { setEncoding ( realJavaEncoding ) ; } else { throw SQLError . createSQLException ( " Unknown ▁ initial ▁ character ▁ set ▁ index ▁ ' " + this . io . serverCharsetIndex + " ' ▁ received ▁ from ▁ server . ▁ Initial ▁ client ▁ character ▁ set ▁ can ▁ be ▁ forced ▁ via ▁ the ▁ ' characterEncoding ' ▁ property . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( getEncoding ( ) == null ) { setEncoding ( " ISO8859_1" ) ; } if ( getUseUnicode ( ) ) { if ( realJavaEncoding != null ) { if ( realJavaEncoding . equalsIgnoreCase ( " UTF - 8" ) || realJavaEncoding . equalsIgnoreCase ( " UTF8" ) ) { boolean utf8mb4Supported = versionMeetsMinimum ( 5 , 5 , 2 ) ; boolean useutf8mb4 = utf8mb4Supported && ( CharsetMapping . UTF8MB4_INDEXES . contains ( this . io . serverCharsetIndex ) ) ; if ( ! getUseOldUTF8Behavior ( ) ) { if ( dontCheckServerMatch || ! characterSetNamesMatches ( " utf8" ) || ( utf8mb4Supported && ! characterSetNamesMatches ( " utf8mb4" ) ) ) { execSQL ( null , " SET ▁ NAMES ▁ " + ( useutf8mb4 ? " utf8mb4" : " utf8" ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , useutf8mb4 ? " utf8mb4" : " utf8" ) ; this . serverVariables . put ( " character _ set _ connection " , useutf8mb4 ? " utf8mb4" : " utf8" ) ; } } else { execSQL ( null , " SET ▁ NAMES ▁ latin1" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , " latin1" ) ; this . serverVariables . put ( " character _ set _ connection " , " latin1" ) ; } setEncoding ( realJavaEncoding ) ; } else { String mysqlCharsetName = CharsetMapping . getMysqlCharsetForJavaEncoding ( realJavaEncoding . toUpperCase ( Locale . ENGLISH ) , this ) ; if ( mysqlCharsetName != null ) { if ( dontCheckServerMatch || ! characterSetNamesMatches ( mysqlCharsetName ) ) { execSQL ( null , " SET ▁ NAMES ▁ " + mysqlCharsetName , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , mysqlCharsetName ) ; this . serverVariables . put ( " character _ set _ connection " , mysqlCharsetName ) ; } } setEncoding ( realJavaEncoding ) ; } } else if ( getEncoding ( ) != null ) { String mysqlCharsetName = getServerCharset ( ) ; if ( getUseOldUTF8Behavior ( ) ) { mysqlCharsetName = " latin1" ; } boolean ucs2 = false ; if ( " ucs2" . equalsIgnoreCase ( mysqlCharsetName ) || " utf16" . equalsIgnoreCase ( mysqlCharsetName ) || " utf16le " . equalsIgnoreCase ( mysqlCharsetName ) || " utf32" . equalsIgnoreCase ( mysqlCharsetName ) ) { mysqlCharsetName = " utf8" ; ucs2 = true ; if ( getCharacterSetResults ( ) == null ) { setCharacterSetResults ( " UTF - 8" ) ; } } if ( dontCheckServerMatch || ! characterSetNamesMatches ( mysqlCharsetName ) || ucs2 ) { try { execSQL ( null , " SET ▁ NAMES ▁ " + mysqlCharsetName , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , mysqlCharsetName ) ; this . serverVariables . put ( " character _ set _ connection " , mysqlCharsetName ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } realJavaEncoding = getEncoding ( ) ; } } String onServer = null ; boolean isNullOnServer = false ; if ( this . serverVariables != null ) { onServer = this . serverVariables . get ( " character _ set _ results " ) ; isNullOnServer = onServer == null || " NULL " . equalsIgnoreCase ( onServer ) || onServer . length ( ) == 0 ; } if ( getCharacterSetResults ( ) == null ) { if ( ! isNullOnServer ) { try { execSQL ( null , " SET ▁ character _ set _ results ▁ = ▁ NULL " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , null ) ; } else { this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , onServer ) ; } } else { if ( getUseOldUTF8Behavior ( ) ) { try { execSQL ( null , " SET ▁ NAMES ▁ latin1" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . serverVariables . put ( " character _ set _ client " , " latin1" ) ; this . serverVariables . put ( " character _ set _ connection " , " latin1" ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } String charsetResults = getCharacterSetResults ( ) ; String mysqlEncodingName = null ; if ( " UTF - 8" . equalsIgnoreCase ( charsetResults ) || " UTF8" . equalsIgnoreCase ( charsetResults ) ) { mysqlEncodingName = " utf8" ; } else if ( " null " . equalsIgnoreCase ( charsetResults ) ) { mysqlEncodingName = " NULL " ; } else { mysqlEncodingName = CharsetMapping . getMysqlCharsetForJavaEncoding ( charsetResults . toUpperCase ( Locale . ENGLISH ) , this ) ; } if ( mysqlEncodingName == null ) { throw SQLError . createSQLException ( " Can ' t ▁ map ▁ " + charsetResults + " ▁ given ▁ for ▁ characterSetResults ▁ to ▁ a ▁ supported ▁ MySQL ▁ encoding . " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } if ( ! mysqlEncodingName . equalsIgnoreCase ( this . serverVariables . get ( " character _ set _ results " ) ) ) { StringBuilder setBuf = new StringBuilder ( " SET ▁ character _ set _ results ▁ = ▁ " . length ( ) + mysqlEncodingName . length ( ) ) ; setBuf . append ( " SET ▁ character _ set _ results ▁ = ▁ " ) . append ( mysqlEncodingName ) ; try { execSQL ( null , setBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , mysqlEncodingName ) ; if ( versionMeetsMinimum ( 5 , 5 , 0 ) ) { this . errorMessageEncoding = charsetResults ; } } else { this . serverVariables . put ( JDBC_LOCAL_CHARACTER_SET_RESULTS , onServer ) ; } } if ( getConnectionCollation ( ) != null ) { StringBuilder setBuf = new StringBuilder ( " SET ▁ collation _ connection ▁ = ▁ " . length ( ) + getConnectionCollation ( ) . length ( ) ) ; setBuf . append ( " SET ▁ collation _ connection ▁ = ▁ " ) . append ( getConnectionCollation ( ) ) ; try { execSQL ( null , setBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } } else { realJavaEncoding = getEncoding ( ) ; } } finally { setEncoding ( realJavaEncoding ) ; } try { CharsetEncoder enc = Charset . forName ( getEncoding ( ) ) . newEncoder ( ) ; CharBuffer cbuf = CharBuffer . allocate ( 1 ) ; ByteBuffer bbuf = ByteBuffer . allocate ( 1 ) ; cbuf . put ( " \u00a5" ) ; cbuf . position ( 0 ) ; enc . encode ( cbuf , bbuf , true ) ; if ( bbuf . get ( 0 ) == ' \ \' ) { this . requiresEscapingEncoder = true ; } else { cbuf . clear ( ) ; bbuf . clear ( ) ; cbuf . put ( " \u20a9" ) ; cbuf . position ( 0 ) ; enc . encode ( cbuf , bbuf , true ) ; if ( bbuf . get ( 0 ) == ' \ \' ) { this . requiresEscapingEncoder = true ; } } } catch ( java . nio . charset . UnsupportedCharsetException ucex ) { try { byte bbuf [ ] = StringUtils . getBytes ( " \u00a5" , getEncoding ( ) ) ; if ( bbuf [ 0 ] == ' \ \' ) { this . requiresEscapingEncoder = true ; } else { bbuf = StringUtils . getBytes ( " \u20a9" , getEncoding ( ) ) ; if ( bbuf [ 0 ] == ' \ \' ) { this . requiresEscapingEncoder = true ; } } } catch ( UnsupportedEncodingException ueex ) { throw SQLError . createSQLException ( " Unable ▁ to ▁ use ▁ encoding : ▁ " + getEncoding ( ) , SQLError . SQL_STATE_GENERAL_ERROR , ueex , getExceptionInterceptor ( ) ) ; } } return characterSetAlreadyConfigured ; }
 @ Override public void register ( OfferServiceModel serviceModel ) { if ( validator . validate ( serviceModel ) . size ( ) != DEFAULT_CONSTRAINT_VIOLATION_SIZE ) { throw new IllegalArgumentException ( DEFAULT_INVALID_MODEL_MESSAGE ) ; } Offer offerEntity = this . modelMapper . map ( serviceModel , Offer . class ) ; this . offerRepository . saveAndFlush ( offerEntity ) ; }
 public void throwConnectionClosedException ( ) throws SQLException { SQLException ex = SQLError . createSQLException ( " No ▁ operations ▁ allowed ▁ after ▁ connection ▁ closed . " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; if ( this . forceClosedReason != null ) { ex . initCause ( this . forceClosedReason ) ; } throw ex ; }
 private void configureTimezone ( ) throws SQLException { String configuredTimeZoneOnServer = this . serverVariables . get ( " timezone " ) ; if ( configuredTimeZoneOnServer == null ) { configuredTimeZoneOnServer = this . serverVariables . get ( " time _ zone " ) ; if ( " SYSTEM " . equalsIgnoreCase ( configuredTimeZoneOnServer ) ) { configuredTimeZoneOnServer = this . serverVariables . get ( " system _ time _ zone " ) ; } } String canonicalTimezone = getServerTimezone ( ) ; if ( ( getUseTimezone ( ) || ! getUseLegacyDatetimeCode ( ) ) && configuredTimeZoneOnServer != null ) { if ( canonicalTimezone == null || StringUtils . isEmptyOrWhitespaceOnly ( canonicalTimezone ) ) { try { canonicalTimezone = TimeUtil . getCanonicalTimezone ( configuredTimeZoneOnServer , getExceptionInterceptor ( ) ) ; } catch ( IllegalArgumentException iae ) { throw SQLError . createSQLException ( iae . getMessage ( ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } } } if ( canonicalTimezone != null && canonicalTimezone . length ( ) > 0 ) { this . serverTimezoneTZ = TimeZone . getTimeZone ( canonicalTimezone ) ; if ( ! canonicalTimezone . equalsIgnoreCase ( " GMT " ) && this . serverTimezoneTZ . getID ( ) . equals ( " GMT " ) ) { throw SQLError . createSQLException ( " No ▁ timezone ▁ mapping ▁ entry ▁ for ▁ ' " + canonicalTimezone + " ' " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } this . isServerTzUTC = ! this . serverTimezoneTZ . useDaylightTime ( ) && this . serverTimezoneTZ . getRawOffset ( ) == 0 ; } }
 public boolean isMergable ( AggregateInfo that ) { boolean ret = _aggregates . size ( ) < 3 && _aggregates . size ( ) + that . _aggregates . size ( ) <= 3 ; for ( Long hopID : that . _aggregates . keySet ( ) ) ret &= ! _inputAggs . contains ( hopID ) ; for ( Long hopID : _aggregates . keySet ( ) ) ret &= ! that . _inputAggs . contains ( hopID ) ; ret &= ! CollectionUtils . intersection ( _fusedInputs , that . _fusedInputs ) . isEmpty ( ) ; Hop in1 = _aggregates . values ( ) . iterator ( ) . next ( ) ; Hop in2 = that . _aggregates . values ( ) . iterator ( ) . next ( ) ; return ret && HopRewriteUtils . isEqualSize ( in1 . getInput ( ) . get ( HopRewriteUtils . isMatrixMultiply ( in1 ) ? 1 : 0 ) , in2 . getInput ( ) . get ( HopRewriteUtils . isMatrixMultiply ( in2 ) ? 1 : 0 ) ) ; }
 public java . sql . CallableStatement prepareCall ( String sql ) throws SQLException { return prepareCall ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
 private Properties createJavaMailProperties ( ) { Properties properties = ( Properties ) System . getProperties ( ) . clone ( ) ; properties . put ( " mail . " + protocol + " . connectiontimeout " , connectionTimeout ) ; properties . put ( " mail . " + protocol + " . timeout " , connectionTimeout ) ; properties . put ( " mail . " + protocol + " . host " , host ) ; properties . put ( " mail . " + protocol + " . port " , " " + port ) ; if ( username != null ) { properties . put ( " mail . " + protocol + " . user " , username ) ; properties . put ( " mail . user " , username ) ; properties . put ( " mail . " + protocol + " . auth " , " true " ) ; } else { properties . put ( " mail . " + protocol + " . auth " , " false " ) ; } properties . put ( " mail . " + protocol + " . rsetbeforequit " , " true " ) ; properties . put ( " mail . transport . protocol " , protocol ) ; properties . put ( " mail . store . protocol " , protocol ) ; properties . put ( " mail . host " , host ) ; if ( debugMode ) { properties . put ( " javax . net . debug " , " all " ) ; } if ( dummyTrustManager && isSecureProtocol ( ) ) { properties . put ( " mail . " + protocol + " . socketFactory . class " , " org . apache . camel . component . mail . security . DummySSLSocketFactory " ) ; properties . put ( " mail . " + protocol + " . socketFactory . fallback " , " false " ) ; properties . put ( " mail . " + protocol + " . socketFactory . port " , " " + port ) ; } return properties ; }
 @ Override public boolean isInvalidateSessionOnLogin ( ) { return false ; }
 public java . lang . Integer getAdmiLoginFailureCount ( ) { return get ( " admi _ login _ failure _ count " ) ; }
 private final ServiceConnection mServiceConnection = new ServiceConnection ( ) { @ Override public void onServiceConnected ( ComponentName componentName , IBinder binder ) { mSpeechService = SpeechService . from ( binder ) ; mSpeechService . addListener ( mSpeechServiceListener ) ; } @ Override public void onServiceDisconnected ( ComponentName componentName ) { mSpeechService = null ; } }
 @ Override public ResponseStats batchGet ( final String ... urls ) throws IOException { mController . reset ( ) ; mController . start ( ) ; mCountdown = new Countdown ( ) ; for ( final String url : urls ) { final CountdownListener < String > listener = new CountdownListener < String > ( mCountdown ) ; mQueue . add ( new StringRequest ( Request . Method . GET , url , listener , listener ) ) ; mCountdown . await ( ) ; } mCountdown . blockUntilDone ( ) ; mController . stop ( ) ; return new ResponseStats ( mController ) ; }
 @ Override public Void visitJoin ( Join join , FieldList fl ) { { FieldList leftList = fl . clone ( ) ; for ( JoinCondition c : join . getConditions ( ) ) { leftList . addReferenced ( c . getLeft ( ) . accept ( finder , null ) ) ; } join . getLeft ( ) . accept ( this , leftList ) ; } { FieldList rightList = fl . clone ( ) ; for ( JoinCondition c : join . getConditions ( ) ) { rightList . addReferenced ( c . getRight ( ) . accept ( finder , null ) ) ; } join . getLeft ( ) . accept ( this , rightList ) ; } return null ; }
 public boolean isSecureProtocol ( ) { return this . protocol . equalsIgnoreCase ( " smtps " ) || this . protocol . equalsIgnoreCase ( " pop3s " ) || this . protocol . equalsIgnoreCase ( " imaps " ) ; }
 public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Bear other = ( Bear ) obj ; if ( someBearField == null ) { if ( other . someBearField != null ) return false ; } else if ( ! someBearField . equals ( other . someBearField ) ) return false ; return true ; }
 @ Override public void didEnterRegion ( Region region ) { OrchextraRegion orchextraRegion = regionMapper . externalClassToModel ( region ) ; beaconsController . onRegionEnter ( orchextraRegion ) ; monitoringListener . onRegionEnter ( region ) ; regionsInEnter . add ( region ) ; GGGLogImpl . log ( " ENTER ▁ BEACON ▁ REGION ▁ : ▁ " + region . getUniqueId ( ) ) ; }
 public DrillbitEndpoint getEndpoint ( ) { return endpoint ; }
 private ConvexHullAggregation ( ) { }
 @ Override public boolean bindService ( Intent intent , ServiceConnection serviceConnection , int i ) { return context . bindService ( intent , serviceConnection , i ) ; }
 private void createConfigCacheIfNeeded ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . serverConfigCache != null ) { return ; } try { Class < ? > factoryClass ; factoryClass = Class . forName ( getServerConfigCacheFactory ( ) ) ; @ SuppressWarnings ( " unchecked " ) CacheAdapterFactory < String , Map < String , String > > cacheFactory = ( ( CacheAdapterFactory < String , Map < String , String > > ) factoryClass . newInstance ( ) ) ; this . serverConfigCache = cacheFactory . getInstance ( this , this . myURL , Integer . MAX_VALUE , Integer . MAX_VALUE , this . props ) ; ExceptionInterceptor evictOnCommsError = new ExceptionInterceptor ( ) { public void init ( Connection conn , Properties config ) throws SQLException { } public void destroy ( ) { } @ SuppressWarnings ( " synthetic - access " ) public SQLException interceptException ( SQLException sqlEx , Connection conn ) { if ( sqlEx . getSQLState ( ) != null && sqlEx . getSQLState ( ) . startsWith ( "08" ) ) { ConnectionImpl . this . serverConfigCache . invalidate ( getURL ( ) ) ; } return null ; } } ; if ( this . exceptionInterceptor == null ) { this . exceptionInterceptor = evictOnCommsError ; } else { ( ( ExceptionInterceptorChain ) this . exceptionInterceptor ) . addRingZero ( evictOnCommsError ) ; } } catch ( ClassNotFoundException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantFindCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( InstantiationException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( IllegalAccessException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } } }
 public boolean isUseInlineAttachments ( ) { return useInlineAttachments ; }
 @ Override protected SubscribeResponse < PushSubscription > createServiceResponse ( ExchangeService service , int responseIndex ) throws Exception { return new SubscribeResponse < PushSubscription > ( new PushSubscription ( service ) ) ; }
 public boolean isAbonormallyLongQuery ( long millisOrNanos ) { synchronized ( getConnectionMutex ( ) ) { if ( this . queryTimeCount < 15 ) { return false ; } double stddev = Math . sqrt ( ( this . queryTimeSumSquares - ( ( this . queryTimeSum * this . queryTimeSum ) / this . queryTimeCount ) ) / ( this . queryTimeCount - 1 ) ) ; return millisOrNanos > ( this . queryTimeMean + 5 * stddev ) ; } }
 public int getHoldability ( ) throws SQLException { return java . sql . ResultSet . CLOSE_CURSORS_AT_COMMIT ; }
 public java . sql . PreparedStatement prepareStatement ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; PreparedStatement pStmt = null ; boolean canServerPrepare = true ; String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; if ( this . useServerPreparedStmts && getEmulateUnsupportedPstmts ( ) ) { canServerPrepare = canHandleAsServerPreparedStatement ( nativeSql ) ; } if ( this . useServerPreparedStmts && canServerPrepare ) { if ( this . getCachePreparedStatements ( ) ) { synchronized ( this . serverSideStatementCache ) { pStmt = ( com . mysql . jdbc . ServerPreparedStatement ) this . serverSideStatementCache . remove ( sql ) ; if ( pStmt != null ) { ( ( com . mysql . jdbc . ServerPreparedStatement ) pStmt ) . setClosed ( false ) ; pStmt . clearParameters ( ) ; } if ( pStmt == null ) { try { pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , resultSetType , resultSetConcurrency ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { ( ( com . mysql . jdbc . ServerPreparedStatement ) pStmt ) . isCached = true ; } pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; } catch ( SQLException sqlEx ) { if ( getEmulateUnsupportedPstmts ( ) ) { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { this . serverSideStatementCheckCache . put ( sql , Boolean . FALSE ) ; } } else { throw sqlEx ; } } } } } else { try { pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , resultSetType , resultSetConcurrency ) ; pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; } catch ( SQLException sqlEx ) { if ( getEmulateUnsupportedPstmts ( ) ) { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; } else { throw sqlEx ; } } } } else { pStmt = ( PreparedStatement ) clientPrepareStatement ( nativeSql , resultSetType , resultSetConcurrency , false ) ; } return pStmt ; } }
 public void setLoginIp ( java . lang . String loginIp ) { set ( " login _ ip " , loginIp ) ; }
 public java . util . Date getLoginTime ( ) { return get ( " login _ time " ) ; }
 public boolean isDummyTrustManager ( ) { return dummyTrustManager ; }
 public AggregateInfo merge ( AggregateInfo that ) { _aggregates . putAll ( that . _aggregates ) ; _inputAggs . addAll ( that . _inputAggs ) ; _fusedInputs . addAll ( that . _fusedInputs ) ; return this ; }
 @ AfterMethod ( alwaysRun = true ) public void cleanupDatabase ( ) { dummyHandle . close ( ) ; }
 public Set getChildrenSet ( ) { return childrenSet ; }
 private void setSavepoint ( MysqlSavepoint savepoint ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( versionMeetsMinimum ( 4 , 0 , 14 ) || versionMeetsMinimum ( 4 , 1 , 1 ) ) { checkClosed ( ) ; StringBuilder savePointQuery = new StringBuilder ( " SAVEPOINT ▁ " ) ; savePointQuery . append ( ' ` ' ) ; savePointQuery . append ( savepoint . getSavepointName ( ) ) ; savePointQuery . append ( ' ` ' ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; stmt . executeUpdate ( savePointQuery . toString ( ) ) ; } finally { closeStatement ( stmt ) ; } } else { throw SQLError . createSQLFeatureNotSupportedException ( ) ; } } }
 public void setPassword ( String password ) { this . password = password ; }
 private void closeStatement ( java . sql . Statement stmt ) { if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlEx ) { } stmt = null ; } }
 public XmlRpcClient ( XmlRpcClientConfig config , String keyStoreComponent , String keyStoreName , String keyAlias ) { this ( config ) ; this . keyStoreComponent = keyStoreComponent ; this . keyStoreName = keyStoreName ; this . keyAlias = keyAlias ; this . setTransportFactory ( this . getClientTransportFactory ( ) ) ; }
 public boolean parserKnowsUnicode ( ) { return this . parserKnowsUnicode ; }
 @ Override public JsonNode getConfiguration ( ) { return this . json ; }
 @ Override public String getLogoutURL ( ) { return null ; }
 public void unregisterFilter ( Filter filter ) { unregisterFilter ( filter , true ) ; }
 public JSR_W ( InstructionHandle target ) { super ( com . sun . org . apache . bcel . internal . Constants . JSR_W , target ) ; length = 5 ; }
 public int getCount ( ) { return counter . get ( ) ; }
 @ Override public void checkContains ( Type subType ) { if ( ! ( subType instanceof MessageType ) ) { throw new InvalidRecordException ( subType + " ▁ found : ▁ expected ▁ " + this ) ; } super . checkContains ( subType ) ; }
 public boolean supportsTransactions ( ) { return this . transactionsSupported ; }
 public double getSideInputSize ( ) { double max = getMaxInputSize ( ) ; return inSizes . values ( ) . stream ( ) . filter ( d -> d < max ) . mapToDouble ( d -> d . doubleValue ( ) ) . sum ( ) ; }
 @ Override public void checkCanCreateTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , CREATE_TABLE ) ) { denyCreateTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateTable ( transactionId , identity , context , tableName ) ; } }
 public String getEncodingForIndex ( int charsetIndex ) throws SQLException { String javaEncoding = null ; if ( getUseOldUTF8Behavior ( ) ) { return getEncoding ( ) ; } if ( charsetIndex != MysqlDefs . NO_CHARSET_INFO ) { try { if ( this . indexToMysqlCharset . size ( ) > 0 ) { javaEncoding = CharsetMapping . getJavaEncodingForMysqlCharset ( this . indexToMysqlCharset . get ( charsetIndex ) , getEncoding ( ) ) ; } if ( javaEncoding == null ) { javaEncoding = CharsetMapping . getJavaEncodingForCollationIndex ( charsetIndex , getEncoding ( ) ) ; } } catch ( ArrayIndexOutOfBoundsException outOfBoundsEx ) { throw SQLError . createSQLException ( " Unknown ▁ character ▁ set ▁ index ▁ for ▁ field ▁ ' " + charsetIndex + " ' ▁ received ▁ from ▁ server . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( javaEncoding == null ) { javaEncoding = getEncoding ( ) ; } } else { javaEncoding = getEncoding ( ) ; } return javaEncoding ; }
 @ Override public Void visitLimit ( Limit limit , FieldList value ) { limit . getInput ( ) . accept ( this , value ) ; return null ; }
 @ Test public void outputOfTestVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; TestImageVisitor v = new TestImageVisitor ( ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , true ) ; oiv . go ( ) ; List < String > dtrs = v . getDelegationTokenRenewers ( ) ; assertEquals ( 1 , dtrs . size ( ) ) ; assertEquals ( TEST_RENEWER , dtrs . get ( 0 ) ) ; } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; } LOG . debug ( " Passed ▁ TestVisitor ▁ validation . " ) ; }
 @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Temporal ▁ column ▁ must ▁ be ▁ of ▁ type ▁ timestamp ▁ or ▁ date : ▁ orderkey " ) public void testInvalidTemporalColumnType ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderkey " ) ) , false ) ; }
 @ Test public void testEmptyExtensionType ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newXmlParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , not ( containsString ( " xtension " ) ) ) ; }
 @ Override public void onCreate ( SQLiteDatabase db ) { db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . TABLE_NAME + " ( ▁ " + FileDownloadModel . ID + " ▁ INTEGER ▁ PRIMARY ▁ KEY , ▁ " + FileDownloadModel . URL + " ▁ VARCHAR , ▁ " + FileDownloadModel . PATH + " ▁ VARCHAR , ▁ " + FileDownloadModel . STATUS + " ▁ TINYINT ( 7 ) , ▁ " + FileDownloadModel . SOFAR + " ▁ INTEGER , ▁ " + FileDownloadModel . TOTAL + " ▁ INTEGER , ▁ " + FileDownloadModel . ERR_MSG + " ▁ VARCHAR , ▁ " + FileDownloadModel . ETAG + " ▁ VARCHAR , ▁ " + FileDownloadModel . PATH_AS_DIRECTORY + " ▁ TINYINT ( 1 ) ▁ DEFAULT ▁ 0 , ▁ " + FileDownloadModel . FILENAME + " ▁ VARCHAR , ▁ " + FileDownloadModel . CONNECTION_COUNT + " ▁ INTEGER ▁ DEFAULT ▁ 1" + " ) " ) ; db . execSQL ( " CREATE ▁ TABLE ▁ IF ▁ NOT ▁ EXISTS ▁ " + DefaultDatabaseImpl . CONNECTION_TABLE_NAME + " ( ▁ " + ConnectionModel . ID + " ▁ INTEGER , ▁ " + ConnectionModel . INDEX + " ▁ INTEGER , ▁ " + ConnectionModel . START_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . CURRENT_OFFSET + " ▁ INTEGER , ▁ " + ConnectionModel . END_OFFSET + " ▁ INTEGER , ▁ " + " PRIMARY ▁ KEY ▁ ( ▁ " + ConnectionModel . ID + " , ▁ " + ConnectionModel . INDEX + " ▁ ) " + " ) " ) ; }
 @ Override public WebDriver createWebDriver ( ) { DesiredCapabilities cap = new SafariCapabilitiesFactory ( ) . createCapabilities ( webDriverConfig ) ; System . out . println ( " Begin ▁ Safari " ) ; synchronized ( this . getClass ( ) ) { driver = new SafariDriver ( cap ) ; } System . out . println ( " safari ▁ started " ) ; this . setWebDriver ( driver ) ; setImplicitWaitTimeout ( webDriverConfig . getImplicitWaitTimeout ( ) ) ; if ( webDriverConfig . getPageLoadTimeout ( ) >= 0 ) { TestLogging . log ( " Safari ▁ doesn ' t ▁ support ▁ pageLoadTimeout " ) ; } return driver ; }
 public DatabaseProperty createInstance ( String propertyName ) { if ( ! _properties . containsKey ( propertyName ) ) return null ; return _properties . get ( propertyName ) . initializeInstance ( ) ; }
 @ Override public SecurityController getController ( ) { return null ; }
 @ Override public int getInventoryStackLimit ( ) { return 64 ; }
 @ Override public void stopMonitoring ( ) { stopMonitoringRegions ( regionsToBeMonitored ) ; monitoring = false ; regionsInEnter . clear ( ) ; beaconManager . unbind ( this ) ; }
 @ Test public void testTablePropertiesWithOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) , ORGANIZED_PROPERTY , true ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertTrue ( metadataDao . getTableInformation ( tableId ) . isOrganized ( ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
 if ( Util . isJdbc4 ( ) ) { try { JDBC_4_CONNECTION_CTOR = Class . forName ( " com . mysql . jdbc . JDBC4Connection " ) . getConstructor ( new Class [ ] { String . class , Integer . TYPE , Properties . class , String . class , String . class } ) ; } catch ( SecurityException e ) { throw new RuntimeException ( e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( e ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } }
 public int getPort ( ) { return port ; }
 private void closeAllOpenStatements ( ) throws SQLException { SQLException postponedException = null ; for ( Statement stmt : this . openStatements ) { try { ( ( StatementImpl ) stmt ) . realClose ( false , true ) ; } catch ( SQLException sqlEx ) { postponedException = sqlEx ; } } if ( postponedException != null ) { throw postponedException ; } }
 public Deck importDeck ( @ NonNull File file ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( format ( " File ▁ ' % s ' ▁ does ▁ not ▁ exist ! " , file ) ) ; } Deck deck = new Deck ( ) ; try { JAXBContext jaxbContext = JAXBContext . newInstance ( Deck . class ) ; Unmarshaller jaxbUnmarshaller = jaxbContext . createUnmarshaller ( ) ; deck = ( Deck ) jaxbUnmarshaller . unmarshal ( file ) ; } catch ( JAXBException e ) { throw new ImportException ( " Could ▁ not ▁ import ▁ deck " , e ) ; } return deck ; }
 @ Test public void outputOfLSVisitor ( ) throws IOException { File testFile = new File ( ROOT , " / basicCheck " ) ; File outputFile = new File ( ROOT , " / basicCheckOutput " ) ; try { DFSTestUtil . copyFile ( originalFsimage , testFile ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; oiv . go ( ) ; HashMap < String , LsElements > fileOutput = readLsfile ( outputFile ) ; compareNamespaces ( writtenFiles , fileOutput ) ; } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } LOG . debug ( " Correctly ▁ generated ▁ ls - style ▁ output . " ) ; }
 public boolean isInitialized ( DrillServiceInstance message ) { return true ; }
 protected void addExpectedServiceAbortedException ( String exceptionMessage ) throws Exception { expectedException = new AssertionFailure ( exceptionMessage ) ; expectedExceptionClass = AssertionFailure . class ; expectedExceptionMessage = exceptionMessage ; }
 @ Override public ResponseStats . MultipartPost postMultipart ( final String url , final OperationParams . Multipart params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; final MultipartRequest request = new MultipartRequest ( url , future , future ) ; request . addStringPart ( params . formField . first , params . formField . second ) ; request . addFilePart ( params . fileName , mContext . getResources ( ) . openRawResource ( params . rawResourceId ) ) ; mQueue . add ( request ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . MultipartPost ( mController , response ) ; }
 protected void setupForExpectedIllegalArgument ( Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { addExpectedException ( IllegalArgumentException . class , exceptionCause , exceptionMessage ) ; }
 @ Override public void didDetermineStateForRegion ( int i , Region region ) { }
 @ Override public void checkCanSetUser ( Identity identity , AccessControlContext context , Optional < Principal > principal , String userName ) { if ( shouldDenyPrivilege ( userName , userName , SET_USER ) ) { denySetUser ( principal , userName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetUser ( identity , context , principal , userName ) ; } }
 @ Test public void testDirectConnectionInvalidConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = abc " , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof InvalidConnectionInfoException ) ; } }
 @ Override protected void ProcessMessage ( Message msg ) { System . err . println ( " Received ▁ REMOVED : ▁ " + msg . getFileID ( ) + " ▁ " + msg . getChunkNo ( ) ) ; if ( _bs . Files . containsPeer ( msg . getFileID ( ) , msg . getChunkNo ( ) , msg . Sender . toString ( ) ) ) { _bs . Files . removePeer ( msg . getFileID ( ) , msg . getChunkNo ( ) , msg . Sender . toString ( ) ) ; int realDegree = _bs . Files . getChunkRealReplicationDegree ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; int desiredDegree = _bs . Files . getChunkDesiredReplicationDegree ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; if ( realDegree < desiredDegree ) { final CounterObserver co = new CounterObserver ( ) ; byte [ ] chunkArray ; try { chunkArray = _bs . readChunk ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; } catch ( IOException e ) { _bs . Files . removeChunk ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ; _bs . Comm . MC . Sender . Send ( Message . makeRemoved ( msg . getFileID ( ) , msg . getChunkNo ( ) ) ) ; return ; } final Chunk chunk = new Chunk ( msg . getChunkNo ( ) , desiredDegree , msg . getFileID ( ) , chunkArray ) ; final Subscription sub = _bs . Comm . MDB . Publisher . getObservable ( ) . filter ( new MessageFilter ( Message . Type . PUTCHUNK , msg . getFileID ( ) , msg . getChunkNo ( ) ) ) . subscribe ( co ) ; Schedulers . io ( ) . schedule ( new Action1 < Scheduler . Inner > ( ) { @ Override public void call ( Scheduler . Inner arg0 ) { if ( ! co . received ( ) ) new ChunkBackup ( _bs , chunk ) ; sub . unsubscribe ( ) ; } } , rand . nextInt ( 401 ) , TimeUnit . MILLISECONDS ) ; } } }
 @ Override public Class < ? > getColumnClass ( int columnIndex ) { switch ( columnIndex ) { case 0 : return String . class ; case 2 : return Boolean . class ; case 1 : case 3 : case 4 : case 5 : return Double . class ; default : return Object . class ; } }
 public String getHost ( ) { return this . host ; }
 public double getMinCosts ( ) { return Math . max ( _read , _compute ) + _write ; }
 @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Ordering ▁ column ▁ does ▁ not ▁ exist : ▁ orderdatefoo " ) public void testInvalidOrderingColumns ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdatefoo " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; fail ( " Expected ▁ createTable ▁ to ▁ fail " ) ; }
 KeySetSerializedForm ( ImmutableMap < K , ? > map ) { this . map = map ; }
 @ MessageMapping ( " / hello " ) @ SendTo ( " / topic / greetings " ) public Object greeting ( HelloMessage message ) throws InterruptedException { Thread . sleep ( 1000 ) ; return new Greeting ( " Hello . ▁ " + message . getName ( ) + " ! " ) ; }
 private void connectOneTryOnly ( boolean isForReconnect , Properties mergedProps ) throws SQLException { Exception connectionNotEstablishedBecause = null ; try { coreConnect ( mergedProps ) ; this . connectionId = this . io . getThreadId ( ) ; this . isClosed = false ; boolean oldAutoCommit = getAutoCommit ( ) ; int oldIsolationLevel = this . isolationLevel ; boolean oldReadOnly = isReadOnly ( false ) ; String oldCatalog = getCatalog ( ) ; this . io . setStatementInterceptors ( this . statementInterceptors ) ; initializePropsFromServer ( ) ; if ( isForReconnect ) { setAutoCommit ( oldAutoCommit ) ; if ( this . hasIsolationLevels ) { setTransactionIsolation ( oldIsolationLevel ) ; } setCatalog ( oldCatalog ) ; setReadOnly ( oldReadOnly ) ; } return ; } catch ( Exception EEE ) { if ( EEE instanceof SQLException && ( ( SQLException ) EEE ) . getErrorCode ( ) == MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD && ! getDisconnectOnExpiredPasswords ( ) ) { return ; } if ( this . io != null ) { this . io . forceClose ( ) ; } connectionNotEstablishedBecause = EEE ; if ( EEE instanceof SQLException ) { throw ( SQLException ) EEE ; } SQLException chainedEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnableToConnect " ) , SQLError . SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE , getExceptionInterceptor ( ) ) ; chainedEx . initCause ( connectionNotEstablishedBecause ) ; throw chainedEx ; } }
 public boolean containsItems ( String key , V item ) { return map . containsKey ( key ) && map . get ( key ) . contains ( item ) ; }
 public boolean addPropertyToDatabase ( DatabaseProperty property ) { if ( _properties . containsKey ( property . getName ( ) ) ) return false ; _properties . put ( property . getName ( ) , property ) ; for ( DatabaseItem item : _items . values ( ) ) { item . addProperty ( property . getName ( ) , null ) ; } WindowMain . addPropertyToTableView ( property ) ; WindowMain . updateGUI ( ) ; return true ; }
 protected DownloadHttpClient ( final String group , boolean safe ) { this . group = group ; this . httpClient = HttpClientFactory . createDefaultHttpClient ( ) ; threadPool = PoolManager . buildPool ( group , DEFAULT_MAX ) ; this . requestMap = new WeakHashMap < > ( ) ; this . downloadRetryHandler = new DownloadRetryHandler ( DEFAULT_RETRYTIMES ) ; }
 public Configuration messageInterpolator ( MessageInterpolator interpolator ) { return null ; }
 @ Test public void testFromName ( ) { MetricType res = MetricType . fromName ( " meter " ) ; assertEquals ( MetricType . METER , res ) ; }
 public java . lang . Integer getVersionNo ( ) { return get ( " version _ no " ) ; }
 public MockedTypeInfo ( @ Nonnull Type mockedType ) { Class < ? > mockedClass = Utilities . getClassType ( mockedType ) ; genericTypeMap = new GenericTypeReflection ( mockedClass , mockedType ) ; String signature = getGenericClassSignature ( mockedType ) ; String classDesc = mockedClass . getName ( ) . replace ( ' . ' , ' / ' ) ; implementationSignature = ' L ' + classDesc + signature ; }
 public XmlRpcClient ( XmlRpcClientConfig config ) { super ( ) ; this . setConfig ( config ) ; }
 public Greeting ( String content ) { this . content = content ; }
 @ Override public List < OfferServiceModel > findAll ( ) { return this . offerRepository . findAll ( ) . stream ( ) . map ( entity -> this . modelMapper . map ( entity , OfferServiceModel . class ) ) . collect ( Collectors . toList ( ) ) ; }
 private MySQLConnection getProxy ( ) { return ( this . proxy != null ) ? this . proxy : ( MySQLConnection ) this ; }
 public String getProtocol ( ) { return protocol ; }
 public Object getConnectionMutex ( ) { return ( this . realProxy != null ) ? this . realProxy : getProxy ( ) ; }
 public void changeUser ( String userName , String newPassword ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( ( userName == null ) || userName . equals ( " " ) ) { userName = " " ; } if ( newPassword == null ) { newPassword = " " ; } this . sessionMaxRows = - 1 ; try { this . io . changeUser ( userName , newPassword , this . database ) ; } catch ( SQLException ex ) { if ( versionMeetsMinimum ( 5 , 6 , 13 ) && "28000" . equals ( ex . getSQLState ( ) ) ) { cleanup ( ex ) ; } throw ex ; } this . user = userName ; this . password = newPassword ; if ( versionMeetsMinimum ( 4 , 1 , 0 ) ) { configureClientCharacterSet ( true ) ; } setSessionVariables ( ) ; setupServerForTruncationChecks ( ) ; } }
 List < SortOrder > getSortOrders ( ) { return sortOrders ; }
 public HttpContext createDefaultHttpContext ( ) { return new DefaultHttpContext ( this . bundle ) ; }
 @ Override public Object eGet ( int featureID , boolean resolve , boolean coreType ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : if ( resolve ) return getThermalGeneratingUnit ( ) ; return basicGetThermalGeneratingUnit ( ) ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : return isIsNetGrossP ( ) ; } return super . eGet ( featureID , resolve , coreType ) ; }
 public DrillServiceInstance setEndpoint ( DrillbitEndpoint endpoint ) { this . endpoint = endpoint ; return this ; }
 public MailConfiguration ( ) { }
 public void setStatement ( IStatement statement ) { _statement = ( Statement ) statement ; }
 public void setAdmiLoginFailureCount ( java . lang . Integer admiLoginFailureCount ) { set ( " admi _ login _ failure _ count " , admiLoginFailureCount ) ; }
 public java . sql . Statement createStatement ( int resultSetType , int resultSetConcurrency , int resultSetHoldability ) throws SQLException { if ( getPedantic ( ) ) { if ( resultSetHoldability != java . sql . ResultSet . HOLD_CURSORS_OVER_COMMIT ) { throw SQLError . createSQLException ( " HOLD _ CUSRORS _ OVER _ COMMIT ▁ is ▁ only ▁ supported ▁ holdability ▁ level " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } } return createStatement ( resultSetType , resultSetConcurrency ) ; }
 public Builder ( List < String > columnNames , List < Type > types ) { requireNonNull ( columnNames , " columnNames ▁ is ▁ null " ) ; ImmutableMap . Builder < String , Integer > columnIndexes = ImmutableMap . builder ( ) ; int columnIndex = 0 ; for ( String columnName : columnNames ) { columnIndexes . put ( columnName , columnIndex ++ ) ; } this . columnIndexes = columnIndexes . build ( ) ; this . types = ImmutableList . copyOf ( requireNonNull ( types , " types ▁ is ▁ null " ) ) ; checkArgument ( columnNames . size ( ) == types . size ( ) , " Column ▁ name ▁ count ▁ does ▁ not ▁ match ▁ type ▁ count : ▁ columnNames = % s , ▁ types = % s " , columnNames , types . size ( ) ) ; pages = new ArrayList < > ( ) ; pageBuilder = new PageBuilder ( types ) ; }
 public boolean isIgnoreUnsupportedCharset ( ) { return ignoreUnsupportedCharset ; }
 @ Test public void testExtensionType ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . setPetName ( new StringDt ( " Fido " ) ) ; patient . getImportantDates ( ) . add ( new DateTimeDt ( "2010-01-02" ) ) ; patient . getImportantDates ( ) . add ( new DateTimeDt ( "2014-01-26T11:11:11" ) ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newXmlParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , containsString ( " < modifierExtension ▁ url = \" http : // example . com / dontuse # importantDates \" > < valueDateTime ▁ value = \" 2010-01-02 \" / > < / modifierExtension > " ) ) ; }
 @ Test public final void test_that_a_Comments_lines_retain_their_indentation ( ) { final Iterator < String > lineIt = comments . iterator ( ) ; assertEquals ( " ▁ ▁ Hello " , lineIt . next ( ) ) ; assertEquals ( " World " , lineIt . next ( ) ) ; assertFalse ( lineIt . hasNext ( ) ) ; }
 protected void setupForExpectedIllegalArgument ( String exceptionMessage ) throws Exception { addExpectedException ( IllegalArgumentException . class , null , exceptionMessage ) ; }
 public boolean isProxySet ( ) { return this . proxy != null ; }
 public String nativeSQL ( String sql ) throws SQLException { if ( sql == null ) { return null ; } Object escapedSqlResult = EscapeProcessor . escapeSQL ( sql , serverSupportsConvertFn ( ) , getMultiHostSafeProxy ( ) ) ; if ( escapedSqlResult instanceof String ) { return ( String ) escapedSqlResult ; } return ( ( EscapeProcessorResult ) escapedSqlResult ) . escapedSql ; }
 private void compareFiles ( FileStatus fs , LsElements elements ) { assertEquals ( " directory ▁ listed ▁ as ▁ such " , fs . isDirectory ( ) ? ' d ' : ' - ' , elements . dir ) ; assertEquals ( " perms ▁ string ▁ equal " , fs . getPermission ( ) . toString ( ) , elements . perms ) ; assertEquals ( " replication ▁ equal " , fs . getReplication ( ) , elements . replication ) ; assertEquals ( " owner ▁ equal " , fs . getOwner ( ) , elements . username ) ; assertEquals ( " group ▁ equal " , fs . getGroup ( ) , elements . groupname ) ; assertEquals ( " lengths ▁ equal " , fs . getLen ( ) , elements . filesize ) ; }
 private ParentPrime ( ) { }
 @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " View ▁ already ▁ exists : ▁ test \\ . test _ view " ) public void testCreateViewWithoutReplace ( ) { SchemaTableName test = new SchemaTableName ( " test " , " test _ view " ) ; try { metadata . createView ( SESSION , test , " test " , false ) ; } catch ( Exception e ) { fail ( " should ▁ have ▁ succeeded " ) ; } metadata . createView ( SESSION , test , " test " , false ) ; }
 public ParameterNameProvider getDefaultParameterNameProvider ( ) { return null ; }
 public GameButton ( TextureRegion region , float x , float y , float width , float height ) { sprite . setRegion ( region ) ; sprite . setBounds ( x , y - height , width , height ) ; isEnabled = true ; }
 public ByteCodeNode generate ( RowExpression expression ) { return expression . accept ( byteCodeGenerator , scope ) ; }
 public String messageName ( ) { return DrillServiceInstance . class . getSimpleName ( ) ; }
 @ Override public String toString ( ) { return toStringHelper ( this ) . add ( " userName " , userName ) . add ( " entityName " , entityName ) . add ( " type " , type ) . toString ( ) ; }
 @ Test public void testCreateTable ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; assertEquals ( ( ( RaptorTableHandle ) tableHandle ) . getTableId ( ) , 1 ) ; ConnectorTableMetadata table = metadata . getTableMetadata ( SESSION , tableHandle ) ; assertTableEqual ( table , getOrdersTable ( ) ) ; ColumnHandle columnHandle = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; assertInstanceOf ( columnHandle , RaptorColumnHandle . class ) ; assertEquals ( ( ( RaptorColumnHandle ) columnHandle ) . getColumnId ( ) , 1 ) ; ColumnMetadata columnMetadata = metadata . getColumnMetadata ( SESSION , tableHandle , columnHandle ) ; assertNotNull ( columnMetadata ) ; assertEquals ( columnMetadata . getName ( ) , " orderkey " ) ; assertEquals ( columnMetadata . getType ( ) , BIGINT ) ; }
 public String toString ( ) { return " using ( ▁ " + ( getExpression ( ) == null ? varStatementsToString ( ) : getExpression ( ) . toString ( ) ) + " ▁ ) \n " + getStatement ( ) == null ? " " : getStatement ( ) . toString ( ) + ( getFinallyStatement ( ) == null ? " " : ( " \n finally \n " + getFinallyStatement ( ) . toString ( ) ) ) ; }
 public MaterialModel ( ) { super ( new String [ ] { " Name " , " Amount " , " Manufacture " , " Manufacture ▁ Cost / unit ▁ ( ISK ) " , " Price / unit ▁ ( ISK ) " , " Total ▁ Cost ▁ ( ISK ) " } , new int [ ] { LEFT , RIGHT , CENTER , RIGHT , RIGHT , RIGHT } , new int [ ] { 2 } ) ; }
 public Configuration addProperty ( String name , String value ) { return null ; }
 public boolean isServerLocal ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { SocketFactory factory = getIO ( ) . socketFactory ; if ( factory instanceof SocketMetadata ) { return ( ( SocketMetadata ) factory ) . isLocallyConnected ( this ) ; } getLog ( ) . logWarn ( Messages . getString ( " Connection . NoMetadataOnSocketFactory " ) ) ; return false ; } }
 public String getHostPortPair ( ) { return this . hostPortPair != null ? this . hostPortPair : this . host + " : " + this . port ; }
 public VolleyLibrary ( final Context context ) { mContext = context ; mController = new OperationController ( context ) ; mQueue = Volley . newRequestQueue ( mContext ) ; mQueue . start ( ) ; }
 @ Override public void openInventory ( ) { }
 public void setTo ( String address ) { recipients . put ( Message . RecipientType . TO , address ) ; }
 public Map getChildrenMap ( ) { return childrenMap ; }
 public Object execute ( ) { if ( ! isCompileTimeConstant ( ) ) { return super . execute ( ) ; } throw new IllegalStateException ( " Can ' t ▁ execute ▁ this ▁ parsed ▁ element ▁ directly " ) ; }
 @ Override public Authenticator getAuthenticator ( ) { return null ; }
 public void setReadOnlyInternal ( boolean readOnlyFlag ) throws SQLException { if ( getReadOnlyPropagatesToServer ( ) && versionMeetsMinimum ( 5 , 6 , 5 ) ) { if ( ! getUseLocalSessionState ( ) || ( readOnlyFlag != this . readOnly ) ) { execSQL ( null , " set ▁ session ▁ transaction ▁ " + ( readOnlyFlag ? " read ▁ only " : " read ▁ write " ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } this . readOnly = readOnlyFlag ; }
 @ Test public void testListTables ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; List < SchemaTableName > tables = metadata . listTables ( SESSION , null ) ; assertEquals ( tables , ImmutableList . of ( DEFAULT_TEST_ORDERS ) ) ; }
 public DatabaseItem [ ] getItemList ( ) { DatabaseItem [ ] items = new DatabaseItem [ _items . values ( ) . size ( ) ] ; return _items . values ( ) . toArray ( items ) ; }
 public void setHoldability ( int arg0 ) throws SQLException { }
 public DrillServiceInstance setRegistrationTimeUTC ( long registrationTimeUTC ) { this . registrationTimeUTC = registrationTimeUTC ; return this ; }
 @ Override public boolean getClickWithJavascript ( ) { return clickWithJavascript ; }
 public String getRevision ( ) { return RevisionUtils . extract ( " $ Revision : ▁ 8034 ▁ $ " ) ; }
 public Properties getAdditionalJavaMailProperties ( ) { if ( additionalJavaMailProperties == null ) { additionalJavaMailProperties = new Properties ( ) ; } return additionalJavaMailProperties ; }
 @ Override public int hashCode ( ) { return this . hashCode ; }
 public void setTypeMap ( java . util . Map < String , Class < ? > > map ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { this . typeMap = map ; } }
 List < Integer > getSortChannels ( ) { return sortChannels ; }
 public void setCodigoProduto ( Long codigoProduto ) { this . codigoProduto = codigoProduto ; }
 private < T > boolean waitUntil ( final Callable < T > callable , final T value , final int seconds ) { final DateTime start = DateTime . now ( ) ; while ( DateTime . now ( ) . isBefore ( start . plusSeconds ( seconds ) ) ) { try { if ( callable . call ( ) . equals ( value ) ) { return true ; } Thread . sleep ( TimeUnit . SECONDS . toMillis ( 1 ) ) ; } catch ( final Exception e ) { return false ; } } return false ; }
 List < String > getDelegationTokenRenewers ( ) { return delegationTokenRenewers ; }
 public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Elephant other = ( Elephant ) obj ; if ( someElephantField == null ) { if ( other . someElephantField != null ) return false ; } else if ( ! someElephantField . equals ( other . someElephantField ) ) return false ; return true ; }
 public void restore ( String backup , String target ) throws IOException { ftp . connect ( app . getProperty ( " ftp . host " ) ) ; ftp . login ( app . getProperty ( " ftp . login " ) , app . getProperty ( " ftp . password " ) ) ; ftp . deleteFile ( target ) ; ftp . rename ( backup , target ) ; ftp . disconnect ( ) ; }
 @ Override public Void visitStore ( Store store , FieldList value ) { store . getInput ( ) . accept ( this , value ) ; return null ; }
 @ Override public void checkCanRenameTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , QualifiedObjectName newTableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , RENAME_TABLE ) ) { denyRenameTable ( tableName . toString ( ) , newTableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanRenameTable ( transactionId , identity , context , tableName , newTableName ) ; } }
 @ Override public boolean isCellEditable ( int rowIndex , int columnIndex ) { return getColumnClass ( columnIndex ) == Boolean . class && dataList . get ( rowIndex ) . canBeManufactured ( ) ; }
 @ Test public final void test_that_a_Comments_with_an_empty_value_is_empty ( ) { final Comments emptyComments = new Comments ( " ▁ ▁ ▁ \t ▁ ▁ ▁ \n \r " ) ; assertEquals ( " " , emptyComments . value ( ) ) ; }
 protected CitationDate ( final Node n ) throws RIFCSException { super ( n , Constants . ELEMENT_DATE ) ; }
 public Configuration constraintValidatorFactory ( ConstraintValidatorFactory constraintValidatorFactory ) { return null ; }
 public HttpServiceImpl ( Bundle bundle , ServletContext context , HandlerRegistry handlerRegistry , ServletContextAttributeListener servletAttributeListener , boolean sharedContextAttributes ) { this . bundle = bundle ; this . handlerRegistry = handlerRegistry ; this . localServlets = new HashSet < Servlet > ( ) ; this . localFilters = new HashSet < Filter > ( ) ; this . contextManager = new ServletContextManager ( this . bundle , context , servletAttributeListener , sharedContextAttributes ) ; }
 public String getCatalog ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { return this . database ; } }
 public void configure ( URI uri ) { String value = uri . getHost ( ) ; if ( value != null ) { setHost ( value ) ; } if ( ! isIgnoreUriScheme ( ) ) { String scheme = uri . getScheme ( ) ; if ( scheme != null ) { setProtocol ( scheme ) ; } } String userInfo = uri . getUserInfo ( ) ; if ( userInfo != null ) { setUsername ( userInfo ) ; } int port = uri . getPort ( ) ; if ( port > 0 ) { setPort ( port ) ; } else if ( port <= 0 && this . port <= 0 ) { setPort ( MailUtils . getDefaultPortForProtocol ( uri . getScheme ( ) ) ) ; } }
 public boolean isUnseen ( ) { return unseen ; }
 public void setJavaMailSender ( JavaMailSender javaMailSender ) { this . javaMailSender = javaMailSender ; }
 @ Setup public void setup ( ) { super . setup ( numSortChannels , totalChannels , 1 , pagesCount ) ; }
 public void accept ( Visitor v ) { v . visitStackProducer ( this ) ; v . visitBranchInstruction ( this ) ; v . visitJsrInstruction ( this ) ; v . visitJSR_W ( this ) ; }
 public void setNumeroAto ( String numeroAto ) { this . numeroAto = numeroAto ; }
 public Agenda ( ) throws IOException { List < Contato > contatos = this . arquivo . ler ( ) ; for ( Contato contato : contatos ) { try { this . inserir ( contato ) ; } catch ( AgendaException e ) { e . printStackTrace ( ) ; } } }
 public void ping ( ) throws SQLException { pingInternal ( true , 0 ) ; }
 @ Override protected ExchangeVersion getMinimumRequiredServerVersion ( ) { return ExchangeVersion . Exchange2007_SP1 ; }
 public void setFailedOver ( boolean flag ) { }
 public void setCpfCnpjRaiz ( String cpfCnpjRaiz ) { this . cpfCnpjRaiz = cpfCnpjRaiz ; }
 public void testFilter ( ) throws Exception { TokenStream stream = new MockTokenizer ( new StringReader ( " Do ▁ have ▁ a ▁ nice ▁ day " ) , MockTokenizer . WHITESPACE , false ) ; ReverseStringFilter filter = new ReverseStringFilter ( TEST_VERSION_CURRENT , stream ) ; assertTokenStreamContents ( filter , new String [ ] { " oD " , " evah " , " a " , " ecin " , " yad " } ) ; }
 public < T > T convertWith ( TypeConverter < T > converter ) { final ArrayList < GroupType > path = new ArrayList < GroupType > ( ) ; path . add ( this ) ; return converter . convertMessageType ( this , convertChildren ( path , converter ) ) ; }
 @ Override public int hashCode ( ) { return UtilFunctions . intHashCode ( Arrays . hashCode ( new int [ ] { partNodes , inputNodes , rootNodes , matPoints } ) , Arrays . hashCode ( new double [ ] { cCompute , cRead , cWrite , cPlan0 , cPlanN } ) ) ; }
 @ Override public Void visitScan ( Scan scan , FieldList value ) { if ( value == null ) { scanFields . put ( scan , new FieldList ( ) ) ; } else { scanFields . put ( scan , value ) ; } return null ; }
 public java . util . Date getCreated ( ) { return get ( " created " ) ; }
 public int getClassOrder ( ) { return m_ClassOrder ; }
 private void checkAndCreateTablesAccessedHistogram ( ) { if ( this . numTablesMetricsHistCounts == null ) { this . numTablesMetricsHistCounts = new int [ HISTOGRAM_BUCKETS ] ; } if ( this . numTablesMetricsHistBreakpoints == null ) { this . numTablesMetricsHistBreakpoints = new long [ HISTOGRAM_BUCKETS ] ; } }
 @ Test public void testTransactionSelect ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; assertFalse ( ( ( RaptorTableHandle ) tableHandle ) . getTransactionId ( ) . isPresent ( ) ) ; }
 ExitException ( final int status , final boolean printHelp , final String message ) { super ( message ) ; this . printHelp = printHelp ; this . status = status ; }
 @ Override public void messageReceived ( ChannelHandlerContext ctx , MessageEvent e ) throws Exception { execCommand ( ctx , e , ( ) -> { UseItemOn useItemOn = new UseItemOn ( originalMessageParts ) ; if ( Strings . isNullOrEmpty ( useItemOn . getItem ( ) ) ) { write ( " No ▁ item ▁ specified . " ) ; return ; } Optional < ItemInstance > inventoryItemOptional = player . getInventoryItem ( useItemOn . getItem ( ) ) ; if ( ! inventoryItemOptional . isPresent ( ) ) { write ( " Useable ▁ item ▁ is ▁ not ▁ found ▁ in ▁ your ▁ inventory . \r \n " ) ; return ; } gameManager . getItemUseHandler ( ) . handle ( player , inventoryItemOptional . get ( ) , useItemOn ) ; } ) ; }
 @ Override public void setRunningMode ( AppRunningModeType appRunningModeType ) { beaconManager . setBackgroundMode ( appRunningModeType == AppRunningModeType . BACKGROUND ) ; }
 public String getReturn ( ) { return _return ; }
 public void setStartDate ( java . util . Date startDate ) { set ( " start _ date " , startDate ) ; }
 public void commit ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . commit ( ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( this . autoCommit && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ call ▁ commit ▁ when ▁ autocommit = true " , getExceptionInterceptor ( ) ) ; } else if ( this . transactionsSupported ) { if ( getUseLocalTransactionState ( ) && versionMeetsMinimum ( 5 , 0 , 0 ) ) { if ( ! this . io . inTransactionOnServer ( ) ) { return ; } } execSQL ( null , " commit " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } catch ( SQLException sqlException ) { if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlException . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ commit ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlException ; } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } return ; }
 public ConstraintValidatorFactory getDefaultConstraintValidatorFactory ( ) { return null ; }
 public void pingInternal ( boolean checkForClosedConnection , int timeoutMillis ) throws SQLException { if ( checkForClosedConnection ) { checkClosed ( ) ; } long pingMillisLifetime = getSelfDestructOnPingSecondsLifetime ( ) ; int pingMaxOperations = getSelfDestructOnPingMaxOperations ( ) ; if ( ( pingMillisLifetime > 0 && ( System . currentTimeMillis ( ) - this . connectionCreationTimeMillis ) > pingMillisLifetime ) || ( pingMaxOperations > 0 && pingMaxOperations <= this . io . getCommandCount ( ) ) ) { close ( ) ; throw SQLError . createSQLException ( Messages . getString ( " Connection . exceededConnectionLifetime " ) , SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE , getExceptionInterceptor ( ) ) ; } this . io . sendCommand ( MysqlDefs . PING , null , null , false , null , timeoutMillis ) ; }
 @ Test public void truncatedFSImage ( ) throws IOException { File testFile = new File ( ROOT , " / truncatedFSImage " ) ; File outputFile = new File ( ROOT , " / trucnatedFSImageOutput " ) ; try { copyPartOfFile ( originalFsimage , testFile ) ; assertTrue ( " Created ▁ truncated ▁ fsimage " , testFile . exists ( ) ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; try { oiv . go ( ) ; fail ( " Managed ▁ to ▁ process ▁ a ▁ truncated ▁ fsimage ▁ file " ) ; } catch ( EOFException e ) { LOG . debug ( " Correctly ▁ handled ▁ EOF " ) ; } } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } }
 @ Bean public ServiceProto . ServiceRef gossipServiceRef ( ) { return ServiceProto . ServiceRef . newBuilder ( ) . setComponentRef ( localComponentRef ) . setServiceId ( " gossip " ) . build ( ) ; }
 @ Override public boolean isInvalidateSessionOnWebsudo ( ) { return false ; }
 public EntityPlayer getPlayer ( ) { return player ; }
 public FtpHelper ( ApplicationManager app ) { this . app = app ; ftp = new FTPClient ( ) ; }
 public HdfsUrlStreamHandlerFactory ( ) { this ( null ) ; }
 public boolean getAutoCommit ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { return this . autoCommit ; } }
 public void addProjected ( SchemaPath path ) { projected . add ( path ) ; }
 public DrillServiceInstance setId ( String id ) { this . id = id ; return this ; }
 public String getItem ( ) { return item ; }
 @ Test public void testZKConnectionInvalidConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = abc " , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof InvalidConnectionInfoException ) ; } }
 public PartitionSignature ( PlanPartition part , int M , StaticCosts costs , double cP0 , double cPN ) { partNodes = part . getPartition ( ) . size ( ) ; inputNodes = part . getInputs ( ) . size ( ) ; rootNodes = part . getRoots ( ) . size ( ) ; matPoints = M ; cCompute = costs . _compute ; cRead = costs . _read ; cWrite = costs . _write ; cPlan0 = cP0 ; cPlanN = cPN ; }
 @ Override public ResponseStats . ImageGet loadImage ( final String url , final OperationParams . Image params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < Bitmap > future = RequestFuture . newFuture ( ) ; mQueue . add ( new ImageRequest ( url , future , 0 , 0 , Bitmap . Config . ARGB_8888 , future ) ) ; final Bitmap response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . ImageGet ( mController , response ) ; }
 public void setNetworkTimeout ( Executor executor , final int milliseconds ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( SET_NETWORK_TIMEOUT_PERM ) ; } if ( executor == null ) { throw SQLError . createSQLException ( " Executor ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } checkClosed ( ) ; final MysqlIO mysqlIo = this . io ; executor . execute ( new Runnable ( ) { public void run ( ) { try { setSocketTimeout ( milliseconds ) ; mysqlIo . setSocketTimeout ( milliseconds ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } } ) ; } }
 protected void validateAfterException ( Throwable e ) { validateExceptionType ( e ) ; }
 @ Test public void testColumnIdentity ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle connectorTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; Map < String , ColumnHandle > columnHandles = metadata . getColumnHandles ( SESSION , connectorTableHandle ) ; ColumnIdentity orderKeyColumnIdentity = metadata . getColumnIdentity ( columnHandles . get ( " orderkey " ) ) ; byte [ ] bytes = orderKeyColumnIdentity . serialize ( ) ; assertEquals ( orderKeyColumnIdentity , metadata . deserializeColumnIdentity ( bytes ) ) ; byte version = 1 ; long columnId = 123456789012L ; ByteArrayDataOutput dataOutput = newDataOutput ( ) ; dataOutput . writeByte ( version ) ; dataOutput . writeLong ( columnId ) ; byte [ ] testBytes = dataOutput . toByteArray ( ) ; ColumnIdentity testColumnIdentity = metadata . deserializeColumnIdentity ( testBytes ) ; assertEquals ( testColumnIdentity , new RaptorColumnIdentity ( columnId ) ) ; }
 protected void validateExceptionType ( Throwable e ) { Assert . equals ( e . getClass ( ) , expectedExceptionClass ) ; Throwable exception = getExceptionForThrowable ( e ) ; if ( exception == null ) exception = e ; if ( expectedExceptionMessage != null ) { Assert . notNull ( exception . getMessage ( ) , " Exception ▁ message ▁ null , ▁ expecting : ▁ " + expectedExceptionMessage ) ; Assert . startsWith ( exception . getMessage ( ) , expectedExceptionMessage ) ; } if ( expectedExceptionCause != null ) { Assert . notNull ( exception . getCause ( ) , " Exception ▁ cause ▁ null , ▁ expecting : ▁ " + expectedExceptionCause . getName ( ) ) ; Assert . equals ( exception . getCause ( ) . getClass ( ) , expectedExceptionCause ) ; } }
 protected void addExpectedException ( Class < ? extends Throwable > exceptionClass , Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { if ( exceptionCause != null ) { Throwable instanceofCause = createException ( exceptionCause , " message " ) ; expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage , instanceofCause ) ; } else expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage ) ; expectedExceptionClass = exceptionClass ; expectedExceptionCause = exceptionCause ; expectedExceptionMessage = exceptionMessage ; }
 public DrillServiceInstance ( ) { }
 public URI getUrl ( ) { return this . url ; }
 @ Before public void setUp ( ) { value = " ▁ ▁ ▁ ▁ Hello ▁ ▁ ▁ \n ▁ ▁ World \n ▁ ▁ ▁ ▁ " ; comments = new Comments ( value ) ; commentsWithDifferentValue = new Comments ( " Hello \n World " ) ; }
 @ Override public void checkCanDropView ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName viewName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , viewName . getObjectName ( ) , DROP_VIEW ) ) { denyDropView ( viewName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropView ( transactionId , identity , context , viewName ) ; } }
 @ Override public void loadState ( Element state ) { setExternalCompilerMemory ( Integer . valueOf ( state . getAttributeValue ( ExternalCompilerMemory , String . valueOf ( DEFAULT_Xmx ) ) ) ) ; setExternalToIncrementalCompiler ( Integer . valueOf ( state . getAttributeValue ( ExternalToIncrementalCompilerLimit , String . valueOf ( DEFAULT_INCREMENTAL_LIMIT ) ) ) ) ; }
 public ValidationException ( final String message , final Throwable cause ) { super ( message , cause ) ; }
 private void verificarExistenciaContato ( String nome ) throws AgendaException { if ( ! this . contatosMap . containsKey ( nome ) ) { throw new AgendaException ( " Contato ▁ " + nome + " ▁ não ▁ existe ! " ) ; } }
 public ColumnDescriptor getColumnDescription ( String [ ] path ) { int maxRep = getMaxRepetitionLevel ( path ) ; int maxDef = getMaxDefinitionLevel ( path ) ; PrimitiveTypeName type = getType ( path ) . asPrimitiveType ( ) . getPrimitiveTypeName ( ) ; return new ColumnDescriptor ( path , type , maxRep , maxDef ) ; }
 public int getNetworkTimeout ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; return getSocketTimeout ( ) ; } }
 public Statement getFinallyStatement ( ) { return _finallyStatement ; }
 @ Override public void convert ( BaseRecyclerHolder holder , SimpleSubjectBean item , int position , boolean isScrolling ) { holder . setText ( R . id . tv_item_simple_movie_text , item . title ) ; holder . setImageFromEntity ( R . id . iv_item_simple_movie_image , item . images ) ; }
 public void unregister ( String alias ) { unregisterServlet ( this . handlerRegistry . getServletByAlias ( alias ) ) ; }
 @ Deprecated public String getServerCharacterEncoding ( ) { return getServerCharset ( ) ; }
 public void setActive ( java . lang . Integer active ) { set ( " active " , active ) ; }
 @ Override public NotificationChain eInverseRemove ( InternalEObject otherEnd , int featureID , NotificationChain msgs ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : return basicSetThermalGeneratingUnit ( null , msgs ) ; } return super . eInverseRemove ( otherEnd , featureID , msgs ) ; }
 protected void setupForExpectedException ( Class < ? extends Throwable > exceptionClass , String exceptionMessage ) throws Exception { addExpectedException ( exceptionClass , null , exceptionMessage ) ; }
 public EnumKnowledgeType getType ( ) { return type ; }
 public void testReverseSupplementary ( ) throws Exception { assertEquals ( " 𩬅艱鍟䇹愯瀛 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 瀛愯䇹鍟艱𩬅 " ) ) ; assertEquals ( " a𩬅艱鍟䇹愯瀛 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 瀛愯䇹鍟艱𩬅a " ) ) ; assertEquals ( " fedcba𩬅 " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " 𩬅abcdef " ) ) ; assertEquals ( " fedcba𩬅z " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " z𩬅abcdef " ) ) ; assertEquals ( " gfe𩬅dcba " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " abcd𩬅efg " ) ) ; }
 public String getDefaultEncoding ( ) { return defaultEncoding ; }
 @ Test public void testSortOrderProperty ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( ORDERING_PROPERTY , ImmutableList . of ( " orderdate " , " custkey " ) ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertTableColumnsEqual ( sortColumns , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderdate " , DATE , 4 , 3 , OptionalInt . empty ( ) , OptionalInt . of ( 0 ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . empty ( ) , OptionalInt . of ( 1 ) , false ) ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , null ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
 public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( properName == null ) ? 0 : properName . hashCode ( ) ) ; return result ; }
 public void update ( List < SimpleSubjectBean > data ) { super . update ( data ) ; }
 @ Test public final void test_that_a_Comments_equality_to_another_is_based_on_its_value ( ) { assertTrue ( comments . equals ( comments ) ) ; assertTrue ( comments . equals ( new Comments ( value ) ) ) ; assertTrue ( new Comments ( value ) . equals ( comments ) ) ; assertFalse ( comments . equals ( null ) ) ; assertFalse ( comments . equals ( new Object ( ) ) ) ; assertFalse ( comments . equals ( commentsWithDifferentValue ) ) ; }
 @ Override public boolean isInsecureCookie ( ) { return false ; }
 public ValidationException ( ) { }
 private void checkServerEncoding ( ) throws SQLException { if ( getUseUnicode ( ) && ( getEncoding ( ) != null ) ) { return ; } String serverCharset = this . serverVariables . get ( " character _ set " ) ; if ( serverCharset == null ) { serverCharset = this . serverVariables . get ( " character _ set _ server " ) ; } String mappedServerEncoding = null ; if ( serverCharset != null ) { try { mappedServerEncoding = CharsetMapping . getJavaEncodingForMysqlCharset ( serverCharset ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } } if ( ! getUseUnicode ( ) && ( mappedServerEncoding != null ) ) { SingleByteCharsetConverter converter = getCharsetConverter ( mappedServerEncoding ) ; if ( converter != null ) { setUseUnicode ( true ) ; setEncoding ( mappedServerEncoding ) ; return ; } } if ( serverCharset != null ) { if ( mappedServerEncoding == null ) { if ( Character . isLowerCase ( serverCharset . charAt ( 0 ) ) ) { char [ ] ach = serverCharset . toCharArray ( ) ; ach [ 0 ] = Character . toUpperCase ( serverCharset . charAt ( 0 ) ) ; setEncoding ( new String ( ach ) ) ; } } if ( mappedServerEncoding == null ) { throw SQLError . createSQLException ( " Unknown ▁ character ▁ encoding ▁ on ▁ server ▁ ' " + serverCharset + " ' , ▁ use ▁ ' characterEncoding = ' ▁ property ▁ " + " ▁ to ▁ provide ▁ correct ▁ mapping " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } try { StringUtils . getBytes ( " abc " , mappedServerEncoding ) ; setEncoding ( mappedServerEncoding ) ; setUseUnicode ( true ) ; } catch ( UnsupportedEncodingException UE ) { throw SQLError . createSQLException ( " The ▁ driver ▁ can ▁ not ▁ map ▁ the ▁ character ▁ encoding ▁ ' " + getEncoding ( ) + " ' ▁ that ▁ your ▁ server ▁ is ▁ using ▁ " + " to ▁ a ▁ character ▁ encoding ▁ your ▁ JVM ▁ understands . ▁ You ▁ can ▁ specify ▁ this ▁ mapping ▁ manually ▁ by ▁ adding ▁ \" useUnicode = true \" ▁ " + " as ▁ well ▁ as ▁ \" characterEncoding = [ an _ encoding _ your _ jvm _ understands ] \" ▁ to ▁ your ▁ JDBC ▁ URL . " , "0S100" , getExceptionInterceptor ( ) ) ; } } }
 private PushButton newSetHoursButton ( final int hours ) { final PushButton button = new PushButton ( Integer . toString ( hours ) ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { @ SuppressWarnings ( { " deprecation " } ) Date d = box . getValue ( ) ; if ( d == null ) { d = new Date ( ) ; d . setMinutes ( 0 ) ; } d . setHours ( hours ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
 public ListHashMap < K , V > addItem ( K key , V value ) { if ( ! map . containsKey ( key ) ) { map . put ( key , new ArrayList < V > ( ) ) ; } map . get ( key ) . add ( value ) ; return this ; }
 CompoundCacheKey ( String partOne , String partTwo ) { this . componentOne = partOne ; this . componentTwo = partTwo ; this . hashCode = ( ( ( this . componentOne != null ) ? this . componentOne : " " ) + this . componentTwo ) . hashCode ( ) ; }
 @ Test public final void test_that_a_Comments_order_is_based_on_its_value ( ) { final Comments commentsAbc = new Comments ( " abc " ) ; final Comments commentsXyz = new Comments ( " xyz " ) ; assertTrue ( commentsAbc . compareTo ( commentsXyz ) < 0 ) ; assertEquals ( 0 , commentsAbc . compareTo ( commentsAbc ) ) ; assertTrue ( commentsXyz . compareTo ( commentsAbc ) > 0 ) ; assertEquals ( 0 , commentsXyz . compareTo ( commentsXyz ) ) ; }
 public boolean useAnsiQuotedIdentifiers ( ) { synchronized ( getConnectionMutex ( ) ) { return this . useAnsiQuotes ; } }
 public synchronized Cursor getTripShareById ( String id ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , TripShare . FIELDS , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { id } , null , null , null , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
 public AggregateInfo ( Hop aggregate ) { _aggregates = new HashMap < > ( ) ; _aggregates . put ( aggregate . getHopID ( ) , aggregate ) ; }
 @ Test public void verifyPagesMergeSortBenchmark ( ) { MergeSortedBenchmarkData state = new MergeSortedBenchmarkData ( ) ; state . setup ( ) ; List < Page > pages = runPagesMergeSortBenchmark ( state ) ; int positionCount = pages . stream ( ) . mapToInt ( Page :: getPositionCount ) . sum ( ) ; assertEquals ( positionCount , state . getTotalPositions ( ) ) ; }
 @ Override public void selectPlans ( CPlanMemoTable memo , ArrayList < Hop > roots ) { Collection < PlanPartition > parts = PlanAnalyzer . analyzePlanPartitions ( memo , roots , true ) ; int sumMatPoints = 0 ; for ( PlanPartition part : parts ) { createAndAddMultiAggPlans ( memo , part . getPartition ( ) , part . getRoots ( ) ) ; selectPlans ( memo , part ) ; sumMatPoints += part . getMatPointsExt ( ) . length ; } createAndAddMultiAggPlans ( memo , roots ) ; for ( Entry < Long , List < MemoTableEntry > > e : getBestPlans ( ) . entrySet ( ) ) memo . setDistinct ( e . getKey ( ) , e . getValue ( ) ) ; if ( ConfigurationManager . isStatistics ( ) ) { if ( sumMatPoints >= 63 ) LOG . warn ( " Long ▁ overflow ▁ on ▁ maintaining ▁ codegen ▁ statistics ▁ " + " for ▁ a ▁ DAG ▁ with ▁ " + sumMatPoints + " ▁ interesting ▁ points . " ) ; Statistics . incrementCodegenEnumAll ( UtilFunctions . pow ( 2 , sumMatPoints ) ) ; } }
 public Page deserialize ( SerializedPage serializedPage ) { checkArgument ( serializedPage != null , " serializedPage ▁ is ▁ null " ) ; Slice slice = serializedPage . getSlice ( ) ; if ( serializedPage . isEncrypted ( ) ) { checkState ( spillCipher . isPresent ( ) , " Page ▁ is ▁ encrypted , ▁ but ▁ spill ▁ cipher ▁ is ▁ missing " ) ; byte [ ] decrypted = new byte [ spillCipher . get ( ) . decryptedMaxLength ( slice . length ( ) ) ] ; int decryptedSize = spillCipher . get ( ) . decrypt ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , decrypted , 0 ) ; slice = Slices . wrappedBuffer ( decrypted , 0 , decryptedSize ) ; } if ( serializedPage . isCompressed ( ) ) { checkState ( decompressor . isPresent ( ) , " Page ▁ is ▁ compressed , ▁ but ▁ decompressor ▁ is ▁ missing " ) ; int uncompressedSize = serializedPage . getUncompressedSizeInBytes ( ) ; byte [ ] decompressed = new byte [ uncompressedSize ] ; checkState ( decompressor . get ( ) . decompress ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , decompressed , 0 , uncompressedSize ) == uncompressedSize ) ; slice = Slices . wrappedBuffer ( decompressed ) ; } return readRawPage ( serializedPage . getPositionCount ( ) , slice . getInput ( ) , blockEncodingSerde ) ; }
 public List < V > remove ( String key ) { return map . remove ( key ) ; }
 private PushButton newShiftDateButton ( final int seconds , final String label ) { final PushButton button = new PushButton ( label ) ; button . setStyleName ( seconds < 0 ? " datePickerPreviousButton " : " datePickerNextButton " ) ; button . addClickHandler ( new ClickHandler ( ) { public void onClick ( final ClickEvent event ) { Date d = box . getValue ( ) ; if ( d == null ) { if ( seconds >= 0 ) { return ; } d = new Date ( ) ; } d . setTime ( d . getTime ( ) + seconds * 1000L ) ; d . setSeconds ( 0 ) ; setDate ( d ) ; } } ) ; return button ; }
 public void shutdownServer ( ) throws SQLException { try { this . io . sendCommand ( MysqlDefs . SHUTDOWN , null , null , false , null , 0 ) ; } catch ( Exception ex ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnhandledExceptionDuringShutdown " ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } }
 @ Override public void checkCanRenameSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName , String newSchemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , RENAME_SCHEMA ) ) { denyRenameSchema ( schemaName . toString ( ) , newSchemaName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanRenameSchema ( transactionId , identity , context , schemaName , newSchemaName ) ; } }
 if ( versionMeetsMinimum ( 5 , 5 , 0 ) ) { this . errorMessageEncoding = this . io . getEncodingForHandshake ( ) ; }
 @ Test public void testEviction ( ) throws IOException { Configuration conf = new Configuration ( ) ; conf . set ( FileSystem . FS_DEFAULT_NAME_KEY , " hdfs : // localhost " ) ; final int MAX_CACHE_SIZE = 2 ; DFSClientCache cache = new DFSClientCache ( conf , MAX_CACHE_SIZE ) ; DFSClient c1 = cache . get ( " test1" ) ; assertTrue ( cache . get ( " test1" ) . toString ( ) . contains ( " ugi = test1" ) ) ; assertEquals ( c1 , cache . get ( " test1" ) ) ; assertFalse ( isDfsClientClose ( c1 ) ) ; cache . get ( " test2" ) ; assertTrue ( isDfsClientClose ( c1 ) ) ; assertEquals ( MAX_CACHE_SIZE - 1 , cache . clientCache . size ( ) ) ; }
 @ Test public void testTableIdentity ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle connectorTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; TableIdentity tableIdentity = metadata . getTableIdentity ( connectorTableHandle ) ; byte [ ] bytes = tableIdentity . serialize ( ) ; assertEquals ( tableIdentity , metadata . deserializeTableIdentity ( bytes ) ) ; byte version = 1 ; long tableId = 12345678L ; ByteArrayDataOutput dataOutput = newDataOutput ( ) ; dataOutput . writeByte ( version ) ; dataOutput . writeLong ( tableId ) ; byte [ ] testBytes = dataOutput . toByteArray ( ) ; TableIdentity testTableIdentity = metadata . deserializeTableIdentity ( testBytes ) ; assertEquals ( testTableIdentity , new RaptorTableIdentity ( tableId ) ) ; }
 @ Test public void testZKSuccessfulConnectionZeroConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = 0" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
 public void incrementNumberOfPrepares ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfPrepares ++ ; } }
 public void setBCC ( String address ) { recipients . put ( Message . RecipientType . BCC , address ) ; }
 public String getAlternativeBodyHeader ( ) { return alternativeBodyHeader ; }
 @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Table ▁ with ▁ temporal ▁ columns ▁ cannot ▁ be ▁ organized " ) public void testInvalidTemporalOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderdate " , ORGANIZED_PROPERTY , true ) ) , false ) ; }
 public InternalTable build ( ) { flushPage ( ) ; return new InternalTable ( columnIndexes , pages ) ; }
 private final VoiceRecorder . Callback mVoiceCallback = new VoiceRecorder . Callback ( ) { @ Override public void onVoiceStart ( ) { if ( mSpeechService != null ) { mSpeechService . startRecognizing ( mVoiceRecorder . getSampleRate ( ) ) ; } } @ Override public void onVoice ( byte [ ] data , int size ) { if ( mSpeechService != null ) { mSpeechService . recognize ( data , size ) ; } } @ Override public void onVoiceEnd ( ) { if ( mSpeechService != null ) { mSpeechService . finishRecognizing ( ) ; } } }
 @ Test public void testDropColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle lastColumn = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . dropColumn ( SESSION , raptorTableHandle , lastColumn ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; }
 @ Test public final void test_that_MISSING_is_essentially_an_empty_instance ( ) { assertEquals ( " " , Comments . MISSING . value ( ) ) ; assertFalse ( Comments . MISSING . iterator ( ) . hasNext ( ) ) ; }
 @ Override public int hashCode ( ) { return id . hashCode ( ) ; }
 public java . sql . Statement createStatement ( int resultSetType , int resultSetConcurrency ) throws SQLException { checkClosed ( ) ; StatementImpl stmt = new StatementImpl ( getMultiHostSafeProxy ( ) , this . database ) ; stmt . setResultSetType ( resultSetType ) ; stmt . setResultSetConcurrency ( resultSetConcurrency ) ; return stmt ; }
 public void setDebugMode ( boolean debugMode ) { this . debugMode = debugMode ; }
 List < Type > getSortTypes ( ) { return sortTypes ; }
 public Deck importDeck ( @ NonNull URL url ) { try { return importDeck ( new File ( url . toURI ( ) ) ) ; } catch ( URISyntaxException e ) { throw new IllegalArgumentException ( format ( " The ▁ provided ▁ URL ▁ ' % s ' ▁ cannot ▁ be ▁ converted ▁ to ▁ a ▁ URI . " , url ) , e ) ; } }
 @ Test public void generateCommandJcdkWithoutConfigurationFailure ( ) throws Exception { exception . expect ( RuntimeException . class ) ; exception . expectMessage ( " Provided ▁ configuration ▁ path ▁ is ▁ not ▁ valid : ▁ " + configurationFile ) ; Files . delete ( configurationFile ) ; JcdkWrapperImpl . generateCommand ( jcdkInstallation , configurationFile ) ; }
 @ Test public void testDirectConnectionConnectTriesGreaterThanDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 5" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
 @ Override public boolean equals ( Object o ) { if ( o instanceof ParentPrime ) { ParentPrime castObj = ( ParentPrime ) o ; return id . equals ( castObj . getId ( ) ) ; } return false ; }
 public void addFusedInput ( long hopID ) { _fusedInputs . add ( hopID ) ; }
 private void createPools ( Properties props ) { Enumeration propNames = props . propertyNames ( ) ; while ( propNames . hasMoreElements ( ) ) { String name = ( String ) propNames . nextElement ( ) ; if ( name . endsWith ( " . url " ) ) { String poolName = name . substring ( 0 , name . lastIndexOf ( " . " ) ) ; String url = props . getProperty ( poolName + " . url " ) ; if ( url == null ) { log ( " 没有为连接池 " + poolName + " 指定URL " ) ; continue ; } String user = props . getProperty ( poolName + " . user " ) ; String password = props . getProperty ( poolName + " . password " ) ; String maxconn = props . getProperty ( poolName + " . maxconn " , "0" ) ; String minconn = props . getProperty ( poolName + " . minConns " , "0" ) ; String strloginterval = props . getProperty ( poolName + " . logInterval " , "0" ) ; int max ; int min ; long logInterval = Long . parseLong ( strloginterval ) ; try { max = Integer . valueOf ( maxconn ) . intValue ( ) ; } catch ( NumberFormatException e ) { log ( " 错误的最大连接数限制 : ▁ " + maxconn + " ▁ . 连接池 : ▁ " + poolName ) ; max = 0 ; } try { min = Integer . valueOf ( minconn ) . intValue ( ) ; } catch ( NumberFormatException e ) { log ( " 错误的最小连接数限制 : ▁ " + minconn + " ▁ . 连接池 : ▁ " + poolName ) ; min = 0 ; } ConnPool pool = new ConnPool ( poolName , url , user , password , max , min , logInterval ) ; pools . put ( poolName , pool ) ; log ( " 成功创建连接池 " + poolName ) ; } } }
 public java . sql . PreparedStatement serverPrepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { String nativeSql = getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; PreparedStatement pStmt = ServerPreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . getCatalog ( ) , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; pStmt . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
 ExceptionInterceptorChain ( String interceptorClasses ) throws SQLException { this . interceptors = Util . loadExtensions ( ConnectionImpl . this , ConnectionImpl . this . props , interceptorClasses , " Connection . BadExceptionInterceptor " , this ) ; }
 @ Override public RoleMapper getRoleMapper ( ) { return null ; }
 public RegimeEspecialIntegracaoDTO cpfCnpjRaiz ( String cpfCnpjRaiz ) { this . cpfCnpjRaiz = cpfCnpjRaiz ; return this ; }
 public String messageFullName ( ) { return DrillServiceInstance . class . getName ( ) ; }
 public void setOptions ( String [ ] options ) throws Exception { String seedString = Utils . getOption ( ' R ' , options ) ; if ( seedString . length ( ) != 0 ) m_Seed = Long . parseLong ( seedString ) ; else m_Seed = 1 ; String orderString = Utils . getOption ( ' C ' , options ) ; if ( orderString . length ( ) != 0 ) m_ClassOrder = Integer . parseInt ( orderString ) ; else m_ClassOrder = FREQ_ASCEND ; if ( getInputFormat ( ) != null ) setInputFormat ( getInputFormat ( ) ) ; m_Random = null ; }
 if ( ! isAliasValid ( alias ) ) { throw new IllegalArgumentException ( " Malformed ▁ servlet ▁ alias ▁ [ " + alias + " ] " ) ; }
 public boolean hasVarStatements ( ) { return _varStmts != null && ! _varStmts . isEmpty ( ) ; }
 @ Override public void didExitRegion ( Region region ) { OrchextraRegion orchextraRegion = regionMapper . externalClassToModel ( region ) ; beaconsController . onRegionExit ( orchextraRegion ) ; monitoringListener . onRegionExit ( region ) ; regionsInEnter . remove ( region ) ; GGGLogImpl . log ( " EXIT ▁ BEACON ▁ REGION ▁ : ▁ " + region . getUniqueId ( ) ) ; }
 public synchronized String getTripShareId ( ) { String tripShareId = " " ; Cursor tripShareCursor = getTripShareCursor ( ) ; try { if ( tripShareCursor != null && tripShareCursor . moveToLast ( ) ) { TripShare tripShare = new TripShare ( tripShareCursor ) ; tripShareId = tripShare . id ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } finally { try { if ( tripShareCursor != null ) { tripShareCursor . close ( ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } } return tripShareId ; }
 public void readExternal ( ObjectInput in ) throws IOException { GraphIOUtil . mergeDelimitedFrom ( in , this , this ) ; }
 @ Override public RedirectPolicy getRedirectPolicy ( ) { return null ; }
 public Future send ( Object tag , String url , DownloadResponseHandler responseHandler , long from , String saveFile ) { final Request request = new Request . Builder ( ) . tag ( tag ) . addHeader ( " Range " , " bytes = " + from + " - " ) . url ( url ) . build ( ) ; return sendRequest ( request , responseHandler , saveFile ) ; }
 @ Test public void onJoinOfNulls ( ) { Assert . assertEquals ( " null , null " , StringUtils . join ( " , " , Arrays . asList ( null , null ) ) ) ; }
 @ Test public void load ( ) { Assert . assertNotNull ( gossipService ) ; Assert . assertTrue ( waitUntil ( new Callable < Integer > ( ) { @ Override public Integer call ( ) throws Exception { return testPresenceListener . getCount ( ) ; } } , 3 , 60 ) ) ; Assert . assertTrue ( testPresenceListener . getCount ( ) > 0 ) ; }
 public int getMaxBytesPerChar ( Integer charsetIndex , String javaCharsetName ) throws SQLException { String charset = null ; int res = 1 ; try { if ( this . indexToCustomMysqlCharset != null ) { charset = this . indexToCustomMysqlCharset . get ( charsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetNameForCollationIndex ( charsetIndex ) ; } if ( charset == null ) { charset = CharsetMapping . getMysqlCharsetForJavaEncoding ( javaCharsetName , this ) ; } Integer mblen = null ; if ( this . mysqlCharsetToCustomMblen != null ) { mblen = this . mysqlCharsetToCustomMblen . get ( charset ) ; } if ( mblen == null ) { mblen = CharsetMapping . getMblen ( charset ) ; } if ( mblen != null ) { res = mblen . intValue ( ) ; } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } return res ; }
 public boolean getRequiresEscapingEncoder ( ) { return this . requiresEscapingEncoder ; }
 @ Override public boolean equals ( Object o ) { if ( this == o ) { return true ; } if ( o == null || getClass ( ) != o . getClass ( ) ) { return false ; } TestingPrivilege that = ( TestingPrivilege ) o ; return Objects . equals ( entityName , that . entityName ) && Objects . equals ( type , that . type ) ; }
 if ( parsedHostPortPair [ NonRegisteringDriver . PORT_NUMBER_INDEX ] != null ) { newPort = parsePortNumber ( parsedHostPortPair [ NonRegisteringDriver . PORT_NUMBER_INDEX ] ) ; }
 @ NonNull @ Override protected final FilterResults performFiltering ( CharSequence constraint ) { return performFilteringImpl ( constraint ) ; }
 @ Override void finishAbnormally ( ) throws IOException { }
 @ Override public void initMonitoring ( ) { beaconManager . bind ( this ) ; }
 public MySQLConnection getMultiHostSafeProxy ( ) { return this . getProxy ( ) ; }
 @ Bean public Work broadcastWork ( ) { return new BroadcastWork ( gossipServiceRef ( ) , serviceRegistry ) ; }
 public MysqlIO getIO ( ) throws SQLException { if ( ( this . io == null ) || this . isClosed ) { throw SQLError . createSQLException ( " Operation ▁ not ▁ allowed ▁ on ▁ closed ▁ connection " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } return this . io ; }
 public void cancelAll ( ) { httpClient . dispatcher ( ) . cancelAll ( ) ; }
 public void setSession ( Session session ) { this . session = session ; }
 public boolean isReadOnly ( ) throws SQLException { return isReadOnly ( true ) ; }
 protected JavaMailSenderImpl createJavaMailSender ( ) { JavaMailSenderImpl answer = new JavaMailSenderImpl ( ) ; if ( javaMailProperties != null ) { answer . setJavaMailProperties ( javaMailProperties ) ; } else { answer . setJavaMailProperties ( createJavaMailProperties ( ) ) ; if ( additionalJavaMailProperties != null ) { answer . getJavaMailProperties ( ) . putAll ( additionalJavaMailProperties ) ; } } if ( defaultEncoding != null ) { answer . setDefaultEncoding ( defaultEncoding ) ; } if ( host != null ) { answer . setHost ( host ) ; } if ( port >= 0 ) { answer . setPort ( port ) ; } if ( username != null ) { answer . setUsername ( username ) ; } if ( password != null ) { answer . setPassword ( password ) ; } if ( protocol != null ) { answer . setProtocol ( protocol ) ; } if ( session != null ) { answer . setSession ( session ) ; } else { Session session = Session . getInstance ( answer . getJavaMailProperties ( ) , getAuthenticator ( ) ) ; session . setDebug ( debugMode ) ; answer . setSession ( session ) ; } return answer ; }
 public void setIgnoreUriScheme ( boolean ignoreUriScheme ) { this . ignoreUriScheme = ignoreUriScheme ; }
 public long getId ( ) { return this . connectionId ; }
 public void decachePreparedStatement ( ServerPreparedStatement pstmt ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( getCachePreparedStatements ( ) && pstmt . isPoolable ( ) ) { synchronized ( this . serverSideStatementCache ) { this . serverSideStatementCache . remove ( pstmt . originalSql ) ; } } } }
 private Boolean transactionSuccessful ( long transactionId ) { try ( Handle handle = dbi . open ( ) ) { return ( Boolean ) handle . createQuery ( " SELECT ▁ successful ▁ FROM ▁ transactions ▁ WHERE ▁ transaction _ id ▁ = ▁ ? " ) . bind ( 0 , transactionId ) . first ( ) . get ( " successful " ) ; } }
 @ Deprecated public boolean hasTriedMaster ( ) { return this . hasTriedMasterFlag ; }
 if ( protocol != null ) { if ( " tcp " . equalsIgnoreCase ( protocol ) ) { newHost = normalizeHost ( mergedProps . getProperty ( NonRegisteringDriver . HOST_PROPERTY_KEY ) ) ; newPort = parsePortNumber ( mergedProps . getProperty ( NonRegisteringDriver . PORT_PROPERTY_KEY , "3306" ) ) ; } else if ( " pipe " . equalsIgnoreCase ( protocol ) ) { setSocketFactoryClassName ( NamedPipeSocketFactory . class . getName ( ) ) ; String path = mergedProps . getProperty ( NonRegisteringDriver . PATH_PROPERTY_KEY ) ; if ( path != null ) { mergedProps . setProperty ( NamedPipeSocketFactory . NAMED_PIPE_PROP_NAME , path ) ; } } else { newHost = normalizeHost ( mergedProps . getProperty ( NonRegisteringDriver . HOST_PROPERTY_KEY ) ) ; newPort = parsePortNumber ( mergedProps . getProperty ( NonRegisteringDriver . PORT_PROPERTY_KEY , "3306" ) ) ; } }
 public void setAutoCommit ( final boolean autoCommitFlag ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . setAutoCommit ( autoCommitFlag ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( getAutoReconnectForPools ( ) ) { setHighAvailability ( true ) ; } try { if ( this . transactionsSupported ) { boolean needsSetOnServer = true ; if ( this . getUseLocalSessionState ( ) && this . autoCommit == autoCommitFlag ) { needsSetOnServer = false ; } else if ( ! this . getHighAvailability ( ) ) { needsSetOnServer = this . getIO ( ) . isSetNeededForAutoCommitMode ( autoCommitFlag ) ; } this . autoCommit = autoCommitFlag ; if ( needsSetOnServer ) { execSQL ( null , autoCommitFlag ? " SET ▁ autocommit = 1" : " SET ▁ autocommit = 0" , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; } } else { if ( ( autoCommitFlag == false ) && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " MySQL ▁ Versions ▁ Older ▁ than ▁ 3.23.15 ▁ do ▁ not ▁ support ▁ transactions " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } this . autoCommit = autoCommitFlag ; } } finally { if ( this . getAutoReconnectForPools ( ) ) { setHighAvailability ( false ) ; } } return ; } }
 public void abortInternal ( ) throws SQLException { if ( this . io != null ) { try { this . io . forceClose ( ) ; this . io . releaseResources ( ) ; } catch ( Throwable t ) { } this . io = null ; } this . isClosed = true ; }
 @ Override public void checkCanSetSystemSessionProperty ( Identity identity , AccessControlContext context , String propertyName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , propertyName , SET_SESSION ) ) { denySetSystemSessionProperty ( propertyName ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSetSystemSessionProperty ( identity , context , propertyName ) ; } }
 public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someElephantField == null ) ? 0 : someElephantField . hashCode ( ) ) ; return result ; }
 public int getSessionMaxRows ( ) { synchronized ( getConnectionMutex ( ) ) { return this . sessionMaxRows ; } }
 public List < Contato > listarContatoPorParteNome ( String parteNome ) { String regex = " \\ w * " + parteNome + " \\ w * " ; Pattern p = Pattern . compile ( regex , Pattern . CASE_INSENSITIVE ) ; List < Contato > contatosEncontrados = new ArrayList < > ( ) ; Collection < Contato > contatosCadastrados = this . contatosMap . values ( ) ; for ( Contato contato : contatosCadastrados ) { Matcher m = p . matcher ( contato . getNome ( ) ) ; if ( m . matches ( ) ) { contatosEncontrados . add ( contato ) ; } } return contatosEncontrados ; }
 public void setChildrenList ( List childrenList ) { this . childrenList = childrenList ; }
 public void setExpression ( IExpression expression ) { _expression = ( Expression ) expression ; }
 public ResearchEvent ( EntityPlayer player ) { this . player = player ; }
 protected SubscribeToPushNotificationsRequest ( ExchangeService service ) throws Exception { super ( service ) ; }
 public void unSafeStatementInterceptors ( ) throws SQLException { ArrayList < StatementInterceptorV2 > unSafedStatementInterceptors = new ArrayList < StatementInterceptorV2 > ( this . statementInterceptors . size ( ) ) ; for ( int i = 0 ; i < this . statementInterceptors . size ( ) ; i ++ ) { NoSubInterceptorWrapper wrappedInterceptor = ( NoSubInterceptorWrapper ) this . statementInterceptors . get ( i ) ; unSafedStatementInterceptors . add ( wrappedInterceptor . getUnderlyingInterceptor ( ) ) ; } this . statementInterceptors = unSafedStatementInterceptors ; if ( this . io != null ) { this . io . setStatementInterceptors ( this . statementInterceptors ) ; } }
 public ThermalGeneratingUnit getThermalGeneratingUnit ( ) { if ( thermalGeneratingUnit != null && thermalGeneratingUnit . eIsProxy ( ) ) { InternalEObject oldThermalGeneratingUnit = ( InternalEObject ) thermalGeneratingUnit ; thermalGeneratingUnit = ( ThermalGeneratingUnit ) eResolveProxy ( oldThermalGeneratingUnit ) ; if ( thermalGeneratingUnit != oldThermalGeneratingUnit ) { if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . RESOLVE , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , oldThermalGeneratingUnit , thermalGeneratingUnit ) ) ; } } return thermalGeneratingUnit ; }
 catch ( IllegalArgumentException ex ) { }
 @ Test public void unsupportedFSLayoutVersion ( ) throws IOException { File testFile = new File ( ROOT , " / invalidLayoutVersion " ) ; File outputFile = new File ( ROOT , " invalidLayoutVersionOutput " ) ; try { int badVersionNum = - 432 ; changeLayoutVersion ( originalFsimage , testFile , badVersionNum ) ; ImageVisitor v = new LsImageVisitor ( outputFile . getPath ( ) , true ) ; OfflineImageViewer oiv = new OfflineImageViewer ( testFile . getPath ( ) , v , false ) ; try { oiv . go ( ) ; fail ( " Shouldn ' t ▁ be ▁ able ▁ to ▁ read ▁ invalid ▁ laytout ▁ version " ) ; } catch ( IOException e ) { if ( ! e . getMessage ( ) . contains ( Integer . toString ( badVersionNum ) ) ) throw e ; LOG . debug ( " Correctly ▁ failed ▁ at ▁ reading ▁ bad ▁ image ▁ version . " ) ; } } finally { if ( testFile . exists ( ) ) testFile . delete ( ) ; if ( outputFile . exists ( ) ) outputFile . delete ( ) ; } }
 public void setInGlobalTx ( boolean flag ) { this . isInGlobalTx = flag ; }
 JSR_W ( ) { }
 @ XmlElementDecl ( namespace = Constants . RESPONSE_XSD , name = " WebShopResponse " ) public JAXBElement < WebShopResponseType > createWebShopResponse ( WebShopResponseType value ) { return new JAXBElement < WebShopResponseType > ( _WebShopResponse_QNAME , WebShopResponseType . class , null , value ) ; }
 public synchronized Cursor getTripShareCursor ( ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , TripShare . FIELDS , null , null , null , null , null , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
 public long getRegistrationTimeUTC ( ) { return registrationTimeUTC ; }
 public void loadCardImage ( String imagePath ) { this . cardImage = new ImageIcon ( imagePath ) . getImage ( ) ; }
 public void setUnseen ( boolean unseen ) { this . unseen = unseen ; }
 public final String getType ( ) { return super . getAttributeValue ( Constants . ATTRIBUTE_TYPE ) ; }
 public ButtonEdit ( String id ) { super ( id ) ; }
 @ Test public void testDirectConnectionNegativeConnectTries ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = - 5" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
 private DynamicFiltersTestUtil ( ) { }
 @ Override public String toString ( ) { return " [ " + outSize + " , ▁ " + computeCosts + " , ▁ { " + Arrays . toString ( inSizes . keySet ( ) . toArray ( new Long [ 0 ] ) ) + " , ▁ " + Arrays . toString ( inSizes . values ( ) . toArray ( new Double [ 0 ] ) ) + " } ] " ; }
 public List < Page > getPages ( ) { return pages ; }
 public void setPassword ( java . lang . String password ) { set ( " password " , password ) ; }
 private void setDate ( final Date d ) { refreshAll ( ) ; box . setValue ( d ) ; box . getTextBox ( ) . setFocus ( true ) ; }
 @ Override Object writeReplace ( ) { return new KeySetSerializedForm < K > ( map ) ; }
 @ Override public int getSizeInventory ( ) { return this . inv . length ; }
 public int getExternalCompilerMemory ( ) { return myExternalCompilerMemory ; }
 public void setValue ( String value ) { this . value = value ; }
 private void stopMonitoringRegions ( List < Region > altRegions ) { try { for ( Region region : altRegions ) { beaconManager . stopMonitoringBeaconsInRegion ( region ) ; GGGLogImpl . log ( " Stop ▁ Beacons ▁ Monitoring ▁ for ▁ region ▁ " + region . getUniqueId ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
 public String getResearchKey ( ) { return researchKey ; }
 public boolean removeItem ( String key , V value ) { if ( ! map . containsKey ( key ) ) { return false ; } return map . get ( key ) . remove ( value ) ; }
 private boolean [ ] enumPlans ( CPlanMemoTable memo , PlanPartition part , StaticCosts costs , ReachabilityGraph rgraph , InterestingPoint [ ] matPoints , int off ) { final int Mlen = matPoints . length - off ; final long len = UtilFunctions . pow ( 2 , Mlen ) ; long numEvalPlans = 2 , numEvalPartPlans = 0 ; final boolean [ ] plan0 = createAssignment ( Mlen , off , 0 ) ; final boolean [ ] planN = createAssignment ( Mlen , off , len - 1 ) ; final double C0 = getPlanCost ( memo , part , matPoints , plan0 , costs . _computeCosts , Double . MAX_VALUE ) ; final double CN = getPlanCost ( memo , part , matPoints , planN , costs . _computeCosts , Double . MAX_VALUE ) ; boolean [ ] bestPlan = ( C0 <= CN ) ? plan0 : planN ; double bestC = Math . min ( C0 , CN ) ; final boolean evalRemain = ( Mlen < COST_MIN_EPS_NUM_POINTS || ! COST_PRUNING || bestC > ( 1 + COST_MIN_EPS ) * costs . getMinCosts ( ) ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum ▁ opening : ▁ " + Arrays . toString ( bestPlan ) + " ▁ - > ▁ " + bestC ) ; if ( ! evalRemain ) LOG . warn ( " Skip ▁ enum ▁ for ▁ | M | = " + Mlen + " , ▁ C = " + bestC + " , ▁ Cmin = " + costs . getMinCosts ( ) ) ; PartitionSignature pKey = null ; if ( probePlanCache ( matPoints ) ) { pKey = new PartitionSignature ( part , matPoints . length , costs , C0 , CN ) ; boolean [ ] plan = getPlan ( pKey ) ; if ( plan != null ) { Statistics . incrementCodegenEnumAllP ( ( rgraph != null || ! STRUCTURAL_PRUNING ) ? len : 0 ) ; return plan ; } } for ( long i = 1 ; i < len - 1 & evalRemain ; i ++ ) { boolean [ ] plan = createAssignment ( Mlen , off , i ) ; long pskip = 0 ; if ( STRUCTURAL_PRUNING && ( rgraph != null ) && rgraph . isCutSet ( plan ) ) { pskip = rgraph . getNumSkipPlans ( plan ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Structural ▁ pruning ▁ for ▁ cut ▁ set : ▁ " + rgraph . getCutSet ( plan ) ) ; SubProblem [ ] prob = rgraph . getSubproblems ( plan ) ; for ( int j = 0 ; j < prob . length ; j ++ ) { if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Subproblem ▁ " + ( j + 1 ) + " / " + prob . length + " : ▁ " + prob [ j ] ) ; boolean [ ] bestTmp = enumPlans ( memo , part , costs , null , prob [ j ] . freeMat , prob [ j ] . offset ) ; LibSpoofPrimitives . vectWrite ( bestTmp , plan , prob [ j ] . freePos ) ; } } else if ( COST_PRUNING ) { double lbC = getLowerBoundCosts ( part , matPoints , memo , costs , plan ) ; if ( lbC >= bestC ) { long skip = getNumSkipPlans ( plan ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Skip ▁ " + skip + " ▁ plans ▁ ( by ▁ cost ) . " ) ; i += skip - 1 ; continue ; } } double pCBound = COST_PRUNING ? bestC : Double . MAX_VALUE ; double C = getPlanCost ( memo , part , matPoints , plan , costs . _computeCosts , pCBound ) ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ " + Arrays . toString ( plan ) + " ▁ - > ▁ " + C ) ; numEvalPartPlans += ( C == Double . POSITIVE_INFINITY ) ? 1 : 0 ; numEvalPlans ++ ; if ( bestPlan == null || C < bestC ) { bestC = C ; bestPlan = plan ; if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Found ▁ new ▁ best ▁ plan . " ) ; } i += pskip ; if ( pskip != 0 && LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Skip ▁ " + pskip + " ▁ plans ▁ ( by ▁ structure ) . " ) ; } if ( ConfigurationManager . isStatistics ( ) ) { Statistics . incrementCodegenEnumAllP ( ( rgraph != null || ! STRUCTURAL_PRUNING ) ? len : 0 ) ; Statistics . incrementCodegenEnumEval ( numEvalPlans ) ; Statistics . incrementCodegenEnumEvalP ( numEvalPartPlans ) ; } if ( LOG . isTraceEnabled ( ) ) LOG . trace ( " Enum : ▁ Optimal ▁ plan : ▁ " + Arrays . toString ( bestPlan ) ) ; if ( probePlanCache ( matPoints ) ) putPlan ( pKey , bestPlan ) ; return ( bestPlan == null ) ? new boolean [ Mlen ] : Arrays . copyOfRange ( bestPlan , off , bestPlan . length ) ; }
 @ Test public void testGetField ( ) throws Exception { @ SuppressWarnings ( " unchecked " ) StatefulSerializer < Serializable > s = new CompactJavaSerializer < > ( null ) ; s . init ( new TransientStateRepository ( ) ) ; ClassLoader loaderA = createClassNameRewritingLoader ( Foo_A . class ) ; Serializable a = ( Serializable ) loaderA . loadClass ( newClassName ( Foo_A . class ) ) . newInstance ( ) ; ByteBuffer encodedA = s . serialize ( a ) ; pushTccl ( createClassNameRewritingLoader ( Foo_B . class ) ) ; try { s . read ( encodedA . duplicate ( ) ) ; } finally { popTccl ( ) ; } pushTccl ( createClassNameRewritingLoader ( Foo_C . class ) ) ; try { s . read ( encodedA . duplicate ( ) ) ; } finally { popTccl ( ) ; } }
 public java . lang . String getPhone ( ) { return get ( " phone " ) ; }
 private void repartitionPerformanceHistogram ( ) { checkAndCreatePerformanceHistogram ( ) ; repartitionHistogram ( this . perfMetricsHistCounts , this . perfMetricsHistBreakpoints , this . shortestQueryTimeMs == Long . MAX_VALUE ? 0 : this . shortestQueryTimeMs , this . longestQueryTimeMs ) ; }
 public void removePropertyFromDatabase ( DatabaseProperty property ) { if ( ! _properties . containsKey ( property . getName ( ) ) ) return ; _properties . remove ( property . getName ( ) ) ; for ( DatabaseItem item : _items . values ( ) ) { item . removeProperty ( property . getName ( ) ) ; } WindowMain . removePropertyFromTableView ( property ) ; WindowMain . updateGUI ( ) ; }
 private void setupAmUI ( ) { hours_minutes . setWidget ( 0 , 1 , newSetHoursButton ( 0 ) ) ; hours_minutes . setWidget ( 0 , 2 , newSetHoursButton ( 1 ) ) ; hours_minutes . setWidget ( 0 , 3 , newSetHoursButton ( 2 ) ) ; hours_minutes . setWidget ( 0 , 4 , newSetHoursButton ( 3 ) ) ; hours_minutes . setWidget ( 0 , 5 , newSetHoursButton ( 4 ) ) ; hours_minutes . setWidget ( 0 , 6 , newSetHoursButton ( 5 ) ) ; hours_minutes . setWidget ( 1 , 1 , newSetHoursButton ( 6 ) ) ; hours_minutes . setWidget ( 1 , 2 , newSetHoursButton ( 7 ) ) ; hours_minutes . setWidget ( 1 , 3 , newSetHoursButton ( 8 ) ) ; hours_minutes . setWidget ( 1 , 4 , newSetHoursButton ( 9 ) ) ; hours_minutes . setWidget ( 1 , 5 , newSetHoursButton ( 10 ) ) ; hours_minutes . setWidget ( 1 , 6 , newSetHoursButton ( 11 ) ) ; }
 public ResearchCategory getCategory ( ) { return category ; }
 public java . lang . Long getId ( ) { return get ( " id " ) ; }
 public int hashCode ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( animals == null ) ? 0 : animals . hashCode ( ) ) ; result = prime * result + ( ( largestAnimal == null ) ? 0 : largestAnimal . hashCode ( ) ) ; return result ; }
 @ Test public void emptyOutputSuccess ( ) throws Exception { assertThat ( jcdkWrapper . getJcdkOutput ( ) , nullValue ( ) ) ; }
 public void destroy ( ) { if ( this . interceptors != null ) { Iterator < Extension > iter = this . interceptors . iterator ( ) ; while ( iter . hasNext ( ) ) { ( ( ExceptionInterceptor ) iter . next ( ) ) . destroy ( ) ; } } }
 private void setupPmUI ( ) { hours_minutes . setWidget ( 0 , 1 , newSetHoursButton ( 12 ) ) ; hours_minutes . setWidget ( 0 , 2 , newSetHoursButton ( 13 ) ) ; hours_minutes . setWidget ( 0 , 3 , newSetHoursButton ( 14 ) ) ; hours_minutes . setWidget ( 0 , 4 , newSetHoursButton ( 15 ) ) ; hours_minutes . setWidget ( 0 , 5 , newSetHoursButton ( 16 ) ) ; hours_minutes . setWidget ( 0 , 6 , newSetHoursButton ( 17 ) ) ; hours_minutes . setWidget ( 1 , 1 , newSetHoursButton ( 18 ) ) ; hours_minutes . setWidget ( 1 , 2 , newSetHoursButton ( 19 ) ) ; hours_minutes . setWidget ( 1 , 3 , newSetHoursButton ( 20 ) ) ; hours_minutes . setWidget ( 1 , 4 , newSetHoursButton ( 21 ) ) ; hours_minutes . setWidget ( 1 , 5 , newSetHoursButton ( 22 ) ) ; hours_minutes . setWidget ( 1 , 6 , newSetHoursButton ( 23 ) ) ; }
 public ValidationException ( final Throwable cause ) { super ( cause ) ; }
 @ Benchmark public List < Page > runPagesMergeSortBenchmark ( MergeSortedBenchmarkData data ) { WorkProcessor < Page > sortedPagesWork = mergeSortedPages ( data . getSplitPages ( ) . stream ( ) . map ( WorkProcessor :: fromIterable ) . collect ( toImmutableList ( ) ) , ORDERING_COMPILER . compilePageWithPositionComparator ( data . getSortTypes ( ) , data . getSortChannels ( ) , data . getSortOrders ( ) ) , data . getOutputChannels ( ) , data . getTypes ( ) , ( pageBuilder , pageWithPosition ) -> pageBuilder . isFull ( ) , false , newSimpleAggregatedMemoryContext ( ) , new DriverYieldSignal ( ) ) ; ImmutableList . Builder < Page > sortedPages = ImmutableList . builder ( ) ; while ( true ) { sortedPagesWork . process ( ) ; if ( sortedPagesWork . isFinished ( ) ) { return sortedPages . build ( ) ; } sortedPages . add ( sortedPagesWork . getResult ( ) ) ; } }
 public String getServerVariable ( String variableName ) { if ( this . serverVariables != null ) { return this . serverVariables . get ( variableName ) ; } return null ; }
 List < List < Page > > getSplitPages ( ) { return splitPages ; }
 @ Override public int hashCode ( ) { return Objects . hash ( entityName , type ) ; }
 public void log ( final String message ) { status . setText ( message ) ; }
 @ Override public void checkCanDeleteFromTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DELETE_TABLE ) ) { denyDeleteTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDeleteFromTable ( transactionId , identity , context , tableName ) ; } }
 public void initializeSafeStatementInterceptors ( ) throws SQLException { this . isClosed = false ; List < Extension > unwrappedInterceptors = Util . loadExtensions ( this , this . props , getStatementInterceptors ( ) , " MysqlIo . BadStatementInterceptor " , getExceptionInterceptor ( ) ) ; this . statementInterceptors = new ArrayList < StatementInterceptorV2 > ( unwrappedInterceptors . size ( ) ) ; for ( int i = 0 ; i < unwrappedInterceptors . size ( ) ; i ++ ) { Extension interceptor = unwrappedInterceptors . get ( i ) ; if ( interceptor instanceof StatementInterceptor ) { if ( ReflectiveStatementInterceptorAdapter . getV2PostProcessMethod ( interceptor . getClass ( ) ) != null ) { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( new ReflectiveStatementInterceptorAdapter ( ( StatementInterceptor ) interceptor ) ) ) ; } else { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( new V1toV2StatementInterceptorAdapter ( ( StatementInterceptor ) interceptor ) ) ) ; } } else { this . statementInterceptors . add ( new NoSubInterceptorWrapper ( ( StatementInterceptorV2 ) interceptor ) ) ; } } }
 public void setCC ( String address ) { recipients . put ( Message . RecipientType . CC , address ) ; }
 @ Override public Void visitGroupingAggregate ( GroupingAggregate groupBy , FieldList value ) { FieldList list = new FieldList ( ) ; for ( NamedExpression e : groupBy . getExprs ( ) ) { list . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } for ( NamedExpression e : groupBy . getKeys ( ) ) { list . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } groupBy . getInput ( ) . accept ( this , list ) ; return null ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) clientPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
 public boolean isProgressNotification ( ) { JsonNode subNode = json . get ( " progressNotification " ) ; if ( subNode == null ) { return false ; } return subNode . booleanValue ( ) ; }
 KeyValue ( String key , String value ) { this . key = key ; this . value = value ; }
 Object readResolve ( ) { return map . keySet ( ) ; }
 @ Test public void testDirectConnectionConnectTriesLessThanDrillbitCount ( ) throws SQLException { Connection connection = null ; try { connection = testDrillDriver . connect ( " jdbc : drill : drillbit = 127.0.0.1:5000,127.0.0.1:5001 ; tries = 1" , JdbcAssert . getDefaultProperties ( ) ) ; fail ( ) ; } catch ( SQLException ex ) { assertNull ( connection ) ; assertTrue ( ex . getCause ( ) instanceof RpcException ) ; assertTrue ( ex . getCause ( ) . getCause ( ) instanceof ExecutionException ) ; } }
 public synchronized Connection getConnection ( long timeout ) { long startTime = new Date ( ) . getTime ( ) ; Connection con ; while ( ( con = getConnection ( ) ) == null ) { try { wait ( timeout ) ; } catch ( InterruptedException e ) { } if ( ( new Date ( ) . getTime ( ) - startTime ) >= timeout ) { return null ; } } return con ; }
 @ Override public void checkCanAddColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , ADD_COLUMN ) ) { denyAddColumn ( tableName . toString ( ) ) ; } super . checkCanAddColumns ( transactionId , identity , context , tableName ) ; }
 public java . lang . Integer getActive ( ) { return get ( " active " ) ; }
 public boolean isDelete ( ) { return delete ; }
 public CachedResultSetMetaData getCachedMetaData ( String sql ) { if ( this . resultSetMetadataCache != null ) { synchronized ( this . resultSetMetadataCache ) { return ( CachedResultSetMetaData ) this . resultSetMetadataCache . get ( sql ) ; } } return null ; }
 public void testReverseChar ( ) throws Exception { char [ ] buffer = { ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' } ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 2 , 3 ) ; assertEquals ( " ABEDCF " , new String ( buffer ) ) ; }
 @ Test public void generateCommandJcdk3Success ( ) throws Exception { String command = JcdkWrapperImpl . generateCommand ( jcdk3Installation , configurationFile ) ; assertThat ( command , equalTo ( String . format ( " java ▁ - cp ▁ % s ▁ " + " - Djc . home = % s ▁ % s ▁ - config ▁ % s " , jcdk3Installation . getConverterClasspath ( ) , jcdk3Installation . getBasePath ( ) , jcdk3Installation . getConverterClass ( ) , configurationFile ) ) ) ; }
 @ Test public void testTemporalColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; List < TableColumn > sortColumns = metadataDao . listSortColumns ( tableId ) ; assertEquals ( sortColumns . size ( ) , 0 ) ; assertEquals ( sortColumns , ImmutableList . of ( ) ) ; assertEquals ( metadataDao . getTemporalColumnId ( tableId ) , Long . valueOf ( 4 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
 public void insert ( final FluoClient fluo , final Collection < RyaStatement > triples , final Optional < String > visibility ) { checkNotNull ( fluo ) ; checkNotNull ( triples ) ; checkNotNull ( visibility ) ; try ( Transaction tx = fluo . newTransaction ( ) ) { for ( final RyaStatement triple : triples ) { try { tx . set ( spoFormat ( triple ) , FluoQueryColumns . TRIPLES , Bytes . of ( visibility . or ( " " ) ) ) ; } catch ( final TripleRowResolverException e ) { log . error ( " Could ▁ not ▁ convert ▁ a ▁ Triple ▁ into ▁ the ▁ SPO ▁ format : ▁ " + triple ) ; } } tx . commit ( ) ; } }
 public SimpleExtension getSimpleExtension ( ) { return simpleExtension ; }
 public void registerFilter ( Filter filter , String pattern , Dictionary initParams , int ranking , HttpContext context ) throws ServletException { if ( filter == null ) { throw new IllegalArgumentException ( " Filter ▁ must ▁ not ▁ be ▁ null " ) ; } FilterHandler handler = new FilterHandler ( getServletContext ( context ) , filter , pattern , ranking ) ; handler . setInitParams ( initParams ) ; this . handlerRegistry . addFilter ( handler ) ; this . localFilters . add ( filter ) ; }
 @ Override public ElevatedSecurityGuard getElevatedSecurityGuard ( ) { return null ; }
 public final String getValue ( ) { return super . getTextContent ( ) ; }
 private ExtServletContext getServletContext ( HttpContext context ) { if ( context == null ) { context = createDefaultHttpContext ( ) ; } return this . contextManager . getServletContext ( context ) ; }
 public double [ ] distributionsByOriginalIndex ( double [ ] before ) { double [ ] after = new double [ m_Converter . length ] ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) after [ i ] = before [ m_Converter [ i ] ] ; return after ; }
 @ Override public void checkCanInsertIntoTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , INSERT_TABLE ) ) { denyInsertTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanInsertIntoTable ( transactionId , identity , context , tableName ) ; } }
 @ Test public final void test_that_the_textual_representation_of_an_empty_Comments_is_correct ( ) { assertEquals ( " < comments > < / comments > " , Comments . MISSING . show ( ) ) ; }
 @ Override public MessageInterpolator getMessageInterpolator ( ) { return null ; }
 public void testReverseSupplementaryChar ( ) throws Exception { char [ ] buffer = " abc瀛愯䇹鍟艱𩬅 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abc𩬅艱鍟䇹愯瀛 " , new String ( buffer ) ) ; buffer = " abc瀛愯䇹鍟艱𩬅d " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 8 ) ; assertEquals ( " abcd𩬅艱鍟䇹愯瀛 " , new String ( buffer ) ) ; buffer = " abc𩬅瀛愯䇹鍟艱 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abc艱鍟䇹愯瀛𩬅 " , new String ( buffer ) ) ; buffer = " abcd𩬅瀛愯䇹鍟艱 " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 8 ) ; assertEquals ( " abc艱鍟䇹愯瀛𩬅d " , new String ( buffer ) ) ; buffer = " abc瀛愯𩬅def " . toCharArray ( ) ; ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , buffer , 3 , 7 ) ; assertEquals ( " abcfed𩬅愯瀛 " , new String ( buffer ) ) ; }
 public RegimeEspecialIntegracaoDTO numeroItem ( String numeroItem ) { this . numeroItem = numeroItem ; return this ; }
 public int getCount ( ) { return lastResults . count ; }
 public double getInputSize ( ) { return inSizes . values ( ) . stream ( ) . mapToDouble ( d -> d . doubleValue ( ) ) . sum ( ) ; }
 public void setPhone ( java . lang . String phone ) { set ( " phone " , phone ) ; }
 @ Test public void onSingleElementShouldReturnTheSameValue ( ) { String string = " hello ▁ world " ; List < String > values = Collections . singletonList ( string ) ; String result = StringUtils . join ( " , " , values ) ; assertThat ( result ) . isEqualTo ( string ) ; }
 public String getErrorMessageEncoding ( ) { return this . errorMessageEncoding ; }
 @ Bean public Transport mockGossipTransport ( ) { final Transport transport = mock ( Transport . class ) ; when ( transport . getRef ( ) ) . thenReturn ( mockGossipTransportRef ( ) ) ; return transport ; }
 public synchronized boolean putTripShare ( final TripShare tripShare ) { boolean success = false ; int result = 0 ; try { final SQLiteDatabase db = dbHelper . getWritableDatabase ( ) ; if ( tripShare . id != null ) { result += db . update ( TripShare . TABLE_NAME , tripShare . getContent ( ) , TripShare . COL_ID + " ▁ IS ▁ ? ▁ " , new String [ ] { tripShare . id } ) ; } if ( result > 0 ) { success = true ; } else { final long rowId = db . insert ( TripShare . TABLE_NAME , null , tripShare . getContent ( ) ) ; if ( rowId > - 1 ) { success = true ; } } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return success ; }
 public boolean supportsIsolationLevel ( ) { return this . hasIsolationLevels ; }
 public void setDeploymentID ( String deploymentID ) { this . deploymentID = deploymentID ; }
 public WebShopResponseType createWebShopResponseType ( ) { return new WebShopResponseType ( ) ; }
 private TripShareDAO ( Context context ) { this . context = context ; this . dbHelper = DatabaseHelper . getInstance ( context ) ; }
 public void checkClosed ( ) throws SQLException { if ( this . isClosed ) { throwConnectionClosedException ( ) ; } }
 private void configureCharsetProperties ( ) throws SQLException { if ( getEncoding ( ) != null ) { try { String testString = " abc " ; StringUtils . getBytes ( testString , getEncoding ( ) ) ; } catch ( UnsupportedEncodingException UE ) { String oldEncoding = getEncoding ( ) ; try { setEncoding ( CharsetMapping . getJavaEncodingForMysqlCharset ( oldEncoding ) ) ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( getEncoding ( ) == null ) { throw SQLError . createSQLException ( " Java ▁ does ▁ not ▁ support ▁ the ▁ MySQL ▁ character ▁ encoding ▁ ' " + oldEncoding + " ' . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } try { String testString = " abc " ; StringUtils . getBytes ( testString , getEncoding ( ) ) ; } catch ( UnsupportedEncodingException encodingEx ) { throw SQLError . createSQLException ( " Unsupported ▁ character ▁ encoding ▁ ' " + getEncoding ( ) + " ' . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } } } }
 public void cancelRequests ( Object tag , boolean mayInterruptIfRunning ) { final List < WeakReference < Future < ? > > > requestList = requestMap . get ( tag ) ; if ( requestList != null ) { for ( final WeakReference < Future < ? > > requestRef : requestList ) { final Future < ? > request = requestRef . get ( ) ; if ( request != null ) { request . cancel ( mayInterruptIfRunning ) ; } } } requestMap . remove ( tag ) ; for ( final Call call : httpClient . dispatcher ( ) . queuedCalls ( ) ) { if ( call . request ( ) . tag ( ) . equals ( group ) ) { call . cancel ( ) ; } } for ( final Call call : httpClient . dispatcher ( ) . runningCalls ( ) ) { if ( call . request ( ) . tag ( ) . equals ( group ) ) { call . cancel ( ) ; } } }
 @ Override public URLStreamHandler createURLStreamHandler ( final String protocol ) { final URLStreamHandler urlStreamHandler = super . createURLStreamHandler ( protocol ) ; if ( urlStreamHandler != null ) { return urlStreamHandler ; } return delegate . map ( factory -> factory . createURLStreamHandler ( protocol ) ) . orElse ( null ) ; }
 public String classOrderTipText ( ) { return " Specify ▁ the ▁ class ▁ order ▁ after ▁ the ▁ filtering " ; }
 public ProfilerEventHandler getProfilerEventHandlerInstance ( ) { return this . eventSink ; }
 @ Test public void blockchainTest ( ) { BalanceProvider balanceProv = new BlockChainHTTPClient ( ) ; Long result = balanceProv . getBalance ( address ) ; assertNotNull ( result ) ; assertTrue ( result > 0 ) ; ReceivedProvider receivedProv = new BlockChainHTTPClient ( ) ; Long result2 = receivedProv . getReceived ( address ) ; assertNotNull ( result2 ) ; assertTrue ( result2 > 0 ) ; System . out . println ( " received = " + result2 ) ; result = balanceProv . getBalance ( "1G1qk5jKudDjkJ21JafGXq3VghESxHJKCp " ) ; assertNotNull ( result ) ; assertTrue ( result >= 0 ) ; result2 = receivedProv . getReceived ( "1G1qk5jKudDjkJ21JafGXq3VghESxHJKCp " ) ; assertNotNull ( result2 ) ; assertTrue ( result2 >= 0 ) ; TransactionProvider transProv = new BlockChainHTTPClient ( ) ; Transaction t = transProv . getTransaction ( " dc3fdb02f11c037f90c25a83e188bfc6ede64327dd658a33cc981fc5750564c3" ) ; assertNotNull ( t ) ; System . out . println ( " t = " + t ) ; Date d ; try { d = SimpleDateFormats . m_ISO8601Local . parse ( "2012-10-09T17:22:30Z " ) ; System . out . println ( d . getTime ( ) ) ; System . out . println ( d ) ; Date d2 = new Date ( 1349803350L * 1000L ) ; System . out . println ( d2 ) ; System . out . println ( SimpleDateFormats . m_ISO8601Local . format ( d2 ) ) ; } catch ( ParseException e ) { e . printStackTrace ( ) ; } TransHexProvider transHexProv = new BlockChainHTTPClient ( ) ; String hex = transHexProv . getTransHex ( " dc3fdb02f11c037f90c25a83e188bfc6ede64327dd658a33cc981fc5750564c3" ) ; System . out . println ( " hex = " + hex ) ; assertEquals ( "01000000017d9d5ee684871124984352a619a2ba7e47dcbe938fe03d309954c5c37dead35b000000006b483045022100ef2ff0eaa8592ba063b23cb5ed4426ec8da75e084eb5d0c639e7ab557244b6c0022062faf9cad264d5d940f5f41b764da8150b20e3ea38f04154cd3aee7674dce600012103e932232ef41a3d2ef858ec3d6eb4ea13b28a096fa5e9a85761f7f578deea1e0effffffff0230d12501000000001976a9146f4c339296f9cb2d45419564f45121ccd84d505188acb8560000000000001976a914a781df4fda5411ecf867101cb18212403d07b6eb88ac00000000" , hex ) ; }
 public ValidatorFactory buildValidatorFactory ( ) { return new DummyValidatorFactory ( ) ; }
 public String globalInfo ( ) { return " Changes ▁ the ▁ order ▁ of ▁ the ▁ classes ▁ so ▁ that ▁ the ▁ class ▁ values ▁ are ▁ " + " no ▁ longer ▁ of ▁ in ▁ the ▁ order ▁ specified ▁ in ▁ the ▁ header . ▁ " + " The ▁ values ▁ will ▁ be ▁ in ▁ the ▁ order ▁ specified ▁ by ▁ the ▁ user ▁ " + " - - ▁ it ▁ could ▁ be ▁ either ▁ in ▁ ascending / descending ▁ order ▁ by ▁ the ▁ class ▁ " + " frequency ▁ or ▁ in ▁ random ▁ order . ▁ Note ▁ that ▁ this ▁ filter ▁ currently ▁ does ▁ not ▁ " + " change ▁ the ▁ header , ▁ only ▁ the ▁ class ▁ values ▁ of ▁ the ▁ instances , ▁ " + " so ▁ there ▁ is ▁ not ▁ much ▁ point ▁ in ▁ using ▁ it ▁ in ▁ conjunction ▁ with ▁ the ▁ " + " FilteredClassifier . ▁ The ▁ value ▁ can ▁ also ▁ be ▁ converted ▁ back ▁ using ▁ " + " ' originalValue ( double ▁ value ) ' ▁ procedure . " ; }
 @ Override public String getLoginCookiePath ( ) { return null ; }
 public SerializedPage serialize ( Page page ) { SliceOutput serializationBuffer = new DynamicSliceOutput ( toIntExact ( page . getSizeInBytes ( ) + Integer . BYTES ) ) ; writeRawPage ( page , serializationBuffer , blockEncodingSerde ) ; Slice slice = serializationBuffer . slice ( ) ; int uncompressedSize = serializationBuffer . size ( ) ; MarkerSet markers = MarkerSet . empty ( ) ; if ( compressor . isPresent ( ) ) { byte [ ] compressed = new byte [ compressor . get ( ) . maxCompressedLength ( uncompressedSize ) ] ; int compressedSize = compressor . get ( ) . compress ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , uncompressedSize , compressed , 0 , compressed . length ) ; if ( ( ( ( double ) compressedSize ) / uncompressedSize ) <= MINIMUM_COMPRESSION_RATIO ) { slice = Slices . wrappedBuffer ( compressed , 0 , compressedSize ) ; markers . add ( COMPRESSED ) ; } } if ( spillCipher . isPresent ( ) ) { byte [ ] encrypted = new byte [ spillCipher . get ( ) . encryptedMaxLength ( slice . length ( ) ) ] ; int encryptedSize = spillCipher . get ( ) . encrypt ( slice . byteArray ( ) , slice . byteArrayOffset ( ) , slice . length ( ) , encrypted , 0 ) ; slice = Slices . wrappedBuffer ( encrypted , 0 , encryptedSize ) ; markers . add ( ENCRYPTED ) ; } if ( ! slice . isCompact ( ) ) { slice = Slices . copyOf ( slice ) ; } return new SerializedPage ( slice , markers , page . getPositionCount ( ) , uncompressedSize ) ; }
 @ Override public boolean isUseableByPlayer ( EntityPlayer player ) { return true ; }
 public void reportNumberOfTablesAccessed ( int numTablesAccessed ) { if ( numTablesAccessed < this . minimumNumberTablesAccessed ) { this . minimumNumberTablesAccessed = numTablesAccessed ; } if ( numTablesAccessed > this . maximumNumberTablesAccessed ) { this . maximumNumberTablesAccessed = numTablesAccessed ; repartitionTablesAccessedHistogram ( ) ; } addToTablesAccessedHistogram ( numTablesAccessed , 1 ) ; }
 @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Table ▁ organization ▁ requires ▁ an ▁ ordering " ) public void testInvalidOrderingOrganization ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ImmutableMap . of ( ORGANIZED_PROPERTY , true ) ) , false ) ; }
 private void startMonitoringRegions ( List < Region > altRegions ) { try { for ( Region region : altRegions ) { beaconManager . startMonitoringBeaconsInRegion ( region ) ; GGGLogImpl . log ( " Start ▁ Beacons ▁ Monitoring ▁ for ▁ region ▁ " + region . getUniqueId ( ) ) ; } } catch ( RemoteException e ) { e . printStackTrace ( ) ; } monitoring = true ; }
 public int getServerSubMinorVersion ( ) { return this . io . getServerSubMinorVersion ( ) ; }
 public void setProfilerEventHandlerInstance ( ProfilerEventHandler h ) { this . eventSink = h ; }
 public List < Contato > listarContatoPorLetra ( char letra ) { List < Contato > contatos = contatosPorLetra . get ( Character . toUpperCase ( letra ) ) ; if ( contatos == null ) { contatos = new ArrayList < > ( ) ; } return contatos ; }
 public StaticCosts ( HashMap < Long , Double > allComputeCosts , double computeCost , double readCost , double writeCost , double minSparsity ) { _computeCosts = allComputeCosts ; _compute = computeCost ; _read = readCost ; _write = writeCost ; _minSparsity = minSparsity ; }
 @ Override public Void visitValues ( Values constant , FieldList value ) { return null ; }
 public OverwriteTableIndexOperatorForCache ( CollectionExecutor collectionExecutor , String queryName , CacheTable cacheTable ) { super ( collectionExecutor , queryName , cacheTable ) ; }
 public boolean matches ( TestingPrivilege testPrivilege ) { return userName . map ( name -> testPrivilege . userName . get ( ) . equals ( name ) ) . orElse ( true ) && entityName . equals ( testPrivilege . entityName ) && type == testPrivilege . type ; }
 @ Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ) ; setContentView ( R . layout . submit ) ; Intent messageIntent = getIntent ( ) ; String message = messageIntent . getStringExtra ( EXTRA_MESSAGE ) ; mText = ( TextView ) findViewById ( R . id . welcome_text ) ; String json = " { " + " ▁ ▁ \" title \" : \" Challenge ▁ satisfaction ▁ survey \" , " + " \" settings \" : ▁ { " + " ▁ ▁ ▁ ▁ \" language \" : ▁ \" en \" " + " ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" thankyou _ screens \" : ▁ [ " + " ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" Thank ▁ you ▁ for ▁ participating ! \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ \" properties \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" show _ button \" : ▁ true , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" button _ text \" : ▁ \" start \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" button _ mode \" : ▁ \" redirect \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" redirect _ url \" : ▁ \" http : // www . typeform . com \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" share _ icons \" : ▁ false " + " ▁ ▁ ▁ ▁ } " + " } " + " ▁ ▁ ] , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" fields \" : ▁ [ " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" What ' s ▁ your ▁ name ? \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" type \" : ▁ \" short _ text \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" validations \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" required \" : ▁ false , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" max _ length \" : ▁ 20" + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" title \" : ▁ \" " + message + " \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" type \" : ▁ \" opinion _ scale \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" properties \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" description \" : ▁ \" \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" steps \" : ▁ 10 , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" start _ at _ one \" : ▁ true , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" labels \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" left \" : ▁ \" ▁ left ▁ label \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" center \" : ▁ \" center ▁ label \" , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" right \" : ▁ \" right ▁ label \" " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } , " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" validations \" : ▁ { " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ \" required \" : ▁ false " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ] " + " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ } " ; try { JSONObject jsonObject = new JSONObject ( json ) ; bob = new BobTheBuilder ( jsonObject ) ; bob . execute ( ) ; } catch ( JSONException e ) { } mTts = new TextToSpeech ( this , new TextToSpeech . OnInitListener ( ) { @ Override public void onInit ( int i ) { if ( i == TextToSpeech . SUCCESS ) { mTts . setOnUtteranceCompletedListener ( new TextToSpeech . OnUtteranceCompletedListener ( ) { @ Override public void onUtteranceCompleted ( String utteranceId ) { runOnUiThread ( new Runnable ( ) { @ Override public void run ( ) { emailBtn = ( Button ) findViewById ( R . id . email ) ; emailBtn . setOnClickListener ( new View . OnClickListener ( ) { public void onClick ( View v ) { String responseBody = bob . getResponseBody ( ) ; try { String jsonObj = new JSONObject ( responseBody ) . getString ( " id " ) ; Intent intent = new Intent ( Intent . ACTION_SEND ) ; intent . setType ( " message / rfc822" ) ; intent . putExtra ( Intent . EXTRA_EMAIL , new String [ ] { " all @ typeform . com " } ) ; intent . putExtra ( Intent . EXTRA_SUBJECT , " Rate ▁ the ▁ Challenge ! " ) ; intent . setPackage ( " com . google . android . gm " ) ; intent . putExtra ( Intent . EXTRA_TEXT , Html . fromHtml ( " Please ▁ fill ▁ the ▁ following ▁ form : ▁ < a ▁ href = \" https : // pauboix . typeform . com / to " + jsonObj + " \" > Link < / a > " ) ) ; if ( intent . resolveActivity ( getPackageManager ( ) ) != null ) startActivity ( intent ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } } ) ; } } ) ; } } ) ; mTts . setLanguage ( Locale . getDefault ( ) ) ; HashMap < String , String > params = new HashMap < String , String > ( ) ; params . put ( TextToSpeech . Engine . KEY_PARAM_UTTERANCE_ID , " stringId " ) ; mTts . speak ( " Your ▁ Typeform ▁ is ▁ Done ! \n ▁ Do ▁ you ▁ want ▁ to ▁ send ▁ it ▁ out ▁ now ? " , TextToSpeech . QUEUE_FLUSH , params ) ; } else { mTts = null ; Log . e ( " MainActivity " , " Failed ▁ to ▁ initialize ▁ the ▁ TextToSpeech ▁ engine " ) ; } } } ) ; }
 public void setFolderName ( String folderName ) { this . folderName = folderName ; }
 public void writeExternal ( ObjectOutput out ) throws IOException { GraphIOUtil . writeDelimitedTo ( out , this , this ) ; }
 @ Override public String getAuthType ( ) { return null ; }
 @ Before public void setUp ( ) throws Exception { }
 @ Test public void verifyPagesIndexSortBenchmark ( ) { PagesIndexSortBenchmarkData state = new PagesIndexSortBenchmarkData ( ) ; state . setup ( ) ; List < Page > pages = runPagesIndexSortBenchmark ( state ) ; int positionCount = pages . stream ( ) . mapToInt ( Page :: getPositionCount ) . sum ( ) ; assertEquals ( positionCount , state . getTotalPositions ( ) ) ; }
 public void readFromNBT ( NBTTagCompound tagCompound ) { NBTTagList tagList = tagCompound . getTagList ( " Inventory " , 10 ) ; for ( int i = 0 ; i < tagList . tagCount ( ) ; i ++ ) { NBTTagCompound tag = tagList . getCompoundTagAt ( i ) ; byte slot = tag . getByte ( " Slot " ) ; if ( slot >= 0 && slot < this . inv . length ) { this . inv [ slot ] = ItemStack . loadItemStackFromNBT ( tag ) ; } } }
 public TraversableResolver getDefaultTraversableResolver ( ) { return null ; }
 public boolean input ( Instance instance ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( " No ▁ input ▁ instance ▁ format ▁ defined " ) ; } if ( m_NewBatch ) { resetQueue ( ) ; m_NewBatch = false ; } if ( m_Converter != null ) { Instance datum = ( Instance ) instance . copy ( ) ; if ( ! datum . isMissing ( m_ClassAttribute ) ) { datum . setClassValue ( ( double ) m_Converter [ ( int ) datum . classValue ( ) ] ) ; } push ( datum ) ; return true ; } if ( ! instance . isMissing ( m_ClassAttribute ) ) { m_ClassCounts [ ( int ) instance . classValue ( ) ] += instance . weight ( ) ; } bufferInput ( instance ) ; return false ; }
 public void setEmail ( java . lang . String email ) { set ( " email " , email ) ; }
 private void connectWithRetries ( boolean isForReconnect , Properties mergedProps ) throws SQLException { double timeout = getInitialTimeout ( ) ; boolean connectionGood = false ; Exception connectionException = null ; for ( int attemptCount = 0 ; ( attemptCount < getMaxReconnects ( ) ) && ! connectionGood ; attemptCount ++ ) { try { if ( this . io != null ) { this . io . forceClose ( ) ; } coreConnect ( mergedProps ) ; pingInternal ( false , 0 ) ; boolean oldAutoCommit ; int oldIsolationLevel ; boolean oldReadOnly ; String oldCatalog ; synchronized ( getConnectionMutex ( ) ) { this . connectionId = this . io . getThreadId ( ) ; this . isClosed = false ; oldAutoCommit = getAutoCommit ( ) ; oldIsolationLevel = this . isolationLevel ; oldReadOnly = isReadOnly ( false ) ; oldCatalog = getCatalog ( ) ; this . io . setStatementInterceptors ( this . statementInterceptors ) ; } initializePropsFromServer ( ) ; if ( isForReconnect ) { setAutoCommit ( oldAutoCommit ) ; if ( this . hasIsolationLevels ) { setTransactionIsolation ( oldIsolationLevel ) ; } setCatalog ( oldCatalog ) ; setReadOnly ( oldReadOnly ) ; } connectionGood = true ; break ; } catch ( Exception EEE ) { connectionException = EEE ; connectionGood = false ; } if ( connectionGood ) { break ; } if ( attemptCount > 0 ) { try { Thread . sleep ( ( long ) timeout * 1000 ) ; } catch ( InterruptedException IE ) { } } } if ( ! connectionGood ) { SQLException chainedEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnableToConnectWithRetries " , new Object [ ] { Integer . valueOf ( getMaxReconnects ( ) ) } ) , SQLError . SQL_STATE_UNABLE_TO_CONNECT_TO_DATASOURCE , getExceptionInterceptor ( ) ) ; chainedEx . initCause ( connectionException ) ; throw chainedEx ; } if ( getParanoid ( ) && ! getHighAvailability ( ) ) { this . password = null ; this . user = null ; } if ( isForReconnect ) { Iterator < Statement > statementIter = this . openStatements . iterator ( ) ; Stack < Statement > serverPreparedStatements = null ; while ( statementIter . hasNext ( ) ) { Statement statementObj = statementIter . next ( ) ; if ( statementObj instanceof ServerPreparedStatement ) { if ( serverPreparedStatements == null ) { serverPreparedStatements = new Stack < Statement > ( ) ; } serverPreparedStatements . add ( statementObj ) ; } } if ( serverPreparedStatements != null ) { while ( ! serverPreparedStatements . isEmpty ( ) ) { ( ( ServerPreparedStatement ) serverPreparedStatements . pop ( ) ) . rePrepare ( ) ; } } } }
 public ObjectFactory ( ) { }
 @ Override boolean isPartialView ( ) { return true ; }
 public XmlRpcTransportFactory getClientTransportFactory ( ) { if ( keyStoreComponent == null || keyStoreName == null || keyAlias == null ) { return this . getTransportFactory ( ) ; } ComponentConfig . KeystoreInfo ks = ComponentConfig . getKeystoreInfo ( keyStoreComponent , keyStoreName ) ; KeyStore keyStore = null ; try { keyStore = KeyStoreUtil . getStore ( ks . createResourceHandler ( ) . getURL ( ) , ks . getPassword ( ) , ks . getType ( ) ) ; } catch ( Exception e ) { Debug . logError ( e , " Unable ▁ to ▁ load ▁ keystore : ▁ " + keyStoreName , module ) ; } return new AliasSupportedTransportFactory ( this , keyStore , ks . getPassword ( ) , keyAlias ) ; }
 private void createPageProducers ( int numMergeSources ) { AtomicInteger counter = new AtomicInteger ( 0 ) ; splitPages = pages . stream ( ) . collect ( Collectors . groupingBy ( it -> counter . getAndIncrement ( ) % numMergeSources ) ) . values ( ) . stream ( ) . collect ( toImmutableList ( ) ) ; }
 private TestingPrivilege ( Optional < String > userName , String entityName , TestingPrivilegeType type ) { this . userName = requireNonNull ( userName , " userName ▁ is ▁ null " ) ; this . entityName = requireNonNull ( entityName , " entityName ▁ is ▁ null " ) ; this . type = requireNonNull ( type , " type ▁ is ▁ null " ) ; }
 public void freeConnection ( String name , Connection con ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { pool . freeConnection ( con ) ; } }
 public ResultSetInternalMethods execSQL ( StatementImpl callingStatement , String sql , int maxRows , Buffer packet , int resultSetType , int resultSetConcurrency , boolean streamResults , String catalog , Field [ ] cachedMetadata , boolean isBatch ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { long queryStartTime = 0 ; int endOfQueryPacketPosition = 0 ; if ( packet != null ) { endOfQueryPacketPosition = packet . getPosition ( ) ; } if ( getGatherPerformanceMetrics ( ) ) { queryStartTime = System . currentTimeMillis ( ) ; } this . lastQueryFinishedTime = 0 ; if ( ( getHighAvailability ( ) ) && ( this . autoCommit || getAutoReconnectForPools ( ) ) && this . needsPing && ! isBatch ) { try { pingInternal ( false , 0 ) ; this . needsPing = false ; } catch ( Exception Ex ) { createNewIO ( true ) ; } } try { if ( packet == null ) { String encoding = null ; if ( getUseUnicode ( ) ) { encoding = getEncoding ( ) ; } return this . io . sqlQueryDirect ( callingStatement , sql , encoding , null , maxRows , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata ) ; } return this . io . sqlQueryDirect ( callingStatement , null , null , packet , maxRows , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata ) ; } catch ( java . sql . SQLException sqlE ) { if ( getDumpQueriesOnException ( ) ) { String extractedSql = extractSqlFromPacket ( sql , packet , endOfQueryPacketPosition ) ; StringBuilder messageBuf = new StringBuilder ( extractedSql . length ( ) + 32 ) ; messageBuf . append ( " \n \n Query ▁ being ▁ executed ▁ when ▁ exception ▁ was ▁ thrown : \n " ) ; messageBuf . append ( extractedSql ) ; messageBuf . append ( " \n \n " ) ; sqlE = appendMessageToException ( sqlE , messageBuf . toString ( ) , getExceptionInterceptor ( ) ) ; } if ( ( getHighAvailability ( ) ) ) { this . needsPing = true ; } else { String sqlState = sqlE . getSQLState ( ) ; if ( ( sqlState != null ) && sqlState . equals ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE ) ) { cleanup ( sqlE ) ; } } throw sqlE ; } catch ( Exception ex ) { if ( getHighAvailability ( ) ) { this . needsPing = true ; } else if ( ex instanceof IOException ) { cleanup ( ex ) ; } SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . UnexpectedException " ) , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } finally { if ( getMaintainTimeStats ( ) ) { this . lastQueryFinishedTime = System . currentTimeMillis ( ) ; } if ( getGatherPerformanceMetrics ( ) ) { long queryTime = System . currentTimeMillis ( ) - queryStartTime ; registerQueryExecutionTime ( queryTime ) ; } } } }
 if ( ( fields . get ( " z " , false ) != true ) || ( fields . get ( " b " , ( byte ) 0 ) != 5 ) || ( fields . get ( " c " , '0' ) != '5' ) || ( fields . get ( " s " , ( short ) 0 ) != 5 ) || ( fields . get ( " i " , 0 ) != 5 ) || ( fields . get ( " j " , 0l ) != 5 ) || ( fields . get ( " f " , 0.0f ) != 5.0f ) || ( fields . get ( " d " , 0.0 ) != 5.0 ) || ( ! fields . get ( " str " , null ) . equals ( "5" ) ) ) { throw new Error ( ) ; }
 public String getFrom ( ) { return from ; }
 public boolean isDebugMode ( ) { return debugMode ; }
 private void cleanup ( Throwable whyCleanedUp ) { try { if ( this . io != null ) { if ( isClosed ( ) ) { this . io . forceClose ( ) ; } else { realClose ( false , false , false , whyCleanedUp ) ; } } } catch ( SQLException sqlEx ) { } this . isClosed = true ; }
 @ Override protected String getSubscriptionXmlElementName ( ) { return XmlElementNames . PushSubscriptionRequest ; }
 public boolean isReadOnly ( boolean useSessionStatus ) throws SQLException { if ( useSessionStatus && ! this . isClosed && versionMeetsMinimum ( 5 , 6 , 5 ) && ! getUseLocalSessionState ( ) && getReadOnlyPropagatesToServer ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { try { stmt = getMetadataSafeStatement ( ) ; rs = stmt . executeQuery ( " select ▁ @ @ session . tx _ read _ only " ) ; if ( rs . next ( ) ) { return rs . getInt ( 1 ) != 0 ; } } catch ( SQLException ex1 ) { if ( ex1 . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw SQLError . createSQLException ( " Could ▁ not ▁ retrieve ▁ transation ▁ read - only ▁ status ▁ server " , SQLError . SQL_STATE_GENERAL_ERROR , ex1 , getExceptionInterceptor ( ) ) ; } } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . readOnly ; }
 if ( servlet == null ) { throw new IllegalArgumentException ( " Servlet ▁ must ▁ not ▁ be ▁ null " ) ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql , int resultSetType , int resultSetConcurrency , boolean processEscapeCodesIfNeeded ) throws SQLException { checkClosed ( ) ; String nativeSql = processEscapeCodesIfNeeded && getProcessEscapeCodesForPrepStmts ( ) ? nativeSQL ( sql ) : sql ; PreparedStatement pStmt = null ; if ( getCachePreparedStatements ( ) ) { PreparedStatement . ParseInfo pStmtInfo = this . cachedPreparedStatementParams . get ( nativeSql ) ; if ( pStmtInfo == null ) { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database ) ; this . cachedPreparedStatementParams . put ( nativeSql , pStmt . getParseInfo ( ) ) ; } else { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database , pStmtInfo ) ; } } else { pStmt = com . mysql . jdbc . PreparedStatement . getInstance ( getMultiHostSafeProxy ( ) , nativeSql , this . database ) ; } pStmt . setResultSetType ( resultSetType ) ; pStmt . setResultSetConcurrency ( resultSetConcurrency ) ; return pStmt ; }
 public MessageType ( String name , List < Type > fields ) { super ( Repetition . REPEATED , name , fields ) ; }
 @ Test public void testTransactionAbort ( ) { long transactionId = 1 ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , getOrdersTable ( ) , Optional . empty ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; shardManager . rollbackTransaction ( transactionId ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertFalse ( transactionSuccessful ( transactionId ) ) ; try { metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; fail ( " expected ▁ exception " ) ; } catch ( PrestoException e ) { assertEquals ( e . getErrorCode ( ) , TRANSACTION_CONFLICT . toErrorCode ( ) ) ; } }
 public ConnectionImpl ( String hostToConnectTo , int portToConnectTo , Properties info , String databaseToConnectTo , String url ) throws SQLException { this . connectionCreationTimeMillis = System . currentTimeMillis ( ) ; if ( databaseToConnectTo == null ) { databaseToConnectTo = " " ; } this . origHostToConnectTo = hostToConnectTo ; this . origPortToConnectTo = portToConnectTo ; this . origDatabaseToConnectTo = databaseToConnectTo ; try { Blob . class . getMethod ( " truncate " , new Class [ ] { Long . TYPE } ) ; this . isRunningOnJDK13 = false ; } catch ( NoSuchMethodException nsme ) { this . isRunningOnJDK13 = true ; } this . sessionCalendar = new GregorianCalendar ( ) ; this . utcCalendar = new GregorianCalendar ( ) ; this . utcCalendar . setTimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; this . log = LogFactory . getLogger ( getLogger ( ) , LOGGER_INSTANCE_NAME , getExceptionInterceptor ( ) ) ; if ( NonRegisteringDriver . isHostPropertiesList ( hostToConnectTo ) ) { Properties hostSpecificProps = NonRegisteringDriver . expandHostKeyValues ( hostToConnectTo ) ; Enumeration < ? > propertyNames = hostSpecificProps . propertyNames ( ) ; while ( propertyNames . hasMoreElements ( ) ) { String propertyName = propertyNames . nextElement ( ) . toString ( ) ; String propertyValue = hostSpecificProps . getProperty ( propertyName ) ; info . setProperty ( propertyName , propertyValue ) ; } } else { if ( hostToConnectTo == null ) { this . host = " localhost " ; this . hostPortPair = this . host + " : " + portToConnectTo ; } else { this . host = hostToConnectTo ; if ( hostToConnectTo . indexOf ( " : " ) == - 1 ) { this . hostPortPair = this . host + " : " + portToConnectTo ; } else { this . hostPortPair = this . host ; } } } this . port = portToConnectTo ; this . database = databaseToConnectTo ; this . myURL = url ; this . user = info . getProperty ( NonRegisteringDriver . USER_PROPERTY_KEY ) ; this . password = info . getProperty ( NonRegisteringDriver . PASSWORD_PROPERTY_KEY ) ; if ( ( this . user == null ) || this . user . equals ( " " ) ) { this . user = " " ; } if ( this . password == null ) { this . password = " " ; } this . props = info ; initializeDriverProperties ( info ) ; this . defaultTimeZone = TimeUtil . getDefaultTimeZone ( getCacheDefaultTimezone ( ) ) ; this . isClientTzUTC = ! this . defaultTimeZone . useDaylightTime ( ) && this . defaultTimeZone . getRawOffset ( ) == 0 ; if ( getUseUsageAdvisor ( ) ) { this . pointOfOrigin = LogUtils . findCallingClassAndMethod ( new Throwable ( ) ) ; } else { this . pointOfOrigin = " " ; } try { this . dbmd = getMetaData ( false , false ) ; initializeSafeStatementInterceptors ( ) ; createNewIO ( false ) ; unSafeStatementInterceptors ( ) ; } catch ( SQLException ex ) { cleanup ( ex ) ; throw ex ; } catch ( Exception ex ) { cleanup ( ex ) ; StringBuilder mesg = new StringBuilder ( 128 ) ; if ( ! getParanoid ( ) ) { mesg . append ( " Cannot ▁ connect ▁ to ▁ MySQL ▁ server ▁ on ▁ " ) ; mesg . append ( this . host ) ; mesg . append ( " : " ) ; mesg . append ( this . port ) ; mesg . append ( " . \n \n " ) ; mesg . append ( " Make ▁ sure ▁ that ▁ there ▁ is ▁ a ▁ MySQL ▁ server ▁ " ) ; mesg . append ( " running ▁ on ▁ the ▁ machine / port ▁ you ▁ are ▁ trying ▁ " ) ; mesg . append ( " to ▁ connect ▁ to ▁ and ▁ that ▁ the ▁ machine ▁ this ▁ software ▁ is ▁ running ▁ on ▁ " ) ; mesg . append ( " is ▁ able ▁ to ▁ connect ▁ to ▁ this ▁ host / port ▁ ( i . e . ▁ not ▁ firewalled ) . ▁ " ) ; mesg . append ( " Also ▁ make ▁ sure ▁ that ▁ the ▁ server ▁ has ▁ not ▁ been ▁ started ▁ with ▁ the ▁ - - skip - networking ▁ " ) ; mesg . append ( " flag . \n \n " ) ; } else { mesg . append ( " Unable ▁ to ▁ connect ▁ to ▁ database . " ) ; } SQLException sqlEx = SQLError . createSQLException ( mesg . toString ( ) , SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } NonRegisteringDriver . trackConnection ( this ) ; }
 @ JsonProperty ( " seq " ) @ NotNull public Integer getSeq ( ) { return seq ; }
 @ Override public FieldList clone ( ) { FieldList newList = new FieldList ( ) ; for ( SchemaPath p : projected ) { newList . addProjected ( p ) ; } for ( SchemaPath p : referenced ) { newList . addReferenced ( p ) ; } return newList ; }
 public String getDeploymentID ( ) { return deploymentID ; }
 @ Override public boolean isCancelable ( ) { return true ; }
 public void setApplicationDeployment ( ApplicationDeployment applicationDeployment ) { this . applicationDeployment = applicationDeployment ; }
 public void tearDown ( ) throws Exception { expectedExceptionMessage = null ; expectedExceptionClass = null ; expectedExceptionCause = null ; }
 public List < Extension > getInterceptors ( ) { return this . interceptors ; }
 public Capabilities getCapabilities ( ) { Capabilities result = super . getCapabilities ( ) ; result . disableAll ( ) ; result . enableAllAttributes ( ) ; result . enable ( Capability . MISSING_VALUES ) ; result . enable ( Capability . NOMINAL_CLASS ) ; return result ; }
 @ Override public String getCookieEncoding ( ) { return null ; }
 public void setNumberOfRooms ( Number numberOfRooms ) { this . numberOfRooms = numberOfRooms ; }
 void init ( @ NonNull FilterableAdapter < T > adapter ) throws AssertionError { this . adapter = adapter ; dataSetObserver = new DataSetObserver ( ) { @ Override public void onChanged ( ) { super . onChanged ( ) ; if ( ! isFiltered ( ) ) return ; performFiltering ( lastConstraint ) ; } @ Override public void onInvalidated ( ) { super . onInvalidated ( ) ; if ( ! isFiltered ( ) ) return ; lastResults = new FilterResults ( ) ; lastResults . count = - 1 ; lastResults . values = Collections . emptyList ( ) ; } } ; adapterDataObserver = new RecyclerView . AdapterDataObserver ( ) { @ Override public void onChanged ( ) { super . onChanged ( ) ; if ( ! isFiltered ( ) ) return ; performFiltering ( lastConstraint ) ; } } ; }
 @ Override public void onRegionsReady ( List < OrchextraRegion > regions ) { List < Region > altRegions = regionMapper . modelListToExternalClassList ( regions ) ; this . regionsToBeMonitored . clear ( ) ; this . regionsToBeMonitored . addAll ( altRegions ) ; startMonitoringRegions ( altRegions ) ; }
 @ Test public final void test_that_a_Comments_hash_code_is_based_on_its_fields ( ) { assertEquals ( comments . hashCode ( ) , comments . hashCode ( ) ) ; assertEquals ( comments . hashCode ( ) , new Comments ( value ) . hashCode ( ) ) ; assertNotEquals ( comments . hashCode ( ) , new Comments ( " Hello \n world " ) . hashCode ( ) ) ; }
 @ Override public ResponseStats . Post post ( final String url , final OperationParams . Post params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; mQueue . add ( new PostFileRequest ( url , future , future , mContext . getResources ( ) . openRawResource ( params . rawResourceId ) ) ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . Post ( mController , response ) ; }
 @ Override public ParameterNameProvider getParameterNameProvider ( ) { return null ; }
 private void monitor ( ) { while ( true ) { if ( ( System . currentTimeMillis ( ) - logTimer ) > logInterval ) { Enumeration checkconn = freeConnections . elements ( ) ; while ( checkconn . hasMoreElements ( ) ) { Connection con = ( Connection ) checkconn . nextElement ( ) ; try { if ( con == null || con . isClosed ( ) ) { freeConnections . removeElement ( con ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } else if ( freeConnections . size ( ) > minConn ) { con . close ( ) ; freeConnections . removeElement ( con ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } } catch ( SQLException e ) { System . out . println ( " momitor ▁ 出错 ！ " ) ; } } while ( freeConnections . size ( ) < minConn ) { Connection con = createNewConnection ( ) ; freeConnections . addElement ( con ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; } logTimer = System . currentTimeMillis ( ) ; } try { Thread . sleep ( SLEEP_INTERVAL ) ; } catch ( InterruptedException e ) { System . out . println ( " 监控线程被打断 ! ! " ) ; } } }
 public void setIgnoreUnsupportedCharset ( boolean ignoreUnsupportedCharset ) { this . ignoreUnsupportedCharset = ignoreUnsupportedCharset ; }
 public void deny ( TestingPrivilege ... deniedPrivileges ) { Collections . addAll ( this . denyPrivileges , deniedPrivileges ) ; }
 @ Override public void accept ( TypeVisitor visitor ) { visitor . visit ( this ) ; }
 public void setConnectionTimeout ( long connectionTimeout ) { this . connectionTimeout = connectionTimeout ; }
 @ Test public void testMarshalDomainObject ( ) throws Exception { MockEndpoint mock = getMockEndpoint ( " mock : result " ) ; mock . expectedMessageCount ( 1 ) ; PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; template . sendBody ( " direct : in " , order ) ; mock . assertIsSatisfied ( ) ; }
 public void clearWarnings ( ) throws SQLException { }
 public boolean versionMeetsMinimum ( int major , int minor , int subminor ) throws SQLException { checkClosed ( ) ; return this . io . versionMeetsMinimum ( major , minor , subminor ) ; }
 @ Override public RememberMeService getRememberMeService ( ) { return null ; }
 private void copyPartOfFile ( File src , File dest ) throws IOException { InputStream in = null ; OutputStream out = null ; byte [ ] b = new byte [ 256 ] ; int bytesWritten = 0 ; int count ; int maxBytes = 700 ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( dest ) ; while ( ( count = in . read ( b ) ) > 0 && bytesWritten < maxBytes ) { out . write ( b ) ; bytesWritten += count ; } } finally { if ( in != null ) in . close ( ) ; if ( out != null ) out . close ( ) ; } }
 @ Bean public MessageFactory gossipMessageFactory ( ) { return new DefaultMessageFactory ( ImmutableList . < Message > of ( GossipServiceProto . ComponentOnline . getDefaultInstance ( ) , GossipServiceProto . ComponentStatus . getDefaultInstance ( ) ) ) ; }
 public int getTransactionIsolation ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . hasIsolationLevels && ! getUseLocalSessionState ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet rs = null ; try { stmt = getMetadataSafeStatement ( ) ; String query = null ; int offset = 0 ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { query = " SELECT ▁ @ @ session . tx _ isolation " ; offset = 1 ; } else { query = " SHOW ▁ VARIABLES ▁ LIKE ▁ ' transaction _ isolation ' " ; offset = 2 ; } rs = stmt . executeQuery ( query ) ; if ( rs . next ( ) ) { String s = rs . getString ( offset ) ; if ( s != null ) { Integer intTI = mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { return intTI . intValue ( ) ; } } throw SQLError . createSQLException ( " Could ▁ not ▁ map ▁ transaction ▁ isolation ▁ ' " + s + " ▁ to ▁ a ▁ valid ▁ JDBC ▁ level . " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } throw SQLError . createSQLException ( " Could ▁ not ▁ retrieve ▁ transaction ▁ isolation ▁ level ▁ from ▁ server " , SQLError . SQL_STATE_GENERAL_ERROR , getExceptionInterceptor ( ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( Exception ex ) { } rs = null ; } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( Exception ex ) { } stmt = null ; } } } return this . isolationLevel ; } }
 public ConnPool ( String name , String URL , String user , String password , int maxConn , int minConn , long logInterval ) { this . name = name ; this . URL = URL ; this . user = user ; this . password = password ; this . maxConn = maxConn ; this . minConn = minConn ; this . logInterval = logInterval ; for ( int i = 0 ; i < minConn ; i ++ ) { Connection initConn = createNewConnection ( ) ; freeConnections . addElement ( initConn ) ; } logTimer = System . currentTimeMillis ( ) ; poolMonitor = new Thread ( new Runnable ( ) { public void run ( ) { monitor ( ) ; } } ) ; poolMonitor . start ( ) ; }
 public DataSetObserver getDataSetObserver ( ) { return dataSetObserver ; }
 private void flushPage ( ) { if ( ! pageBuilder . isEmpty ( ) ) { pages . add ( pageBuilder . build ( ) ) ; pageBuilder . reset ( ) ; } }
 @ Override public void unbindService ( ServiceConnection serviceConnection ) { context . unbindService ( serviceConnection ) ; }
 @ Override public List < SecurityService > getServices ( ) { return null ; }
 @ Override public String getLoginURL ( ) { return null ; }
 private boolean canHandleAsServerPreparedStatementNoCache ( String sql ) throws SQLException { if ( StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " CALL " ) ) { return false ; } boolean canHandleAsStatement = true ; if ( ! versionMeetsMinimum ( 5 , 0 , 7 ) && ( StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " SELECT " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " DELETE " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " INSERT " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " UPDATE " ) || StringUtils . startsWithIgnoreCaseAndNonAlphaNumeric ( sql , " REPLACE " ) ) ) { int currentPos = 0 ; int statementLength = sql . length ( ) ; int lastPosToLook = statementLength - 7 ; boolean allowBackslashEscapes = ! this . noBackslashEscapes ; String quoteChar = this . useAnsiQuotes ? " \" " : " ' " ; boolean foundLimitWithPlaceholder = false ; while ( currentPos < lastPosToLook ) { int limitStart = StringUtils . indexOfIgnoreCase ( currentPos , sql , " LIMIT ▁ " , quoteChar , quoteChar , allowBackslashEscapes ? StringUtils . SEARCH_MODE__ALL : StringUtils . SEARCH_MODE__MRK_COM_WS ) ; if ( limitStart == - 1 ) { break ; } currentPos = limitStart + 7 ; while ( currentPos < statementLength ) { char c = sql . charAt ( currentPos ) ; if ( ! Character . isDigit ( c ) && ! Character . isWhitespace ( c ) && c != ' , ' && c != ' ? ' ) { break ; } if ( c == ' ? ' ) { foundLimitWithPlaceholder = true ; break ; } currentPos ++ ; } } canHandleAsStatement = ! foundLimitWithPlaceholder ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " XA ▁ " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " CREATE ▁ TABLE " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " DO " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " SET " ) ) { canHandleAsStatement = false ; } else if ( StringUtils . startsWithIgnoreCaseAndWs ( sql , " SHOW ▁ WARNINGS " ) && versionMeetsMinimum ( 5 , 7 , 2 ) ) { canHandleAsStatement = false ; } return canHandleAsStatement ; }
 private void repartitionTablesAccessedHistogram ( ) { checkAndCreateTablesAccessedHistogram ( ) ; repartitionHistogram ( this . numTablesMetricsHistCounts , this . numTablesMetricsHistBreakpoints , this . minimumNumberTablesAccessed == Long . MAX_VALUE ? 0 : this . minimumNumberTablesAccessed , this . maximumNumberTablesAccessed ) ; }
 @ Test public void testCreateBucketedTableAsSelect ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 32 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " , " custkey " ) ) ) ; ConnectorNewTableLayout layout = metadata . getNewTableLayout ( SESSION , ordersTable ) . get ( ) ; assertEquals ( layout . getPartitionColumns ( ) , ImmutableList . of ( " orderkey " , " custkey " ) ) ; assertInstanceOf ( layout . getPartitioning ( ) , RaptorPartitioningHandle . class ) ; RaptorPartitioningHandle partitioning = ( RaptorPartitioningHandle ) layout . getPartitioning ( ) ; assertEquals ( partitioning . getDistributionId ( ) , 1 ) ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , ordersTable , Optional . of ( layout ) ) ; metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; long tableId = raptorTableHandle . getTableId ( ) ; MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) , new TableColumn ( DEFAULT_TEST_ORDERS , " custkey " , BIGINT , 2 , 1 , OptionalInt . of ( 1 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 32 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; metadata . dropTable ( SESSION , tableHandle ) ; }
 @ Override public String getOriginalURLKey ( ) { return null ; }
 public void addInputAggregate ( long hopID ) { _inputAggs . add ( hopID ) ; }
 public void setFrom ( String from ) { this . from = from ; }
 public void reset ( ) { denyPrivileges . clear ( ) ; }
 public DateTimePicker ( ) { }
 private void stopVoiceRecorder ( ) { if ( mVoiceRecorder != null ) { mVoiceRecorder . stop ( ) ; mVoiceRecorder = null ; } }
 public String getFieldName ( int number ) { switch ( number ) { case 1 : return " id " ; case 2 : return " registrationTimeUTC " ; case 3 : return " endpoint " ; default : return null ; } }
 public void setId ( java . lang . Long id ) { set ( " id " , id ) ; }
 @ Test public void generateCommandJcdk2Success ( ) throws Exception { String command = JcdkWrapperImpl . generateCommand ( jcdk2Installation , configurationFile ) ; assertThat ( command , equalTo ( String . format ( " java ▁ - cp ▁ % s ▁ " + " - Djc . home = % s ▁ % s ▁ - config ▁ % s " , jcdk2Installation . getConverterClasspath ( ) , jcdk2Installation . getBasePath ( ) , jcdk2Installation . getConverterClass ( ) , configurationFile ) ) ) ; }
 public boolean isRunningOnJDK13 ( ) { return this . isRunningOnJDK13 ; }
 public Configuration ignoreXmlConfiguration ( ) { return null ; }
 public java . sql . Statement getMetadataSafeStatement ( ) throws SQLException { java . sql . Statement stmt = createStatement ( ) ; if ( stmt . getMaxRows ( ) != 0 ) { stmt . setMaxRows ( 0 ) ; } stmt . setEscapeProcessing ( false ) ; if ( stmt . getFetchSize ( ) != 0 ) { stmt . setFetchSize ( 0 ) ; } return stmt ; }
 @ Override public UnmodifiableIterator < K > iterator ( ) { return map . keyIterator ( ) ; }
 public boolean isNoBackslashEscapesSet ( ) { return this . noBackslashEscapes ; }
 public StringBuilder generateConnectionCommentBlock ( StringBuilder buf ) { buf . append ( " /* ▁ conn ▁ id ▁ " ) ; buf . append ( getId ( ) ) ; buf . append ( " ▁ clock : ▁ " ) ; buf . append ( System . currentTimeMillis ( ) ) ; buf . append ( " ▁ */ ▁ " ) ; return buf ; }
 public void setChildrenMap ( Map childrenMap ) { this . childrenMap = childrenMap ; }
 private void buildCollationMapping ( ) throws SQLException { Map < Integer , String > indexToCharset = null ; Map < Number , String > sortedCollationMap = null ; Map < Integer , String > customCharset = null ; Map < String , Integer > customMblen = null ; if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { indexToCharset = dynamicIndexToCharsetMapByUrl . get ( getURL ( ) ) ; sortedCollationMap = dynamicIndexToCollationMapByUrl . get ( getURL ( ) ) ; customCharset = customIndexToCharsetMapByUrl . get ( getURL ( ) ) ; customMblen = customCharsetToMblenMapByUrl . get ( getURL ( ) ) ; } } if ( indexToCharset == null ) { indexToCharset = new HashMap < Integer , String > ( ) ; if ( versionMeetsMinimum ( 4 , 1 , 0 ) && getDetectCustomCollations ( ) ) { java . sql . Statement stmt = null ; java . sql . ResultSet results = null ; try { sortedCollationMap = new TreeMap < Number , String > ( ) ; customCharset = new HashMap < Integer , String > ( ) ; customMblen = new HashMap < String , Integer > ( ) ; stmt = getMetadataSafeStatement ( ) ; try { results = stmt . executeQuery ( " SHOW ▁ COLLATION " ) ; if ( versionMeetsMinimum ( 5 , 0 , 0 ) ) { Util . resultSetToMap ( sortedCollationMap , results , 3 , 2 ) ; } else { while ( results . next ( ) ) { sortedCollationMap . put ( results . getLong ( 3 ) , results . getString ( 2 ) ) ; } } } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } for ( Iterator < Map . Entry < Number , String > > indexIter = sortedCollationMap . entrySet ( ) . iterator ( ) ; indexIter . hasNext ( ) ; ) { Map . Entry < Number , String > indexEntry = indexIter . next ( ) ; int collationIndex = indexEntry . getKey ( ) . intValue ( ) ; String charsetName = indexEntry . getValue ( ) ; indexToCharset . put ( collationIndex , charsetName ) ; if ( collationIndex >= CharsetMapping . MAP_SIZE || ! charsetName . equals ( CharsetMapping . getMysqlCharsetNameForCollationIndex ( collationIndex ) ) ) { customCharset . put ( collationIndex , charsetName ) ; } if ( ! CharsetMapping . CHARSET_NAME_TO_CHARSET . containsKey ( charsetName ) ) { customMblen . put ( charsetName , null ) ; } } if ( customMblen . size ( ) > 0 ) { try { results = stmt . executeQuery ( " SHOW ▁ CHARACTER ▁ SET " ) ; while ( results . next ( ) ) { String charsetName = results . getString ( " Charset " ) ; if ( customMblen . containsKey ( charsetName ) ) { customMblen . put ( charsetName , results . getInt ( " Maxlen " ) ) ; } } } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { dynamicIndexToCharsetMapByUrl . put ( getURL ( ) , indexToCharset ) ; dynamicIndexToCollationMapByUrl . put ( getURL ( ) , sortedCollationMap ) ; customIndexToCharsetMapByUrl . put ( getURL ( ) , customCharset ) ; customCharsetToMblenMapByUrl . put ( getURL ( ) , customMblen ) ; } } } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } finally { if ( results != null ) { try { results . close ( ) ; } catch ( java . sql . SQLException sqlE ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( java . sql . SQLException sqlE ) { } } } } else { for ( int i = 1 ; i < CharsetMapping . MAP_SIZE ; i ++ ) { indexToCharset . put ( i , CharsetMapping . getMysqlCharsetNameForCollationIndex ( i ) ) ; } if ( getCacheServerConfiguration ( ) ) { synchronized ( dynamicIndexToCharsetMapByUrl ) { dynamicIndexToCharsetMapByUrl . put ( getURL ( ) , indexToCharset ) ; } } } } this . indexToMysqlCharset = Collections . unmodifiableMap ( indexToCharset ) ; if ( customCharset != null ) { this . indexToCustomMysqlCharset = Collections . unmodifiableMap ( customCharset ) ; } if ( customMblen != null ) { this . mysqlCharsetToCustomMblen = Collections . unmodifiableMap ( customMblen ) ; } }
 public java . lang . Integer getUserLevel ( ) { return get ( " user _ level " ) ; }
 @ Benchmark public List < Page > runPagesIndexSortBenchmark ( PagesIndexSortBenchmarkData data ) { PagesIndex . TestingFactory pagesIndexFactory = new PagesIndex . TestingFactory ( false ) ; PagesIndex pageIndex = pagesIndexFactory . newPagesIndex ( data . getTypes ( ) , data . getTotalPositions ( ) ) ; for ( Page page : data . getPages ( ) ) { pageIndex . addPage ( page ) ; } pageIndex . sort ( data . getSortChannels ( ) , data . getSortOrders ( ) ) ; return Streams . stream ( pageIndex . getSortedPages ( ) ) . collect ( toImmutableList ( ) ) ; }
 public boolean isClientTzUTC ( ) { return this . isClientTzUTC ; }
 public java . util . Map < String , Class < ? > > getTypeMap ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . typeMap == null ) { this . typeMap = new HashMap < String , Class < ? > > ( ) ; } return this . typeMap ; } }
 public void setCatalog ( final String catalog ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( catalog == null ) { throw SQLError . createSQLException ( " Catalog ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . setCatalog ( catalog ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( getUseLocalSessionState ( ) ) { if ( this . lowerCaseTableNames ) { if ( this . database . equalsIgnoreCase ( catalog ) ) { return ; } } else { if ( this . database . equals ( catalog ) ) { return ; } } } String quotedId = this . dbmd . getIdentifierQuoteString ( ) ; if ( ( quotedId == null ) || quotedId . equals ( " ▁ " ) ) { quotedId = " " ; } StringBuilder query = new StringBuilder ( " USE ▁ " ) ; query . append ( StringUtils . quoteIdentifier ( catalog , quotedId , getPedantic ( ) ) ) ; execSQL ( null , query . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . database = catalog ; } }
 public void close ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . close ( ) ; } } . doForAll ( ) ; } realClose ( true , true , false , null ) ; } }
 public String getSchema ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; return null ; } }
 public final void setType ( final String type ) { super . setAttributeValue ( Constants . ATTRIBUTE_TYPE , type ) ; }
 public synchronized TripShare getTripShare ( ) { Cursor tripShareCursor = getTripShareCursor ( ) ; TripShare tripShare = null ; try { if ( tripShareCursor != null && tripShareCursor . moveToLast ( ) ) { tripShare = new TripShare ( tripShareCursor ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } finally { try { if ( tripShareCursor != null ) { tripShareCursor . close ( ) ; } } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } } return tripShare ; }
 private int getServerVariableAsInt ( String variableName , int fallbackValue ) throws SQLException { try { return Integer . parseInt ( this . serverVariables . get ( variableName ) ) ; } catch ( NumberFormatException nfe ) { getLog ( ) . logWarn ( Messages . getString ( " Connection . BadValueInServerVariables " , new Object [ ] { variableName , this . serverVariables . get ( variableName ) , Integer . valueOf ( fallbackValue ) } ) ) ; return fallbackValue ; } }
 public void setSeed ( long seed ) { m_Seed = seed ; m_Random = null ; }
 protected ConnectionImpl ( ) { }
 public boolean storesLowerCaseTableName ( ) { return this . storesLowerCaseTableName ; }
 public UseCommand ( GameManager gameManager ) { super ( gameManager , validTriggers , description , correctUsage ) ; }
 public String getUsername ( ) { return username ; }
 @ Override public String getLoginForwardPath ( ) { return null ; }
 public boolean isInGlobalTx ( ) { return this . isInGlobalTx ; }
 @ BeforeMethod public void setupDatabase ( ) { TypeRegistry typeRegistry = new TypeRegistry ( ) ; dbi = new DBI ( " jdbc : h2 : mem : test " + System . nanoTime ( ) ) ; dbi . registerMapper ( new TableColumn . Mapper ( typeRegistry ) ) ; dbi . registerMapper ( new Distribution . Mapper ( typeRegistry ) ) ; dummyHandle = dbi . open ( ) ; createTablesWithRetry ( dbi ) ; RaptorConnectorId connectorId = new RaptorConnectorId ( " raptor " ) ; NodeManager nodeManager = new TestingNodeManager ( ) ; NodeSupplier nodeSupplier = nodeManager :: getWorkerNodes ; shardManager = createShardManager ( dbi , nodeSupplier , systemTicker ( ) ) ; metadata = new RaptorMetadata ( connectorId . toString ( ) , dbi , shardManager ) ; }
 public void changeTexture ( TextureRegion region ) { sprite . setRegion ( region ) ; }
 private void initializePropsFromServer ( ) throws SQLException { String connectionInterceptorClasses = getConnectionLifecycleInterceptors ( ) ; this . connectionLifecycleInterceptors = null ; if ( connectionInterceptorClasses != null ) { this . connectionLifecycleInterceptors = Util . loadExtensions ( this , this . props , connectionInterceptorClasses , " Connection . badLifecycleInterceptor " , getExceptionInterceptor ( ) ) ; } setSessionVariables ( ) ; if ( ! versionMeetsMinimum ( 4 , 1 , 0 ) ) { setTransformedBitIsBoolean ( false ) ; } this . parserKnowsUnicode = versionMeetsMinimum ( 4 , 1 , 0 ) ; if ( getUseServerPreparedStmts ( ) && versionMeetsMinimum ( 4 , 1 , 0 ) ) { this . useServerPreparedStmts = true ; if ( versionMeetsMinimum ( 5 , 0 , 0 ) && ! versionMeetsMinimum ( 5 , 0 , 3 ) ) { this . useServerPreparedStmts = false ; } } if ( versionMeetsMinimum ( 3 , 21 , 22 ) ) { loadServerVariables ( ) ; if ( versionMeetsMinimum ( 5 , 0 , 2 ) ) { this . autoIncrementIncrement = getServerVariableAsInt ( " auto _ increment _ increment " , 1 ) ; } else { this . autoIncrementIncrement = 1 ; } buildCollationMapping ( ) ; LicenseConfiguration . checkLicenseType ( this . serverVariables ) ; String lowerCaseTables = this . serverVariables . get ( " lower _ case _ table _ names " ) ; this . lowerCaseTableNames = " on " . equalsIgnoreCase ( lowerCaseTables ) || "1" . equalsIgnoreCase ( lowerCaseTables ) || "2" . equalsIgnoreCase ( lowerCaseTables ) ; this . storesLowerCaseTableName = "1" . equalsIgnoreCase ( lowerCaseTables ) || " on " . equalsIgnoreCase ( lowerCaseTables ) ; configureTimezone ( ) ; if ( this . serverVariables . containsKey ( " max _ allowed _ packet " ) ) { int serverMaxAllowedPacket = getServerVariableAsInt ( " max _ allowed _ packet " , - 1 ) ; if ( serverMaxAllowedPacket != - 1 && ( serverMaxAllowedPacket < getMaxAllowedPacket ( ) || getMaxAllowedPacket ( ) <= 0 ) ) { setMaxAllowedPacket ( serverMaxAllowedPacket ) ; } else if ( serverMaxAllowedPacket == - 1 && getMaxAllowedPacket ( ) == - 1 ) { setMaxAllowedPacket ( 65535 ) ; } if ( getUseServerPrepStmts ( ) ) { int preferredBlobSendChunkSize = getBlobSendChunkSize ( ) ; int packetHeaderSize = ServerPreparedStatement . BLOB_STREAM_READ_BUF_SIZE + 11 ; int allowedBlobSendChunkSize = Math . min ( preferredBlobSendChunkSize , getMaxAllowedPacket ( ) ) - packetHeaderSize ; if ( allowedBlobSendChunkSize <= 0 ) { throw SQLError . createSQLException ( " Connection ▁ setting ▁ too ▁ low ▁ for ▁ ' maxAllowedPacket ' . ▁ " + " When ▁ ' useServerPrepStmts = true ' , ▁ ' maxAllowedPacket ' ▁ must ▁ be ▁ higher ▁ than ▁ " + packetHeaderSize + " . ▁ Check ▁ also ▁ ' max _ allowed _ packet ' ▁ in ▁ MySQL ▁ configuration ▁ files . " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } setBlobSendChunkSize ( String . valueOf ( allowedBlobSendChunkSize ) ) ; } } if ( this . serverVariables . containsKey ( " net _ buffer _ length " ) ) { this . netBufferLength = getServerVariableAsInt ( " net _ buffer _ length " , 16 * 1024 ) ; } checkTransactionIsolationLevel ( ) ; if ( ! versionMeetsMinimum ( 4 , 1 , 0 ) ) { checkServerEncoding ( ) ; } this . io . checkForCharsetMismatch ( ) ; if ( this . serverVariables . containsKey ( " sql _ mode " ) ) { String sqlModeAsString = this . serverVariables . get ( " sql _ mode " ) ; if ( StringUtils . isStrictlyNumeric ( sqlModeAsString ) ) { this . useAnsiQuotes = ( Integer . parseInt ( sqlModeAsString ) & 4 ) > 0 ; } else if ( sqlModeAsString != null ) { this . useAnsiQuotes = sqlModeAsString . indexOf ( " ANSI _ QUOTES " ) != - 1 ; this . noBackslashEscapes = sqlModeAsString . indexOf ( " NO _ BACKSLASH _ ESCAPES " ) != - 1 ; } } } boolean overrideDefaultAutocommit = isAutoCommitNonDefaultOnServer ( ) ; configureClientCharacterSet ( false ) ; try { this . errorMessageEncoding = CharsetMapping . getCharacterEncodingForErrorMessages ( this ) ; } catch ( SQLException ex ) { throw ex ; } catch ( RuntimeException ex ) { SQLException sqlEx = SQLError . createSQLException ( ex . toString ( ) , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , null ) ; sqlEx . initCause ( ex ) ; throw sqlEx ; } if ( versionMeetsMinimum ( 3 , 23 , 15 ) ) { this . transactionsSupported = true ; if ( ! overrideDefaultAutocommit ) { try { setAutoCommit ( true ) ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } } } else { this . transactionsSupported = false ; } if ( versionMeetsMinimum ( 3 , 23 , 36 ) ) { this . hasIsolationLevels = true ; } else { this . hasIsolationLevels = false ; } this . hasQuotedIdentifiers = versionMeetsMinimum ( 3 , 23 , 6 ) ; this . io . resetMaxBuf ( ) ; if ( this . io . versionMeetsMinimum ( 4 , 1 , 0 ) ) { String characterSetResultsOnServerMysql = this . serverVariables . get ( JDBC_LOCAL_CHARACTER_SET_RESULTS ) ; if ( characterSetResultsOnServerMysql == null || StringUtils . startsWithIgnoreCaseAndWs ( characterSetResultsOnServerMysql , " NULL " ) || characterSetResultsOnServerMysql . length ( ) == 0 ) { String defaultMetadataCharsetMysql = this . serverVariables . get ( " character _ set _ system " ) ; String defaultMetadataCharset = null ; if ( defaultMetadataCharsetMysql != null ) { defaultMetadataCharset = CharsetMapping . getJavaEncodingForMysqlCharset ( defaultMetadataCharsetMysql ) ; } else { defaultMetadataCharset = " UTF - 8" ; } this . characterSetMetadata = defaultMetadataCharset ; } else { this . characterSetResultsOnServer = CharsetMapping . getJavaEncodingForMysqlCharset ( characterSetResultsOnServerMysql ) ; this . characterSetMetadata = this . characterSetResultsOnServer ; } } else { this . characterSetMetadata = getEncoding ( ) ; } if ( versionMeetsMinimum ( 4 , 1 , 0 ) && ! this . versionMeetsMinimum ( 4 , 1 , 10 ) && getAllowMultiQueries ( ) ) { if ( isQueryCacheEnabled ( ) ) { setAllowMultiQueries ( false ) ; } } if ( versionMeetsMinimum ( 5 , 0 , 0 ) && ( getUseLocalTransactionState ( ) || getElideSetAutoCommits ( ) ) && isQueryCacheEnabled ( ) && ! versionMeetsMinimum ( 5 , 1 , 32 ) ) { setUseLocalTransactionState ( false ) ; setElideSetAutoCommits ( false ) ; } setupServerForTruncationChecks ( ) ; }
 public void releaseSavepoint ( Savepoint arg0 ) throws SQLException { }
 public void setIsEnabled ( boolean isEnabled ) { this . isEnabled = isEnabled ; }
 private boolean transactionExists ( long transactionId ) { try ( Handle handle = dbi . open ( ) ) { return handle . createQuery ( " SELECT ▁ count ( * ) ▁ FROM ▁ transactions ▁ WHERE ▁ transaction _ id ▁ = ▁ ? " ) . bind ( 0 , transactionId ) . map ( BooleanMapper . FIRST ) . first ( ) ; } }
 public java . sql . CallableStatement prepareCall ( String sql , int resultSetType , int resultSetConcurrency ) throws SQLException { if ( versionMeetsMinimum ( 5 , 0 , 0 ) ) { CallableStatement cStmt = null ; if ( ! getCacheCallableStatements ( ) ) { cStmt = parseCallableStatement ( sql ) ; } else { synchronized ( this . parsedCallableStatementCache ) { CompoundCacheKey key = new CompoundCacheKey ( getCatalog ( ) , sql ) ; CallableStatement . CallableStatementParamInfo cachedParamInfo = ( CallableStatement . CallableStatementParamInfo ) this . parsedCallableStatementCache . get ( key ) ; if ( cachedParamInfo != null ) { cStmt = CallableStatement . getInstance ( getMultiHostSafeProxy ( ) , cachedParamInfo ) ; } else { cStmt = parseCallableStatement ( sql ) ; synchronized ( cStmt ) { cachedParamInfo = cStmt . paramInfo ; } this . parsedCallableStatementCache . put ( key , cachedParamInfo ) ; } } } cStmt . setResultSetType ( resultSetType ) ; cStmt . setResultSetConcurrency ( resultSetConcurrency ) ; return cStmt ; } throw SQLError . createSQLException ( " Callable ▁ statements ▁ not ▁ supported . " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; }
 @ Override public ItemStack getStackInSlot ( int slot ) { return this . inv [ slot ] ; }
 public int getFrequency ( ) { return this . frequency ; }
 public boolean isClosed ( ) { return this . isClosed ; }
 protected void addExpectedServiceAbortedException ( Class < ? > exceptionClass , String exceptionMessage ) throws Exception { expectedException = ( Exception ) createException ( exceptionClass , exceptionMessage ) ; expectedExceptionClass = exceptionClass ; expectedExceptionMessage = exceptionMessage ; }
 public void transactionCompleted ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { ( ( ConnectionLifecycleInterceptor ) each ) . transactionCompleted ( ) ; } } ; iter . doForAll ( ) ; } } }
 @ Override public void checkCanDropTable ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , DROP_TABLE ) ) { denyDropTable ( tableName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanDropTable ( transactionId , identity , context , tableName ) ; } }
 public void setProxy ( MySQLConnection proxy ) { this . proxy = proxy ; this . realProxy = this . proxy instanceof MultiHostMySQLConnection ? ( ( MultiHostMySQLConnection ) proxy ) . getThisAsProxy ( ) : null ; }
 private void selectPlans ( CPlanMemoTable memo , PlanPartition part ) { pruneInvalidAndSpecialCasePlans ( memo , part ) ; if ( part . getMatPointsExt ( ) == null || part . getMatPointsExt ( ) . length == 0 ) { for ( Long hopID : part . getRoots ( ) ) rSelectPlansFuseAll ( memo , memo . getHopRefs ( ) . get ( hopID ) , null , part . getPartition ( ) ) ; } else { HashMap < Long , Double > computeCosts = new HashMap < > ( ) ; for ( Long hopID : part . getPartition ( ) ) getComputeCosts ( memo . getHopRefs ( ) . get ( hopID ) , computeCosts ) ; StaticCosts costs = new StaticCosts ( computeCosts , sumComputeCost ( computeCosts ) , getReadCost ( part , memo ) , getWriteCost ( part . getRoots ( ) , memo ) , minOuterSparsity ( part , memo ) ) ; ReachabilityGraph rgraph = STRUCTURAL_PRUNING ? new ReachabilityGraph ( part , memo ) : null ; if ( STRUCTURAL_PRUNING ) { part . setMatPointsExt ( rgraph . getSortedSearchSpace ( ) ) ; for ( Long hopID : part . getPartition ( ) ) memo . pruneRedundant ( hopID , true , part . getMatPointsExt ( ) ) ; } boolean [ ] bestPlan = enumPlans ( memo , part , costs , rgraph , part . getMatPointsExt ( ) , 0 ) ; HashSet < Long > visited = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) rPruneSuboptimalPlans ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited , part , part . getMatPointsExt ( ) , bestPlan ) ; HashSet < Long > visited2 = new HashSet < > ( ) ; for ( Long hopID : part . getRoots ( ) ) rPruneInvalidPlans ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited2 , part , bestPlan ) ; for ( Long hopID : part . getRoots ( ) ) rSelectPlansFuseAll ( memo , memo . getHopRefs ( ) . get ( hopID ) , null , part . getPartition ( ) ) ; } }
 public void setCreated ( java . util . Date created ) { set ( " created " , created ) ; }
 public CallSiteBinder getCallSiteBinder ( ) { return callSiteBinder ; }
 @ JsonProperty ( " numeroItem " ) @ NotNull public String getNumeroItem ( ) { return numeroItem ; }
 @ Override public void writeToStringBuilder ( StringBuilder sb , String indent ) { sb . append ( " message ▁ " ) . append ( getName ( ) ) . append ( getOriginalType ( ) == null ? " " : " ▁ ( " + getOriginalType ( ) + " ) " ) . append ( " ▁ { \n " ) ; membersDisplayString ( sb , " ▁ ▁ " ) ; sb . append ( " } \n " ) ; }
 @ Test public void testGroupModification ( ) { app . getNavigationHelper ( ) . gotoGroupsPage ( ) ; if ( ! app . getGroupHelper ( ) . isThereAGroup ( ) ) { app . getGroupHelper ( ) . createGroup ( new GroupData ( " test " , null , null ) ) ; } app . getNavigationHelper ( ) . selection ( ) ; app . getGroupHelper ( ) . initGroupModification ( ) ; app . getGroupHelper ( ) . fillGroupForm ( new GroupData ( " tEsT1" , " tEsT2" , " tEsT3" ) ) ; app . getGroupHelper ( ) . submitUpdateGroupModification ( ) ; app . getGroupHelper ( ) . returnToGroupPage ( ) ; }
 public void setReadInfoMsgEnabled ( boolean flag ) { this . readInfoMsg = flag ; }
 public Calendar getSessionLockedCalendar ( ) { return this . sessionCalendar ; }
 @ Test public void testRenameColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle columnHandle = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . renameColumn ( SESSION , raptorTableHandle , columnHandle , " orderkey _ renamed " ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey _ renamed " ) ) ; }
 public void setFrequency ( int frequency ) { this . frequency = frequency ; }
 public ThermalGeneratingUnit basicGetThermalGeneratingUnit ( ) { return thermalGeneratingUnit ; }
 public boolean isFiltered ( ) { return lastResults != null && lastResults . count > - 1 ; }
 @ Test ( expectedExceptions = PrestoException . class , expectedExceptionsMessageRegExp = " Temporal ▁ column ▁ does ▁ not ▁ exist : ▁ foo " ) public void testInvalidTemporalColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata ordersTable = getOrdersTable ( ImmutableMap . of ( TEMPORAL_COLUMN_PROPERTY , " foo " ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; fail ( " Expected ▁ createTable ▁ to ▁ fail " ) ; }
 public boolean batchFinished ( ) throws Exception { Instances data = getInputFormat ( ) ; if ( data == null ) throw new IllegalStateException ( " No ▁ input ▁ instance ▁ format ▁ defined " ) ; if ( m_Converter == null ) { int [ ] randomIndices = new int [ m_ClassCounts . length ] ; for ( int i = 0 ; i < randomIndices . length ; i ++ ) { randomIndices [ i ] = i ; } for ( int j = randomIndices . length - 1 ; j > 0 ; j -- ) { int toSwap = m_Random . nextInt ( j + 1 ) ; int tmpIndex = randomIndices [ j ] ; randomIndices [ j ] = randomIndices [ toSwap ] ; randomIndices [ toSwap ] = tmpIndex ; } double [ ] randomizedCounts = new double [ m_ClassCounts . length ] ; for ( int i = 0 ; i < randomizedCounts . length ; i ++ ) { randomizedCounts [ i ] = m_ClassCounts [ randomIndices [ i ] ] ; } if ( m_ClassOrder == RANDOM ) { m_Converter = randomIndices ; m_ClassCounts = randomizedCounts ; } else { int [ ] sorted = Utils . sort ( randomizedCounts ) ; m_Converter = new int [ sorted . length ] ; if ( m_ClassOrder == FREQ_ASCEND ) { for ( int i = 0 ; i < sorted . length ; i ++ ) { m_Converter [ i ] = randomIndices [ sorted [ i ] ] ; } } else if ( m_ClassOrder == FREQ_DESCEND ) { for ( int i = 0 ; i < sorted . length ; i ++ ) { m_Converter [ i ] = randomIndices [ sorted [ sorted . length - i - 1 ] ] ; } } else { throw new IllegalArgumentException ( " Class ▁ order ▁ not ▁ defined ! " ) ; } double [ ] tmp2 = new double [ m_ClassCounts . length ] ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) { tmp2 [ i ] = m_ClassCounts [ m_Converter [ i ] ] ; } m_ClassCounts = tmp2 ; } FastVector values = new FastVector ( data . classAttribute ( ) . numValues ( ) ) ; for ( int i = 0 ; i < data . numClasses ( ) ; i ++ ) { values . addElement ( data . classAttribute ( ) . value ( m_Converter [ i ] ) ) ; } FastVector newVec = new FastVector ( data . numAttributes ( ) ) ; for ( int i = 0 ; i < data . numAttributes ( ) ; i ++ ) { if ( i == data . classIndex ( ) ) { newVec . addElement ( new Attribute ( data . classAttribute ( ) . name ( ) , values , data . classAttribute ( ) . getMetadata ( ) ) ) ; } else { newVec . addElement ( data . attribute ( i ) ) ; } } Instances newInsts = new Instances ( data . relationName ( ) , newVec , 0 ) ; newInsts . setClassIndex ( data . classIndex ( ) ) ; setOutputFormat ( newInsts ) ; int [ ] temp = new int [ m_Converter . length ] ; for ( int i = 0 ; i < temp . length ; i ++ ) { temp [ m_Converter [ i ] ] = i ; } m_Converter = temp ; for ( int xyz = 0 ; xyz < data . numInstances ( ) ; xyz ++ ) { Instance datum = data . instance ( xyz ) ; if ( ! datum . isMissing ( datum . classIndex ( ) ) ) { datum . setClassValue ( ( double ) m_Converter [ ( int ) datum . classValue ( ) ] ) ; } push ( datum ) ; } } flushInput ( ) ; m_NewBatch = true ; return ( numPendingOutput ( ) != 0 ) ; }
 public void upload ( File file , String target , String backup ) throws IOException { ftp . connect ( app . getProperty ( " ftp . host " ) ) ; ftp . login ( app . getProperty ( " ftp . login " ) , app . getProperty ( " ftp . password " ) ) ; ftp . deleteFile ( backup ) ; ftp . rename ( target , backup ) ; ftp . enterLocalPassiveMode ( ) ; ftp . storeFile ( target , new FileInputStream ( file ) ) ; ftp . disconnect ( ) ; }
 @ Override void finish ( ) throws IOException { }
 @ Override public void setInventorySlotContents ( int slot , ItemStack itemStack ) { this . inv [ slot ] = itemStack ; if ( itemStack != null && itemStack . stackSize > this . getInventoryStackLimit ( ) ) { itemStack . stackSize = this . getInventoryStackLimit ( ) ; } }
 public void setDummyTrustManager ( boolean dummyTrustManager ) { this . dummyTrustManager = dummyTrustManager ; }
 public void testReverseString ( ) throws Exception { assertEquals ( " A " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " A " ) ) ; assertEquals ( " BA " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " AB " ) ) ; assertEquals ( " CBA " , ReverseStringFilter . reverse ( TEST_VERSION_CURRENT , " ABC " ) ) ; }
 public ResultSetInternalMethods execSQL ( StatementImpl callingStatement , String sql , int maxRows , Buffer packet , int resultSetType , int resultSetConcurrency , boolean streamResults , String catalog , Field [ ] cachedMetadata ) throws SQLException { return execSQL ( callingStatement , sql , maxRows , packet , resultSetType , resultSetConcurrency , streamResults , catalog , cachedMetadata , false ) ; }
 public void addInputSize ( long hopID , double inputSize ) { inSizes . put ( hopID , inputSize ) ; }
 String getPresentationOrigin ( ) { JsonNode subNode = json . get ( " presentationOrigin " ) ; if ( subNode == null ) { return null ; } String textValue = subNode . textValue ( ) ; if ( textValue == null ) { return null ; } return textValue ; }
 private HashMap < String , LsElements > readLsfile ( File lsFile ) throws IOException { BufferedReader br = new BufferedReader ( new FileReader ( lsFile ) ) ; String line = null ; HashMap < String , LsElements > fileContents = new HashMap < String , LsElements > ( ) ; while ( ( line = br . readLine ( ) ) != null ) readLsLine ( line , fileContents ) ; br . close ( ) ; return fileContents ; }
 public ItemStack getCellphone ( ) { this . markDirty ( ) ; return this . cellphone ; }
 public void setProtocol ( String protocol ) { this . protocol = protocol ; }
 public Number getNumberOfRooms ( ) { return numberOfRooms ; }
 @ Test public void testSet_BooleanArray ( ) throws Exception { Series a = getBuilder ( ) . addAll ( Series . of ( 1 , 2 , 3 , 4 , 5 ) ) . build ( ) ; Series expected = getBuilder ( ) . addAll ( Series . of ( 1 , 2 , 320 , 320 , 320 ) ) . build ( ) ; a . set ( a . where ( Double . class , v -> v > 2 ) , 320 ) ; System . out . println ( IntSeries . range ( 2000 ) . sort ( SortOrder . ASC ) ) ; Assert . assertEquals ( expected , a ) ; }
 public boolean isMasterConnection ( ) { return false ; }
 protected void setupForExpectedAssertionFailure ( Class < ? extends Throwable > exceptionCause , String exceptionMessage ) throws Exception { addExpectedException ( AssertionFailure . class , exceptionCause , exceptionMessage ) ; }
 public SQLWarning getWarnings ( ) throws SQLException { return null ; }
 public String getUser ( ) { return this . user ; }
 private void changeLayoutVersion ( File src , File dest , int newVersion ) throws IOException { DataInputStream in = null ; DataOutputStream out = null ; try { in = new DataInputStream ( new FileInputStream ( src ) ) ; out = new DataOutputStream ( new FileOutputStream ( dest ) ) ; in . readInt ( ) ; out . writeInt ( newVersion ) ; byte [ ] b = new byte [ 1024 ] ; while ( in . read ( b ) > 0 ) { out . write ( b ) ; } } finally { if ( in != null ) in . close ( ) ; if ( out != null ) out . close ( ) ; } }
 @ Override K get ( int index ) { return map . entrySet ( ) . asList ( ) . get ( index ) . getKey ( ) ; }
 public void draw ( SpriteBatch spriteBatch ) { sprite . draw ( spriteBatch ) ; }
 public void setStatementComment ( String comment ) { this . statementComment = comment ; }
 public List < V > getMutable ( K key ) { return map . get ( key ) ; }
 public boolean isIsNetGrossP ( ) { return isNetGrossP ; }
 @ Override public boolean equals ( Object obj ) { if ( obj instanceof CompoundCacheKey ) { CompoundCacheKey another = ( CompoundCacheKey ) obj ; boolean firstPartEqual = false ; if ( this . componentOne == null ) { firstPartEqual = ( another . componentOne == null ) ; } else { firstPartEqual = this . componentOne . equals ( another . componentOne ) ; } return ( firstPartEqual && this . componentTwo . equals ( another . componentTwo ) ) ; } return false ; }
 @ PostConstruct public void registerService ( ) { serviceRegistry . registerService ( gossipService ( ) , mockGossipTransport ( ) ) ; if ( localTransportClientFactory instanceof LocalTransportClientFactory ) { final LocalTransportClientFactory localTransportClientFactoryImpl = ( LocalTransportClientFactory ) localTransportClientFactory ; localTransportClientFactoryImpl . addService ( " gossip " , gossipService ( ) ) ; } serviceRegistry . initTransportClient ( gossipServiceRef ( ) , mockGossipTransportRef ( ) ) ; }
 public void setDelete ( boolean delete ) { this . delete = delete ; }
 @ Test public void testDropColumnDisallowed ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; Map < String , Object > properties = ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , ORDERING_PROPERTY , ImmutableList . of ( " totalprice " ) , TEMPORAL_COLUMN_PROPERTY , " orderdate " ) ; ConnectorTableMetadata ordersTable = buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " totalprice " , DOUBLE ) . column ( " orderdate " , DATE ) . column ( " highestid " , BIGINT ) ) ; metadata . createTable ( SESSION , ordersTable , false ) ; ConnectorTableHandle ordersTableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( ordersTableHandle , RaptorTableHandle . class ) ; RaptorTableHandle ordersRaptorTableHandle = ( RaptorTableHandle ) ordersTableHandle ; assertEquals ( ordersRaptorTableHandle . getTableId ( ) , 1 ) ; assertInstanceOf ( ordersRaptorTableHandle , RaptorTableHandle . class ) ; ColumnHandle bucketColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " orderkey " ) ; assertThrows ( " Cannot ▁ drop ▁ bucket ▁ columns " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , bucketColumn ) ) ; ColumnHandle sortColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " totalprice " ) ; assertThrows ( " Cannot ▁ drop ▁ sort ▁ columns " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , sortColumn ) ) ; ColumnHandle temporalColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " orderdate " ) ; assertThrows ( " Cannot ▁ drop ▁ the ▁ temporal ▁ column " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , temporalColumn ) ) ; ColumnHandle highestColumn = metadata . getColumnHandles ( SESSION , ordersRaptorTableHandle ) . get ( " highestid " ) ; assertThrows ( " Cannot ▁ drop ▁ the ▁ column ▁ which ▁ has ▁ the ▁ largest ▁ column ▁ ID ▁ in ▁ the ▁ table " , ( ) -> metadata . dropColumn ( SESSION , ordersTableHandle , highestColumn ) ) ; }
 public void unregisterAll ( ) { HashSet < Servlet > servlets = new HashSet < Servlet > ( this . localServlets ) ; for ( Servlet servlet : servlets ) { unregisterServlet ( servlet , false ) ; } HashSet < Filter > filters = new HashSet < Filter > ( this . localFilters ) ; for ( Filter fiter : filters ) { unregisterFilter ( fiter , false ) ; } }
 public String getURL ( ) { return this . myURL ; }
 public void insert ( final FluoClient fluo , final RyaStatement triple ) { checkNotNull ( fluo ) ; checkNotNull ( triple ) ; insert ( fluo , Collections . singleton ( triple ) ) ; }
 protected Throwable getExceptionForThrowable ( Throwable e ) { if ( e instanceof RuntimeException == false ) return e ; Throwable cause = e . getCause ( ) ; if ( cause instanceof Error ) return cause ; if ( cause instanceof RuntimeException ) return getExceptionForThrowable ( cause ) ; return cause ; }
 public Map < Message . RecipientType , String > getRecipients ( ) { return recipients ; }
 public Configuration < ? > createGenericConfiguration ( BootstrapState state ) { return new DummyConfiguration ( ) ; }
 @ Override public void checkCanSelectFromColumns ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName , Set < String > columns ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , SELECT_COLUMN ) ) { denySelectColumns ( tableName . toString ( ) , columns ) ; } for ( String column : columns ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , column , SELECT_COLUMN ) ) { denySelectColumns ( tableName . toString ( ) , columns ) ; } } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanSelectFromColumns ( transactionId , identity , context , tableName , columns ) ; } }
 @ Override public Void visitOrder ( Order order , FieldList fl ) { for ( Ordering o : order . getOrderings ( ) ) { fl . addReferenced ( o . getExpr ( ) . accept ( finder , null ) ) ; } return null ; }
 private void obtainRegionsToScan ( ) { beaconsController . getAllRegionsFromDataBase ( this ) ; }
 @ Override public ResponseStats . Get get ( final String url , final OperationParams . Get params ) throws IOException { mController . reset ( ) ; mController . start ( ) ; final RequestFuture < String > future = RequestFuture . newFuture ( ) ; mQueue . add ( new StringRequest ( Request . Method . GET , url , future , future ) ) ; final String response = get ( future ) ; mController . stop ( ) ; return new ResponseStats . Get ( mController , response ) ; }
 @ Override public void queryBefore ( AopContext ac ) { setParma ( " userId " , ac ) ; String keyWord = this . getRecord ( ) . getStr ( " keyWord " ) ; StringBuffer whereBuffer = new StringBuffer ( ) ; whereBuffer . append ( " ▁ and ▁ ( " ) . append ( " ▁ province _ city ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ school ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ career ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ domain ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ professional ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ product _ service _ name ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ organization ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zy ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zl ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ sc ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ zy2 ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ industry _ ranking ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ qualification ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' ▁ or " ) . append ( " ▁ key _ word ▁ like ▁ concat ( ' % ' , ' " ) . append ( keyWord ) . append ( " , ' % ' " ) ; ac . setCondition ( whereBuffer . toString ( ) ) ; super . queryBefore ( ac ) ; }
 int getTotalPositions ( ) { return totalPositions ; }
 public synchronized void freeConnection ( Connection con ) { freeConnections . addElement ( con ) ; checkedOut -- ; log ( " 从连接池 " + name + " 被占用的链接数 " + checkedOut ) ; log ( " 从连接池 " + name + " 目前可使用连接数 " + freeConnections . size ( ) ) ; notifyAll ( ) ; }
 @ Override public void eSet ( int featureID , Object newValue ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : setThermalGeneratingUnit ( ( ThermalGeneratingUnit ) newValue ) ; return ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : setIsNetGrossP ( ( Boolean ) newValue ) ; return ; } super . eSet ( featureID , newValue ) ; }
 @ Override public void updateRegions ( List deletedRegions , List newRegions ) { if ( ! deletedRegions . isEmpty ( ) ) { List < Region > deleted = regionMapper . modelListToExternalClassList ( deletedRegions ) ; stopMonitoringRegions ( deleted ) ; } if ( ! newRegions . isEmpty ( ) ) { List < Region > added = regionMapper . modelListToExternalClassList ( newRegions ) ; startMonitoringRegions ( added ) ; } }
 @ RequestMapping ( value = " / " , method = RequestMethod . GET ) public ResponseEntity < List < Client > > getAll ( ) { List < Client > entities = clientService . findAll ( ) ; return ackEntities ( entities ) ; }
 public String getSubject ( ) { return subject ; }
 public UseItemOn ( List < String > originalMessageParts ) { originalMessageParts . remove ( 0 ) ; String fullCommand = Joiner . on ( " ▁ " ) . join ( originalMessageParts ) ; if ( fullCommand . endsWith ( " ▁ on " ) ) fullCommand = fullCommand . substring ( 0 , fullCommand . length ( ) - 3 ) ; item = getItem ( fullCommand ) ; target = getItemTarget ( fullCommand ) ; }
 @ Test public void checkDecapitalize ( ) { Assert . assertEquals ( " " , StringUtils . decapitalize ( " " ) ) ; Assert . assertEquals ( " test " , StringUtils . decapitalize ( " Test " ) ) ; Assert . assertEquals ( " someTest " , StringUtils . decapitalize ( " SomeTest " ) ) ; }
 public java . sql . PreparedStatement serverPrepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) serverPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
 @ Test public final void test_that_the_textual_representation_of_a_Comments_is_correct ( ) { assertEquals ( " < comments > \n ▁ ▁ ▁ ▁ ▁ ▁ Hello \n ▁ ▁ ▁ ▁ World \n < / comments > " , comments . show ( ) ) ; }
 @ Override public String toString ( ) { return " [ " + Arrays . toString ( _aggregates . keySet ( ) . toArray ( new Long [ 0 ] ) ) + " : ▁ " + " { " + Arrays . toString ( _inputAggs . toArray ( new Long [ 0 ] ) ) + " } , " + " { " + Arrays . toString ( _fusedInputs . toArray ( new Long [ 0 ] ) ) + " } ] " ; }
 public void setFinallyStatement ( Statement finallyStatement ) { _finallyStatement = finallyStatement ; }
 public ValidationException ( final String message ) { super ( message ) ; }
 @ JsonProperty ( " cpfCnpjRaiz " ) @ NotNull public String getCpfCnpjRaiz ( ) { return cpfCnpjRaiz ; }
 public ByteCodeGeneratorContext ( ByteCodeExpressionVisitor byteCodeGenerator , Scope scope , CallSiteBinder callSiteBinder , FunctionRegistry registry ) { checkNotNull ( byteCodeGenerator , " byteCodeGenerator ▁ is ▁ null " ) ; checkNotNull ( scope , " scope ▁ is ▁ null " ) ; checkNotNull ( callSiteBinder , " callSiteBinder ▁ is ▁ null " ) ; checkNotNull ( registry , " registry ▁ is ▁ null " ) ; this . byteCodeGenerator = byteCodeGenerator ; this . scope = scope ; this . callSiteBinder = callSiteBinder ; this . registry = registry ; this . wasNull = scope . getVariable ( " wasNull " ) ; }
 public boolean isPropertyNameInDatabase ( String propertyName ) { return _properties . containsKey ( propertyName ) ; }
 public Knowledge ( EntityPlayer player , EnumKnowledgeType type , ResearchCategory category , int amount ) { super ( player ) ; this . type = type ; this . category = category ; this . amount = amount ; }
 public List < IVarStatement > getVarStatements ( ) { return _varStmts ; }
 public double originalValue ( double value ) throws Exception { if ( m_Converter == null ) throw new IllegalStateException ( " Coverter ▁ table ▁ not ▁ defined ▁ yet ! " ) ; for ( int i = 0 ; i < m_Converter . length ; i ++ ) if ( ( int ) value == m_Converter [ i ] ) return ( double ) i ; return - 1 ; }
 " , method = RequestMethod . DELETE ) @ CrossOrigin public ResponseEntity < Void > delete ( @ PathVariable ( " id " ) String id ) { clientService . delete ( id ) ; return ack ( ) ; }
 @ AfterEach public void tearDown ( ) throws Exception { if ( userId != null ) cont . deleteRecord ( " SEC _ USER " , userId ) ; }
 public TwoDimensionCodeImage ( BufferedImage bufImg ) { this . bufImg = bufImg ; }
 private void compareNamespaces ( HashMap < String , FileStatus > written , HashMap < String , LsElements > fileOutput ) { assertEquals ( " Should ▁ be ▁ the ▁ same ▁ number ▁ of ▁ files ▁ in ▁ both , ▁ plus ▁ one ▁ for ▁ root " + " ▁ in ▁ fileoutput " , fileOutput . keySet ( ) . size ( ) , written . keySet ( ) . size ( ) + 1 ) ; Set < String > inFile = fileOutput . keySet ( ) ; for ( String path : inFile ) { if ( path . equals ( " / " ) ) continue ; assertTrue ( " Path ▁ in ▁ file ▁ ( " + path + " ) ▁ was ▁ written ▁ to ▁ fs " , written . containsKey ( path ) ) ; compareFiles ( written . get ( path ) , fileOutput . get ( path ) ) ; written . remove ( path ) ; } assertEquals ( " No ▁ more ▁ files ▁ were ▁ written ▁ to ▁ fs " , 0 , written . size ( ) ) ; }
 @ Override public void findOffer ( OfferFindServiceModel model ) { if ( this . validator . validate ( model ) . size ( ) != DEFAULT_CONSTRAINT_VIOLATION_SIZE ) { throw new IllegalArgumentException ( DEFAULT_INVALID_MODEL_MESSAGE ) ; } Offer offer = this . offerRepository . findAll ( ) . stream ( ) . filter ( o -> o . getApartmentType ( ) . toLowerCase ( ) . equals ( model . getApartmentType ( ) . toLowerCase ( ) ) && this . isFamilyBudgetEnough ( model . getFamilyBudget ( ) , o ) ) . findFirst ( ) . orElse ( null ) ; if ( offer == null ) { throw new IllegalArgumentException ( DEFAULT_NOT_FOUND_OFFER_MESSAGE ) ; } this . offerRepository . delete ( offer ) ; }
 private void createPages ( int totalChannels , int pagesCount ) { int positionCount = PageBuilderStatus . DEFAULT_MAX_PAGE_SIZE_IN_BYTES / ( totalChannels * 8 ) ; pages = new ArrayList < > ( pagesCount ) ; for ( int numPage = 0 ; numPage < pagesCount ; numPage ++ ) { pages . add ( createSequencePage ( types , positionCount ) ) ; } totalPositions = positionCount * pagesCount ; }
 public long getConnectionTimeout ( ) { return connectionTimeout ; }
 void setDateTimeBox ( final DateTimeBox box ) { this . box = box ; }
 @ Override public boolean eIsSet ( int featureID ) { switch ( featureID ) { case ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT : return thermalGeneratingUnit != null ; case ProductionPackage . HEAT_RATE_CURVE__IS_NET_GROSS_P : return isNetGrossP != IS_NET_GROSS_P_EDEFAULT ; } return super . eIsSet ( featureID ) ; }
 @ Override public List < String > getInvalidateSessionExcludeList ( ) { return null ; }
 public List < ColumnDescriptor > getColumns ( ) { List < String [ ] > paths = this . getPaths ( 0 ) ; List < ColumnDescriptor > columns = new ArrayList < ColumnDescriptor > ( paths . size ( ) ) ; for ( String [ ] path : paths ) { columns . add ( new ColumnDescriptor ( path , getType ( path ) . asPrimitiveType ( ) . getPrimitiveTypeName ( ) , getMaxRepetitionLevel ( path ) , getMaxDefinitionLevel ( path ) ) ) ; } return columns ; }
 public void recachePreparedStatement ( ServerPreparedStatement pstmt ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( getCachePreparedStatements ( ) && pstmt . isPoolable ( ) ) { synchronized ( this . serverSideStatementCache ) { this . serverSideStatementCache . put ( pstmt . originalSql , pstmt ) ; } } } }
 if ( this . contatosMap . containsKey ( nome ) ) { throw new AgendaException ( " contato ▁ " + nome + " ▁ já ▁ existe " ) ; }
 private void createPreparedStatementCaches ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { int cacheSize = getPreparedStatementCacheSize ( ) ; try { Class < ? > factoryClass ; factoryClass = Class . forName ( getParseInfoCacheFactory ( ) ) ; @ SuppressWarnings ( " unchecked " ) CacheAdapterFactory < String , ParseInfo > cacheFactory = ( ( CacheAdapterFactory < String , ParseInfo > ) factoryClass . newInstance ( ) ) ; this . cachedPreparedStatementParams = cacheFactory . getInstance ( this , this . myURL , getPreparedStatementCacheSize ( ) , getPreparedStatementCacheSqlLimit ( ) , this . props ) ; } catch ( ClassNotFoundException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantFindCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( InstantiationException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } catch ( IllegalAccessException e ) { SQLException sqlEx = SQLError . createSQLException ( Messages . getString ( " Connection . CantLoadCacheFactory " , new Object [ ] { getParseInfoCacheFactory ( ) , " parseInfoCacheFactory " } ) , getExceptionInterceptor ( ) ) ; sqlEx . initCause ( e ) ; throw sqlEx ; } if ( getUseServerPreparedStmts ( ) ) { this . serverSideStatementCheckCache = new LRUCache ( cacheSize ) ; this . serverSideStatementCache = new LRUCache ( cacheSize ) { private static final long serialVersionUID = 7692318650375988114L ; @ Override protected boolean removeEldestEntry ( java . util . Map . Entry < Object , Object > eldest ) { if ( this . maxElements <= 1 ) { return false ; } boolean removeIt = super . removeEldestEntry ( eldest ) ; if ( removeIt ) { ServerPreparedStatement ps = ( ServerPreparedStatement ) eldest . getValue ( ) ; ps . isCached = false ; ps . setClosed ( false ) ; try { ps . close ( ) ; } catch ( SQLException sqlEx ) { } } return removeIt ; } } ; } } }
 public ActivityInputPort getInputPort ( final String name ) { for ( final ActivityInputPort port : this . getInputPorts ( ) ) { if ( port . getName ( ) . equals ( name ) ) { return port ; } } return null ; }
 @ Override public void setAsText ( String text ) { if ( ! text . isEmpty ( ) ) { ValueDefinition valueDefinition = definitionService . getValueDefinition ( text ) ; if ( valueDefinition != null ) { setValue ( valueDefinition ) ; } else { throw new IllegalArgumentException ( " Invalid ▁ UID : ▁ " + text ) ; } } else { throw new IllegalArgumentException ( " UID ▁ is ▁ empty " ) ; } }
 public void incrementNumberOfPreparedExecutes ( ) { if ( getGatherPerformanceMetrics ( ) ) { this . numberOfPreparedExecutes ++ ; this . numberOfQueriesIssued ++ ; } }
 public boolean addItemToDatabase ( DatabaseItem item ) { if ( _items . containsKey ( item . getName ( ) ) ) { return false ; } for ( String propertyName : _properties . keySet ( ) ) { if ( ! item . hasProperty ( propertyName ) ) item . addProperty ( propertyName , null ) ; } _items . put ( item . getName ( ) , item ) ; WindowMain . addItemToListView ( item ) ; WindowMain . addItemToTableView ( item ) ; return true ; }
 private SimpleHiveConnManager ( ) { init ( ) ; }
 public java . util . Date getStartDate ( ) { return get ( " start _ date " ) ; }
 public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( obj == null ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Zoo other = ( Zoo ) obj ; if ( animals == null ) { if ( other . animals != null ) return false ; } else if ( ! animals . equals ( other . animals ) ) return false ; if ( largestAnimal == null ) { if ( other . largestAnimal != null ) return false ; } else if ( ! largestAnimal . equals ( other . largestAnimal ) ) return false ; return true ; }
 @ Test public void testFromName_Invalid ( ) { MetricType res = MetricType . fromName ( " foo " ) ; assertEquals ( null , res ) ; }
 public void setTransactionIsolation ( int level ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; if ( this . hasIsolationLevels ) { String sql = null ; boolean shouldSendSet = false ; if ( getAlwaysSendSetIsolation ( ) ) { shouldSendSet = true ; } else { if ( level != this . isolationLevel ) { shouldSendSet = true ; } } if ( getUseLocalSessionState ( ) ) { shouldSendSet = this . isolationLevel != level ; } if ( shouldSendSet ) { switch ( level ) { case java . sql . Connection . TRANSACTION_NONE : throw SQLError . createSQLException ( " Transaction ▁ isolation ▁ level ▁ NONE ▁ not ▁ supported ▁ by ▁ MySQL " , getExceptionInterceptor ( ) ) ; case java . sql . Connection . TRANSACTION_READ_COMMITTED : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ READ ▁ COMMITTED " ; break ; case java . sql . Connection . TRANSACTION_READ_UNCOMMITTED : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ READ ▁ UNCOMMITTED " ; break ; case java . sql . Connection . TRANSACTION_REPEATABLE_READ : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ REPEATABLE ▁ READ " ; break ; case java . sql . Connection . TRANSACTION_SERIALIZABLE : sql = " SET ▁ SESSION ▁ TRANSACTION ▁ ISOLATION ▁ LEVEL ▁ SERIALIZABLE " ; break ; default : throw SQLError . createSQLException ( " Unsupported ▁ transaction ▁ isolation ▁ level ▁ ' " + level + " ' " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } execSQL ( null , sql , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; this . isolationLevel = level ; } } else { throw SQLError . createSQLException ( " Transaction ▁ Isolation ▁ Levels ▁ are ▁ not ▁ supported ▁ on ▁ MySQL ▁ versions ▁ older ▁ than ▁ 3.23.36 . " , SQLError . SQL_STATE_DRIVER_NOT_CAPABLE , getExceptionInterceptor ( ) ) ; } } }
 public QuantitativeValue getOccupancy ( ) { return occupancy ; }
 if ( contatosLetra == null ) { contatosLetra = new ArrayList < > ( ) ; contatosPorLetra . put ( letraInicial , contatosLetra ) ; }
 public synchronized void release ( ) { Enumeration allConnections = freeConnections . elements ( ) ; while ( allConnections . hasMoreElements ( ) ) { Connection con = ( Connection ) allConnections . nextElement ( ) ; try { con . close ( ) ; log ( " 关闭连接池 " + name + " 中的一个连接 " ) ; } catch ( SQLException e ) { log ( e , " 无法关闭连接池 " + name + " 中的连接 " ) ; } } freeConnections . removeAllElements ( ) ; }
 @ Override public void checkCanRenameColumn ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName tableName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , tableName . getObjectName ( ) , RENAME_COLUMN ) ) { denyRenameColumn ( tableName . toString ( ) ) ; } super . checkCanRenameColumn ( transactionId , identity , context , tableName ) ; }
 public synchronized Cursor getTripShare ( String [ ] projection , String selection , String [ ] selectionArgs , String sortOrder ) { Cursor cursor = null ; try { final SQLiteDatabase db = dbHelper . getReadableDatabase ( ) ; cursor = db . query ( TripShare . TABLE_NAME , projection , selection , selectionArgs , null , null , sortOrder , null ) ; } catch ( Exception e ) { Util . logException ( e , LOG_LABEL ) ; } return cursor ; }
 @ RequestMapping ( value = " / " , method = RequestMethod . PUT ) @ CrossOrigin public ResponseEntity < Client > update ( @ RequestBody Client input ) throws ContextedException { Client entity = clientService . save ( input ) ; return ackEntity ( entity ) ; }
 private boolean canHandleAsServerPreparedStatement ( String sql ) throws SQLException { if ( sql == null || sql . length ( ) == 0 ) { return true ; } if ( ! this . useServerPreparedStmts ) { return false ; } if ( getCachePreparedStatements ( ) ) { synchronized ( this . serverSideStatementCheckCache ) { Boolean flag = ( Boolean ) this . serverSideStatementCheckCache . get ( sql ) ; if ( flag != null ) { return flag . booleanValue ( ) ; } boolean canHandle = canHandleAsServerPreparedStatementNoCache ( sql ) ; if ( sql . length ( ) < getPreparedStatementCacheSqlLimit ( ) ) { this . serverSideStatementCheckCache . put ( sql , canHandle ? Boolean . TRUE : Boolean . FALSE ) ; } return canHandle ; } } return canHandleAsServerPreparedStatementNoCache ( sql ) ; }
 protected ITerminalStatement getLeastSignificantTerminalStatement_internal ( boolean [ ] bAbsolute ) { bAbsolute [ 0 ] = false ; return getStatement ( ) == null ? null : getStatement ( ) . getLeastSignificantTerminalStatement ( bAbsolute ) ; }
 public void setUrl ( URI url ) { this . url = url ; }
 public void setUserLevel ( java . lang . Integer userLevel ) { set ( " user _ level " , userLevel ) ; }
 public HdfsUrlStreamHandlerFactory ( final URLStreamHandlerFactory delegate ) { this . delegate = Optional . ofNullable ( delegate ) ; }
 private boolean isAliasValid ( String alias ) { if ( alias == null ) { return false ; } if ( ! alias . equals ( " / " ) && ( ! alias . startsWith ( " / " ) || alias . endsWith ( " / " ) ) ) { return false ; } return true ; }
 private Connection createNewConnection ( ) { Connection con = null ; try { if ( user == null ) { con = DriverManager . getConnection ( URL ) ; } else { con = DriverManager . getConnection ( URL , user , password ) ; } log ( " 连接池 " + name + " 创建一个新的连接 " ) ; } catch ( SQLException e ) { log ( " 无法创建下列URL的连接 : ▁ " + URL + " \n \t " + e . getNextException ( ) ) ; return null ; } return con ; }
 @ Override protected final void publishResults ( CharSequence constraint , FilterResults results ) throws AssertionError { lastConstraint = constraint ; lastResults = results ; adapter . notifyDataSetChanged ( ) ; }
 @ Override protected void validate ( ) throws Exception { super . validate ( ) ; EwsUtilities . validateParam ( this . getUrl ( ) , " Url " ) ; if ( ( this . getFrequency ( ) < 1 ) || ( this . getFrequency ( ) > 1440 ) ) { throw new ArgumentException ( String . format ( Strings . InvalidFrequencyValue , this . getFrequency ( ) ) ) ; } }
 @ Test public void checkoutAfterConvertFailureSuccess ( ) throws Exception { try { jcdkWrapper . convert ( ) ; } catch ( ConvertionException e ) { } assertThat ( jcdkWrapper . getJcdkOutput ( ) , startsWith ( " Error : ▁ Could ▁ not ▁ find ▁ or ▁ load ▁ main ▁ class ▁ " ) ) ; }
 @ Override public String getLoginCookieKey ( ) { return null ; }
 public Schema < DrillServiceInstance > cachedSchema ( ) { return DEFAULT_INSTANCE ; }
 public Configuration createSpecializedConfiguration ( BootstrapState state ) { return null ; }
 public void translate ( float posX , float posY ) { sprite . setPosition ( posX , posY ) ; }
 public void paintComponent ( Graphics g ) { g . drawImage ( this . cardImage , 2 , 2 , this ) ; }
 private void rollbackNoChecks ( ) throws SQLException { if ( getUseLocalTransactionState ( ) && versionMeetsMinimum ( 5 , 0 , 0 ) ) { if ( ! this . io . inTransactionOnServer ( ) ) { return ; } } execSQL ( null , " rollback " , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; }
 public void unregisterServlet ( Servlet servlet ) { unregisterServlet ( servlet , true ) ; }
 public java . lang . String getEmail ( ) { return get ( " email " ) ; }
 protected void setupForExpectedAssertionFailure ( String exceptionMessage ) throws Exception { addExpectedException ( AssertionFailure . class , null , exceptionMessage ) ; }
 public Connection getConnection ( String name , long time ) { ConnPool pool = ( ConnPool ) pools . get ( name ) ; if ( pool != null ) { return pool . getConnection ( time ) ; } return null ; }
 public InternalTable ( Map < String , Integer > columnIndexes , Iterable < Page > pages ) { this . columnIndexes = ImmutableMap . copyOf ( requireNonNull ( columnIndexes , " columnIndexes ▁ is ▁ null " ) ) ; this . pages = ImmutableList . copyOf ( requireNonNull ( pages , " pages ▁ is ▁ null " ) ) ; }
 public Research ( EntityPlayer player , String researchKey ) { super ( player ) ; this . researchKey = researchKey ; }
 private void unregisterFilter ( Filter filter , final boolean destroy ) { if ( filter != null ) { this . handlerRegistry . removeFilter ( filter , destroy ) ; this . localFilters . remove ( filter ) ; } }
 public void setEndDate ( java . util . Date endDate ) { set ( " end _ date " , endDate ) ; }
 public void abort ( Executor executor ) throws SQLException { SecurityManager sec = System . getSecurityManager ( ) ; if ( sec != null ) { sec . checkPermission ( ABORT_PERM ) ; } if ( executor == null ) { throw SQLError . createSQLException ( " Executor ▁ can ▁ not ▁ be ▁ null " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , getExceptionInterceptor ( ) ) ; } executor . execute ( new Runnable ( ) { public void run ( ) { try { abortInternal ( ) ; } catch ( SQLException e ) { throw new RuntimeException ( e ) ; } } } ) ; }
 @ Override public void checkCanCreateView ( TransactionId transactionId , Identity identity , AccessControlContext context , QualifiedObjectName viewName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , viewName . getObjectName ( ) , CREATE_VIEW ) ) { denyCreateView ( viewName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateView ( transactionId , identity , context , viewName ) ; } }
 public java . lang . String getNick ( ) { return get ( " nick " ) ; }
 public void writeTo ( Output output , DrillServiceInstance message ) throws IOException { if ( message . id != null ) output . writeString ( 1 , message . id , false ) ; if ( message . registrationTimeUTC != 0 ) output . writeInt64 ( 2 , message . registrationTimeUTC , false ) ; if ( message . endpoint != null ) output . writeObject ( 3 , message . endpoint , DrillbitEndpoint . getSchema ( ) , false ) ; }
 public int getExternalToIncrementalCompilerLimit ( ) { return myExternalToIncrementalCompiler ; }
 public String getKey ( ) { return key ; }
 public boolean useFuel ( ) { if ( this . getStoredPearls ( ) <= 0 ) { return false ; } this . getStackInSlot ( 0 ) ; this . decrStackSize ( 0 , 1 ) ; this . markDirty ( ) ; return true ; }
 public void registerQueryExecutionTime ( long queryTimeMs ) { if ( queryTimeMs > this . longestQueryTimeMs ) { this . longestQueryTimeMs = queryTimeMs ; repartitionPerformanceHistogram ( ) ; } addToPerformanceHistogram ( queryTimeMs , 1 ) ; if ( queryTimeMs < this . shortestQueryTimeMs ) { this . shortestQueryTimeMs = ( queryTimeMs == 0 ) ? 1 : queryTimeMs ; } this . numberOfQueriesIssued ++ ; this . totalQueryTimeMs += queryTimeMs ; }
 private void unregisterServlet ( Servlet servlet , final boolean destroy ) { if ( servlet != null ) { this . handlerRegistry . removeServlet ( servlet , destroy ) ; this . localServlets . remove ( servlet ) ; } }
 private void loadServerVariables ( ) throws SQLException { if ( getCacheServerConfiguration ( ) ) { createConfigCacheIfNeeded ( ) ; Map < String , String > cachedVariableMap = this . serverConfigCache . get ( getURL ( ) ) ; if ( cachedVariableMap != null ) { String cachedServerVersion = cachedVariableMap . get ( SERVER_VERSION_STRING_var_NAME ) ; if ( cachedServerVersion != null && this . io . getServerVersion ( ) != null && cachedServerVersion . equals ( this . io . getServerVersion ( ) ) ) { this . serverVariables = cachedVariableMap ; return ; } this . serverConfigCache . invalidate ( getURL ( ) ) ; } } java . sql . Statement stmt = null ; java . sql . ResultSet results = null ; try { stmt = getMetadataSafeStatement ( ) ; String version = this . dbmd . getDriverVersion ( ) ; if ( version != null && version . indexOf ( ' * ' ) != - 1 ) { StringBuilder buf = new StringBuilder ( version . length ( ) + 10 ) ; for ( int i = 0 ; i < version . length ( ) ; i ++ ) { char c = version . charAt ( i ) ; if ( c == ' * ' ) { buf . append ( " [ star ] " ) ; } else { buf . append ( c ) ; } } version = buf . toString ( ) ; } String versionComment = ( this . getParanoid ( ) || version == null ) ? " " : " /* ▁ " + version + " ▁ */ " ; this . serverVariables = new HashMap < String , String > ( ) ; try { if ( versionMeetsMinimum ( 5 , 1 , 0 ) ) { StringBuilder queryBuf = new StringBuilder ( versionComment ) . append ( " SELECT " ) ; queryBuf . append ( " ▁ ▁ @ @ session . auto _ increment _ increment ▁ AS ▁ auto _ increment _ increment " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ client ▁ AS ▁ character _ set _ client " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ connection ▁ AS ▁ character _ set _ connection " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ results ▁ AS ▁ character _ set _ results " ) ; queryBuf . append ( " , ▁ @ @ character _ set _ server ▁ AS ▁ character _ set _ server " ) ; queryBuf . append ( " , ▁ @ @ init _ connect ▁ AS ▁ init _ connect " ) ; queryBuf . append ( " , ▁ @ @ interactive _ timeout ▁ AS ▁ interactive _ timeout " ) ; if ( ! versionMeetsMinimum ( 5 , 5 , 0 ) ) { queryBuf . append ( " , ▁ @ @ language ▁ AS ▁ language " ) ; } queryBuf . append ( " , ▁ @ @ license ▁ AS ▁ license " ) ; queryBuf . append ( " , ▁ @ @ lower _ case _ table _ names ▁ AS ▁ lower _ case _ table _ names " ) ; queryBuf . append ( " , ▁ @ @ max _ allowed _ packet ▁ AS ▁ max _ allowed _ packet " ) ; queryBuf . append ( " , ▁ @ @ net _ buffer _ length ▁ AS ▁ net _ buffer _ length " ) ; queryBuf . append ( " , ▁ @ @ net _ write _ timeout ▁ AS ▁ net _ write _ timeout " ) ; queryBuf . append ( " , ▁ @ @ query _ cache _ size ▁ AS ▁ query _ cache _ size " ) ; queryBuf . append ( " , ▁ @ @ query _ cache _ type ▁ AS ▁ query _ cache _ type " ) ; queryBuf . append ( " , ▁ @ @ sql _ mode ▁ AS ▁ sql _ mode " ) ; queryBuf . append ( " , ▁ @ @ system _ time _ zone ▁ AS ▁ system _ time _ zone " ) ; queryBuf . append ( " , ▁ @ @ time _ zone ▁ AS ▁ time _ zone " ) ; queryBuf . append ( " , ▁ @ @ tx _ isolation ▁ AS ▁ tx _ isolation " ) ; queryBuf . append ( " , ▁ @ @ wait _ timeout ▁ AS ▁ wait _ timeout " ) ; results = stmt . executeQuery ( queryBuf . toString ( ) ) ; if ( results . next ( ) ) { ResultSetMetaData rsmd = results . getMetaData ( ) ; for ( int i = 1 ; i <= rsmd . getColumnCount ( ) ; i ++ ) { this . serverVariables . put ( rsmd . getColumnLabel ( i ) , results . getString ( i ) ) ; } } } else { results = stmt . executeQuery ( versionComment + " SHOW ▁ VARIABLES " ) ; while ( results . next ( ) ) { this . serverVariables . put ( results . getString ( 1 ) , results . getString ( 2 ) ) ; } } results . close ( ) ; results = null ; } catch ( SQLException ex ) { if ( ex . getErrorCode ( ) != MysqlErrorNumbers . ER_MUST_CHANGE_PASSWORD || getDisconnectOnExpiredPasswords ( ) ) { throw ex ; } } if ( getCacheServerConfiguration ( ) ) { this . serverVariables . put ( SERVER_VERSION_STRING_var_NAME , this . io . getServerVersion ( ) ) ; this . serverConfigCache . put ( getURL ( ) , this . serverVariables ) ; } } catch ( SQLException e ) { throw e ; } finally { if ( results != null ) { try { results . close ( ) ; } catch ( SQLException sqlE ) { } } if ( stmt != null ) { try { stmt . close ( ) ; } catch ( SQLException sqlE ) { } } } }
 public void setFetchSize ( int fetchSize ) { this . fetchSize = fetchSize ; }
 public boolean supportsQuotedIdentifiers ( ) { return this . hasQuotedIdentifiers ; }
 @ Override public Void visitProject ( Project project , FieldList value ) { FieldList fl = new FieldList ( ) ; for ( NamedExpression e : project . getSelections ( ) ) { fl . addProjected ( e . getExpr ( ) . accept ( finder , null ) ) ; } return null ; }
 @ Test public void testViews ( ) { SchemaTableName test1 = new SchemaTableName ( " test " , " test _ view1" ) ; SchemaTableName test2 = new SchemaTableName ( " test " , " test _ view2" ) ; metadata . createView ( SESSION , test1 , " test1" , false ) ; metadata . createView ( SESSION , test2 , " test2" , false ) ; List < SchemaTableName > list = metadata . listViews ( SESSION , " test " ) ; assertEqualsIgnoreOrder ( list , ImmutableList . of ( test1 , test2 ) ) ; Map < SchemaTableName , ConnectorViewDefinition > views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertEquals ( views . keySet ( ) , ImmutableSet . of ( test1 , test2 ) ) ; assertEquals ( views . get ( test1 ) . getViewData ( ) , " test1" ) ; assertEquals ( views . get ( test2 ) . getViewData ( ) , " test2" ) ; metadata . dropView ( SESSION , test1 ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertEquals ( views . keySet ( ) , ImmutableSet . of ( test2 ) ) ; metadata . dropView ( SESSION , test2 ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( " test " ) ) ; assertTrue ( views . isEmpty ( ) ) ; views = metadata . getViews ( SESSION , new SchemaTablePrefix ( ) ) ; assertTrue ( views . isEmpty ( ) ) ; }
 public ParentPrime ( Long id , String name ) { this . id = id ; this . name = name ; }
 public Variable wasNull ( ) { return wasNull ; }
 @ Test public void testArrayMethods ( ) throws Exception { Series s = Series . of ( " dsadsa " , 20.0 , 30.0 , 40.0 ) ; s . setIndex ( Index . of ( " a " , " b " , " c " , " d " ) ) ; System . out . println ( s . getIndex ( ) ) ; s = s . reindex ( Index . of ( " AAA " , " BBB " , " CCC " , " DDD " ) ) ; Series b = s . reshape ( 2 , 2 ) ; System . out . println ( b . getIndex ( ) ) ; System . out . println ( b ) ; for ( Object key : s . getIndex ( ) ) { System . out . println ( key + " ▁ " + b . get ( key ) + b . get ( key ) . getClass ( ) ) ; } System . out . println ( b . asArray ( ) ) ; List < Series > vsplit = Arrays . vsplit ( b , 2 ) ; System . out . println ( vsplit . get ( 0 ) ) ; }
 public List < V > get ( K key ) { List < V > mutable = getMutable ( key ) ; if ( mutable == null ) { return null ; } return ImmutableList . copyOf ( mutable ) ; }
 @ Override public Void visitFilter ( Filter filter , FieldList value ) { value . addReferenced ( filter . getExpr ( ) . accept ( finder , null ) ) ; return null ; }
 public void setSeq ( Integer seq ) { this . seq = seq ; }
 @ Override public < T extends Interceptor > List < T > getInterceptors ( Class < T > desiredInterceptorClass ) { return null ; }
 @ Test public void testAddColumnAfterDropColumn ( ) { assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; metadata . createTable ( SESSION , buildTable ( ImmutableMap . of ( ) , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " price " , BIGINT ) ) , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; ColumnHandle column = metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ; metadata . dropColumn ( SESSION , raptorTableHandle , column ) ; metadata . addColumn ( SESSION , raptorTableHandle , new ColumnMetadata ( " new _ col " , BIGINT ) ) ; assertNull ( metadata . getColumnHandles ( SESSION , tableHandle ) . get ( " orderkey " ) ) ; assertNotNull ( metadata . getColumnHandles ( SESSION , raptorTableHandle ) . get ( " new _ col " ) ) ; }
 public void setThermalGeneratingUnit ( ThermalGeneratingUnit newThermalGeneratingUnit ) { if ( newThermalGeneratingUnit != thermalGeneratingUnit ) { NotificationChain msgs = null ; if ( thermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) thermalGeneratingUnit ) . eInverseRemove ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; if ( newThermalGeneratingUnit != null ) msgs = ( ( InternalEObject ) newThermalGeneratingUnit ) . eInverseAdd ( this , ProductionPackage . THERMAL_GENERATING_UNIT__HEAT_RATE_CURVE , ThermalGeneratingUnit . class , msgs ) ; msgs = basicSetThermalGeneratingUnit ( newThermalGeneratingUnit , msgs ) ; if ( msgs != null ) msgs . dispatch ( ) ; } else if ( eNotificationRequired ( ) ) eNotify ( new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , newThermalGeneratingUnit , newThermalGeneratingUnit ) ) ; }
 @ Override public void checkCanCreateSchema ( TransactionId transactionId , Identity identity , AccessControlContext context , CatalogSchemaName schemaName ) { if ( shouldDenyPrivilege ( identity . getUser ( ) , schemaName . getSchemaName ( ) , CREATE_SCHEMA ) ) { denyCreateSchema ( schemaName . toString ( ) ) ; } if ( denyPrivileges . isEmpty ( ) ) { super . checkCanCreateSchema ( transactionId , identity , context , schemaName ) ; } }
 @ Override public void onBeaconServiceConnect ( ) { obtainRegionsToScan ( ) ; }
 public void setNumeroItem ( String numeroItem ) { this . numeroItem = numeroItem ; }
 @ Override public void configure ( final JsonNode json ) throws ActivityConfigurationException { this . json = json ; }
 public java . sql . PreparedStatement prepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
 public java . sql . Savepoint setSavepoint ( String name ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { MysqlSavepoint savepoint = new MysqlSavepoint ( name , getExceptionInterceptor ( ) ) ; setSavepoint ( savepoint ) ; return savepoint ; } }
 public java . sql . PreparedStatement prepareStatement ( String sql ) throws SQLException { return prepareStatement ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
 public CardPanel ( String imagePath ) { this . loadCardImage ( imagePath ) ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql , int autoGenKeyIndex ) throws SQLException { java . sql . PreparedStatement pStmt = clientPrepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( autoGenKeyIndex == java . sql . Statement . RETURN_GENERATED_KEYS ) ; return pStmt ; }
 public int getAmount ( ) { return amount ; }
 public void unregisterStatement ( Statement stmt ) { this . openStatements . remove ( stmt ) ; }
 public boolean equals ( Object obj ) { if ( this == obj ) return true ; if ( ! super . equals ( obj ) ) return false ; if ( getClass ( ) != obj . getClass ( ) ) return false ; Tiger other = ( Tiger ) obj ; if ( someTigerField == null ) { if ( other . someTigerField != null ) return false ; } else if ( ! someTigerField . equals ( other . someTigerField ) ) return false ; return true ; }
 private void init ( ) { InputStream is = getClass ( ) . getResourceAsStream ( CONF_FILE_NAME ) ; Properties dbProps = new Properties ( ) ; try { dbProps . load ( is ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . err . println ( " 不能读取属性文件 . ▁ " + " 请确保db . properties在CLASSPATH指定的路径中 " ) ; return ; } String logFile = dbProps . getProperty ( " logfile " , " DBConnectionManager . log " ) ; try { log = new PrintWriter ( new FileWriter ( logFile , true ) , true ) ; } catch ( IOException e ) { System . err . println ( " 无法打开日志文件 : ▁ " + logFile ) ; log = new PrintWriter ( System . err ) ; } loadDrivers ( dbProps ) ; createPools ( dbProps ) ; }
 @ Override public String toString ( ) { if ( eIsProxy ( ) ) return super . toString ( ) ; StringBuffer result = new StringBuffer ( super . toString ( ) ) ; result . append ( " ▁ ( isNetGrossP : ▁ " ) ; result . append ( isNetGrossP ) ; result . append ( ' ) ' ) ; return result . toString ( ) ; }
 private double rGetPlanCosts ( CPlanMemoTable memo , final Hop current , HashSet < VisitMarkCost > visited , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan , HashMap < Long , Double > computeCosts , CostVector costsCurrent , TemplateType currentType , final double costBound ) { final long currentHopId = current . getHopID ( ) ; if ( ! visited . add ( new VisitMarkCost ( currentHopId , ( costsCurrent == null || currentType == TemplateType . MAGG ) ? - 1 : costsCurrent . ID ) ) ) return 0 ; MemoTableEntry best = null ; boolean opened = ( currentType == null ) ; if ( memo . contains ( currentHopId ) ) { if ( currentType == null ) { for ( MemoTableEntry me : memo . get ( currentHopId ) ) best = me . isValid ( ) && hasNoRefToMatPoint ( currentHopId , me , matPoints , plan ) && BasicPlanComparator . icompare ( me , best ) < 0 ? me : best ; opened = true ; } else { for ( MemoTableEntry me : memo . get ( currentHopId ) ) best = ( me . type == currentType || me . type == TemplateType . CELL ) && hasNoRefToMatPoint ( currentHopId , me , matPoints , plan ) && TypedPlanComparator . icompare ( me , best , currentType ) < 0 ? me : best ; } } CostVector costVect = ! opened ? costsCurrent : new CostVector ( getSize ( current ) ) ; double costs = 0 ; if ( opened && best != null && best . type == TemplateType . MAGG ) { if ( best . input1 == currentHopId ) for ( int i = 1 ; i < 3 ; i ++ ) { if ( ! best . isPlanRef ( i ) ) continue ; costs += rGetPlanCosts ( memo , memo . getHopRefs ( ) . get ( best . input ( i ) ) , visited , part , matPoints , plan , computeCosts , costVect , TemplateType . MAGG , costBound - costs ) ; if ( costs >= costBound ) return Double . POSITIVE_INFINITY ; } else return 0 ; } if ( computeCosts . containsKey ( currentHopId ) ) costVect . computeCosts += computeCosts . get ( currentHopId ) ; for ( int i = 0 ; i < current . getInput ( ) . size ( ) ; i ++ ) { Hop c = current . getInput ( ) . get ( i ) ; if ( best != null && best . isPlanRef ( i ) ) costs += rGetPlanCosts ( memo , c , visited , part , matPoints , plan , computeCosts , costVect , best . type , costBound - costs ) ; else if ( best != null && isImplicitlyFused ( current , i , best . type ) ) costVect . addInputSize ( c . getInput ( ) . get ( 0 ) . getHopID ( ) , getSize ( c ) ) ; else { if ( part . getPartition ( ) . contains ( c . getHopID ( ) ) ) costs += rGetPlanCosts ( memo , c , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; if ( costVect != null && c . getDataType ( ) . isMatrix ( ) ) costVect . addInputSize ( c . getHopID ( ) , getSize ( c ) ) ; } if ( costs >= costBound ) return Double . POSITIVE_INFINITY ; } if ( opened ) { double memInputs = sumInputMemoryEstimates ( memo , costVect ) ; double tmpCosts = costVect . outSize * 8 / WRITE_BANDWIDTH_MEM + Math . max ( memInputs / READ_BANDWIDTH_MEM , costVect . computeCosts / COMPUTE_BANDWIDTH ) ; if ( memInputs > OptimizerUtils . getLocalMemBudget ( ) ) tmpCosts += costVect . getSideInputSize ( ) * 8 / READ_BANDWIDTH_BROADCAST ; Hop driver = memo . getHopRefs ( ) . get ( costVect . getMaxInputSizeHopID ( ) ) ; if ( best != null && best . type == TemplateType . OUTER ) tmpCosts *= driver . dimsKnown ( true ) ? driver . getSparsity ( ) : SPARSE_SAFE_SPARSITY_EST ; else if ( memInputs <= OptimizerUtils . getLocalMemBudget ( ) && sumTmpInputOutputSize ( memo , costVect ) * 8 > LazyWriteBuffer . getWriteBufferLimit ( ) ) tmpCosts += costVect . outSize * 8 / WRITE_BANDWIDTH_IO ; costs += tmpCosts ; if ( LOG . isTraceEnabled ( ) ) { String type = ( best != null ) ? best . type . name ( ) : " HOP " ; LOG . trace ( " Cost ▁ vector ▁ ( " + type + " ▁ " + currentHopId + " ) : ▁ " + costVect + " ▁ - > ▁ " + tmpCosts ) ; } } else if ( part . getExtConsumed ( ) . contains ( current . getHopID ( ) ) ) { costs += rGetPlanCosts ( memo , current , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; } if ( costs < 0 || Double . isNaN ( costs ) || Double . isInfinite ( costs ) ) throw new RuntimeException ( " Wrong ▁ cost ▁ estimate : ▁ " + costs ) ; return costs ; }
 public int getServerMinorVersion ( ) { return this . io . getServerMinorVersion ( ) ; }
 @ Override void start ( ) throws IOException { }
 @ Deprecated public MySQLConnection getLoadBalanceSafeProxy ( ) { return getMultiHostSafeProxy ( ) ; }
 public SafariDriverFactory ( final DriverConfig cfg ) { super ( cfg ) ; }
 @ Override public void setValueAt ( Object aValue , int rowIndex , int columnIndex ) { if ( getColumnClass ( columnIndex ) == Boolean . class ) { dataList . get ( rowIndex ) . setProduced ( ( Boolean ) aValue ) ; fireTableCellUpdated ( rowIndex , columnIndex ) ; } }
 public String getMailStoreLogInformation ( ) { String ssl = " " ; if ( isSecureProtocol ( ) ) { ssl = " ▁ ( SSL ▁ enabled " + ( dummyTrustManager ? " ▁ using ▁ DummyTrustManager ) " : " ) " ) ; } return protocol + " : // " + host + " : " + port + ssl + " , ▁ folder = " + folderName ; }
 public void rollback ( final Savepoint savepoint ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { if ( versionMeetsMinimum ( 4 , 0 , 14 ) || versionMeetsMinimum ( 4 , 1 , 1 ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . rollback ( savepoint ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } StringBuilder rollbackQuery = new StringBuilder ( " ROLLBACK ▁ TO ▁ SAVEPOINT ▁ " ) ; rollbackQuery . append ( ' ` ' ) ; rollbackQuery . append ( savepoint . getSavepointName ( ) ) ; rollbackQuery . append ( ' ` ' ) ; java . sql . Statement stmt = null ; try { stmt = getMetadataSafeStatement ( ) ; stmt . executeUpdate ( rollbackQuery . toString ( ) ) ; } catch ( SQLException sqlEx ) { int errno = sqlEx . getErrorCode ( ) ; if ( errno == 1181 ) { String msg = sqlEx . getMessage ( ) ; if ( msg != null ) { int indexOfError153 = msg . indexOf ( "153" ) ; if ( indexOfError153 != - 1 ) { throw SQLError . createSQLException ( " Savepoint ▁ ' " + savepoint . getSavepointName ( ) + " ' ▁ does ▁ not ▁ exist " , SQLError . SQL_STATE_ILLEGAL_ARGUMENT , errno , getExceptionInterceptor ( ) ) ; } } } if ( getIgnoreNonTxTables ( ) && ( sqlEx . getErrorCode ( ) != SQLError . ER_WARNING_NOT_COMPLETE_ROLLBACK ) ) { throw sqlEx ; } if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlEx . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ rollback ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlEx ; } finally { closeStatement ( stmt ) ; } } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } else { throw SQLError . createSQLFeatureNotSupportedException ( ) ; } } }
 private void checkAndCreatePerformanceHistogram ( ) { if ( this . perfMetricsHistCounts == null ) { this . perfMetricsHistCounts = new int [ HISTOGRAM_BUCKETS ] ; } if ( this . perfMetricsHistBreakpoints == null ) { this . perfMetricsHistBreakpoints = new long [ HISTOGRAM_BUCKETS ] ; } }
 public T getItem ( int position ) throws ArrayIndexOutOfBoundsException { return ( ( List < T > ) lastResults . values ) . get ( position ) ; }
 public StatusBarFooter ( final ApplicationWindow parent , final int style ) { super ( parent , style ) ; final FillLayout layout = new FillLayout ( ) ; layout . marginWidth = 5 ; setLayout ( layout ) ; status = new CLabel ( this , SWT . NONE ) ; }
 @ Override public void onOpen ( SQLiteDatabase db ) { super . onOpen ( db ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . JELLY_BEAN ) { setWriteAheadLoggingEnabled ( true ) ; } else if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { db . enableWriteAheadLogging ( ) ; } }
 @ Setup public void setup ( ) { super . setup ( numSortChannels , totalChannels , numMergeSources , pagesCount ) ; }
 TestImageVisitor ( ) { }
 @ Override public Set < SchemaPath > visitUnknown ( LogicalExpression e , Void value ) { Set < SchemaPath > paths = Sets . newHashSet ( ) ; for ( LogicalExpression ex : e ) { paths . addAll ( ex . accept ( this , null ) ) ; } return paths ; }
 @ JsonProperty ( " numeroAto " ) @ NotNull public String getNumeroAto ( ) { return numeroAto ; }
 public void testOverwrite ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; Zoo zoo = new Zoo ( ) ; zoo . largestAnimal = filledBear ( ) ; Zoo overwriteZoo = new Zoo ( ) ; overwriteZoo . largestAnimal = filledTiger ( ) ; byte [ ] data = ProtostuffIOUtil . toByteArray ( overwriteZoo , schema , buf ( ) ) ; ProtostuffIOUtil . mergeFrom ( data , zoo , schema ) ; assertTrue ( zoo . largestAnimal instanceof Tiger ) ; }
 private Long getTableDistributionId ( long tableId ) { try ( Handle handle = dbi . open ( ) ) { return handle . createQuery ( " SELECT ▁ distribution _ id ▁ FROM ▁ tables ▁ WHERE ▁ table _ id ▁ = ▁ ? " ) . bind ( 0 , tableId ) . map ( LongMapper . FIRST ) . first ( ) ; } }
 public void reportQueryTime ( long millisOrNanos ) { synchronized ( getConnectionMutex ( ) ) { this . queryTimeCount ++ ; this . queryTimeSum += millisOrNanos ; this . queryTimeSumSquares += ( millisOrNanos * millisOrNanos ) ; this . queryTimeMean = ( ( this . queryTimeMean * ( this . queryTimeCount - 1 ) ) + millisOrNanos ) / this . queryTimeCount ; } }
 @ Test public void onTwoElementsShouldReturnJoinedValues ( ) { List < String > values = Arrays . asList ( " hello " , " world " ) ; String result = StringUtils . join ( " ▁ " , values ) ; assertThat ( result ) . isEqualTo ( " hello ▁ world " ) ; }
 public boolean hasSameProperties ( Connection c ) { return this . props . equals ( c . getProperties ( ) ) ; }
 public void setReadOnly ( boolean readOnlyFlag ) throws SQLException { checkClosed ( ) ; setReadOnlyInternal ( readOnlyFlag ) ; }
 @ Override public int getPixel ( int x , int y ) { return bufImg . getRGB ( x , y ) ; }
 public Spannable highlightFilteredSubstring ( String name ) { SpannableString string = new SpannableString ( name ) ; if ( ! isFiltered ( ) ) return string ; String filteredString = lastConstraint . toString ( ) . trim ( ) . toLowerCase ( ) ; String lowercase = name . toLowerCase ( ) ; int length = filteredString . length ( ) ; int index = - 1 , prevIndex ; do { prevIndex = index ; index = lowercase . indexOf ( filteredString , prevIndex + 1 ) ; if ( index == - 1 ) { break ; } string . setSpan ( new ForegroundColorSpan ( highlightColor ) , index , index + length , 0 ) ; } while ( true ) ; return string ; }
 private void initializeDriverProperties ( Properties info ) throws SQLException { initializeProperties ( info ) ; String exceptionInterceptorClasses = getExceptionInterceptors ( ) ; if ( exceptionInterceptorClasses != null && ! " " . equals ( exceptionInterceptorClasses ) ) { this . exceptionInterceptor = new ExceptionInterceptorChain ( exceptionInterceptorClasses ) ; } this . usePlatformCharsetConverters = getUseJvmCharsetConverters ( ) ; this . log = LogFactory . getLogger ( getLogger ( ) , LOGGER_INSTANCE_NAME , getExceptionInterceptor ( ) ) ; if ( getProfileSql ( ) || getUseUsageAdvisor ( ) ) { this . eventSink = ProfilerEventHandlerFactory . getInstance ( getMultiHostSafeProxy ( ) ) ; } if ( getCachePreparedStatements ( ) ) { createPreparedStatementCaches ( ) ; } if ( getNoDatetimeStringSync ( ) && getUseTimezone ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ enable ▁ noDatetimeStringSync ▁ and ▁ useTimezone ▁ configuration ▁ properties ▁ at ▁ the ▁ same ▁ time " , SQLError . SQL_STATE_INVALID_CONNECTION_ATTRIBUTE , getExceptionInterceptor ( ) ) ; } if ( getCacheCallableStatements ( ) ) { this . parsedCallableStatementCache = new LRUCache ( getCallableStatementCacheSize ( ) ) ; } if ( getAllowMultiQueries ( ) ) { setCacheResultSetMetadata ( false ) ; } if ( getCacheResultSetMetadata ( ) ) { this . resultSetMetadataCache = new LRUCache ( getMetadataCacheSize ( ) ) ; } if ( getSocksProxyHost ( ) != null ) { setSocketFactoryClassName ( " com . mysql . jdbc . SocksProxySocketFactory " ) ; } }
 public void setSchema ( String schema ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; } }
 @ Override public boolean isMonitoring ( ) { return monitoring ; }
 public void visitExceptionInfo ( Clazz clazz , Method method , CodeAttribute codeAttribute , ExceptionInfo exceptionInfo ) { int catchType = exceptionInfo . u2catchType ; if ( catchType != 0 ) { clazz . constantPoolEntryAccept ( catchType , constantVisitor ) ; } }
 @ Override public String getWebsudoRequestKey ( ) { return null ; }
 public int getAutoIncrementIncrement ( ) { return this . autoIncrementIncrement ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql ) throws SQLException { return clientPrepareStatement ( sql , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
 public void removeItemFromDatabase ( DatabaseItem item ) { if ( ! _items . containsKey ( item . getName ( ) ) ) return ; _items . remove ( item . getName ( ) ) ; WindowMain . removeItemFromListView ( item ) ; WindowMain . removeItemFromTableView ( item ) ; }
 public final void setValue ( final String value ) { super . setTextContent ( value ) ; }
 public NotificationChain basicSetThermalGeneratingUnit ( ThermalGeneratingUnit newThermalGeneratingUnit , NotificationChain msgs ) { ThermalGeneratingUnit oldThermalGeneratingUnit = thermalGeneratingUnit ; thermalGeneratingUnit = newThermalGeneratingUnit ; if ( eNotificationRequired ( ) ) { ENotificationImpl notification = new ENotificationImpl ( this , Notification . SET , ProductionPackage . HEAT_RATE_CURVE__THERMAL_GENERATING_UNIT , oldThermalGeneratingUnit , newThermalGeneratingUnit ) ; if ( msgs == null ) msgs = notification ; else msgs . add ( notification ) ; } return msgs ; }
 public java . sql . PreparedStatement prepareStatement ( String sql , int [ ] autoGenKeyIndexes ) throws SQLException { java . sql . PreparedStatement pStmt = prepareStatement ( sql ) ; ( ( com . mysql . jdbc . PreparedStatement ) pStmt ) . setRetrieveGeneratedKeys ( ( autoGenKeyIndexes != null ) && ( autoGenKeyIndexes . length > 0 ) ) ; return pStmt ; }
 protected < T > T createException ( Class < T > classObject , Object exceptionMessage ) throws Exception { return createException ( classObject , exceptionMessage , null ) ; }
 public Log getLog ( ) throws SQLException { return this . log ; }
 @ Test public void testListTableColumns ( ) { metadata . createTable ( SESSION , getOrdersTable ( ) , false ) ; Map < SchemaTableName , List < ColumnMetadata > > columns = metadata . listTableColumns ( SESSION , new SchemaTablePrefix ( ) ) ; assertEquals ( columns , ImmutableMap . of ( DEFAULT_TEST_ORDERS , getOrdersTable ( ) . getColumns ( ) ) ) ; }
 @ Override public boolean contains ( @ Nullable Object object ) { return map . containsKey ( object ) ; }
 @ Override void visitEnclosingElement ( ImageElement element ) throws IOException { }
 public int getActiveStatementCount ( ) { return this . openStatements . size ( ) ; }
 public MailConfiguration copy ( ) { try { MailConfiguration copy = ( MailConfiguration ) clone ( ) ; copy . recipients = new HashMap < Message . RecipientType , String > ( ) ; copy . recipients . putAll ( this . recipients ) ; return copy ; } catch ( CloneNotSupportedException e ) { throw new RuntimeCamelException ( e ) ; } }
 public void setUsername ( String username ) { this . username = username ; if ( getRecipients ( ) . size ( ) == 0 ) { String address = username ; if ( address . indexOf ( " @ " ) == - 1 ) { address += " @ " + host ; } setTo ( address ) ; } }
 private void repartitionHistogram ( int [ ] histCounts , long [ ] histBreakpoints , long currentLowerBound , long currentUpperBound ) { if ( this . oldHistCounts == null ) { this . oldHistCounts = new int [ histCounts . length ] ; this . oldHistBreakpoints = new long [ histBreakpoints . length ] ; } System . arraycopy ( histCounts , 0 , this . oldHistCounts , 0 , histCounts . length ) ; System . arraycopy ( histBreakpoints , 0 , this . oldHistBreakpoints , 0 , histBreakpoints . length ) ; createInitialHistogram ( histBreakpoints , currentLowerBound , currentUpperBound ) ; for ( int i = 0 ; i < HISTOGRAM_BUCKETS ; i ++ ) { addToHistogram ( histCounts , histBreakpoints , this . oldHistBreakpoints [ i ] , this . oldHistCounts [ i ] , currentLowerBound , currentUpperBound ) ; } }
 private java . sql . DatabaseMetaData getMetaData ( boolean checkClosed , boolean checkForInfoSchema ) throws SQLException { if ( checkClosed ) { checkClosed ( ) ; } return com . mysql . jdbc . DatabaseMetaData . getInstance ( getMultiHostSafeProxy ( ) , this . database , checkForInfoSchema ) ; }
 public Connection duplicate ( ) throws SQLException { return new ConnectionImpl ( this . origHostToConnectTo , this . origPortToConnectTo , this . props , this . origDatabaseToConnectTo , this . myURL ) ; }
 protected void addExpectedNullPointerException ( ) throws Exception { expectedException = new NullPointerException ( null ) ; expectedExceptionClass = NullPointerException . class ; expectedExceptionMessage = null ; }
 @ Test public void testSerialization ( ) throws Exception { User user ; Group group ; user = new User ( ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; user = reserialize ( user ) ; assertTrue ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; Transaction tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = new User ( ) ; userId = user . getId ( ) ; user . setName ( " testUser " ) ; user . setLogin ( " testLogin " ) ; user . setGroup ( em . find ( Group . class , UUID . fromString ( "0fa2b1a5-1d68-4d69-9fbd - dff348347f93" ) ) ) ; em . persist ( user ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . find ( User . class , userId ) ; assertNotNull ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; group = user . getGroup ( ) ; assertNotNull ( group ) ; assertFalse ( BaseEntityInternalAccess . isNew ( group ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( group ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( group ) ) ; user = reserialize ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } user . setName ( " changed ▁ name " ) ; tx = cont . persistence ( ) . createTransaction ( ) ; try { EntityManager em = cont . persistence ( ) . getEntityManager ( ) ; user = em . merge ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isDetached ( user ) ) ; tx . commit ( ) ; } finally { tx . end ( ) ; } assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; user = reserialize ( user ) ; assertFalse ( BaseEntityInternalAccess . isNew ( user ) ) ; assertFalse ( BaseEntityInternalAccess . isManaged ( user ) ) ; assertTrue ( BaseEntityInternalAccess . isDetached ( user ) ) ; }
 public java . sql . PreparedStatement clientPrepareStatement ( String sql , String [ ] autoGenKeyColNames ) throws SQLException { PreparedStatement pStmt = ( PreparedStatement ) clientPrepareStatement ( sql ) ; pStmt . setRetrieveGeneratedKeys ( ( autoGenKeyColNames != null ) && ( autoGenKeyColNames . length > 0 ) ) ; return pStmt ; }
 @ Test public void testHead ( ) throws Exception { Series a = new TypeInferenceBuilder ( ) . set ( " a " , 10 ) . set ( " b " , 100 ) . set ( " c " , 1 ) . set ( " d " , 11 ) . build ( ) ; System . out . println ( a ) ; Series sort = a . sort ( SortOrder . ASC ) ; System . out . println ( sort ) ; }
 public void dumpTestcaseQuery ( String query ) { System . err . println ( query ) ; }
 public String getContentType ( ) { return contentType ; }
 protected Future sendRequest ( Request urlRequest , DownloadResponseHandler responseHandler , String saveFile ) { final Future < ? > request = threadPool . submit ( new DownloadThread ( this , httpClient , urlRequest , responseHandler , saveFile ) ) ; if ( urlRequest . tag ( ) != null ) { List < WeakReference < Future < ? > > > requestList = requestMap . get ( urlRequest . tag ( ) ) ; if ( requestList == null ) { requestList = new LinkedList < > ( ) ; requestMap . put ( urlRequest . tag ( ) , requestList ) ; } requestList . add ( new WeakReference < Future < ? > > ( request ) ) ; } return request ; }
 public void dump ( DataOutputStream out ) throws IOException { index = getTargetOffset ( ) ; out . writeByte ( opcode ) ; out . writeInt ( index ) ; }
 private CallableStatement parseCallableStatement ( String sql ) throws SQLException { Object escapedSqlResult = EscapeProcessor . escapeSQL ( sql , serverSupportsConvertFn ( ) , getMultiHostSafeProxy ( ) ) ; boolean isFunctionCall = false ; String parsedSql = null ; if ( escapedSqlResult instanceof EscapeProcessorResult ) { parsedSql = ( ( EscapeProcessorResult ) escapedSqlResult ) . escapedSql ; isFunctionCall = ( ( EscapeProcessorResult ) escapedSqlResult ) . callingStoredFunction ; } else { parsedSql = ( String ) escapedSqlResult ; isFunctionCall = false ; } return CallableStatement . getInstance ( getMultiHostSafeProxy ( ) , parsedSql , this . database , isFunctionCall ) ; }
 @ Test public void testZKSuccessfulConnectionNegativeConnectTries ( ) throws SQLException { Connection connection = testDrillDriver . connect ( " jdbc : drill : zk = local ; tries = - 1" , JdbcAssert . getDefaultProperties ( ) ) ; assertNotNull ( connection ) ; connection . close ( ) ; }
 private void setupServerForTruncationChecks ( ) throws SQLException { if ( getJdbcCompliantTruncation ( ) ) { if ( versionMeetsMinimum ( 5 , 0 , 2 ) ) { String currentSqlMode = this . serverVariables . get ( " sql _ mode " ) ; boolean strictTransTablesIsSet = StringUtils . indexOfIgnoreCase ( currentSqlMode , " STRICT _ TRANS _ TABLES " ) != - 1 ; if ( currentSqlMode == null || currentSqlMode . length ( ) == 0 || ! strictTransTablesIsSet ) { StringBuilder commandBuf = new StringBuilder ( " SET ▁ sql _ mode = ' " ) ; if ( currentSqlMode != null && currentSqlMode . length ( ) > 0 ) { commandBuf . append ( currentSqlMode ) ; commandBuf . append ( " , " ) ; } commandBuf . append ( " STRICT _ TRANS _ TABLES ' " ) ; execSQL ( null , commandBuf . toString ( ) , - 1 , null , DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY , false , this . database , null , false ) ; setJdbcCompliantTruncation ( false ) ; } else if ( strictTransTablesIsSet ) { setJdbcCompliantTruncation ( false ) ; } } } }
 @ Test public void testTransactionTableWrite ( ) { long transactionId = 1 ; ConnectorOutputTableHandle outputHandle = metadata . beginCreateTable ( SESSION , getOrdersTable ( ) , Optional . empty ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertNull ( transactionSuccessful ( transactionId ) ) ; metadata . finishCreateTable ( SESSION , outputHandle , ImmutableList . of ( ) ) ; assertTrue ( transactionExists ( transactionId ) ) ; assertTrue ( transactionSuccessful ( transactionId ) ) ; }
 public void testMerge ( ) throws Exception { Schema < Zoo > schema = RuntimeSchema . getSchema ( Zoo . class ) ; final String properName = " elephant " ; Elephant elephant = new Elephant ( ) ; elephant . someElephantField = " elephantField " ; elephant . normalBodyTemperature = 25f ; elephant . properName = properName ; Zoo zoo = new Zoo ( ) ; zoo . largestAnimal = elephant ; Elephant sickElephant = new Elephant ( ) ; sickElephant . normalBodyTemperature = 50f ; sickElephant . someElephantField = " sickElephantField " ; Zoo mergeZoo = new Zoo ( ) ; mergeZoo . largestAnimal = sickElephant ; byte [ ] data = ProtostuffIOUtil . toByteArray ( mergeZoo , schema , buf ( ) ) ; ProtostuffIOUtil . mergeFrom ( data , zoo , schema ) ; assertTrue ( zoo . largestAnimal == elephant ) ; assertTrue ( elephant . normalBodyTemperature == 50f ) ; assertEquals ( elephant . someElephantField , " sickElephantField " ) ; assertTrue ( properName == elephant . properName ) ; }
 public void rollback ( ) throws SQLException { synchronized ( getConnectionMutex ( ) ) { checkClosed ( ) ; try { if ( this . connectionLifecycleInterceptors != null ) { IterateBlock < Extension > iter = new IterateBlock < Extension > ( this . connectionLifecycleInterceptors . iterator ( ) ) { @ Override void forEach ( Extension each ) throws SQLException { if ( ! ( ( ConnectionLifecycleInterceptor ) each ) . rollback ( ) ) { this . stopIterating = true ; } } } ; iter . doForAll ( ) ; if ( ! iter . fullIteration ( ) ) { return ; } } if ( this . autoCommit && ! getRelaxAutoCommit ( ) ) { throw SQLError . createSQLException ( " Can ' t ▁ call ▁ rollback ▁ when ▁ autocommit = true " , SQLError . SQL_STATE_CONNECTION_NOT_OPEN , getExceptionInterceptor ( ) ) ; } else if ( this . transactionsSupported ) { try { rollbackNoChecks ( ) ; } catch ( SQLException sqlEx ) { if ( getIgnoreNonTxTables ( ) && ( sqlEx . getErrorCode ( ) == SQLError . ER_WARNING_NOT_COMPLETE_ROLLBACK ) ) { return ; } throw sqlEx ; } } } catch ( SQLException sqlException ) { if ( SQLError . SQL_STATE_COMMUNICATION_LINK_FAILURE . equals ( sqlException . getSQLState ( ) ) ) { throw SQLError . createSQLException ( " Communications ▁ link ▁ failure ▁ during ▁ rollback ( ) . ▁ Transaction ▁ resolution ▁ unknown . " , SQLError . SQL_STATE_TRANSACTION_RESOLUTION_UNKNOWN , getExceptionInterceptor ( ) ) ; } throw sqlException ; } finally { this . needsPing = this . getReconnectAtTxEnd ( ) ; } } }
 @ Override public ExceptionInterceptor getExceptionInterceptor ( ) { return this . exceptionInterceptor ; }
 public boolean isCursorFetchEnabled ( ) throws SQLException { return ( versionMeetsMinimum ( 5 , 0 , 2 ) && getUseCursorFetch ( ) ) ; }
 public Configuration addMapping ( InputStream stream ) { return null ; }
 @ Test public void testCreateBucketedTableExistingDistribution ( ) { MetadataDao metadataDao = dbi . onDemand ( MetadataDao . class ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ) ; ConnectorTableMetadata table = getOrdersTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , DISTRIBUTION_NAME_PROPERTY , " orders " ) ) ; metadata . createTable ( SESSION , table , false ) ; ConnectorTableHandle tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_ORDERS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; RaptorTableHandle raptorTableHandle = ( RaptorTableHandle ) tableHandle ; long tableId = raptorTableHandle . getTableId ( ) ; assertEquals ( raptorTableHandle . getTableId ( ) , 1 ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_ORDERS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; assertNull ( metadata . getTableHandle ( SESSION , DEFAULT_TEST_LINEITEMS ) ) ; table = getLineItemsTable ( ImmutableMap . of ( BUCKET_COUNT_PROPERTY , 16 , BUCKETED_ON_PROPERTY , ImmutableList . of ( " orderkey " ) , DISTRIBUTION_NAME_PROPERTY , " orders " ) ) ; metadata . createTable ( SESSION , table , false ) ; tableHandle = metadata . getTableHandle ( SESSION , DEFAULT_TEST_LINEITEMS ) ; assertInstanceOf ( tableHandle , RaptorTableHandle . class ) ; raptorTableHandle = ( RaptorTableHandle ) tableHandle ; tableId = raptorTableHandle . getTableId ( ) ; assertEquals ( tableId , 2 ) ; assertTableColumnsEqual ( metadataDao . listBucketColumns ( tableId ) , ImmutableList . of ( new TableColumn ( DEFAULT_TEST_LINEITEMS , " orderkey " , BIGINT , 1 , 0 , OptionalInt . of ( 0 ) , OptionalInt . empty ( ) , false ) ) ) ; assertEquals ( raptorTableHandle . getBucketCount ( ) , OptionalInt . of ( 16 ) ) ; assertEquals ( getTableDistributionId ( tableId ) , Long . valueOf ( 1 ) ) ; }
 public Contato obterContato ( String nome ) { return this . contatosMap . get ( nome ) ; }
 private void log ( Throwable e , String msg ) { log . println ( new Date ( ) + " : ▁ " + msg ) ; e . printStackTrace ( log ) ; }
 public Builder add ( Object ... values ) { pageBuilder . declarePosition ( ) ; for ( int i = 0 ; i < types . size ( ) ; i ++ ) { writeNativeValue ( types . get ( i ) , pageBuilder . getBlockBuilder ( i ) , values [ i ] ) ; } if ( pageBuilder . isFull ( ) ) { flushPage ( ) ; } return this ; }
 @ Test public final void executeBridgeMethod ( ) throws Exception { final Method compareTo = Comments . class . getDeclaredMethod ( " compareTo " , Object . class ) ; compareTo . invoke ( comments , comments ) ; }
 @ Test public void testEmptyExtensionTypeJson ( ) { DummyPatientWithExtensions patient = new DummyPatientWithExtensions ( ) ; patient . addName ( ) . addFamily ( " Smith " ) . addGiven ( " John " ) . addGiven ( " Quincy " ) . addSuffix ( " Jr " ) ; String messageString = ourCtx . newJsonParser ( ) . encodeResourceToString ( patient ) ; ourLog . info ( messageString ) ; assertThat ( messageString , not ( containsString ( " xtension " ) ) ) ; }
 private double getPlanCost ( CPlanMemoTable memo , PlanPartition part , InterestingPoint [ ] matPoints , boolean [ ] plan , HashMap < Long , Double > computeCosts , final double costBound ) { HashSet < VisitMarkCost > visited = new HashSet < > ( ) ; double costs = 0 ; int rem = part . getRoots ( ) . size ( ) ; for ( Long hopID : part . getRoots ( ) ) { costs += rGetPlanCosts ( memo , memo . getHopRefs ( ) . get ( hopID ) , visited , part , matPoints , plan , computeCosts , null , null , costBound - costs ) ; if ( costs >= costBound && -- rem > 0 ) return Double . POSITIVE_INFINITY ; } return costs ; }
 public String getPlayerNo ( ) { return playerNo ; }
 public void resetServerState ( ) throws SQLException { if ( ! getParanoid ( ) && ( ( this . io != null ) && versionMeetsMinimum ( 4 , 0 , 6 ) ) ) { changeUser ( this . user , this . password ) ; } }
 public void setOccupancy ( QuantitativeValue occupancy ) { this . occupancy = occupancy ; }
 private boolean shouldDenyPrivilege ( String userName , String entityName , TestingPrivilegeType type ) { TestingPrivilege testPrivilege = privilege ( userName , entityName , type ) ; for ( TestingPrivilege denyPrivilege : denyPrivileges ) { if ( denyPrivilege . matches ( testPrivilege ) ) { return true ; } } return false ; }
 @ Override void visit ( ImageElement element , String value ) throws IOException { if ( element == ImageElement . DELEGATION_TOKEN_IDENTIFIER_RENEWER ) { delegationTokenRenewers . add ( value ) ; } }
 @ Autowired public OfferServiceImpl ( OfferRepository offerRepository , ModelMapper modelMapper , Validator validator ) { this . offerRepository = offerRepository ; this . modelMapper = modelMapper ; this . validator = validator ; }
 public boolean serverSupportsConvertFn ( ) throws SQLException { return versionMeetsMinimum ( 4 , 0 , 2 ) ; }
 @ Override public Element getState ( ) { final Element element = new Element ( GOSU_COMPILER_SETTINGS_TAG ) ; element . setAttribute ( ExternalCompilerMemory , String . valueOf ( myExternalCompilerMemory ) ) ; element . setAttribute ( ExternalToIncrementalCompilerLimit , String . valueOf ( myExternalToIncrementalCompiler ) ) ; return element ; }
 @ Override public String toString ( ) { StringBuilder sb = new StringBuilder ( ) ; int count = 0 ; for ( Entry < K , List < V > > entry : map . entrySet ( ) ) { sb . append ( entry . getKey ( ) + " ▁ ( " + entry . getKey ( ) . hashCode ( ) + " ) ▁ = ▁ " + entry . getValue ( ) + SystemUtils . LINE_SEPARATOR ) ; ++ count ; if ( count == 10 ) { sb . append ( " . . . " ) ; return sb . toString ( ) ; } } return sb . toString ( ) ; }
 public void setUpdated ( java . util . Date updated ) { set ( " updated " , updated ) ; }
 public boolean lowerCaseTableNames ( ) { return this . lowerCaseTableNames ; }
 private void loadDrivers ( Properties props ) { String driverClasses = props . getProperty ( " drivers " ) ; StringTokenizer st = new StringTokenizer ( driverClasses ) ; while ( st . hasMoreElements ( ) ) { String driverClassName = st . nextToken ( ) . trim ( ) ; try { Driver driver = ( Driver ) Class . forName ( driverClassName ) . newInstance ( ) ; DriverManager . registerDriver ( driver ) ; drivers . addElement ( driver ) ; log ( " 成功注册JDBC驱动程序 " + driverClassName ) ; } catch ( Exception e ) { log ( " 无法注册JDBC驱动程序 : ▁ " + driverClassName + " , ▁ 错误 : ▁ " + e ) ; } } }
 public List < String [ ] > getPaths ( ) { return this . getPaths ( 0 ) ; }
 public TransationType createTransationType ( ) { return new TransationType ( ) ; }
 @ Override public int getWidth ( ) { return bufImg . getWidth ( ) ; }
 public void setNick ( java . lang . String nick ) { set ( " nick " , nick ) ; }
 public boolean containsKey ( String key ) { return map . containsKey ( key ) ; }
 public UsingStatement ( ) { _varStmts = Collections . emptyList ( ) ; }
 void addRingZero ( ExceptionInterceptor interceptor ) throws SQLException { this . interceptors . add ( 0 , interceptor ) ; }
 @ Test public void testMarshalAndUnmarshal ( ) throws Exception { PurchaseOrder order = new PurchaseOrder ( ) ; order . setName ( " Tiger " ) ; order . setAmount ( 1 ) ; order . setPrice ( 99.95 ) ; MockEndpoint mock = getMockEndpoint ( " mock : reverse " ) ; mock . expectedMessageCount ( 1 ) ; mock . message ( 0 ) . body ( ) . isInstanceOf ( PurchaseOrder . class ) ; mock . message ( 0 ) . body ( ) . equals ( order ) ; Object result = ( Object ) template . requestBody ( " direct : marshal " , order ) ; String body = context . getTypeConverter ( ) . convertTo ( String . class , result ) ; template . sendBody ( " direct : reverse " , body ) ; mock . assertIsSatisfied ( ) ; }
 public int hashCode ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( someTigerField == null ) ? 0 : someTigerField . hashCode ( ) ) ; return result ; }
 public Player ( String playerNo ) { this . setPlayerNo ( playerNo ) ; }
 public java . sql . Statement createStatement ( ) throws SQLException { return createStatement ( DEFAULT_RESULT_SET_TYPE , DEFAULT_RESULT_SET_CONCURRENCY ) ; }
 public PagesSerde ( BlockEncodingSerde blockEncodingSerde , Optional < Compressor > compressor , Optional < Decompressor > decompressor , Optional < SpillCipher > spillCipher ) { this . blockEncodingSerde = requireNonNull ( blockEncodingSerde , " blockEncodingSerde ▁ is ▁ null " ) ; checkArgument ( compressor . isPresent ( ) == decompressor . isPresent ( ) , " compressor ▁ and ▁ decompressor ▁ must ▁ both ▁ be ▁ present ▁ or ▁ both ▁ be ▁ absent " ) ; this . compressor = requireNonNull ( compressor , " compressor ▁ is ▁ null " ) ; this . decompressor = requireNonNull ( decompressor , " decompressor ▁ is ▁ null " ) ; this . spillCipher = requireNonNull ( spillCipher , " spillCipher ▁ is ▁ null " ) ; }
 public DrillServiceInstance newMessage ( ) { return new DrillServiceInstance ( ) ; }
 @ Test public void testTestSort ( ) throws Exception { Series a = new TypeInferenceBuilder ( ) . set ( 40 , 3 ) . set ( 30 , 2 ) . set ( 20 , 4 ) . set ( 10 , 1 ) . build ( ) ; Series v = a . sort ( SortOrder . DESC ) ; System . out . println ( v . asList ( Object . class ) ) ; System . out . println ( v ) ; }
 @ Override public boolean equals ( Object o ) { if ( ! ( o instanceof PartitionSignature ) ) return false ; PartitionSignature that = ( PartitionSignature ) o ; return partNodes == that . partNodes && inputNodes == that . inputNodes && rootNodes == that . rootNodes && matPoints == that . matPoints && cCompute == that . cCompute && cRead == that . cRead && cWrite == that . cWrite && cPlan0 == that . cPlan0 && cPlanN == that . cPlanN ; }
 public void insert ( final FluoClient fluo , final Collection < RyaStatement > triples ) { checkNotNull ( fluo ) ; checkNotNull ( triples ) ; try ( Transaction tx = fluo . newTransaction ( ) ) { for ( final RyaStatement triple : triples ) { Optional < byte [ ] > visibility = Optional . fromNullable ( triple . getColumnVisibility ( ) ) ; try { tx . set ( spoFormat ( triple ) , FluoQueryColumns . TRIPLES , Bytes . of ( visibility . or ( new byte [ 0 ] ) ) ) ; } catch ( final TripleRowResolverException e ) { log . error ( " Could ▁ not ▁ convert ▁ a ▁ Triple ▁ into ▁ the ▁ SPO ▁ format : ▁ " + triple ) ; } } tx . commit ( ) ; } }
 public java . sql . DatabaseMetaData getMetaData ( ) throws SQLException { return getMetaData ( true , true ) ; }
 public int getMaxBytesPerChar ( String javaCharsetName ) throws SQLException { return getMaxBytesPerChar ( null , javaCharsetName ) ; }
 private void checkTransactionIsolationLevel ( ) throws SQLException { String txIsolationName = null ; if ( versionMeetsMinimum ( 4 , 0 , 3 ) ) { txIsolationName = " tx _ isolation " ; } else { txIsolationName = " transaction _ isolation " ; } String s = this . serverVariables . get ( txIsolationName ) ; if ( s != null ) { Integer intTI = mapTransIsolationNameToValue . get ( s ) ; if ( intTI != null ) { this . isolationLevel = intTI . intValue ( ) ; } } }
 public String getServerVersion ( ) { return this . io . getServerVersion ( ) ; }
 @ Override public ComplexEventChunk < StreamEvent > tryUpdate ( ComplexEventChunk < StateEvent > updatingOrAddingEventChunk , Object storeEvents , InMemoryCompiledUpdateSet compiledUpdateSet , AddingStreamEventExtractor addingStreamEventExtractor ) { updatingOrAddingEventChunk . reset ( ) ; while ( updatingOrAddingEventChunk . hasNext ( ) ) { StateEvent overwritingOrAddingEvent = updatingOrAddingEventChunk . next ( ) ; ( ( IndexedEventHolder ) storeEvents ) . overwrite ( addingStreamEventExtractor . getAddingStreamEvent ( overwritingOrAddingEvent ) ) ; } return null ; }
 public RegimeEspecialIntegracaoDTO seq ( Integer seq ) { this . seq = seq ; return this ; }
 public MessageType ( String name , Type ... fields ) { super ( Repetition . REPEATED , name , fields ) ; }
 @ Override public boolean isItemValidForSlot ( int slot , ItemStack item ) { return item != null && item . getItem ( ) instanceof ItemEnderPearl ; }
 public BaseFilter setHighlightColor ( int highlightColor ) throws AssertionError { this . highlightColor = highlightColor ; return this ; }
 public ApplicationDeployment getApplicationDeployment ( ) { return applicationDeployment ; }
 @ Override void visitEnclosingElement ( ImageElement element , ImageElement key , String value ) throws IOException { }
 List < Page > getPages ( ) { return pages ; }
 private boolean isNameValid ( String name ) { if ( name == null ) { return false ; } if ( ! name . equals ( " / " ) && name . endsWith ( " / " ) ) { return false ; } return true ; }
