 @ Nullable public static boolean [ ] readBooleanArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; boolean [ ] res = new boolean [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readBoolean ( ) ; return res ; }
 public static StoreReader createReader ( InputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ stream , ▁ copying ▁ into ▁ temp ▁ folder " ) ; try { File file = TempUtils . copyIntoTempFile ( " paldbtempreader " , stream ) ; LOGGER . log ( Level . INFO , " Copied ▁ stream ▁ into ▁ temp ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new ReaderImpl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
 public static void setIgniteHome ( @ Nullable String path ) { GridTuple < String > ggHomeTup = ggHome ; String ggHome0 ; if ( ggHomeTup == null ) { synchronized ( IgniteUtils . class ) { ggHomeTup = ggHome ; if ( ggHomeTup == null ) { if ( F . isEmpty ( path ) ) System . clearProperty ( IGNITE_HOME ) ; else System . setProperty ( IGNITE_HOME , path ) ; ggHome = F . t ( path ) ; return ; } else ggHome0 = ggHomeTup . get ( ) ; } } else ggHome0 = ggHomeTup . get ( ) ; if ( ggHome0 != null && ! ggHome0 . equals ( path ) ) throw new IgniteException ( " Failed ▁ to ▁ set ▁ IGNITE _ HOME ▁ after ▁ it ▁ has ▁ been ▁ already ▁ resolved ▁ " + " [ igniteHome = " + ggHome0 + " , ▁ newIgniteHome = " + path + ' ] ' ) ; }
 @ Nullable public static String getNetworkInterfaceName ( String addr ) { assert addr != null ; try { InetAddress inetAddr = InetAddress . getByName ( addr ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) for ( InetAddress itfAddr : asIterable ( itf . getInetAddresses ( ) ) ) if ( itfAddr . equals ( inetAddr ) ) return itf . getDisplayName ( ) ; } catch ( UnknownHostException ignore ) { return null ; } catch ( SocketException ignore ) { return null ; } return null ; }
 private static Set < Long > getDeadlockedThreadIds ( ThreadMXBean mxBean ) { final long [ ] deadlockedIds = mxBean . findDeadlockedThreads ( ) ; final Set < Long > deadlockedThreadsIds ; if ( ! F . isEmpty ( deadlockedIds ) ) { Set < Long > set = new HashSet < > ( ) ; for ( long id : deadlockedIds ) set . add ( id ) ; deadlockedThreadsIds = Collections . unmodifiableSet ( set ) ; } else deadlockedThreadsIds = Collections . emptySet ( ) ; return deadlockedThreadsIds ; }
 public static void quietAndWarn ( IgniteLogger log , Object msg , Object shortMsg ) { warn ( log , msg ) ; if ( log . isQuiet ( ) ) quiet ( false , shortMsg ) ; }
 public static String toOSFilePath ( String path ) { if ( path == null ) { return null ; } String normaliedOSPath = path . replace ( ' \ \' , File . separatorChar ) . replace ( ' / ' , File . separatorChar ) ; return normalizePath ( normaliedOSPath ) ; }
 public static < T > void writeArray ( ObjectOutput out , T [ ] arr ) throws IOException { int len = arr == null ? 0 : arr . length ; out . writeInt ( len ) ; if ( arr != null && arr . length > 0 ) for ( T t : arr ) out . writeObject ( t ) ; }
 public static void writeBytesCollection ( DataOutput out , Collection < byte [ ] > bytes ) throws IOException { if ( bytes != null ) { out . writeInt ( bytes . size ( ) ) ; for ( byte [ ] b : bytes ) writeByteArray ( out , b ) ; } else out . writeInt ( - 1 ) ; }
 public static boolean isSolaris ( ) { return solaris ; }
 public static File getFileFromInputStream ( InputStream inputStream , String fileExtension ) { FileOutputStream fileOutputStream = null ; File file = null ; try { file = File . createTempFile ( " ebayCodegen " , fileExtension ) ; byte [ ] bytes = new byte [ 10000 ] ; fileOutputStream = new FileOutputStream ( file ) ; int readCount = 0 ; while ( ( readCount = inputStream . read ( bytes ) ) > 0 ) { fileOutputStream . write ( bytes , 0 , readCount ) ; } } catch ( IOException e ) { getLogger ( ) . log ( Level . INFO , " exception ▁ while ▁ trying ▁ to ▁ create ▁ the ▁ tekmp ▁ file ▁ : ▁ exception ▁ is ▁ : ▁ " + e . getMessage ( ) ) ; } finally { if ( fileOutputStream != null ) { try { fileOutputStream . close ( ) ; } catch ( IOException e ) { getLogger ( ) . log ( Level . FINE , " Exception ▁ while ▁ closing ▁ the ▁ file ▁ outut ▁ stream ▁ for ▁ the ▁ file ▁ " ) ; } } } return file ; }
 public static boolean containsStringArray ( String [ ] arr , @ Nullable String val , boolean ignoreCase ) { assert arr != null ; for ( String s : arr ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignoreCase ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
 public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Object obj ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( obj . getClass ( ) ) ) ; log = logRef . get ( ) ; } return log ; }
 public static byte [ ] uuidToBytes ( @ Nullable UUID uuid ) { return GridClientByteUtils . uuidToBytes ( uuid ) ; }
 public static void closeQuietly ( WSDLLocator locator ) { if ( locator == null ) { return ; } locator . close ( ) ; }
 public static Collector < JsonValue , JsonObjectBuilder , JsonObject > toJsonObject ( Function < JsonValue , String > keyMapper , Function < JsonValue , JsonValue > valueMapper ) { return null ; }
 public static int [ ] toIntArray ( @ Nullable Collection < Integer > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_INTS ; int [ ] arr = new int [ c . size ( ) ] ; int idx = 0 ; for ( Integer i : c ) arr [ idx ++ ] = i ; return arr ; }
 public static long [ ] toLongArray ( @ Nullable Collection < Long > c ) { if ( c == null || c . isEmpty ( ) ) return EMPTY_LONGS ; long [ ] arr = new long [ c . size ( ) ] ; int idx = 0 ; for ( Long l : c ) arr [ idx ++ ] = l ; return arr ; }
 private static String findProjectHome ( File startDir ) { for ( File cur = startDir . getAbsoluteFile ( ) ; cur != null ; cur = cur . getParentFile ( ) ) { if ( ! new File ( cur , " bin " ) . isDirectory ( ) || ! new File ( cur , " config " ) . isDirectory ( ) ) continue ; return cur . getPath ( ) ; } return null ; }
 public static void writeIntKeyIntValueMap ( DataOutput out , Map < Integer , Integer > map ) throws IOException { if ( map != null ) { out . writeBoolean ( true ) ; out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , Integer > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeInt ( e . getValue ( ) ) ; } } else out . writeBoolean ( false ) ; }
 public static boolean isPrimitiveArray ( Object obj ) { Class < ? > cls = obj . getClass ( ) ; return cls . isArray ( ) && cls . getComponentType ( ) . isPrimitive ( ) ; }
 public static byte [ ] readByteArray ( ByteBuffer ... bufs ) { assert ! F . isEmpty ( bufs ) ; int size = 0 ; for ( ByteBuffer buf : bufs ) size += buf . remaining ( ) ; byte [ ] res = new byte [ size ] ; int off = 0 ; for ( ByteBuffer buf : bufs ) { int len = buf . remaining ( ) ; if ( len != 0 ) { buf . get ( res , off , len ) ; off += len ; } } assert off == res . length ; return res ; }
 public static boolean relaxDiscoveryOrdered ( ) { return " true " . equalsIgnoreCase ( System . getProperty ( IGNITE_NO_DISCO_ORDER ) ) ; }
 public static boolean reachable ( InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( reachTimeout ) ; } catch ( IOException ignore ) { return false ; } }
 public static void deleteFile ( File file ) throws IOException { if ( file == null || ! file . exists ( ) ) { return ; } if ( ! file . delete ( ) ) { throw new IOException ( " Can ' t ▁ delete ▁ file ▁ : ▁ " + file . getPath ( ) ) ; } }
 public static List < PluginProvider > allPluginProviders ( ) { return AccessController . doPrivileged ( new PrivilegedAction < List < PluginProvider > > ( ) { @ Override public List < PluginProvider > run ( ) { List < PluginProvider > providers = new ArrayList < > ( ) ; ServiceLoader < PluginProvider > ldr = ServiceLoader . load ( PluginProvider . class ) ; for ( PluginProvider provider : ldr ) providers . add ( provider ) ; return providers ; } } ) ; }
 public static byte [ ] floatToBytes ( float f ) { return intToBytes ( Float . floatToIntBits ( f ) ) ; }
 @ Nullable public static Class < ? > classForName ( String cls , @ Nullable Class < ? > dflt ) { try { return cls == null ? dflt : Class . forName ( cls ) ; } catch ( ClassNotFoundException ignore ) { return dflt ; } }
 public static boolean addLastCause ( @ Nullable Throwable e , @ Nullable Throwable cause , IgniteLogger log ) { if ( e == null || cause == null ) return false ; for ( Throwable t = e ; t != null ; t = t . getCause ( ) ) { if ( t == cause ) return false ; if ( t . getCause ( ) == null || t . getCause ( ) == t ) { try { t . initCause ( cause ) ; } catch ( IllegalStateException ignored ) { error ( log , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain ▁ ( cause ▁ is ▁ printed ▁ here ▁ but ▁ will ▁ " + " not ▁ be ▁ propagated ▁ to ▁ callee ) : ▁ " + e , " Failed ▁ to ▁ add ▁ cause ▁ to ▁ the ▁ end ▁ of ▁ cause ▁ chain : ▁ " + e , cause ) ; } return true ; } } return false ; }
 public static void cancel ( Iterable < ? extends GridWorker > ws ) { if ( ws != null ) for ( GridWorker w : ws ) w . cancel ( ) ; }
 private static File getResourceFromJar ( String entryPath , String fileName ) { try { InputStream jis = MsgClassGenerator . class . getClassLoader ( ) . getResourceAsStream ( entryPath + fileName ) ; if ( jis == null ) { logMessage ( " Error : ▁ there ▁ is ▁ no ▁ " + entryPath + fileName + " ▁ in ▁ the ▁ resources ! " ) ; return null ; } File resFile = new File ( fileName ) ; resFile . createNewFile ( ) ; resFile . deleteOnExit ( ) ; FileOutputStream fos = new FileOutputStream ( resFile ) ; byte [ ] data = new byte [ jis . available ( ) ] ; int i ; while ( ( i = jis . read ( data ) ) > 0 ) { fos . write ( data , 0 , i ) ; data = new byte [ jis . available ( ) ] ; } jis . close ( ) ; fos . close ( ) ; return resFile ; } catch ( Exception e ) { logMessage ( " Couldn ' t ▁ extract ▁ resource ! " ) ; e . printStackTrace ( ) ; return null ; } }
 public static Collection < String > grids2names ( @ Nullable Collection < ? extends Ignite > grids ) { return F . viewReadOnly ( grids , new C1 < Ignite , String > ( ) { @ Override public String apply ( Ignite g ) { return g . name ( ) ; } } ) ; }
 public static boolean isHotSpot ( ) { return jvmImplName . contains ( " Java ▁ HotSpot ( TM ) " ) ; }
 public static int arrayCopy ( byte [ ] src , int off , byte [ ] resBuf , int resOff , int len ) { assert resBuf . length >= resOff + len ; if ( UNSAFE_BYTE_ARR_CP ) UNSAFE . copyMemory ( src , BYTE_ARRAY_DATA_OFFSET + off , resBuf , BYTE_ARRAY_DATA_OFFSET + resOff , len ) ; else System . arraycopy ( src , off , resBuf , resOff , len ) ; return resOff + len ; }
 public static GridCacheVersion readVersion ( long ptr , boolean verEx ) { GridCacheVersion ver = new GridCacheVersion ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) ) ; if ( verEx ) { ptr += 24 ; ver = new GridCacheVersionEx ( UNSAFE . getInt ( ptr ) , UNSAFE . getInt ( ptr + 4 ) , UNSAFE . getLong ( ptr + 8 ) , UNSAFE . getLong ( ptr + 16 ) , ver ) ; } return ver ; }
 public static void main ( String [ ] args ) { }
 public static boolean sameMacs ( ClusterNode loc , ClusterNode rmt ) { assert loc != null ; assert rmt != null ; String locMacs = loc . attribute ( IgniteNodeAttributes . ATTR_MACS ) ; String rmtMacs = rmt . attribute ( IgniteNodeAttributes . ATTR_MACS ) ; return locMacs != null && locMacs . equals ( rmtMacs ) ; }
 public static void nullifyWorkDirectory ( ) { igniteWork = null ; }
 public static void courtesy ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; courtesy ( log , s , s ) ; }
 public static < K , V > void printConcurrentHashMapInfo ( ConcurrentHashMap < K , V > map ) { assert map != null ; Object [ ] segs = field ( map , " segments " ) ; X . println ( " Concurrent ▁ map ▁ stats ▁ [ identityHash = ▁ " + System . identityHashCode ( map ) + " , ▁ segsCnt = " + segs . length + ' ] ' ) ; int emptySegsCnt = 0 ; int totalCollisions = 0 ; for ( int i = 0 ; i < segs . length ; i ++ ) { int segCnt = IgniteUtils . < Integer > field ( segs [ i ] , " count " ) ; if ( segCnt == 0 ) { emptySegsCnt ++ ; continue ; } Object [ ] tab = field ( segs [ i ] , " table " ) ; int tabLen = tab . length ; X . println ( " ▁ ▁ ▁ ▁ Segment - " + i + " ▁ [ count = " + segCnt + " , ▁ len = " + tabLen + ' ] ' ) ; Map < Integer , Integer > bucketsStats = new TreeMap < > ( ) ; for ( Object entry : tab ) { int cnt = 0 ; while ( entry != null ) { cnt ++ ; entry = field ( entry , " next " ) ; } Integer bucketCnt = bucketsStats . get ( cnt ) ; if ( bucketCnt == null ) bucketCnt = 0 ; bucketCnt ++ ; bucketsStats . put ( cnt , bucketCnt ) ; if ( cnt > 1 ) totalCollisions += ( cnt - 1 ) ; } for ( Map . Entry < Integer , Integer > e : bucketsStats . entrySet ( ) ) X . println ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ Buckets ▁ with ▁ count ▁ " + e . getKey ( ) + " : ▁ " + e . getValue ( ) ) ; } X . println ( " ▁ ▁ ▁ ▁ Map ▁ summary ▁ [ emptySegs = " + emptySegsCnt + " , ▁ collisions = " + totalCollisions + ' ] ' ) ; }
 public static String format ( long sysTime ) { return LONG_DATE_FMT . format ( new java . util . Date ( sysTime ) ) ; }
 public static final ActionCache AMNESIAC_CACHE = new ActionCache ( ) { @ Override public void put ( String fingerprint , Entry entry ) { } @ Override public Entry get ( String fingerprint ) { return null ; } @ Override public void remove ( String key ) { } @ Override public long save ( ) { return - 1 ; } @ Override public void clear ( ) { } @ Override public void dump ( PrintStream out ) { } @ Override public void accountHit ( ) { } @ Override public void accountMiss ( MissReason reason ) { } @ Override public void mergeIntoActionCacheStatistics ( ActionCacheStatistics . Builder builder ) { } @ Override public void resetStatistics ( ) { } }
 public static void close ( @ Nullable AutoCloseable rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static byte [ ] decodeHex ( char [ ] data ) throws IgniteCheckedException { int len = data . length ; if ( ( len & 0x01 ) != 0 ) throw new IgniteCheckedException ( " Odd ▁ number ▁ of ▁ characters . " ) ; byte [ ] out = new byte [ len >> 1 ] ; for ( int i = 0 , j = 0 ; j < len ; i ++ ) { int f = toDigit ( data [ j ] , j ) << 4 ; j ++ ; f |= toDigit ( data [ j ] , j ) ; j ++ ; out [ i ] = ( byte ) ( f & 0xFF ) ; } return out ; }
 public static void skip ( DataInputPlus in , Version version ) throws IOException { readPosition ( in , version ) ; skipPromotedIndex ( in , version ) ; }
 public static String jvmName ( ) { return jvmImplName ; }
 public static void assertParameter ( boolean cond , String condDesc ) throws IgniteException { if ( ! cond ) throw new IgniteException ( " Parameter ▁ failed ▁ condition ▁ check : ▁ " + condDesc ) ; }
 public static void writeLock ( ReadWriteLock lock ) throws IgniteInterruptedCheckedException { try { lock . writeLock ( ) . lockInterruptibly ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String jdkVersion ( ) { return jdkVer ; }
 public static boolean hasSharedMemory ( ) { if ( hasShmem == null ) { if ( isWindows ( ) ) hasShmem = false ; else { try { IpcSharedMemoryNativeLoader . load ( null ) ; hasShmem = true ; } catch ( IgniteCheckedException ignore ) { hasShmem = false ; } } } return hasShmem ; }
 public static void closeQuietly ( JarFile jarfile ) { if ( jarfile == null ) { return ; } try { jarfile . close ( ) ; } catch ( IOException ignore ) { } }
 public static String format ( Date date , String ptrn ) { java . text . DateFormat format = new java . text . SimpleDateFormat ( ptrn ) ; return format . format ( date ) ; }
 public static void writeStringToFile ( File file , String s , String charset , boolean append ) throws IOException { if ( s == null ) return ; try ( OutputStream out = new FileOutputStream ( file , append ) ) { out . write ( s . getBytes ( charset ) ) ; } }
 private static Set < SSTableReader > overlapping ( Collection < SSTableReader > candidates , Iterable < SSTableReader > others ) { assert ! candidates . isEmpty ( ) ; Iterator < SSTableReader > iter = candidates . iterator ( ) ; SSTableReader sstable = iter . next ( ) ; Token first = sstable . first . token ; Token last = sstable . last . token ; while ( iter . hasNext ( ) ) { sstable = iter . next ( ) ; first = first . compareTo ( sstable . first . token ) <= 0 ? first : sstable . first . token ; last = last . compareTo ( sstable . last . token ) >= 0 ? last : sstable . last . token ; } return overlapping ( first , last , others ) ; }
 public static < K , V > Map < K , V > sealMap ( Map < K , V > m ) { assert m != null ; return Collections . unmodifiableMap ( new HashMap < > ( m ) ) ; }
 public static Builder builder ( ) { return new Builder ( ) ; }
 private static TrustManager [ ] getTrustManagers ( ) { return new TrustManager [ ] { new X509TrustManager ( ) { @ Nullable @ Override public X509Certificate [ ] getAcceptedIssuers ( ) { return null ; } @ Override public void checkClientTrusted ( X509Certificate [ ] certs , String authType ) { } @ Override public void checkServerTrusted ( X509Certificate [ ] certs , String authType ) { } } } ; }
 public static < E > List < E > sealList ( E ... a ) { return Collections . unmodifiableList ( Arrays . asList ( a ) ) ; }
 public static String getNSFromPackageName ( String packageName ) { StringBuffer strBuf = new StringBuffer ( ) ; int prevIndex = packageName . length ( ) ; int currentIndex = packageName . lastIndexOf ( PACKAGE_class_DELIMITER ) ; if ( currentIndex > 0 ) { strBuf . append ( HTTP ) ; } else if ( prevIndex > 0 ) { strBuf . append ( HTTP ) ; strBuf . append ( packageName ) ; return strBuf . toString ( ) ; } else if ( currentIndex == - 1 ) { return strBuf . toString ( ) ; } while ( currentIndex != - 1 ) { strBuf . append ( packageName . substring ( currentIndex + 1 , prevIndex ) ) ; prevIndex = currentIndex ; currentIndex = packageName . lastIndexOf ( PACKAGE_class_DELIMITER , prevIndex - 1 ) ; strBuf . append ( PACKAGE_class_DELIMITER ) ; if ( currentIndex == - 1 ) { strBuf . append ( packageName . substring ( 0 , prevIndex ) ) ; } } return strBuf . toString ( ) ; }
 public static Constructor objectConstructor ( ) { return OBJECT_CTOR ; }
 public static IgniteBiTuple < Object , Object > addLog4jNoOpLogger ( ) throws IgniteCheckedException { Object rootLog ; Object nullApp ; try { Class < ? > logCls = Class . forName ( " org . apache . log4j . Logger " ) ; rootLog = logCls . getMethod ( " getRootLogger " ) . invoke ( logCls ) ; try { nullApp = Class . forName ( " org . apache . log4j . varia . NullAppender " ) . newInstance ( ) ; } catch ( ClassNotFoundException ignore ) { return new IgniteBiTuple < > ( rootLog , null ) ; } Class appCls = Class . forName ( " org . apache . log4j . Appender " ) ; rootLog . getClass ( ) . getMethod ( " addAppender " , appCls ) . invoke ( rootLog , nullApp ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ add ▁ no - op ▁ logger ▁ for ▁ Log4j . " , e ) ; } return new IgniteBiTuple < > ( rootLog , nullApp ) ; }
 private static void appendClassLoaderHash ( SB sb ) { if ( getBoolean ( IGNITE_MBEAN_APPEND_class_LOADER_ID , true ) ) { String clsLdrHash = Integer . toHexString ( Ignite . class . getClassLoader ( ) . hashCode ( ) ) ; sb . a ( " clsLdr = " ) . a ( clsLdrHash ) . a ( ' , ' ) ; } }
 public static boolean await ( Condition cond , long time , TimeUnit unit ) throws IgniteInterruptedCheckedException { try { return cond . await ( time , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String readUTFStringNullable ( DataInput in ) throws IOException { return in . readBoolean ( ) ? in . readUTF ( ) : null ; }
 public static boolean isGenericArrayType ( Type type ) { return ( type instanceof GenericArrayType ) ; }
 public static void writeStringToFile ( File file , String s ) throws IOException { writeStringToFile ( file , s , Charset . defaultCharset ( ) . toString ( ) , false ) ; }
 @ Nullable public static String hidePassword ( @ Nullable String uri ) { if ( uri == null ) return null ; if ( Pattern . matches ( " . * : // ( . * : . * ) @ . * " , uri ) ) { int userInfoLastIdx = uri . indexOf ( ' @ ' ) ; assert userInfoLastIdx != - 1 ; String str = uri . substring ( 0 , userInfoLastIdx ) ; int userInfoStartIdx = str . lastIndexOf ( ' / ' ) ; str = str . substring ( userInfoStartIdx + 1 ) ; String [ ] params = str . split ( " ; " ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < params . length ; i ++ ) { int idx ; if ( ( idx = params [ i ] . indexOf ( ' : ' ) ) != - 1 ) params [ i ] = params [ i ] . substring ( 0 , idx + 1 ) + ' * ' ; builder . append ( params [ i ] ) ; if ( i != params . length - 1 ) builder . append ( ' ; ' ) ; } return new StringBuilder ( uri ) . replace ( userInfoStartIdx + 1 , userInfoLastIdx , builder . toString ( ) ) . toString ( ) ; } return uri ; }
 public static int hash ( int h ) { h ^= h >>> 16 ; h *= 0x85ebca6b ; h ^= h >>> 13 ; h *= 0xc2b2ae35 ; return ( h >>> 16 ) ^ h ; }
 public static LabelLateBoundDefault < ? > getAndroidSdkLabel ( Label androidSdk ) { return LabelLateBoundDefault . fromTargetConfiguration ( AndroidConfiguration . class , androidSdk , ( rule , attributes , configuration ) -> configuration . getSdk ( ) ) ; }
 public static boolean isWildCardType ( Type type ) { return ( type instanceof WildcardType ) ; }
 public static synchronized Collection < String > allLocalIps ( ) { List < String > ips = new ArrayList < > ( 4 ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { if ( ! itf . isLoopback ( ) ) { Enumeration < InetAddress > addrs = itf . getInetAddresses ( ) ; for ( InetAddress addr : asIterable ( addrs ) ) { String hostAddr = addr . getHostAddress ( ) ; if ( ! addr . isLoopbackAddress ( ) && ! ips . contains ( hostAddr ) ) ips . add ( hostAddr ) ; } } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( ips ) ; return ips ; }
 public static int hashCode ( ByteBuffer ... bufs ) { int res = 1 ; for ( ByteBuffer buf : bufs ) { int pos = buf . position ( ) ; while ( buf . hasRemaining ( ) ) res = 31 * res + buf . get ( ) ; buf . position ( pos ) ; } return res ; }
 public static boolean containsIntArray ( int [ ] arr , int val ) { assert arr != null ; if ( arr . length == 0 ) return false ; for ( int i : arr ) if ( i == val ) return true ; return false ; }
 public static < T > T getByIndex ( Collection < T > vals , int idx ) { assert idx < vals . size ( ) ; int i = 0 ; for ( T val : vals ) { if ( idx == i ) return val ; i ++ ; } assert false : " Should ▁ never ▁ be ▁ reached . " ; return null ; }
 public static String consistentId ( Collection < String > addrs , int port ) { assert ! F . isEmpty ( addrs ) ; StringBuilder sb = new StringBuilder ( ) ; for ( String addr : addrs ) sb . append ( addr ) . append ( ' , ' ) ; sb . delete ( sb . length ( ) - 1 , sb . length ( ) ) ; sb . append ( ' : ' ) . append ( port ) ; return sb . toString ( ) ; }
 public static void writeMap ( ObjectOutput out , Map < ? , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < ? , ? > e : map . entrySet ( ) ) { out . writeObject ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
 private static String convertToJavaSrcFilePath ( String qualifiedJavaName ) { if ( isEmptyString ( qualifiedJavaName ) ) { return qualifiedJavaName ; } int dotJavaPos = qualifiedJavaName . lastIndexOf ( " . java " ) ; if ( dotJavaPos > - 1 ) { return convertToFilePath ( qualifiedJavaName . substring ( 0 , dotJavaPos ) , " . java " ) ; } else { return convertToFilePath ( qualifiedJavaName , " . java " ) ; } }
 static void deserializeFromPages ( BinaryRowData reuse , ChannelReaderInputView inView , BinaryRowDataSerializer buildSideSerializer ) throws IOException { if ( shouldAdvance ( inView . getCurrentSegmentLimit ( ) - inView . getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { inView . advance ( ) ; } MemorySegment segment = ( reuse . getSegments ( ) != null ) ? reuse . getSegments ( ) [ 0 ] : null ; int length = toLength ( inView . getCurrentSegment ( ) . getLong ( inView . getCurrentPositionInSegment ( ) ) ) ; inView . skipBytesToRead ( 8 ) ; if ( segment == null || segment . size ( ) < length ) { segment = MemorySegmentFactory . wrap ( new byte [ length ] ) ; } inView . readFully ( segment . getHeapMemory ( ) , 0 , length ) ; reuse . pointTo ( segment , 0 , length ) ; }
 @ Nullable public static byte [ ] readByteArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; byte [ ] res = new byte [ len ] ; in . readFully ( res ) ; return res ; }
 public static String osName ( ) { return osName ; }
 public static < T extends R , R > List < R > arrayList ( Collection < T > c , @ Nullable IgnitePredicate < ? super T > ... p ) { assert c != null ; return IgniteUtils . arrayList ( c , c . size ( ) , p ) ; }
 public static boolean isNonDecreasingArray ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) return false ; } return true ; }
 @ Deprecated public static void dumpStack ( Thread t ) { dumpStack ( t , System . err ) ; }
 public static boolean isGrid ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite . internal " ) ; }
 @ Deprecated public static void debugx ( String msg ) { X . printerrln ( debugPrefix ( ) + msg ) ; }
 public static File urlToFile ( URL url ) { File file = null ; try { file = new File ( url . toURI ( ) ) ; } catch ( Exception exception ) { file = new File ( url . getPath ( ) ) ; } return file ; }
 public static FieldChoicesdialogs fromValue ( String v ) { for ( FieldChoicesdialogs c : FieldChoicesdialogs . values ( ) ) { if ( c . value . equals ( v ) ) { return c ; } } throw new IllegalArgumentException ( v ) ; }
 public static String makeFirstLetterUpper ( String str ) { if ( isEmptyString ( str ) ) { return str ; } char firstChar = str . charAt ( 0 ) ; if ( Character . isLetter ( firstChar ) && Character . isLowerCase ( firstChar ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toUpperCase ( firstChar ) ; return String . valueOf ( chars ) ; } else { return str ; } }
 public static int ceilPow2 ( int v ) { return Integer . highestOneBit ( v - 1 ) << 1 ; }
 public static String getJavaClassName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( idx + 1 ) ; }
 public static File getDir ( String destDir ) throws IOException { if ( destDir == null ) { return null ; } File dir = new File ( destDir ) ; if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new IOException ( destDir + " : ▁ non - existent ▁ directory " ) ; } return dir ; }
 public static void close ( @ Nullable Selector rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static void writeIntKeyMap ( ObjectOutput out , Map < Integer , ? > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < Integer , ? > e : map . entrySet ( ) ) { out . writeInt ( e . getKey ( ) ) ; out . writeObject ( e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
 public static String classNameToResourceName ( String clsName ) { return clsName . replaceAll ( " \\ . " , " / " ) + " . class " ; }
 public static boolean containsObjectArray ( @ Nullable Object [ ] arr , @ Nullable Collection < Object > c ) { if ( arr == null || arr . length == 0 || c == null || c . isEmpty ( ) ) return false ; for ( Object o : arr ) { if ( c . contains ( o ) ) return true ; } return false ; }
 public static void writeIntCollection ( DataOutput out , Collection < Integer > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Integer i : col ) out . writeInt ( i ) ; } else out . writeInt ( - 1 ) ; }
 public static void log ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; log ( log , s , s ) ; }
 public static int [ ] difference ( int [ ] a , int aLen , int [ ] b , int bLen ) { assert a != null ; assert b != null ; assert isIncreasingArray ( a , aLen ) ; assert isIncreasingArray ( b , bLen ) ; int [ ] res = new int [ aLen ] ; int resLen = 0 ; int i = 0 ; int j = 0 ; while ( i < aLen && j < bLen ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ resLen ++ ] = a [ i ++ ] ; else j ++ ; } while ( i < aLen ) res [ resLen ++ ] = a [ i ++ ] ; return copyIfExceeded ( res , resLen ) ; }
 @ Nullable public static IgniteUuid readGridUuid ( long ptr ) { if ( UNSAFE . getBoolean ( null , ptr ++ ) ) { long most = UNSAFE . getLong ( ptr ) ; ptr += 8 ; long least = UNSAFE . getLong ( ptr ) ; ptr += 8 ; UUID globalId = new UUID ( most , least ) ; long locId = UNSAFE . getLong ( ptr ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
 public static boolean isWindows81 ( ) { return win81 ; }
 public static void clearClassCache ( ClassLoader ldr ) { classCache . remove ( ldr ) ; }
 public static boolean isNetWare ( ) { return netware ; }
 public static JsArrayNumber wrapArray ( double [ ] srcArray ) { JsArrayNumber result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
 public static String getTemplateContent ( String templateName ) throws IOException { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; InputStream inputStream = classLoader . getResourceAsStream ( templateName ) ; if ( inputStream == null ) { throw new IOException ( " Failed ▁ to ▁ load ▁ resource ▁ : ▁ " + templateName ) ; } String templateContent = readContent ( inputStream ) ; return templateContent ; }
 @ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , IgniteOutClosure < R > c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . apply ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
 public static File resolveWorkDirectory ( String path , boolean delIfExist ) throws IgniteCheckedException { File dir = new File ( path ) ; if ( ! dir . isAbsolute ( ) ) { String ggWork0 = igniteWork ; if ( F . isEmpty ( ggWork0 ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ resolve ▁ path ▁ ( work ▁ directory ▁ has ▁ not ▁ been ▁ set ) : ▁ " + path ) ; dir = new File ( ggWork0 , dir . getPath ( ) ) ; } if ( delIfExist && dir . exists ( ) ) { if ( ! U . delete ( dir ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ delete ▁ directory : ▁ " + dir ) ; } if ( ! mkdirs ( dir ) ) throw new IgniteCheckedException ( " Directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + dir ) ; if ( ! dir . canRead ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ directory : ▁ " + dir ) ; if ( ! dir . canWrite ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ directory : ▁ " + dir ) ; return dir ; }
 public static String compact ( String s ) { return s . replace ( " org . apache . ignite . internal . visor . " , " o . a . i . i . v . " ) . replace ( " org . apache . ignite . internal . " , " o . a . i . i . " ) . replace ( " org . apache . ignite . scalar . " , " o . a . i . s . " ) . replace ( " org . apache . ignite . " , " o . a . i . " ) ; }
 public static String toJavaSrcFilePath ( String srcDir , String qualifiedJavaName ) { if ( srcDir == null || qualifiedJavaName == null ) { return null ; } String filePath = toOSFilePath ( srcDir ) + convertToJavaSrcFilePath ( qualifiedJavaName ) ; return filePath ; }
 public static Collection < InetSocketAddress > resolveAddresses ( AddressResolver addrRslvr , Iterable < String > addrs , int port ) throws IgniteSpiException { assert addrRslvr != null ; Collection < InetSocketAddress > extAddrs = new HashSet < > ( ) ; for ( String addr : addrs ) { InetSocketAddress sockAddr = new InetSocketAddress ( addr , port ) ; if ( ! sockAddr . isUnresolved ( ) ) { try { Collection < InetSocketAddress > extAddrs0 = addrRslvr . getExternalAddresses ( sockAddr ) ; if ( extAddrs0 != null ) extAddrs . addAll ( extAddrs0 ) ; } catch ( IgniteCheckedException e ) { throw new IgniteSpiException ( " Failed ▁ to ▁ get ▁ mapped ▁ external ▁ addresses ▁ " + " [ addrRslvr = " + addrRslvr + " , ▁ addr = " + addr + ' ] ' , e ) ; } } } return extAddrs ; }
 public static void onGridStart ( ) { synchronized ( mux ) { if ( gridCnt == 0 ) { assert timer == null ; timer = new Thread ( new Runnable ( ) { @ SuppressWarnings ( { " BusyWait " , " InfiniteLoopStatement " } ) @ Override public void run ( ) { while ( true ) { curTimeMillis = System . currentTimeMillis ( ) ; try { Thread . sleep ( 10 ) ; } catch ( InterruptedException ignored ) { break ; } } } } , " ignite - clock " ) ; timer . setDaemon ( true ) ; timer . setPriority ( 10 ) ; timer . start ( ) ; } ++ gridCnt ; } }
 public static < T > T get ( Future < T > fut ) throws IgniteCheckedException { try { return fut . get ( ) ; } catch ( ExecutionException e ) { throw new IgniteCheckedException ( e . getCause ( ) ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } catch ( CancellationException e ) { throw new IgniteCheckedException ( e ) ; } }
 private static boolean [ ] [ ] getPixels ( final String assetPath , final Context context , final int tileColumns , final int tileRows ) { final Bitmap bitmap = getBitmap ( assetPath , context ) ; if ( bitmap == null ) { return null ; } final int xOffset = bitmap . getWidth ( ) / tileColumns ; final int yOffset = bitmap . getHeight ( ) / tileRows ; final boolean [ ] [ ] pixels = new boolean [ xOffset ] [ yOffset ] ; for ( int x = 0 ; x < xOffset ; x ++ ) { for ( int y = 0 ; y < yOffset ; y ++ ) { pixels [ x ] [ y ] = bitmap . getPixel ( x , y ) == Color . TRANSPARENT ? ALPHA : PIXEL ; } } return pixels ; }
 @ Nullable public static String readString ( DataInput in ) throws IOException { return ! in . readBoolean ( ) ? in . readUTF ( ) : null ; }
 public static void interrupt ( @ Nullable Thread t ) { if ( t != null ) t . interrupt ( ) ; }
 public static Collector < JsonValue , Map < String , JsonArrayBuilder > , JsonObject > groupingBy ( Function < JsonValue , String > classifier , Collector < JsonValue , JsonArrayBuilder , JsonArray > downstream ) { return null ; }
 @ Nullable public static List < IgniteUuid > readGridUuids ( DataInput in ) throws IOException { List < IgniteUuid > col = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( readGridUuid ( in ) ) ; } return col ; }
 public static Collector < JsonValue , Map < String , JsonArrayBuilder > , JsonObject > groupingBy ( Function < JsonValue , String > classifier ) { return null ; }
 public static void addAllFiles ( File dir , List < String > files ) { if ( dir . isDirectory ( ) ) { if ( ! dir . getName ( ) . equals ( " . " ) && ! dir . getName ( ) . equals ( " . . " ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { if ( children [ i ] . isDirectory ( ) ) { addAllFiles ( children [ i ] , files ) ; } else { files . add ( children [ i ] . getAbsolutePath ( ) ) ; } } } } }
 public static int toDigit ( char ch , int idx ) throws IgniteCheckedException { int digit = Character . digit ( ch , 16 ) ; if ( digit == - 1 ) throw new IgniteCheckedException ( " Illegal ▁ hexadecimal ▁ character ▁ " + ch + " ▁ at ▁ index ▁ " + idx ) ; return digit ; }
 ) public static void unzip ( File zipFile , File toDir , @ Nullable IgniteLogger log ) throws IOException { ZipFile zip = null ; try { zip = new ZipFile ( zipFile ) ; for ( ZipEntry entry : asIterable ( zip . entries ( ) ) ) { if ( entry . isDirectory ( ) ) { new File ( toDir , entry . getName ( ) ) . mkdirs ( ) ; continue ; } InputStream in = null ; OutputStream out = null ; try { in = zip . getInputStream ( entry ) ; File outFile = new File ( toDir , entry . getName ( ) ) ; if ( ! outFile . getParentFile ( ) . exists ( ) ) outFile . getParentFile ( ) . mkdirs ( ) ; out = new BufferedOutputStream ( new FileOutputStream ( outFile ) ) ; copy ( in , out ) ; } finally { close ( in , log ) ; close ( out , log ) ; } } } finally { if ( zip != null ) zip . close ( ) ; } }
 public static void wrapThreadLoader ( ClassLoader ldr , Runnable c ) { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; c . run ( ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
 public static String jvmSpec ( ) { return jvmSpecName ; }
 public static < T extends Annotation > boolean hasAnnotation ( Class < ? > cls , Class < T > annCls ) { return getAnnotation ( cls , annCls ) != null ; }
 public static boolean mkdirs ( File dir ) { assert dir != null ; return dir . mkdirs ( ) || dir . exists ( ) ; }
 public static int safeAbs ( int i ) { i = Math . abs ( i ) ; return i < 0 ? 0 : i ; }
 @ Nullable public static < R > R wrapThreadLoader ( ClassLoader ldr , Callable < R > c ) throws IgniteCheckedException { Thread curThread = Thread . currentThread ( ) ; ClassLoader ctxLdr = curThread . getContextClassLoader ( ) ; try { curThread . setContextClassLoader ( ldr ) ; return c . call ( ) ; } catch ( IgniteCheckedException | RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } finally { curThread . setContextClassLoader ( ctxLdr ) ; } }
 public static void rollbackConnectionQuiet ( @ Nullable Connection rsrc ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException ignored ) { } }
 public static void stopLifecycleAware ( IgniteLogger log , Iterable < ? > objs ) { for ( Object obj : objs ) { if ( obj instanceof LifecycleAware ) { try { ( ( LifecycleAware ) obj ) . stop ( ) ; } catch ( Exception e ) { U . error ( log , " Failed ▁ to ▁ stop ▁ component ▁ ( ignoring ) : ▁ " + obj , e ) ; } } } }
 public static String nl ( ) { return NL ; }
 private static Iterable < ClusterNode > nodesPerJvm ( Iterable < ClusterNode > nodes ) { Map < String , ClusterNode > grpMap = new HashMap < > ( ) ; for ( ClusterNode node : nodes ) { String grpId = node . attribute ( ATTR_MACS ) + " | " + node . attribute ( ATTR_JVM_PID ) ; if ( ! grpMap . containsKey ( grpId ) ) grpMap . put ( grpId , node ) ; } return grpMap . values ( ) ; }
 public static int [ ] copyIfExceeded ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; return len == arr . length ? arr : Arrays . copyOf ( arr , len ) ; }
 public static int doubleToBytes ( double d , byte [ ] bytes , int off ) { return longToBytes ( Double . doubleToLongBits ( d ) , bytes , off ) ; }
 public static void writeUuid ( DataOutput out , UUID uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . getMostSignificantBits ( ) ) ; out . writeLong ( uid . getLeastSignificantBits ( ) ) ; } }
 @ org . junit . BeforeClass public static void setUp ( ) throws Exception { System . out . println ( " = = = ▁ Setting ▁ up ▁ inmemory ▁ db ▁ for ▁ Ansible ▁ DAO ▁ Test ▁ = = = " ) ; CREATE_TMP_DB_SQL = new Scanner ( new FileInputStream ( SQL_FOLDER_PATH + " recreateDb . sql " ) ) . useDelimiter ( " \\ A " ) . next ( ) ; JdbcDataSource ds = new JdbcDataSource ( ) ; ds . setURL ( JDBC_URL ) ; ds . setUser ( " sa " ) ; ds . setPassword ( " sa " ) ; Connection conn = ds . getConnection ( ) ; conn = ds . getConnection ( ) ; conn . createStatement ( ) . execute ( CREATE_TMP_DB_SQL ) ; conn . commit ( ) ; conn . close ( ) ; }
 @ Nullable private static URL resolveInClasspath ( String path ) { ClassLoader clsLdr = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( clsLdr == null ) return null ; return clsLdr . getResource ( path . replaceAll ( " \\ \ \" , " / " ) ) ; }
 private static final Predicate < SSTableReader > suspectP = new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader candidate ) { return candidate . isMarkedSuspect ( ) ; } }
 public static < T > HashSet < T > newHashSet ( int expSize ) { return new HashSet < > ( capacity ( expSize ) ) ; }
 public static boolean delete ( @ Nullable File file ) { if ( file == null ) return false ; boolean res = true ; if ( file . isDirectory ( ) ) { File [ ] files = file . listFiles ( ) ; if ( files != null && files . length > 0 ) for ( File file1 : files ) if ( file1 . isDirectory ( ) ) res &= delete ( file1 ) ; else if ( file1 . getName ( ) . endsWith ( " jar " ) ) try { new JarFile ( file1 , false ) . close ( ) ; res &= file1 . delete ( ) ; } catch ( IOException ignore ) { } else res &= file1 . delete ( ) ; res &= file . delete ( ) ; } else res = file . delete ( ) ; return res ; }
 public static synchronized void mutateLevel ( SSTableMetadata oldMetadata , Descriptor descriptor , String filename , int level ) throws IOException { logger . debug ( " Mutating ▁ { } ▁ to ▁ level ▁ { } " , descriptor . filenameFor ( Component . STATS ) , level ) ; SSTableMetadata metadata = SSTableMetadata . copyWithNewSSTableLevel ( oldMetadata , level ) ; DataOutputStream out = new DataOutputStream ( new FileOutputStream ( filename + " - tmp " ) ) ; SSTableMetadata . serializer . legacySerialize ( metadata , descriptor , out ) ; out . flush ( ) ; out . close ( ) ; FileUtils . renameWithConfirm ( filename + " - tmp " , filename ) ; }
 public static void courtesy ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) log . getLogger ( IgniteConfiguration . COURTESY_LOGGER_NAME ) . warning ( compact ( longMsg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( courtesy ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; }
 public static Map < String , String > readStringMap ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; else { Map < String , String > map = U . newHashMap ( size ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( readUTFStringNullable ( in ) , readUTFStringNullable ( in ) ) ; return map ; } }
 public static boolean isIncreasingArray ( int [ ] arr , int len ) { assert arr != null ; assert 0 <= len && len <= arr . length ; if ( arr . length == 0 ) return true ; for ( int i = 1 ; i < len ; i ++ ) { if ( arr [ i - 1 ] >= arr [ i ] ) return false ; } return true ; }
 public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , List < SSTableReader > sstables ) { return create ( cfs , maxSSTableSize , sstables , new SizeTieredCompactionStrategyOptions ( ) ) ; }
 public static byte [ ] copyMemory ( long ptr , int size ) { byte [ ] res = new byte [ size ] ; UNSAFE . copyMemory ( null , ptr , res , BYTE_ARRAY_DATA_OFFSET , size ) ; return res ; }
 public static PageData setPageParam ( PageData pd ) { String page_now_str = pd . get ( " page _ now " ) . toString ( ) ; int pageNowInt = Integer . parseInt ( page_now_str ) - 1 ; String page_size_str = pd . get ( " page _ size " ) . toString ( ) ; int pageSizeInt = Integer . parseInt ( page_size_str ) ; String page_now = pageNowInt + " " ; String page_start = ( pageNowInt * pageSizeInt ) + " " ; pd . put ( " page _ now " , page_now ) ; pd . put ( " page _ start " , page_start ) ; return pd ; }
 public static String getQualifiedClassName ( String javaFilePath , String srcLocation ) { int pkgStartPos = javaFilePath . indexOf ( srcLocation ) ; String qualifiedJavaFile = null ; if ( pkgStartPos > - 1 ) { String normalizedSrcLoc = CodeGenUtil . normalizePath ( srcLocation ) ; int startPos = pkgStartPos + normalizedSrcLoc . length ( ) ; qualifiedJavaFile = javaFilePath . substring ( startPos ) ; } else { qualifiedJavaFile = javaFilePath ; } return toQualifiedClassName ( qualifiedJavaFile ) ; }
 public static void debugHeapUsage ( ) { System . gc ( ) ; Runtime runtime = Runtime . getRuntime ( ) ; X . println ( ' < ' + DEBUG_DATE_FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + " > ▁ Heap ▁ stats ▁ [ free = " + runtime . freeMemory ( ) / ( 1024 * 1024 ) + " M , ▁ total = " + runtime . totalMemory ( ) / ( 1024 * 1024 ) + " M ] " ) ; }
 public static void writeBooleanArray ( DataOutput out , @ Nullable boolean [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( boolean b : arr ) out . writeBoolean ( b ) ; } }
 public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mtdName , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mtdName != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { Method mtd = null ; for ( Method declaredMtd : c . getDeclaredMethods ( ) ) { if ( declaredMtd . getName ( ) . equals ( mtdName ) ) { if ( mtd == null ) mtd = declaredMtd ; else throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( ambigous ▁ method ▁ name ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; } } if ( mtd == null ) continue ; boolean accessible = mtd . isAccessible ( ) ; T res ; try { mtd . setAccessible ( true ) ; res = ( T ) mtd . invoke ( obj , params ) ; } finally { if ( ! accessible ) mtd . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; }
 public static < T extends R , R > List < R > arrayList ( Iterable < T > c , int cap , @ Nullable IgnitePredicate < ? super T > ... p ) { assert c != null ; assert cap >= 0 ; List < R > list = new ArrayList < > ( cap ) ; for ( T t : c ) { if ( F . isAll ( t , p ) ) list . add ( t ) ; } return list ; }
 private static CallTrackingLogger getLogger ( ) { return logger ; }
 public static String addressesAsString ( Collection < String > addrs , Collection < String > hostNames ) { if ( F . isEmpty ( addrs ) ) return " " ; if ( F . isEmpty ( hostNames ) ) return addrs . toString ( ) ; SB sb = new SB ( " [ " ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; boolean first = true ; for ( String addr : addrs ) { if ( first ) first = false ; else sb . a ( " , ▁ " ) ; String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; sb . a ( hostName != null ? hostName : " " ) . a ( ' / ' ) . a ( addr ) ; } sb . a ( ' ] ' ) ; return sb . toString ( ) ; }
 @ Deprecated public static void dumpStack ( ) { dumpStack ( " Dumping ▁ stack . " ) ; }
 public static boolean isWindowsVista ( ) { return winVista ; }
 public static String toJavaSrcFilePath ( String srcDir , Class < ? > clazz ) { if ( srcDir == null || clazz == null ) { return null ; } String filePath = toJavaSrcFilePath ( srcDir , clazz . getName ( ) ) ; return filePath ; }
 public static String getTaskName ( Class < ? extends ComputeTask < ? , ? > > taskCls ) { ComputeTaskName nameAnn = getAnnotation ( taskCls , ComputeTaskName . class ) ; return nameAnn == null ? taskCls . getName ( ) : nameAnn . value ( ) ; }
 public static String spiAttribute ( IgniteSpi spi , String attrName ) { assert spi != null ; assert spi . getName ( ) != null ; return spi . getName ( ) + ' . ' + attrName ; }
 public static long readPosition ( DataInputPlus in , Version version ) throws IOException { return version . storeRows ( ) ? in . readUnsignedVInt ( ) : in . readLong ( ) ; }
 public static OutputStream getFileOutputStream ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File outputFile = new File ( dir , fileName ) ; deleteFile ( outputFile ) ; FileOutputStream fileOutStream = new FileOutputStream ( outputFile ) ; return fileOutStream ; }
 public static void main ( String [ ] args ) { GraphParent tmp = new GraphParent ( ) ; tmp . init ( ) ; }
 public static void closeQuietly ( InputSource inputSource ) { if ( inputSource == null ) { return ; } closeQuietly ( inputSource . getCharacterStream ( ) ) ; closeQuietly ( inputSource . getByteStream ( ) ) ; }
 private static String normalizePath ( String path ) { if ( path == null ) { return null ; } if ( path . endsWith ( " \ \" ) || path . endsWith ( " / " ) ) { return path ; } else { return path + File . separatorChar ; } }
 public static void copy ( File src , File dest , boolean overwrite ) throws IOException { assert src != null ; assert dest != null ; if ( ! src . exists ( ) ) throw new FileNotFoundException ( " Source ▁ can ' t ▁ be ▁ found : ▁ " + src ) ; if ( src . getAbsoluteFile ( ) . equals ( dest . getAbsoluteFile ( ) ) ) throw new IOException ( " Source ▁ and ▁ destination ▁ are ▁ the ▁ same ▁ [ src = " + src + " , ▁ dest = " + dest + ' ] ' ) ; if ( dest . exists ( ) ) { if ( ! dest . isDirectory ( ) && ! overwrite ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + dest ) ; if ( ! dest . canWrite ( ) ) throw new IOException ( " Destination ▁ is ▁ not ▁ writable : " + dest ) ; } else { File parent = dest . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) parent . mkdirs ( ) ; if ( src . isDirectory ( ) ) dest . mkdir ( ) ; } if ( src . isDirectory ( ) ) { File [ ] files = src . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { File dir = new File ( dest , file . getName ( ) ) ; if ( ! dir . exists ( ) && ! dir . mkdirs ( ) ) throw new IOException ( " Can ' t ▁ create ▁ directory : ▁ " + dir ) ; copy ( file , dir , overwrite ) ; } else copy ( file , dest , overwrite ) ; } } else { File file = dest . exists ( ) && dest . isDirectory ( ) ? new File ( dest , src . getName ( ) ) : dest ; if ( ! overwrite && file . exists ( ) ) throw new IOException ( " Destination ▁ already ▁ exists : ▁ " + file ) ; FileInputStream in = null ; FileOutputStream out = null ; try { in = new FileInputStream ( src ) ; out = new FileOutputStream ( file ) ; copy ( in , out ) ; } finally { if ( in != null ) in . close ( ) ; if ( out != null ) { out . getFD ( ) . sync ( ) ; out . close ( ) ; } } } }
 public static void removeJavaNoOpLogger ( Collection < Handler > rmvHnds ) { Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . getHandlers ( ) ) log . removeHandler ( h ) ; if ( ! F . isEmpty ( rmvHnds ) ) { for ( Handler h : rmvHnds ) log . addHandler ( h ) ; } }
 public static String jvmVersion ( ) { return jvmImplVer ; }
 public static void await ( Condition cond ) throws IgniteInterruptedCheckedException { try { cond . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static Collection < UUID > nodeIds ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . viewReadOnly ( nodes , F . node2id ( ) ) ; }
 public static boolean isLinux ( ) { return linux ; }
 public static long microTime ( ) { return System . nanoTime ( ) / 1000 ; }
 @ Nullable public static Class < ? > box ( @ Nullable Class < ? > cls ) { if ( cls == null ) return null ; if ( ! cls . isPrimitive ( ) ) return cls ; return boxedClsMap . get ( cls ) ; }
 public static int [ ] addAll ( int [ ] arr1 , int [ ] arr2 ) { int [ ] all = new int [ arr1 . length + arr2 . length ] ; System . arraycopy ( arr1 , 0 , all , 0 , arr1 . length ) ; System . arraycopy ( arr2 , 0 , all , arr1 . length , arr2 . length ) ; return all ; }
 private static boolean checkNextToken ( StringTokenizer t , String str , String date ) throws IgniteCheckedException { try { if ( t . nextToken ( ) . equals ( str ) ) return true ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + date ) ; } catch ( NoSuchElementException ignored ) { return false ; } }
 private static MemorySegment [ ] listToArray ( List < MemorySegment > list ) { if ( list != null ) { return list . toArray ( new MemorySegment [ 0 ] ) ; } return null ; }
 public static boolean bytesEqual ( byte [ ] a , int aOff , byte [ ] b , int bOff , int len ) { if ( aOff + len > a . length || bOff + len > b . length ) return false ; else { for ( int i = 0 ; i < len ; i ++ ) if ( a [ aOff + i ] != b [ bOff + i ] ) return false ; return true ; } }
 public static Map < String , Collection < ClusterNode > > neighborhood ( Iterable < ClusterNode > nodes ) { Map < String , Collection < ClusterNode > > map = new HashMap < > ( ) ; for ( ClusterNode n : nodes ) { String macs = n . attribute ( ATTR_MACS ) ; assert macs != null : " Missing ▁ MACs ▁ attribute : ▁ " + n ; Collection < ClusterNode > neighbors = map . get ( macs ) ; if ( neighbors == null ) map . put ( macs , neighbors = new ArrayList < > ( 2 ) ) ; neighbors . add ( n ) ; } return map ; }
 public static void logMessage ( String msg ) { System . out . println ( msg ) ; }
 ) @ Nullable public static URL resolveIgniteUrl ( String path , boolean metaInf ) { File f = resolveIgnitePath ( path ) ; if ( f != null ) { try { return f . toURI ( ) . toURL ( ) ; } catch ( MalformedURLException e ) { } } ClassLoader clsLdr = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( clsLdr != null ) { String locPath = ( metaInf ? " META - INF / " : " " ) + path . replaceAll ( " \\ \ \" , " / " ) ; return clsLdr . getResource ( locPath ) ; } else return null ; }
 public static LinkOptions of ( ImmutableList < String > linkOptions , SymbolGenerator < ? > symbolGenerator ) { return new LinkOptions ( linkOptions , symbolGenerator . generate ( ) ) ; }
 public static CompilationMXBean getCompilerMx ( ) { return ManagementFactory . getCompilationMXBean ( ) ; }
 private static String debugPrefix ( ) { return ' < ' + DEBUG_DATE_FMT . format ( new Date ( System . currentTimeMillis ( ) ) ) + " > < DEBUG > < " + Thread . currentThread ( ) . getName ( ) + ' > ' + ' ▁ ' ; }
 public static void writeIntArray ( DataOutput out , @ Nullable int [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; for ( int b : arr ) out . writeInt ( b ) ; } }
 public static String addressesAsString ( ClusterNode node ) { return addressesAsString ( node . addresses ( ) , node . hostNames ( ) ) ; }
 public static < T > ObjectName registerCacheMBean ( MBeanServer mbeanSrv , @ Nullable String gridName , @ Nullable String cacheName , String name , T impl , Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , makeCacheMBeanName ( gridName , cacheName , name ) ) . getObjectName ( ) ; }
 public static void close ( @ Nullable DatagramSocket rsrc ) { if ( rsrc != null ) rsrc . close ( ) ; }
 private static String testMethodStatic ( ) { return " foo " ; }
 @ Nullable public static Method findNonPublicMethod ( Class < ? > cls , String name , Class < ? > ... paramTypes ) { while ( cls != null ) { try { Method mtd = cls . getDeclaredMethod ( name , paramTypes ) ; if ( mtd . getReturnType ( ) != void . class ) { mtd . setAccessible ( true ) ; return mtd ; } } catch ( NoSuchMethodException ignored ) { } cls = cls . getSuperclass ( ) ; } return null ; }
 public static String readFileToString ( String fileName , String charset ) throws IOException { Reader input = new InputStreamReader ( new FileInputStream ( fileName ) , charset ) ; StringWriter output = new StringWriter ( ) ; char [ ] buf = new char [ 4096 ] ; int n ; while ( ( n = input . read ( buf ) ) != - 1 ) output . write ( buf , 0 , n ) ; return output . toString ( ) ; }
 public static IgniteClosure < UUID , ClusterNode > id2Node ( final GridKernalContext ctx ) { assert ctx != null ; return new C1 < UUID , ClusterNode > ( ) { @ Nullable @ Override public ClusterNode apply ( UUID id ) { return ctx . discovery ( ) . node ( id ) ; } } ; }
 public static GridCacheAttributes [ ] cacheAttributes ( ClusterNode n ) { return n . attribute ( ATTR_CACHE ) ; }
 public static boolean isSufficientlyTestedOs ( ) { return win7 || win8 || win81 || winXp || winVista || mac || linux || solaris ; }
 public static void closeQuiet ( @ Nullable SelectionKey rsrc ) { if ( rsrc != null ) closeQuiet ( rsrc . channel ( ) ) ; }
 public static Class < ? > forName ( String clsName , @ Nullable ClassLoader ldr ) throws ClassNotFoundException { assert clsName != null ; Class < ? > cls = primitiveMap . get ( clsName ) ; if ( cls != null ) return cls ; if ( ldr == null ) ldr = gridClassLoader ; ConcurrentMap < String , Class > ldrMap = classCache . get ( ldr ) ; if ( ldrMap == null ) { ConcurrentMap < String , Class > old = classCache . putIfAbsent ( ldr , ldrMap = new ConcurrentHashMap8 < > ( ) ) ; if ( old != null ) ldrMap = old ; } cls = ldrMap . get ( clsName ) ; if ( cls == null ) { Class old = ldrMap . putIfAbsent ( clsName , cls = Class . forName ( clsName , true , ldr ) ) ; if ( old != null ) cls = old ; } return cls ; }
 private static Set < SSTableReader > overlapping ( Token start , Token end , Iterable < SSTableReader > sstables ) { assert start . compareTo ( end ) <= 0 ; Set < SSTableReader > overlapped = new HashSet < SSTableReader > ( ) ; Bounds < Token > promotedBounds = new Bounds < Token > ( start , end ) ; for ( SSTableReader candidate : sstables ) { Bounds < Token > candidateBounds = new Bounds < Token > ( candidate . first . token , candidate . last . token ) ; if ( candidateBounds . intersects ( promotedBounds ) ) overlapped . add ( candidate ) ; } return overlapped ; }
 private static int getBucketBuffersByRowCount ( long rowCount , int maxSegs , int segmentSize ) { int minNumBuckets = ( int ) Math . ceil ( ( rowCount / 0.5 ) ) ; Preconditions . checkArgument ( segmentSize % 16 == 0 ) ; return MathUtils . roundDownToPowerOf2 ( ( int ) Math . max ( 1 , Math . min ( maxSegs , Math . ceil ( ( ( double ) minNumBuckets ) * 16 / segmentSize ) ) ) ) ; }
 public static MemoryMXBean getMemoryMx ( ) { return ManagementFactory . getMemoryMXBean ( ) ; }
 public static double heapSize ( int precision ) { return roundedHeapSize ( Runtime . getRuntime ( ) . maxMemory ( ) , precision ) ; }
 public static int writeMessageFully ( Message msg , OutputStream out , ByteBuffer buf , MessageWriter writer ) throws IOException { assert msg != null ; assert out != null ; assert buf != null ; assert buf . hasArray ( ) ; boolean finished = false ; int cnt = 0 ; while ( ! finished ) { finished = msg . writeTo ( buf , writer ) ; out . write ( buf . array ( ) , 0 , buf . position ( ) ) ; cnt += buf . position ( ) ; buf . clear ( ) ; } return cnt ; }
 public static boolean containsStringCollection ( Iterable < String > c , @ Nullable String val , boolean ignoreCase ) { assert c != null ; for ( String s : c ) { if ( s == null && val == null ) return true ; if ( s == null || val == null ) continue ; if ( ignoreCase ) { if ( s . equalsIgnoreCase ( val ) ) return true ; } else if ( s . equals ( val ) ) return true ; } return false ; }
 public static int copy ( InputStream in , OutputStream out ) throws IOException { assert in != null ; assert out != null ; byte [ ] buf = new byte [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
 public static boolean isMacOs ( ) { return mac ; }
 public static boolean isWindows7 ( ) { return win7 ; }
 public static String toShortString ( ClusterNode n ) { return " GridNode ▁ [ id = " + n . id ( ) + " , ▁ order = " + n . order ( ) + " , ▁ addr = " + n . addresses ( ) + " , ▁ daemon = " + n . isDaemon ( ) + ' ] ' ; }
 public static < T > ObjectName registerMBean ( MBeanServer mbeanSrv , ObjectName name , T impl , Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , name ) . getObjectName ( ) ; }
 public static void dumpThreads ( @ Nullable IgniteLogger log ) { ThreadMXBean mxBean = ManagementFactory . getThreadMXBean ( ) ; final Set < Long > deadlockedThreadsIds = getDeadlockedThreadIds ( mxBean ) ; if ( deadlockedThreadsIds . size ( ) == 0 ) warn ( log , " No ▁ deadlocked ▁ threads ▁ detected . " ) ; else warn ( log , " Deadlocked ▁ threads ▁ detected ▁ ( see ▁ thread ▁ dump ▁ below ) ▁ " + " [ deadlockedThreadsCnt = " + deadlockedThreadsIds . size ( ) + ' ] ' ) ; ThreadInfo [ ] threadInfos = mxBean . dumpAllThreads ( mxBean . isObjectMonitorUsageSupported ( ) , mxBean . isSynchronizerUsageSupported ( ) ) ; GridStringBuilder sb = new GridStringBuilder ( " Thread ▁ dump ▁ at ▁ " ) . a ( new SimpleDateFormat ( " yyyy / MM / dd ▁ HH : mm : ss ▁ z " ) . format ( new Date ( U . currentTimeMillis ( ) ) ) ) . a ( NL ) ; for ( ThreadInfo info : threadInfos ) { printThreadInfo ( info , sb , deadlockedThreadsIds ) ; sb . a ( NL ) ; if ( info . getLockedSynchronizers ( ) != null && info . getLockedSynchronizers ( ) . length > 0 ) { printSynchronizersInfo ( info . getLockedSynchronizers ( ) , sb ) ; sb . a ( NL ) ; } } sb . a ( NL ) ; warn ( log , sb . toString ( ) ) ; }
 @ Nullable public static List < UUID > readUuids ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < UUID > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( readUuid ( in ) ) ; return col ; }
 public static boolean join ( @ Nullable Thread t , @ Nullable IgniteLogger log ) { if ( t != null ) try { t . join ( ) ; return true ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ a ▁ thread : ▁ " + t ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
 public static String gridEventName ( int type ) { String name = GRID_EVT_NAMES . get ( type ) ; return name != null ? name : Integer . toString ( type ) ; }
 public static void acquire ( Semaphore sem ) throws IgniteInterruptedCheckedException { try { sem . acquire ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String byteArray2String ( byte [ ] arr , String hdrFmt , String bodyFmt ) { assert arr != null ; assert hdrFmt != null ; assert bodyFmt != null ; SB sb = new SB ( ) ; sb . a ( ' { ' ) ; boolean first = true ; for ( byte b : arr ) if ( first ) { sb . a ( String . format ( hdrFmt , b ) ) ; first = false ; } else sb . a ( String . format ( bodyFmt , b ) ) ; sb . a ( ' } ' ) ; return sb . toString ( ) ; }
 public static boolean hasNearCache ( ClusterNode n , String cacheName ) { GridCacheAttributes [ ] caches = n . attribute ( ATTR_CACHE ) ; if ( caches != null ) for ( GridCacheAttributes attrs : caches ) if ( F . eq ( cacheName , attrs . cacheName ( ) ) ) return attrs . nearCacheEnabled ( ) ; return false ; }
 public static void igniteUuidToBytes ( IgniteUuid uuid , byte [ ] out , int off ) { assert uuid != null ; longToBytes ( uuid . globalId ( ) . getMostSignificantBits ( ) , out , off ) ; longToBytes ( uuid . globalId ( ) . getLeastSignificantBits ( ) , out , off + 8 ) ; longToBytes ( uuid . localId ( ) , out , off + 16 ) ; }
 public static String toQualifiedClassName ( String javaFilePath ) { String filePathNoExt = null ; if ( javaFilePath == null ) { return null ; } boolean isJavaExtensionPresent = javaFilePath . endsWith ( " . java " ) ; if ( isJavaExtensionPresent ) { filePathNoExt = javaFilePath . substring ( 0 , javaFilePath . length ( ) - 5 ) ; } boolean isClassExtensionPresent = javaFilePath . endsWith ( " . class " ) ; if ( isClassExtensionPresent ) { filePathNoExt = javaFilePath . substring ( 0 , javaFilePath . length ( ) - 6 ) ; } if ( filePathNoExt == null ) filePathNoExt = javaFilePath ; return filePathNoExt . replace ( ' \ \' , ' . ' ) . replace ( ' / ' , ' . ' ) ; }
 public static synchronized InetAddress getLocalHost ( ) throws IOException { if ( locHost == null ) resetLocalHost ( ) ; return locHost ; }
 public static String pad ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' ▁ ' ) ; return new String ( dash ) ; }
 public static String dash ( int len ) { char [ ] dash = new char [ len ] ; Arrays . fill ( dash , ' - ' ) ; dash [ 0 ] = dash [ len - 1 ] = ' + ' ; return new String ( dash ) ; }
 public static void writeStringMap ( DataOutput out , @ Nullable Map < String , String > map ) throws IOException { if ( map != null ) { out . writeInt ( map . size ( ) ) ; for ( Map . Entry < String , String > e : map . entrySet ( ) ) { writeUTFStringNullable ( out , e . getKey ( ) ) ; writeUTFStringNullable ( out , e . getValue ( ) ) ; } } else out . writeInt ( - 1 ) ; }
 public static boolean containsObjectArray ( @ Nullable Object [ ] arr , Object val , @ Nullable Object ... vals ) { if ( arr == null || arr . length == 0 ) return false ; for ( Object o : arr ) { if ( F . eq ( o , val ) ) return true ; if ( vals != null && vals . length > 0 ) for ( Object v : vals ) if ( F . eq ( o , v ) ) return true ; } return false ; }
 public static List < String > jvmArgs ( ) { return ManagementFactory . getRuntimeMXBean ( ) . getInputArguments ( ) ; }
 private static boolean shouldAdvance ( int available , BinaryRowDataSerializer serializer ) { return available < 8 + serializer . getFixedLengthPartSize ( ) ; }
 private static String readContent ( InputStream input ) throws IOException { Charset defaultCharset = Charset . defaultCharset ( ) ; InputStreamReader isr = new InputStreamReader ( input , defaultCharset ) ; BufferedReader reader = new BufferedReader ( isr ) ; StringBuilder strBuff = new StringBuilder ( ) ; try { char [ ] charBuff = new char [ 512 ] ; int charsRead = - 1 ; while ( ( charsRead = reader . read ( charBuff ) ) > - 1 ) { strBuff . append ( charBuff , 0 , charsRead ) ; } } finally { reader . close ( ) ; } return strBuff . toString ( ) ; }
 public static boolean isWindows2003 ( ) { return win2003 ; }
 public static void closeQuiet ( @ Nullable Context rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException ignored ) { } }
 public static GridPeerDeployAware peerDeployAware0 ( @ Nullable Iterable < ? > c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; Collection < Object > tmpC = new ArrayList < > ( ) ; for ( Object e : c ) tmpC . add ( e ) ; tmpC . add ( c ) ; boolean notAllNulls = false ; for ( Object obj : tmpC ) { if ( obj != null ) { notAllNulls = true ; if ( hasCommonClassLoader ( obj , tmpC ) ) return obj == c ? peerDeployAware ( obj ) : peerDeployAware0 ( obj ) ; } } if ( notAllNulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peerDeployAware ( c ) ; }
 public static String byteArray2HexString ( byte [ ] arr ) { SB sb = new SB ( arr . length << 1 ) ; for ( byte b : arr ) sb . a ( Integer . toHexString ( MASK & b >>> 4 ) ) . a ( Integer . toHexString ( MASK & b ) ) ; return sb . toString ( ) . toUpperCase ( ) ; }
 public static < K , V > Map < K , V > copyMap ( Map < K , V > m ) { return new HashMap < > ( m ) ; }
 public static byte [ ] igniteUuidToBytes ( IgniteUuid uuid ) { assert uuid != null ; byte [ ] out = new byte [ 24 ] ; igniteUuidToBytes ( uuid , out , 0 ) ; return out ; }
 public static File createDir ( String dirPath ) throws IOException { File dir = new File ( dirPath ) ; if ( dir . exists ( ) ) { return dir ; } if ( dir . mkdirs ( ) == false ) { throw new IOException ( " Failed ▁ to ▁ create ▁ dir ( s ) ▁ : ▁ " + dirPath ) ; } return dir ; }
 public static void cancel ( @ Nullable GridWorker w ) { if ( w != null ) w . cancel ( ) ; }
 public static String id8 ( IgniteUuid id ) { String s = id . toString ( ) ; return s . substring ( 0 , 4 ) + s . substring ( s . length ( ) - 4 ) ; }
 public static int bytesToInt ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Integer . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; int res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
 public static JsArrayNumber wrapArray ( float [ ] srcArray ) { JsArrayNumber result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
 public static int copy ( Reader in , Writer out ) throws IOException { assert in != null ; assert out != null ; char [ ] buf = new char [ BUF_SIZE ] ; int cnt = 0 ; for ( int n ; ( n = in . read ( buf ) ) > 0 ; ) { out . write ( buf , 0 , n ) ; cnt += n ; } return cnt ; }
 private static void setScores ( DynamicEndpointSnitch dsnitch , int rounds , List < InetAddress > hosts , Integer ... scores ) throws InterruptedException { for ( int round = 0 ; round < rounds ; round ++ ) { for ( int i = 0 ; i < hosts . size ( ) ; i ++ ) dsnitch . receiveTiming ( hosts . get ( i ) , scores [ i ] ) ; } Thread . sleep ( 150 ) ; }
 public static StoreReader createReader ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new ReaderImpl ( config , file ) ; }
 public static void writeGridUuids ( DataOutput out , @ Nullable Collection < IgniteUuid > col ) throws IOException { if ( col != null ) { out . writeBoolean ( true ) ; out . writeInt ( col . size ( ) ) ; for ( IgniteUuid id : col ) writeGridUuid ( out , id ) ; } else out . writeBoolean ( false ) ; }
 public static Object returnObject ( PageData pd , Map map ) { if ( pd . containsKey ( " callback " ) ) { String callback = pd . get ( " callback " ) . toString ( ) ; return new JSONPObject ( callback , map ) ; } else { return map ; } }
 public static boolean isJdk ( Class < ? > cls ) { if ( cls . isPrimitive ( ) ) return true ; String s = cls . getName ( ) ; return s . startsWith ( " java . " ) || s . startsWith ( " javax . " ) ; }
 public static InputStream getInputStreamForAFileFromClasspath ( String relativeFilePath , ClassLoader parentClassLoader ) { relativeFilePath = relativeFilePath . replace ( " \ \" , " / " ) ; getLogger ( ) . log ( Level . INFO , " call ▁ to ▁ getInputStreamForAFileFromClasspath ▁ for ▁ path ▁ : ▁ " + relativeFilePath ) ; InputStream inStream = null ; if ( parentClassLoader != null ) inStream = parentClassLoader . getResourceAsStream ( relativeFilePath ) ; if ( inStream == null ) { ClassLoader myClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; inStream = myClassLoader . getResourceAsStream ( relativeFilePath ) ; } if ( inStream == null ) inStream = CodeGenUtil . class . getClassLoader ( ) . getResourceAsStream ( relativeFilePath ) ; if ( inStream == null ) getLogger ( ) . log ( Level . WARNING , " Could ▁ not ▁ find ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relativeFilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInputStreamForAFileFromClasspath " ) ; else getLogger ( ) . log ( Level . INFO , " Found ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relativeFilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInputStreamForAFileFromClasspath " ) ; return inStream ; }
 public static long currentTimeMillis ( ) { return curTimeMillis ; }
 public static String [ ] unwrapArray ( JsArrayString jsArrayString ) { String [ ] result = new String [ jsArrayString . length ( ) ] ; for ( int i = 0 ; i < jsArrayString . length ( ) ; i ++ ) { result [ i ] = jsArrayString . get ( i ) ; } return result ; }
 public static void rollbackConnection ( @ Nullable Connection rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . rollback ( ) ; } catch ( SQLException e ) { warn ( log , " Failed ▁ to ▁ rollback ▁ JDBC ▁ connection : ▁ " + e . getMessage ( ) ) ; } }
 static PiFieldMatch translateCriterion ( Criterion criterion , PiMatchFieldId fieldId , PiMatchType matchType , int bitWidth ) throws PiTranslationException { if ( ! TRANSLATORS . containsKey ( criterion . getClass ( ) ) ) { throw new PiTranslationException ( format ( " Translation ▁ of ▁ criterion ▁ class ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . getClass ( ) . getSimpleName ( ) ) ) ; } CriterionTranslator translator = TRANSLATORS . get ( criterion . getClass ( ) ) ; try { translator . init ( criterion , bitWidth ) ; switch ( matchType ) { case EXACT : return new PiExactFieldMatch ( fieldId , translator . exactMatch ( ) ) ; case TERNARY : Pair < ImmutableByteSequence , ImmutableByteSequence > tp = translator . ternaryMatch ( ) ; return new PiTernaryFieldMatch ( fieldId , tp . getLeft ( ) , tp . getRight ( ) ) ; case LPM : Pair < ImmutableByteSequence , Integer > lp = translator . lpmMatch ( ) ; return new PiLpmFieldMatch ( fieldId , lp . getLeft ( ) , lp . getRight ( ) ) ; default : throw new PiTranslationException ( format ( " Translation ▁ of ▁ criterion ▁ % s ▁ ( % s ▁ class ) ▁ to ▁ match ▁ type ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . type ( ) . name ( ) , criterion . getClass ( ) . getSimpleName ( ) , matchType . name ( ) ) ) ; } } catch ( ByteSequenceTrimException e ) { throw new PiTranslationException ( format ( " Size ▁ mismatch ▁ for ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } catch ( CriterionTranslatorException e ) { throw new PiTranslationException ( format ( " Unable ▁ to ▁ translate ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } }
 public static double heapSize ( Iterable < ClusterNode > nodes , int precision ) { double heap = 0.0 ; for ( ClusterNode n : nodesPerJvm ( nodes ) ) { ClusterMetrics m = n . metrics ( ) ; heap += Math . max ( m . getHeapMemoryInitialized ( ) , m . getHeapMemoryMaximum ( ) ) ; } return roundedHeapSize ( heap , precision ) ; }
 public static void writeUuids ( DataOutput out , @ Nullable Collection < UUID > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( UUID id : col ) writeUuid ( out , id ) ; } else out . writeInt ( - 1 ) ; }
 @ Deprecated public static void dumpStack ( String msg ) { new Exception ( debugPrefix ( ) + msg ) . printStackTrace ( System . out ) ; }
 public static void writeString ( DataOutput out , String s ) throws IOException { out . writeBoolean ( s == null ) ; if ( s != null ) out . writeUTF ( s ) ; }
 public static ClusterGroupEmptyCheckedException emptyTopologyException ( ) { return new ClusterGroupEmptyCheckedException ( " Cluster ▁ group ▁ is ▁ empty . " ) ; }
 public static String getFilePath ( String dir , String fileName ) { if ( dir == null || fileName == null ) { return null ; } String filePath = toOSFilePath ( dir ) + fileName ; return filePath ; }
 public static void error ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg , @ Nullable Throwable e ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) { if ( e == null ) log . error ( compact ( longMsg . toString ( ) ) ) ; else log . error ( compact ( longMsg . toString ( ) ) , e ) ; } else { X . printerr ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( err ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; if ( e != null ) e . printStackTrace ( System . err ) ; else X . printerrln ( ) ; } }
 public static String fl ( String msg , Object ... args ) { assert args . length % 2 == 0 ; StringBuilder sb = new StringBuilder ( msg ) ; if ( args . length > 0 ) { sb . append ( " ▁ [ " ) ; for ( int i = 0 ; i < args . length / 2 ; i ++ ) { sb . append ( args [ i * 2 ] ) . append ( ' = ' ) . append ( args [ i * 2 + 1 ] ) ; sb . append ( " , ▁ " ) ; } sb . delete ( sb . length ( ) - 2 , sb . length ( ) ) ; sb . append ( ' ] ' ) ; } return sb . toString ( ) ; }
 public static EventNotificationEntity forValue ( int value ) { return values ( ) [ value ] ; }
 public static byte [ ] longToBytes ( long l ) { return GridClientByteUtils . longToBytes ( l ) ; }
 private static void logResolveFailed ( Class cls , Exception e ) { warn ( null , " Failed ▁ to ▁ resolve ▁ IGNITE _ HOME ▁ automatically ▁ for ▁ class ▁ codebase ▁ " + " [ class = " + cls + ( e == null ? " " : " , ▁ e = " + e . getMessage ( ) ) + ' ] ' ) ; }
 public static int capacity ( int expSize ) { if ( expSize < 3 ) return expSize + 1 ; if ( expSize < ( 1 << 30 ) ) return expSize + expSize / 3 ; return Integer . MAX_VALUE ; }
 public static CcLinkingContext merge ( List < CcLinkingContext > ccLinkingContexts ) { Builder mergedCcLinkingContext = CcLinkingContext . builder ( ) ; ExtraLinkTimeLibraries . Builder mergedExtraLinkTimeLibraries = ExtraLinkTimeLibraries . builder ( ) ; for ( CcLinkingContext ccLinkingContext : ccLinkingContexts ) { mergedCcLinkingContext . addTransitiveLinkerInputs ( ccLinkingContext . getLinkerInputs ( ) ) ; if ( ccLinkingContext . getExtraLinkTimeLibraries ( ) != null ) { mergedExtraLinkTimeLibraries . addTransitive ( ccLinkingContext . getExtraLinkTimeLibraries ( ) ) ; } } mergedCcLinkingContext . setExtraLinkTimeLibraries ( mergedExtraLinkTimeLibraries . build ( ) ) ; return mergedCcLinkingContext . build ( ) ; }
 @ Nullable public static String lambdaEnclosingClassName ( String clsName ) { int idx = clsName . indexOf ( " $ $ Lambda $ " ) ; return idx != - 1 ? clsName . substring ( 0 , idx ) : null ; }
 public static GridPeerDeployAware detectPeerDeployAware ( GridPeerDeployAware obj ) { GridPeerDeployAware p = nestedPeerDeployAware ( obj , true , new GridLeanIdentitySet < > ( ) ) ; return p != null ? p : peerDeployAware ( obj . getClass ( ) ) ; }
 public static void error ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; if ( msg instanceof Throwable ) { Throwable t = ( Throwable ) msg ; error ( log , t . getMessage ( ) , t ) ; } else { String s = msg . toString ( ) ; error ( log , s , s , null ) ; } }
 public static String getSimpleName ( Class < ? > cls ) { String name = cls . getSimpleName ( ) ; if ( F . isEmpty ( name ) ) name = cls . getName ( ) . substring ( cls . getPackage ( ) . getName ( ) . length ( ) + 1 ) ; return name ; }
 public static int [ ] gridEvents ( final int ... excl ) { if ( F . isEmpty ( excl ) ) return GRID_EVTS ; List < Integer > evts = toIntList ( GRID_EVTS , new P1 < Integer > ( ) { @ Override public boolean apply ( Integer i ) { return ! containsIntArray ( excl , i ) ; } } ) ; return toIntArray ( evts ) ; }
 public static boolean hasProguardSpecs ( AttributeMap rule ) { return rule . isConfigurable ( " proguard _ specs " ) || ! rule . get ( " proguard _ specs " , LABEL_LIST ) . isEmpty ( ) ; }
 public static Collection < InetSocketAddress > toSocketAddresses ( ClusterNode node , int port ) { return toSocketAddresses ( node . addresses ( ) , node . hostNames ( ) , port ) ; }
 public static boolean discoOrdered ( DiscoverySpi discoSpi ) { DiscoverySpiOrderSupport ann = U . getAnnotation ( discoSpi . getClass ( ) , DiscoverySpiOrderSupport . class ) ; return ann != null && ann . value ( ) ; }
 public static boolean join ( @ Nullable GridWorker w , @ Nullable IgniteLogger log ) { if ( w != null ) try { w . join ( ) ; } catch ( InterruptedException ignore ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ completion ▁ of ▁ runnable : ▁ " + w ) ; Thread . currentThread ( ) . interrupt ( ) ; return false ; } return true ; }
 public static void move ( String srcFilePath , String destLoc , boolean override ) throws IOException { File srcFile = new File ( srcFilePath ) ; File destDir = createDir ( destLoc ) ; File newFile = new File ( destDir , srcFile . getName ( ) ) ; if ( newFile . exists ( ) ) { if ( override == false ) { return ; } else { deleteFile ( newFile ) ; } } boolean success = srcFile . renameTo ( newFile ) ; if ( success == false ) { throw new IOException ( " Failed ▁ to ▁ move ▁ file ▁ : ▁ " + srcFilePath + " ▁ to ▁ " + destLoc ) ; } }
 @ Nullable public static < T > T newInstance ( Class < T > cls ) throws IgniteCheckedException { boolean set = false ; Constructor < T > ctor = null ; try { ctor = cls . getDeclaredConstructor ( ) ; if ( ctor == null ) return null ; if ( ! ctor . isAccessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ctor . newInstance ( ) ; } catch ( NoSuchMethodException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ find ▁ empty ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( ctor != null && set ) ctor . setAccessible ( false ) ; } }
 public static Collector < Map . Entry < String , JsonValue > , JsonObjectBuilder , JsonObject > toJsonObject ( ) { return null ; }
 public static < K , V > LinkedHashMap < K , V > newLinkedHashMap ( int expSize ) { return new LinkedHashMap < > ( capacity ( expSize ) ) ; }
 @ Nullable private static String resolveProjectHome ( ) { assert Thread . holdsLock ( IgniteUtils . class ) ; String ggHome0 = IgniteSystemProperties . getString ( IGNITE_HOME ) ; if ( ! F . isEmpty ( ggHome0 ) ) return ggHome0 ; String appWorkDir = System . getProperty ( " user . dir " ) ; if ( appWorkDir != null ) { ggHome0 = findProjectHome ( new File ( appWorkDir ) ) ; if ( ggHome0 != null ) return ggHome0 ; } URI classesUri ; Class < IgniteUtils > cls = IgniteUtils . class ; try { ProtectionDomain domain = cls . getProtectionDomain ( ) ; if ( domain == null || domain . getCodeSource ( ) == null || domain . getCodeSource ( ) . getLocation ( ) == null ) { logResolveFailed ( cls , null ) ; return null ; } classesUri = domain . getCodeSource ( ) . getLocation ( ) . toURI ( ) ; if ( isWindows ( ) && classesUri . getAuthority ( ) != null ) classesUri = new URI ( classesUri . toString ( ) . replace ( " file : // " , " file : / " ) ) ; } catch ( URISyntaxException | SecurityException e ) { logResolveFailed ( cls , e ) ; return null ; } File classesFile ; try { classesFile = new File ( classesUri ) ; } catch ( IllegalArgumentException e ) { logResolveFailed ( cls , e ) ; return null ; } return findProjectHome ( classesFile ) ; }
 public static int hash ( Object key ) { return hash ( key . hashCode ( ) ) ; }
 private static void printThreadInfo ( ThreadInfo threadInfo , GridStringBuilder sb , Set < Long > deadlockedIdSet ) { final long id = threadInfo . getThreadId ( ) ; if ( deadlockedIdSet . contains ( id ) ) sb . a ( " # # # # # ▁ DEADLOCKED ▁ " ) ; sb . a ( " Thread ▁ [ name = \" " ) . a ( threadInfo . getThreadName ( ) ) . a ( " \" , ▁ id = " ) . a ( threadInfo . getThreadId ( ) ) . a ( " , ▁ state = " ) . a ( threadInfo . getThreadState ( ) ) . a ( " , ▁ blockCnt = " ) . a ( threadInfo . getBlockedCount ( ) ) . a ( " , ▁ waitCnt = " ) . a ( threadInfo . getWaitedCount ( ) ) . a ( " ] " ) . a ( NL ) ; LockInfo lockInfo = threadInfo . getLockInfo ( ) ; if ( lockInfo != null ) { sb . a ( " ▁ ▁ ▁ ▁ Lock ▁ [ object = " ) . a ( lockInfo ) . a ( " , ▁ ownerName = " ) . a ( threadInfo . getLockOwnerName ( ) ) . a ( " , ▁ ownerId = " ) . a ( threadInfo . getLockOwnerId ( ) ) . a ( " ] " ) . a ( NL ) ; } MonitorInfo [ ] monitors = threadInfo . getLockedMonitors ( ) ; StackTraceElement [ ] elements = threadInfo . getStackTrace ( ) ; for ( int i = 0 ; i < elements . length ; i ++ ) { StackTraceElement e = elements [ i ] ; sb . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ at ▁ " ) . a ( e . toString ( ) ) ; for ( MonitorInfo monitor : monitors ) { if ( monitor . getLockedStackDepth ( ) == i ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ - ▁ locked ▁ " ) . a ( monitor ) ; } sb . a ( NL ) ; } }
 public static boolean isWindows2008 ( ) { return win2008 ; }
 public static boolean deleteContentsOfDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return true ; }
 public static Map < String , String > createNS2PackageMap ( InputOptions inputOptions ) { Map < String , String > ns2PkgMap = new HashMap < String , String > ( ) ; PkgToNSMappingList pkgNsMapList = inputOptions . getPkgNSMappings ( ) ; if ( pkgNsMapList != null && ! pkgNsMapList . getPkgNsMap ( ) . isEmpty ( ) ) { for ( PkgNSMappingType pkgNsMapType : pkgNsMapList . getPkgNsMap ( ) ) { ns2PkgMap . put ( pkgNsMapType . getNamespace ( ) , pkgNsMapType . getPackage ( ) ) ; } } return ns2PkgMap ; }
 public static Calendar parseIsoDate ( String str ) throws IgniteCheckedException { StringTokenizer t = new StringTokenizer ( str , " + - : . TZ " , true ) ; Calendar cal = Calendar . getInstance ( ) ; cal . clear ( ) ; try { if ( t . hasMoreTokens ( ) ) cal . set ( Calendar . YEAR , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( checkNextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MONTH , Integer . parseInt ( t . nextToken ( ) ) - 1 ) ; else return cal ; if ( checkNextToken ( t , " - " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . DAY_OF_MONTH , Integer . parseInt ( t . nextToken ( ) ) ) ; else return cal ; if ( checkNextToken ( t , " T " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . HOUR_OF_DAY , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . HOUR_OF_DAY , 0 ) ; cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return cal ; } if ( checkNextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) cal . set ( Calendar . MINUTE , Integer . parseInt ( t . nextToken ( ) ) ) ; else { cal . set ( Calendar . MINUTE , 0 ) ; cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; return cal ; } if ( ! t . hasMoreTokens ( ) ) return cal ; String tok = t . nextToken ( ) ; if ( " : " . equals ( tok ) ) { if ( t . hasMoreTokens ( ) ) { cal . set ( Calendar . SECOND , Integer . parseInt ( t . nextToken ( ) ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; if ( " . " . equals ( tok ) ) { String nt = t . nextToken ( ) ; while ( nt . length ( ) < 3 ) nt += "0" ; nt = nt . substring ( 0 , 3 ) ; cal . set ( Calendar . MILLISECOND , Integer . parseInt ( nt ) ) ; if ( ! t . hasMoreTokens ( ) ) return cal ; tok = t . nextToken ( ) ; } else cal . set ( Calendar . MILLISECOND , 0 ) ; } else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } else { cal . set ( Calendar . SECOND , 0 ) ; cal . set ( Calendar . MILLISECOND , 0 ) ; } if ( ! " Z " . equals ( tok ) ) { if ( ! " + " . equals ( tok ) && ! " - " . equals ( tok ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; boolean plus = " + " . equals ( tok ) ; if ( ! t . hasMoreTokens ( ) ) throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; tok = t . nextToken ( ) ; int tzHour ; int tzMin ; if ( tok . length ( ) == 4 ) { tzHour = Integer . parseInt ( tok . substring ( 0 , 2 ) ) ; tzMin = Integer . parseInt ( tok . substring ( 2 , 4 ) ) ; } else { tzHour = Integer . parseInt ( tok ) ; if ( checkNextToken ( t , " : " , str ) && t . hasMoreTokens ( ) ) tzMin = Integer . parseInt ( t . nextToken ( ) ) ; else throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str ) ; } if ( plus ) cal . set ( Calendar . ZONE_OFFSET , ( tzHour * 60 + tzMin ) * 60 * 1000 ) ; else cal . set ( Calendar . ZONE_OFFSET , - ( tzHour * 60 + tzMin ) * 60 * 1000 ) ; } else cal . setTimeZone ( TimeZone . getTimeZone ( " GMT " ) ) ; } catch ( NumberFormatException ex ) { throw new IgniteCheckedException ( " Invalid ▁ date ▁ format : ▁ " + str , ex ) ; } return cal ; }
 public static JsArrayInteger wrapArray ( int [ ] srcArray ) { JsArrayInteger result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
 public static boolean isJavaVersionAtLeast ( String v ) { return compareVersionNumbers ( javaRtVer , v ) >= 0 ; }
 public static Comparator < InetSocketAddress > inetAddressesComparator ( final boolean sameHost ) { return new Comparator < InetSocketAddress > ( ) { @ Override public int compare ( InetSocketAddress addr1 , InetSocketAddress addr2 ) { if ( addr1 . isUnresolved ( ) && addr2 . isUnresolved ( ) ) return 0 ; if ( addr1 . isUnresolved ( ) || addr2 . isUnresolved ( ) ) return addr1 . isUnresolved ( ) ? 1 : - 1 ; boolean addr1Loopback = addr1 . getAddress ( ) . isLoopbackAddress ( ) ; if ( addr1Loopback == addr2 . getAddress ( ) . isLoopbackAddress ( ) ) return 0 ; if ( sameHost ) return addr1Loopback ? - 1 : 1 ; else return addr1Loopback ? 1 : - 1 ; } } ; }
 public static void nullifyHomeDirectory ( ) { ggHome = null ; }
 public static String customDirectoryLogFileName ( @ Nullable String dir , String fileName ) { assert fileName != null ; if ( dir == null ) return fileName ; int sep = fileName . lastIndexOf ( File . separator ) ; return dir + ( sep < 0 ? File . separator + fileName : fileName . substring ( sep ) ) ; }
 public static < K , V > Map < K , V > limitedMap ( int limit ) { if ( limit == 0 ) return Collections . emptyMap ( ) ; if ( limit < 5 ) return new GridLeanMap < > ( limit ) ; return new HashMap < > ( capacity ( limit ) , 0.75f ) ; }
 public static void releaseQuiet ( @ Nullable FileLock lock ) { if ( lock != null ) try { lock . release ( ) ; } catch ( Exception ignored ) { } }
 public static ClusterNode oldest ( Collection < ClusterNode > c , @ Nullable IgnitePredicate < ClusterNode > p ) { ClusterNode oldest = null ; long minOrder = Long . MAX_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) < minOrder ) { oldest = n ; minOrder = n . order ( ) ; } } return oldest ; }
 public static boolean isWindows ( ) { return win7 || win8 || win81 || winXp || win95 || win98 || winNt || win2k || win2003 || win2008 || winVista || unknownWin ; }
 public static boolean p2pLoader ( ClassLoader ldr ) { return ldr instanceof GridDeploymentInfo ; }
 public static void init ( ) { PApplet . main ( " anpharos . gui . Graph . GraphParent " ) ; }
 public static < E extends Throwable > E withCause ( E e , @ Nullable Throwable cause ) { assert e != null ; if ( cause != null ) e . initCause ( cause ) ; return e ; }
 public static ClusterNode youngest ( Collection < ClusterNode > c , @ Nullable IgnitePredicate < ClusterNode > p ) { ClusterNode youngest = null ; long maxOrder = Long . MIN_VALUE ; for ( ClusterNode n : c ) { if ( ( p == null || p . apply ( n ) ) && n . order ( ) > maxOrder ) { youngest = n ; maxOrder = n . order ( ) ; } } return youngest ; }
 public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException ignore ) { } }
 public static URL resolveSpringUrl ( String springCfgPath ) throws IgniteCheckedException { A . notNull ( springCfgPath , " springCfgPath " ) ; URL url ; try { url = new URL ( springCfgPath ) ; } catch ( MalformedURLException e ) { url = U . resolveIgniteUrl ( springCfgPath ) ; if ( url == null ) url = resolveInClasspath ( springCfgPath ) ; if ( url == null ) throw new IgniteCheckedException ( " Spring ▁ XML ▁ configuration ▁ path ▁ is ▁ invalid : ▁ " + springCfgPath + " . ▁ Note ▁ that ▁ this ▁ path ▁ should ▁ be ▁ either ▁ absolute ▁ or ▁ a ▁ relative ▁ local ▁ file ▁ system ▁ path , ▁ " + " relative ▁ to ▁ META - INF ▁ in ▁ classpath ▁ or ▁ valid ▁ URL ▁ to ▁ IGNITE _ HOME . " , e ) ; } return url ; }
 public static boolean isIgnite ( Class < ? > cls ) { return cls . getName ( ) . startsWith ( " org . apache . ignite " ) ; }
 public static MultidexMode fromValue ( String value ) { for ( MultidexMode mode : values ( ) ) { if ( mode . getAttributeValue ( ) . equals ( value ) ) { return mode ; } } return null ; }
 public static IgniteProductVersion productVersion ( ClusterNode node ) { String verStr = node . attribute ( ATTR_BUILD_VER ) ; String buildDate = node . attribute ( ATTR_BUILD_DATE ) ; if ( buildDate != null ) verStr += ' - ' + buildDate ; return IgniteProductVersion . fromString ( verStr ) ; }
 public static void flushAndCloseQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { if ( closeable instanceof Flushable ) { ( ( Flushable ) closeable ) . flush ( ) ; } } catch ( IOException e ) { } try { closeable . close ( ) ; } catch ( IOException ignore ) { } }
 public static int uuidToBytes ( @ Nullable UUID uuid , byte [ ] arr , int off ) { return off + GridClientByteUtils . uuidToBytes ( uuid , arr , off ) ; }
 public static void writeByteArray ( DataOutput out , @ Nullable byte [ ] arr , int maxLen ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { int len = Math . min ( arr . length , maxLen ) ; out . writeInt ( len ) ; out . write ( arr , 0 , len ) ; } }
 public static List < Integer > toIntList ( @ Nullable int [ ] arr , IgnitePredicate < Integer > ... p ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Integer > ret = new ArrayList < > ( arr . length ) ; if ( F . isEmpty ( p ) ) for ( int i : arr ) ret . add ( i ) ; else { for ( int i : arr ) if ( F . isAll ( i , p ) ) ret . add ( i ) ; } return ret ; }
 public static String osVersion ( ) { return osVer ; }
 public static boolean hasParent ( @ Nullable ClassLoader parent , ClassLoader ldr ) { if ( parent != null ) { for ( ; ldr != null ; ldr = ldr . getParent ( ) ) { if ( ldr . equals ( parent ) ) return true ; } return false ; } return true ; }
 private static void printSynchronizersInfo ( LockInfo [ ] syncs , GridStringBuilder sb ) { sb . a ( " ▁ ▁ ▁ ▁ Locked ▁ synchronizers : " ) ; for ( LockInfo info : syncs ) sb . a ( NL ) . a ( " ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ " ) . a ( info ) ; }
 public static String id8 ( UUID id ) { return id . toString ( ) . substring ( 0 , 8 ) ; }
 public static int compareVersionNumbers ( @ Nullable String v1 , @ Nullable String v2 ) { if ( v1 == null && v2 == null ) return 0 ; if ( v1 == null ) return - 1 ; if ( v2 == null ) return 1 ; String [ ] part1 = v1 . split ( " [ \\ . \\ _ \\ - ] " ) ; String [ ] part2 = v2 . split ( " [ \\ . \\ _ \\ - ] " ) ; int idx = 0 ; for ( ; idx < part1 . length && idx < part2 . length ; idx ++ ) { String p1 = part1 [ idx ] ; String p2 = part2 [ idx ] ; int cmp = ( p1 . matches ( " \\ d + " ) && p2 . matches ( " \\ d + " ) ) ? Integer . valueOf ( p1 ) . compareTo ( Integer . valueOf ( p2 ) ) : p1 . compareTo ( p2 ) ; if ( cmp != 0 ) return cmp ; } if ( part1 . length == part2 . length ) return 0 ; else return part1 . length > idx ? 1 : - 1 ; }
 public static < T > T field ( Object obj , String fieldName ) { assert obj != null ; assert fieldName != null ; try { for ( Class cls = obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { for ( Field field : cls . getDeclaredFields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . isAccessible ( ) ; field . setAccessible ( true ) ; T val = ( T ) field . get ( obj ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } } } catch ( Exception e ) { throw new IgniteException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' , e ) ; } throw new IgniteException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ obj = " + obj + ' ] ' ) ; }
 public static float bytesToFloat ( byte [ ] bytes , int off ) { return Float . intBitsToFloat ( bytesToInt ( bytes , off ) ) ; }
 public static boolean deleteDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return dir . delete ( ) ; }
 public static String nodeIdLogFileName ( UUID nodeId , String fileName ) { assert nodeId != null ; assert fileName != null ; fileName = GridFilenameUtils . separatorsToSystem ( fileName ) ; int dot = fileName . lastIndexOf ( ' . ' ) ; if ( dot < 0 || dot == fileName . length ( ) - 1 ) return fileName + ' - ' + U . id8 ( nodeId ) ; else return fileName . substring ( 0 , dot ) + ' - ' + U . id8 ( nodeId ) + fileName . substring ( dot ) ; }
 public static Collection < InetAddress > toInetAddresses ( ClusterNode node ) throws IgniteCheckedException { return toInetAddresses ( node . addresses ( ) , node . hostNames ( ) ) ; }
 public static JsArrayString wrapArray ( String [ ] srcArray ) { JsArrayString result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
 public static double heapSize ( ClusterNode node , int precision ) { return heapSize ( Collections . singleton ( node ) , precision ) ; }
 public static int longToBytes ( long l , byte [ ] bytes , int off ) { return off + GridClientByteUtils . longToBytes ( l , bytes , off ) ; }
 private static void setCrosstoolToAndroid ( BuildOptions options ) { AndroidConfiguration . Options androidOptions = options . get ( AndroidConfiguration . Options . class ) ; CppOptions cppOptions = options . get ( CppOptions . class ) ; if ( androidOptions . androidCrosstoolTop != null ) { cppOptions . crosstoolTop = androidOptions . androidCrosstoolTop ; } androidOptions . configurationDistinguisher = ConfigurationDistinguisher . ANDROID ; }
 @ Nullable public static ClassLoader detectObjectClassLoader ( @ Nullable Object obj ) { if ( obj == null ) return null ; if ( obj instanceof GridPeerDeployAware ) return ( ( GridPeerDeployAware ) obj ) . classLoader ( ) ; return detectClassLoader ( obj . getClass ( ) ) ; }
 public static < E extends Enum > void writeEnum ( DataOutput out , E e ) throws IOException { out . writeByte ( e == null ? - 1 : e . ordinal ( ) ) ; }
 public static TextureContainer < TiledTextureRegion > produce ( final Texture texture , final Context context , final String assetPath , final int texturePositionX , final int texturePositionY , final int tileColumns , final int tileRows ) { return new TextureContainer < TiledTextureRegion > ( TextureRegionFactory . createTiledFromAsset ( texture , context , assetPath , texturePositionX , texturePositionY , tileColumns , tileRows ) , getPixels ( assetPath , context , tileColumns , tileRows ) , assetPath ) ; }
 public static boolean await ( CountDownLatch latch , long timeout , TimeUnit unit ) throws IgniteInterruptedCheckedException { try { return latch . await ( timeout , unit ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String jvmVendor ( ) { return jvmImplVendor ; }
 public static boolean checkParam ( String method , PageData pd ) { boolean result = false ; int falseCount = 0 ; String [ ] paramArray = new String [ 20 ] ; String [ ] valueArray = new String [ 20 ] ; String [ ] tempArray = new String [ 20 ] ; if ( method == " registered " ) { paramArray = Const . APP_REGISTERED_PARAM_ARRAY ; valueArray = Const . APP_REGISTERED_VALUE_ARRAY ; } else if ( method == " getAppuserByUsernmae " ) { paramArray = Const . APP_GETAPPUSER_PARAM_ARRAY ; valueArray = Const . APP_GETAPPUSER_VALUE_ARRAY ; } int size = paramArray . length ; for ( int i = 0 ; i < size ; i ++ ) { String param = paramArray [ i ] ; if ( ! pd . containsKey ( param ) ) { tempArray [ falseCount ] = valueArray [ i ] + " - - " + param ; falseCount += 1 ; } } if ( falseCount > 0 ) { logger . error ( method + " 接口 ， 请求协议中缺少 ▁ " + falseCount + " 个 ▁ 参数 " ) ; for ( int j = 1 ; j <= falseCount ; j ++ ) { logger . error ( " ▁ ▁ ▁ 第 " + j + " 个 ： " + tempArray [ j - 1 ] ) ; } } else { result = true ; } return result ; }
 public static void writeByteArray ( DataOutput out , @ Nullable byte [ ] arr ) throws IOException { if ( arr == null ) out . writeInt ( - 1 ) ; else { out . writeInt ( arr . length ) ; out . write ( arr ) ; } }
 public static UUID bytesToUuid ( byte [ ] bytes , int off ) { return GridClientByteUtils . bytesToUuid ( bytes , off ) ; }
 private static long toAddrAndLen ( long address , int size ) { return ( address << SIZE_BITS ) | size ; }
 public static void clearClassCache ( ) { classCache . clear ( ) ; }
 public static RuntimeMXBean getRuntimeMx ( ) { return ManagementFactory . getRuntimeMXBean ( ) ; }
 public static String convertToFilePath ( String qualifiedJavaName , String suffix ) { return qualifiedJavaName . replace ( ' . ' , File . separatorChar ) + suffix ; }
 @ Nullable public static URL resolveIgniteUrl ( String path ) { return resolveIgniteUrl ( path , true ) ; }
 public static int concurrentMapSegment ( int hash , int concurLvl ) { hash += ( hash << 15 ) ^ 0xffffcd7d ; hash ^= ( hash >>> 10 ) ; hash += ( hash << 3 ) ; hash ^= ( hash >>> 6 ) ; hash += ( hash << 2 ) + ( hash << 14 ) ; int shift = 0 ; int size = 1 ; while ( size < concurLvl ) { ++ shift ; size <<= 1 ; } int segmentShift = 32 - shift ; int segmentMask = size - 1 ; return ( hash >>> segmentShift ) & segmentMask ; }
 public static < V , C extends Collection < ? super V > > C addAll ( C c , V ... vals ) { Collections . addAll ( c , vals ) ; return c ; }
 public static List < InetAddress > filterReachable ( List < InetAddress > addrs ) { final int reachTimeout = 2000 ; if ( addrs . isEmpty ( ) ) return Collections . emptyList ( ) ; if ( addrs . size ( ) == 1 ) { InetAddress addr = addrs . get ( 0 ) ; if ( reachable ( addr , reachTimeout ) ) return Collections . singletonList ( addr ) ; return Collections . emptyList ( ) ; } final List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Collection < Future < ? > > futs = new ArrayList < > ( addrs . size ( ) ) ; ExecutorService executor = Executors . newFixedThreadPool ( Math . min ( 10 , addrs . size ( ) ) ) ; for ( final InetAddress addr : addrs ) { futs . add ( executor . submit ( new Runnable ( ) { @ Override public void run ( ) { if ( reachable ( addr , reachTimeout ) ) { synchronized ( res ) { res . add ( addr ) ; } } } } ) ) ; } for ( Future < ? > fut : futs ) { try { fut . get ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteException ( " Thread ▁ has ▁ been ▁ interrupted . " , e ) ; } catch ( ExecutionException e ) { throw new IgniteException ( e ) ; } } executor . shutdown ( ) ; return res ; }
 public static Collection < InetAddress > toInetAddresses ( Collection < String > addrs , Collection < String > hostNames ) throws IgniteCheckedException { List < InetAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; InetAddress inetAddr = null ; if ( ! F . isEmpty ( hostName ) ) { try { inetAddr = InetAddress . getByName ( hostName ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr == null || inetAddr . isLoopbackAddress ( ) ) { try { inetAddr = InetAddress . getByName ( addr ) ; } catch ( UnknownHostException ignored ) { } } if ( inetAddr != null ) res . add ( inetAddr ) ; } if ( res . isEmpty ( ) ) throw new IgniteCheckedException ( " Addresses ▁ can ▁ not ▁ be ▁ resolved ▁ [ addr = " + addrs + " , ▁ hostNames = " + hostNames + ' ] ' ) ; return F . viewListReadOnly ( res , F . < InetAddress > identity ( ) ) ; }
 public static void removeLog4jNoOpLogger ( IgniteBiTuple < Object , Object > t ) throws IgniteCheckedException { Object rootLog = t . get1 ( ) ; Object nullApp = t . get2 ( ) ; if ( nullApp == null ) return ; try { Class appenderCls = Class . forName ( " org . apache . log4j . Appender " ) ; rootLog . getClass ( ) . getMethod ( " removeAppender " , appenderCls ) . invoke ( rootLog , nullApp ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ remove ▁ previously ▁ added ▁ no - op ▁ logger ▁ for ▁ Log4j . " , e ) ; } }
 public static boolean isLoadableBy ( String clsName , @ Nullable ClassLoader ldr ) { assert clsName != null ; if ( ldr == null ) ldr = gridClassLoader ; String lambdaParent = U . lambdaEnclosingClassName ( clsName ) ; try { ldr . loadClass ( lambdaParent == null ? clsName : lambdaParent ) ; return true ; } catch ( ClassNotFoundException ignore ) { return false ; } }
 public static boolean joinThreads ( Iterable < ? extends Thread > workers , @ Nullable IgniteLogger log ) { boolean retval = true ; if ( workers != null ) for ( Thread worker : workers ) if ( ! join ( worker , log ) ) retval = false ; return retval ; }
 public static void main ( String [ ] args ) { PageData pd = new PageData ( ) ; pd . put ( " username " , " zhangsan " ) ; checkParam ( " registered " , pd ) ; }
 public static byte [ ] doubleToBytes ( double d ) { return longToBytes ( Double . doubleToLongBits ( d ) ) ; }
 public static boolean overridesEqualsAndHashCode ( Object obj ) { try { Class < ? > cls = obj . getClass ( ) ; return ! Object . class . equals ( cls . getMethod ( " equals " , Object . class ) . getDeclaringClass ( ) ) && ! Object . class . equals ( cls . getMethod ( " hashCode " ) . getDeclaringClass ( ) ) ; } catch ( NoSuchMethodException | SecurityException ignore ) { return true ; } }
 @ Nullable public static List < Integer > readIntList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
 public static String getPackageName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( 0 , idx ) ; }
 private static Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , IgniteException > > exceptionConverters ( ) { Map < Class < ? extends IgniteCheckedException > , C1 < IgniteCheckedException , IgniteException > > m = new HashMap < > ( ) ; m . put ( IgniteInterruptedCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteInterruptedException ( e . getMessage ( ) , ( InterruptedException ) e . getCause ( ) ) ; } } ) ; m . put ( IgniteFutureCancelledCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteFutureCancelledException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteFutureTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteFutureTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ClusterGroupEmptyCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ClusterGroupEmptyException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ClusterTopologyCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { ClusterTopologyException topEx = new ClusterTopologyException ( e . getMessage ( ) , e ) ; ClusterTopologyCheckedException checked = ( ClusterTopologyCheckedException ) e ; if ( checked . retryReadyFuture ( ) != null ) topEx . retryReadyFuture ( new IgniteFutureImpl < > ( checked . retryReadyFuture ( ) ) ) ; return topEx ; } } ) ; m . put ( IgniteDeploymentCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteDeploymentException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ComputeTaskTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ComputeTaskTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( ComputeTaskCancelledCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new ComputeTaskCancelledException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxRollbackCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionRollbackException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxHeuristicCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionHeuristicException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxTimeoutCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionTimeoutException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteTxOptimisticCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new TransactionOptimisticException ( e . getMessage ( ) , e ) ; } } ) ; m . put ( IgniteClientDisconnectedCheckedException . class , new C1 < IgniteCheckedException , IgniteException > ( ) { @ Override public IgniteException apply ( IgniteCheckedException e ) { return new IgniteClientDisconnectedException ( ( ( IgniteClientDisconnectedCheckedException ) e ) . reconnectFuture ( ) , e . getMessage ( ) , e ) ; } } ) ; return m ; }
 public static boolean isWindowsXp ( ) { return winXp ; }
 ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return false ; } else return false ; return true ; }
 @ AfterClass public static void tearDown ( ) throws SQLException { System . out . println ( " = = = = ▁ Cleaning ▁ inmemory ▁ db ▁ = = = = " ) ; RunScript . execute ( JDBC_URL , " sa " , " sa " , " classpath : cz / kec / of / ansible / dao / clearDb . sql " , Charset . forName ( " UTF - 8" ) , false ) ; }
 public static void startThreads ( Iterable < ? extends Thread > threads ) { if ( threads != null ) { for ( Thread thread : threads ) { if ( thread != null ) thread . start ( ) ; } } }
 private static long toAddress ( long addrAndLen ) { return addrAndLen >>> SIZE_BITS ; }
 public static int jvmPid ( ) { String name = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; try { int idx = name . indexOf ( ' @ ' ) ; return idx > 0 ? Integer . parseInt ( name . substring ( 0 , idx ) ) : - 1 ; } catch ( NumberFormatException ignored ) { return - 1 ; } }
 public static < T extends R , R > List < R > arrayList ( Collection < T > c ) { assert c != null ; return new ArrayList < R > ( c ) ; }
 public static double bytesToDouble ( byte [ ] bytes , int off ) { return Double . longBitsToDouble ( bytesToLong ( bytes , off ) ) ; }
 public static void close ( @ Nullable SelectionKey rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) close ( rsrc . channel ( ) , log ) ; }
 public static String jreVersion ( ) { return javaRtVer ; }
 public static void setWorkDirectory ( @ Nullable String userWorkDir , @ Nullable String userIgniteHome ) throws IgniteCheckedException { String igniteWork0 = igniteWork ; if ( igniteWork0 == null ) { synchronized ( IgniteUtils . class ) { igniteWork0 = igniteWork ; if ( igniteWork0 != null ) return ; File workDir ; if ( ! F . isEmpty ( userWorkDir ) ) workDir = new File ( userWorkDir ) ; else if ( ! F . isEmpty ( IGNITE_WORK_DIR ) ) workDir = new File ( IGNITE_WORK_DIR ) ; else if ( ! F . isEmpty ( userIgniteHome ) ) workDir = new File ( userIgniteHome , " work " ) ; else { String tmpDirPath = System . getProperty ( " java . io . tmpdir " ) ; if ( tmpDirPath == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ work ▁ directory ▁ in ▁ OS ▁ temp ▁ " + " ( property ▁ ' java . io . tmpdir ' ▁ is ▁ null ) . " ) ; workDir = new File ( tmpDirPath , " ignite " + File . separator + " work " ) ; } if ( ! workDir . isAbsolute ( ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ path ▁ must ▁ be ▁ absolute : ▁ " + workDir ) ; if ( ! mkdirs ( workDir ) ) throw new IgniteCheckedException ( " Work ▁ directory ▁ does ▁ not ▁ exist ▁ and ▁ cannot ▁ be ▁ created : ▁ " + workDir ) ; if ( ! workDir . canRead ( ) ) throw new IgniteCheckedException ( " Cannot ▁ read ▁ from ▁ work ▁ directory : ▁ " + workDir ) ; if ( ! workDir . canWrite ( ) ) throw new IgniteCheckedException ( " Cannot ▁ write ▁ to ▁ work ▁ directory : ▁ " + workDir ) ; igniteWork = workDir . getAbsolutePath ( ) ; } } }
 public static Class < ? > detectClass ( Object obj ) { assert obj != null ; if ( obj instanceof GridPeerDeployAware ) return ( ( GridPeerDeployAware ) obj ) . deployClass ( ) ; if ( U . isPrimitiveArray ( obj ) ) return obj . getClass ( ) ; if ( ! U . isJdk ( obj . getClass ( ) ) ) return obj . getClass ( ) ; if ( obj instanceof Iterable < ? > ) { Object o = F . first ( ( Iterable < ? > ) obj ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } if ( obj instanceof Map ) { Map . Entry < ? , ? > e = F . firstEntry ( ( Map < ? , ? > ) obj ) ; if ( e != null ) { Object k = e . getKey ( ) ; if ( k != null && ! U . isJdk ( k . getClass ( ) ) ) return k . getClass ( ) ; Object v = e . getValue ( ) ; return v != null ? v . getClass ( ) : obj . getClass ( ) ; } } if ( obj . getClass ( ) . isArray ( ) ) { int len = Array . getLength ( obj ) ; if ( len > 0 ) { Object o = Array . get ( obj , 0 ) ; return o != null ? o . getClass ( ) : obj . getClass ( ) ; } else return obj . getClass ( ) . getComponentType ( ) ; } return obj . getClass ( ) ; }
 @ Nullable public static IgniteUuid readGridUuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; UUID globalId = IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) ; long locId = in . readLong ( ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
 public static ThreadMXBean getThreadMx ( ) { return ManagementFactory . getThreadMXBean ( ) ; }
 public static int intToBytes ( int i , byte [ ] bytes , int off ) { return off + GridClientByteUtils . intToBytes ( i , bytes , off ) ; }
 private static void addresses ( InetAddress addr , Collection < String > addrs , Collection < String > hostNames ) { String hostName = addr . getHostName ( ) ; String ipAddr = addr . getHostAddress ( ) ; addrs . add ( ipAddr ) ; if ( ! F . isEmpty ( hostName ) && ! addr . isLoopbackAddress ( ) ) hostNames . add ( hostName ) ; }
 public static < T > Iterable < T > randomIterable ( Collection < T > col ) { List < T > list = new ArrayList < > ( col ) ; Collections . shuffle ( list ) ; return list ; }
 static private void add ( DataStreamMarshaller dsm ) { marshaller [ dsm . getDataStructureType ( ) ] = dsm ; }
 ) @ Nullable public static Map < Integer , Integer > readIntKeyIntValueMap ( DataInput in ) throws IOException { Map < Integer , Integer > map = null ; if ( in . readBoolean ( ) ) { int size = in . readInt ( ) ; map = new HashMap < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) map . put ( in . readInt ( ) , in . readInt ( ) ) ; } return map ; }
 public static DataStream < Tuple5 < Integer , Long , Integer , String , Long > > get5TupleDataStream ( StreamExecutionEnvironment env ) { List < Tuple5 < Integer , Long , Integer , String , Long > > data = new ArrayList < > ( ) ; data . add ( new Tuple5 < > ( 1 , 1L , 0 , " Hallo " , 1L ) ) ; data . add ( new Tuple5 < > ( 2 , 2L , 1 , " Hallo ▁ Welt " , 2L ) ) ; data . add ( new Tuple5 < > ( 2 , 3L , 2 , " Hallo ▁ Welt ▁ wie " , 1L ) ) ; data . add ( new Tuple5 < > ( 3 , 4L , 3 , " Hallo ▁ Welt ▁ wie ▁ gehts ? " , 2L ) ) ; data . add ( new Tuple5 < > ( 3 , 5L , 4 , " ABC " , 2L ) ) ; data . add ( new Tuple5 < > ( 3 , 6L , 5 , " BCD " , 3L ) ) ; data . add ( new Tuple5 < > ( 4 , 7L , 6 , " CDE " , 2L ) ) ; data . add ( new Tuple5 < > ( 4 , 8L , 7 , " DEF " , 1L ) ) ; data . add ( new Tuple5 < > ( 4 , 9L , 8 , " EFG " , 1L ) ) ; data . add ( new Tuple5 < > ( 4 , 10L , 9 , " FGH " , 2L ) ) ; data . add ( new Tuple5 < > ( 5 , 11L , 10 , " GHI " , 1L ) ) ; data . add ( new Tuple5 < > ( 5 , 12L , 11 , " HIJ " , 3L ) ) ; data . add ( new Tuple5 < > ( 5 , 13L , 12 , " IJK " , 3L ) ) ; data . add ( new Tuple5 < > ( 5 , 15L , 14 , " KLM " , 2L ) ) ; data . add ( new Tuple5 < > ( 5 , 14L , 13 , " JKL " , 2L ) ) ; return env . fromCollection ( data ) ; }
 @ Nullable public static int [ ] readIntArray ( DataInput in ) throws IOException { int len = in . readInt ( ) ; if ( len == - 1 ) return null ; int [ ] res = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) res [ i ] = in . readInt ( ) ; return res ; }
 public static String filler ( int len , char ch ) { char [ ] a = new char [ len ] ; Arrays . fill ( a , ch ) ; return new String ( a ) ; }
 public static void writeStringToFile ( File file , String s , String charset ) throws IOException { writeStringToFile ( file , s , charset , false ) ; }
 ) private static byte hexCharToByte ( char ch ) throws IllegalArgumentException { switch ( ch ) { case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : return ( byte ) ( ch - '0' ) ; case ' a ' : case ' A ' : return 0xa ; case ' b ' : case ' B ' : return 0xb ; case ' c ' : case ' C ' : return 0xc ; case ' d ' : case ' D ' : return 0xd ; case ' e ' : case ' E ' : return 0xe ; case ' f ' : case ' F ' : return 0xf ; default : throw new IllegalArgumentException ( " Hex ▁ decoding ▁ wrong ▁ input ▁ character ▁ [ character = " + ch + ' ] ' ) ; } }
 @ Deprecated public static void debugStack ( IgniteLogger log , String msg ) { log . error ( msg , new Exception ( debugPrefix ( ) + msg ) ) ; }
 @ Nullable public static List < Byte > readByteList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; List < Byte > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readByte ( ) ) ; return col ; }
 public static void await ( CountDownLatch latch ) throws IgniteInterruptedCheckedException { try { if ( latch . getCount ( ) > 0 ) latch . await ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String jdkString ( ) { return jdkStr ; }
 public static void warn ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) log . warning ( compact ( longMsg . toString ( ) ) ) ; else X . println ( " [ " + SHORT_DATE_FMT . format ( new java . util . Date ( ) ) + " ] ▁ ( wrn ) ▁ " + compact ( shortMsg . toString ( ) ) ) ; }
 public static void writeByteCollection ( DataOutput out , Collection < Byte > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Byte i : col ) out . writeByte ( i ) ; } else out . writeInt ( - 1 ) ; }
 private static String capitalFirst ( @ Nullable String str ) { return str == null ? null : str . isEmpty ( ) ? " " : Character . toUpperCase ( str . charAt ( 0 ) ) + str . substring ( 1 ) ; }
 public static < T > LinkedHashSet < T > newLinkedHashSet ( int expSize ) { return new LinkedHashSet < > ( capacity ( expSize ) ) ; }
 public static synchronized < T > ListType < T > getInstance ( AbstractType < T > elements , boolean isMultiCell ) { Map < AbstractType < ? > , ListType > internMap = isMultiCell ? instances : frozenInstances ; ListType < T > t = internMap . get ( elements ) ; if ( t == null ) { t = new ListType < T > ( elements , isMultiCell ) ; internMap . put ( elements , t ) ; } return t ; }
 public static TextureContainer < TextureRegion > produce ( final Texture texture , final Context context , final String assetPath , final int texturePositionX , final int texturePositionY ) { return new TextureContainer < TextureRegion > ( TextureRegionFactory . createFromAsset ( texture , context , assetPath , texturePositionX , texturePositionY ) , getPixels ( assetPath , context , 1 , 1 ) , assetPath ) ; }
 @ NonNull public static < T > ReadOnlyProperty < T > create ( @ NonNull Observable < T > observable ) { return new ReadOnlyProperty < > ( observable ) ; }
 public static Exception unwrap ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof GridClosureException ) { t = ( ( GridClosureException ) t ) . unwrap ( ) ; continue ; } return ( Exception ) t ; } }
 public static InetAddress resolveLocalHost ( @ Nullable String hostName ) throws IOException { return F . isEmpty ( hostName ) ? new InetSocketAddress ( 0 ) . getAddress ( ) : InetAddress . getByName ( hostName ) ; }
 public static C1 < IgniteCheckedException , IgniteException > getExceptionConverter ( Class < ? extends IgniteCheckedException > clazz ) { return exceptionConverters . get ( clazz ) ; }
 public static Collection < UUID > gridIds ( @ Nullable Collection < ? extends Ignite > grids ) { return F . viewReadOnly ( grids , new C1 < Ignite , UUID > ( ) { @ Override public UUID apply ( Ignite g ) { return g . cluster ( ) . localNode ( ) . id ( ) ; } } ) ; }
 @ Nullable public static Set < Integer > readIntSet ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Set < Integer > set = new HashSet < > ( size , 1.0f ) ; for ( int i = 0 ; i < size ; i ++ ) set . add ( in . readInt ( ) ) ; return set ; }
 public static Collector < JsonValue , JsonArrayBuilder , JsonArray > toJsonArray ( ) { return null ; }
 public static void interrupt ( Iterable < ? extends Thread > workers ) { if ( workers != null ) for ( Thread worker : workers ) worker . interrupt ( ) ; }
 @ Nullable private static GridPeerDeployAware nestedPeerDeployAware ( Object obj , boolean top , Set < Object > processed ) { if ( ! processed . add ( obj ) ) return null ; if ( obj instanceof GridPeerDeployAware ) { GridPeerDeployAware p = ( GridPeerDeployAware ) obj ; if ( ! top && p . deployClass ( ) != null ) return p ; for ( Class < ? > cls = obj . getClass ( ) ; ! cls . equals ( Object . class ) ; cls = cls . getSuperclass ( ) ) { IgniteBiTuple < Class < ? > , Collection < Field > > tup = p2pFields . get ( cls . getName ( ) ) ; boolean cached = tup != null && tup . get1 ( ) . equals ( cls ) ; Iterable < Field > fields = cached ? tup . get2 ( ) : Arrays . asList ( cls . getDeclaredFields ( ) ) ; if ( ! cached ) { tup = F . t2 ( ) ; tup . set1 ( cls ) ; } for ( Field f : fields ) if ( cached || f . getName ( ) . startsWith ( " this $ " ) || f . getName ( ) . startsWith ( " val $ " ) ) { if ( ! cached ) { f . setAccessible ( true ) ; if ( tup . get2 ( ) == null ) tup . set2 ( new LinkedList < Field > ( ) ) ; tup . get2 ( ) . add ( f ) ; } try { Object o = f . get ( obj ) ; if ( o != null ) { p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) { if ( ! cached ) p2pFields . put ( cls . getName ( ) , tup ) ; return p ; } } } catch ( IllegalAccessException ignored ) { return null ; } } } } else if ( isIgnite ( obj . getClass ( ) ) ) return null ; else if ( obj instanceof Iterable ) for ( Object o : ( Iterable < ? > ) obj ) { GridPeerDeployAware p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) return p ; } else if ( obj . getClass ( ) . isArray ( ) ) { Class < ? > type = obj . getClass ( ) . getComponentType ( ) ; if ( ! type . isPrimitive ( ) && ! isJdk ( type ) ) { Object [ ] arr = ( Object [ ] ) obj ; for ( Object o : arr ) { GridPeerDeployAware p = nestedPeerDeployAware ( o , false , processed ) ; if ( p != null ) return p ; } } } return null ; }
 public static Collection < InetSocketAddress > toSocketAddresses ( Collection < String > addrs , Collection < String > hostNames , int port ) { List < InetSocketAddress > res = new ArrayList < > ( addrs . size ( ) ) ; Iterator < String > hostNamesIt = hostNames . iterator ( ) ; for ( String addr : addrs ) { String hostName = hostNamesIt . hasNext ( ) ? hostNamesIt . next ( ) : null ; if ( ! F . isEmpty ( hostName ) ) { InetSocketAddress inetSockAddr = new InetSocketAddress ( hostName , port ) ; if ( inetSockAddr . isUnresolved ( ) || inetSockAddr . getAddress ( ) . isLoopbackAddress ( ) ) inetSockAddr = new InetSocketAddress ( addr , port ) ; res . add ( inetSockAddr ) ; } res . add ( new InetSocketAddress ( addr , port ) ) ; } return F . viewListReadOnly ( res , F . < InetSocketAddress > identity ( ) ) ; }
 public static < T > T property ( Object obj , String propName ) { assert obj != null ; assert propName != null ; try { Method m ; try { m = obj . getClass ( ) . getMethod ( " get " + capitalFirst ( propName ) ) ; } catch ( NoSuchMethodException ignored ) { m = obj . getClass ( ) . getMethod ( " is " + capitalFirst ( propName ) ) ; } assert F . isEmpty ( m . getParameterTypes ( ) ) ; boolean accessible = m . isAccessible ( ) ; try { m . setAccessible ( true ) ; return ( T ) m . invoke ( obj ) ; } finally { m . setAccessible ( accessible ) ; } } catch ( Exception e ) { throw new IgniteException ( " Failed ▁ to ▁ get ▁ property ▁ value ▁ [ property = " + propName + " , ▁ obj = " + obj + ' ] ' , e ) ; } }
 public static GridPeerDeployAware peerDeployAware ( Object obj ) { assert obj != null ; if ( obj instanceof GridPeerDeployAware ) return ( GridPeerDeployAware ) obj ; final Class < ? > cls = obj instanceof Class ? ( Class ) obj : obj . getClass ( ) ; return new GridPeerDeployAware ( ) { private ClassLoader ldr ; @ Override public Class < ? > deployClass ( ) { return cls ; } @ Override public ClassLoader classLoader ( ) { if ( ldr == null ) ldr = detectClassLoader ( cls ) ; return ldr ; } } ; }
 public static String jreName ( ) { return javaRtName ; }
 public static HTPackage init ( ) { if ( isInited ) return ( HTPackage ) EPackage . Registry . INSTANCE . getEPackage ( HTPackage . eNS_URI ) ; HTPackageImpl theHTPackage = ( HTPackageImpl ) ( EPackage . Registry . INSTANCE . get ( eNS_URI ) instanceof HTPackageImpl ? EPackage . Registry . INSTANCE . get ( eNS_URI ) : new HTPackageImpl ( ) ) ; isInited = true ; XMLNamespacePackage . eINSTANCE . eClass ( ) ; XMLTypePackage . eINSTANCE . eClass ( ) ; theHTPackage . createPackageContents ( ) ; theHTPackage . initializePackageContents ( ) ; theHTPackage . freeze ( ) ; EPackage . Registry . INSTANCE . put ( HTPackage . eNS_URI , theHTPackage ) ; return theHTPackage ; }
 public static boolean isSolarisX86 ( ) { return solaris && x86 ; }
 @ Nullable public static < T > T newInstance ( String cls ) throws IgniteCheckedException { Class < ? > cls0 ; try { cls0 = Class . forName ( cls ) ; } catch ( Exception e ) { throw new IgniteCheckedException ( e ) ; } return ( T ) newInstance ( cls0 ) ; }
 public static boolean isPrimitiveOrWrapper ( Class < ? > cls ) { return cls . isPrimitive ( ) || Boolean . class . equals ( cls ) || Byte . class . equals ( cls ) || Character . class . equals ( cls ) || Short . class . equals ( cls ) || Integer . class . equals ( cls ) || Long . class . equals ( cls ) || Float . class . equals ( cls ) || Double . class . equals ( cls ) || Void . class . equals ( cls ) ; }
 private static boolean unsafeByteArrayCopyAvailable ( ) { try { Class < ? extends Unsafe > unsafeCls = UNSAFE . getClass ( ) ; unsafeCls . getMethod ( " copyMemory " , Object . class , long . class , Object . class , long . class , long . class ) ; return true ; } catch ( Exception ignored ) { return false ; } }
 public static String osString ( ) { return osStr ; }
 public static void closeQuiet ( @ Nullable AutoCloseable rsrc ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( Exception ignored ) { } }
 ) @ Nullable public static < T > T forceNewInstance ( Class < ? > cls ) throws IgniteCheckedException { Constructor ctor = forceEmptyConstructor ( cls ) ; if ( ctor == null ) return null ; boolean set = false ; try { if ( ! ctor . isAccessible ( ) ) { ctor . setAccessible ( true ) ; set = true ; } return ( T ) ctor . newInstance ( ) ; } catch ( InstantiationException | InvocationTargetException | IllegalAccessException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ create ▁ new ▁ instance ▁ for ▁ class : ▁ " + cls , e ) ; } finally { if ( set ) ctor . setAccessible ( false ) ; } }
 public static < T > T field ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Class c = cls ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { for ( Field field : c . getDeclaredFields ( ) ) { if ( field . getName ( ) . equals ( fieldName ) ) { if ( ! Modifier . isStatic ( field . getModifiers ( ) ) ) throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ class ▁ field ▁ ( field ▁ is ▁ not ▁ static ) ▁ [ cls = " + cls + " , ▁ fieldName = " + fieldName + ' ] ' ) ; boolean accessible = field . isAccessible ( ) ; T val ; try { field . setAccessible ( true ) ; val = ( T ) field . get ( null ) ; } finally { if ( ! accessible ) field . setAccessible ( false ) ; } return val ; } } } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ ( field ▁ was ▁ not ▁ found ) ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
 ) public static void wait ( Object mux ) throws IgniteInterruptedCheckedException { try { mux . wait ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 @ Nullable public static < T extends Annotation > T getAnnotation ( Class < ? > cls , Class < T > annCls ) { if ( cls == Object . class ) return null ; T ann = cls . getAnnotation ( annCls ) ; if ( ann != null ) return ann ; for ( Class < ? > itf : cls . getInterfaces ( ) ) { ann = getAnnotation ( itf , annCls ) ; if ( ann != null ) return ann ; } if ( ! cls . isInterface ( ) ) { ann = getAnnotation ( cls . getSuperclass ( ) , annCls ) ; if ( ann != null ) return ann ; } return null ; }
 public static Collection < String > nodes2names ( @ Nullable Collection < ? extends ClusterNode > nodes ) { return F . viewReadOnly ( nodes , new C1 < ClusterNode , String > ( ) { @ Override public String apply ( ClusterNode n ) { return G . ignite ( n . id ( ) ) . name ( ) ; } } ) ; }
 @ Deprecated public static void debug ( Object msg ) { X . error ( debugPrefix ( ) + msg ) ; }
 public static boolean isPow2 ( int i ) { return i > 0 && ( i & ( i - 1 ) ) == 0 ; }
 public static < T extends Annotation > boolean hasAnnotation ( Object o , Class < T > annCls ) { return o != null && hasAnnotation ( o . getClass ( ) , annCls ) ; }
 public static String normalizePackageName ( String packageName ) { if ( isEmptyString ( packageName ) || ! packageName . endsWith ( " . " ) ) { return packageName ; } else { return packageName . substring ( 0 , packageName . length ( ) - 1 ) ; } }
 public static void reloadChanges ( ChangeSet cs ) throws OrmException { for ( ChangeData cd : cs . changes ( ) ) { cd . reloadChange ( ) ; cd . setPatchSets ( null ) ; } }
 static int compareListOrSet ( AbstractType < ? > elementsComparator , ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) || ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? 1 : o2 . hasRemaining ( ) ? - 1 : 0 ; ByteBuffer bb1 = o1 . duplicate ( ) ; ByteBuffer bb2 = o2 . duplicate ( ) ; int size1 = CollectionSerializer . readCollectionSize ( bb1 , 3 ) ; int size2 = CollectionSerializer . readCollectionSize ( bb2 , 3 ) ; for ( int i = 0 ; i < Math . min ( size1 , size2 ) ; i ++ ) { ByteBuffer v1 = CollectionSerializer . readValue ( bb1 , 3 ) ; ByteBuffer v2 = CollectionSerializer . readValue ( bb2 , 3 ) ; int cmp = elementsComparator . compare ( v1 , v2 ) ; if ( cmp != 0 ) return cmp ; } return size1 == size2 ? 0 : ( size1 < size2 ? - 1 : 1 ) ; }
 private static synchronized InetAddress resetLocalHost ( ) throws IOException { locHost = null ; String sysLocHost = IgniteSystemProperties . getString ( IGNITE_LOCAL_HOST ) ; if ( sysLocHost != null ) sysLocHost = sysLocHost . trim ( ) ; if ( ! F . isEmpty ( sysLocHost ) ) locHost = InetAddress . getByName ( sysLocHost ) ; else { List < NetworkInterface > itfs = new ArrayList < > ( ) ; for ( NetworkInterface itf : asIterable ( NetworkInterface . getNetworkInterfaces ( ) ) ) itfs . add ( itf ) ; Collections . sort ( itfs , new Comparator < NetworkInterface > ( ) { @ Override public int compare ( NetworkInterface itf1 , NetworkInterface itf2 ) { return itf1 . getName ( ) . compareTo ( itf2 . getName ( ) ) ; } } ) ; int reachTimeout = 2000 ; for ( NetworkInterface itf : itfs ) { boolean found = false ; for ( InetAddress addr : asIterable ( itf . getInetAddresses ( ) ) ) { if ( ! addr . isLoopbackAddress ( ) && ! addr . isLinkLocalAddress ( ) && reachable ( itf , addr , reachTimeout ) ) { locHost = addr ; found = true ; break ; } } if ( found ) break ; } } if ( locHost == null ) locHost = InetAddress . getLocalHost ( ) ; return locHost ; }
 public static List < Long > toLongList ( @ Nullable long [ ] arr ) { if ( arr == null || arr . length == 0 ) return Collections . emptyList ( ) ; List < Long > ret = new ArrayList < > ( arr . length ) ; for ( long l : arr ) ret . add ( l ) ; return ret ; }
 public static void writeUTFStringNullable ( DataOutput out , @ Nullable String val ) throws IOException { if ( val != null ) { out . writeBoolean ( true ) ; out . writeUTF ( val ) ; } else out . writeBoolean ( false ) ; }
 public static String getFileContents ( String filePath ) throws IOException { FileInputStream fileInStream = new FileInputStream ( filePath ) ; return readContent ( fileInStream ) ; }
 public static IgniteException convertException ( IgniteCheckedException e ) { IgniteClientDisconnectedException e0 = e . getCause ( IgniteClientDisconnectedException . class ) ; if ( e0 != null ) { assert e0 . reconnectFuture ( ) != null : e0 ; throw e0 ; } IgniteClientDisconnectedCheckedException disconnectedErr = e . getCause ( IgniteClientDisconnectedCheckedException . class ) ; if ( disconnectedErr != null ) { assert disconnectedErr . reconnectFuture ( ) != null : disconnectedErr ; e = disconnectedErr ; } C1 < IgniteCheckedException , IgniteException > converter = exceptionConverters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof IgniteException ) return ( IgniteException ) e . getCause ( ) ; return new IgniteException ( e . getMessage ( ) , e ) ; }
 public static long writeVersion ( byte [ ] arr , long off , GridCacheVersion ver ) { boolean verEx = ver instanceof GridCacheVersionEx ; UNSAFE . putBoolean ( arr , off ++ , verEx ) ; if ( verEx ) { GridCacheVersion drVer = ver . conflictVersion ( ) ; assert drVer != null ; UNSAFE . putInt ( arr , off , drVer . topologyVersion ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , drVer . nodeOrderAndDrIdRaw ( ) ) ; off += 4 ; UNSAFE . putLong ( arr , off , drVer . globalTime ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , drVer . order ( ) ) ; off += 8 ; } UNSAFE . putInt ( arr , off , ver . topologyVersion ( ) ) ; off += 4 ; UNSAFE . putInt ( arr , off , ver . nodeOrderAndDrIdRaw ( ) ) ; off += 4 ; UNSAFE . putLong ( arr , off , ver . globalTime ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , ver . order ( ) ) ; off += 8 ; return off ; }
 public static long bytesToLong ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Long . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; long res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
 public static void run ( File dir , File props ) { new MsgClassGenerator ( ) . generate ( dir , props ) ; }
 public static int shortToBytes ( short s , byte [ ] bytes , int off ) { return off + GridClientByteUtils . shortToBytes ( s , bytes , off ) ; }
 public static void awaitQuiet ( CyclicBarrier barrier ) { boolean interrupted = false ; while ( true ) { try { barrier . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } catch ( BrokenBarrierException ignored ) { break ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
 public static void registerAllExtensions ( com . google . protobuf . ExtensionRegistry registry ) { }
 public static void writeCollection ( ObjectOutput out , Collection < ? > col ) throws IOException { if ( col != null ) { out . writeInt ( col . size ( ) ) ; for ( Object o : col ) out . writeObject ( o ) ; } else out . writeInt ( - 1 ) ; }
 private static Bitmap getBitmap ( final String assetPath , final Context context ) { InputStream stream = null ; Bitmap bitmap = null ; try { stream = context . getAssets ( ) . open ( HalligatorActivity . GRAPHIC_ASSETS_PATH + assetPath ) ; bitmap = BitmapFactory . decodeStream ( stream ) ; } catch ( IOException e ) { Log . e ( " TextureContainerProvider " , " Exception " , e ) ; } finally { try { if ( stream != null ) { stream . close ( ) ; } } catch ( IOException e ) { Log . e ( " TextureContainerProvider " , " Exception " , e ) ; } } return bitmap ; }
 @ Nullable public static Method ctorFactory ( ) { return CTOR_FACTORY ; }
 public static ObjectName makeMBeanName ( @ Nullable String gridName , @ Nullable String grp , String name ) throws MalformedObjectNameException { SB sb = new SB ( JMX_DOMAIN + ' : ' ) ; appendClassLoaderHash ( sb ) ; appendJvmId ( sb ) ; if ( gridName != null && ! gridName . isEmpty ( ) ) sb . a ( " grid = " ) . a ( gridName ) . a ( ' , ' ) ; if ( grp != null ) sb . a ( " group = " ) . a ( grp ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
 public static boolean isWindows8 ( ) { return win8 ; }
 public static void closeQuietly ( XMLStreamWriter writer ) { if ( writer == null ) { return ; } try { writer . close ( ) ; } catch ( XMLStreamException ignore ) { } }
 public static String genDestFolderPath ( String destLoc , String serviceName , String suffixPath ) { StringBuilder destFolderPath = new StringBuilder ( ) ; destFolderPath . append ( toOSFilePath ( destLoc ) ) ; destFolderPath . append ( toOSFilePath ( suffixPath ) ) ; destFolderPath . append ( serviceName ) ; return destFolderPath . toString ( ) ; }
 public static void shutdownNow ( Class < ? > owner , @ Nullable ExecutorService exec , @ Nullable IgniteLogger log ) { if ( exec != null ) { List < Runnable > tasks = exec . shutdownNow ( ) ; if ( ! F . isEmpty ( tasks ) ) U . warn ( log , " Runnable ▁ tasks ▁ outlived ▁ thread ▁ pool ▁ executor ▁ service ▁ [ owner = " + getSimpleName ( owner ) + " , ▁ tasks = " + tasks + ' ] ' ) ; try { exec . awaitTermination ( Long . MAX_VALUE , TimeUnit . MILLISECONDS ) ; } catch ( InterruptedException ignored ) { warn ( log , " Got ▁ interrupted ▁ while ▁ waiting ▁ for ▁ executor ▁ service ▁ to ▁ stop . " ) ; exec . shutdownNow ( ) ; Thread . currentThread ( ) . interrupt ( ) ; } } }
 public static String makeFirstLetterLower ( String str ) { if ( isEmptyString ( str ) ) { return str ; } char firstChar = str . charAt ( 0 ) ; if ( Character . isLetter ( firstChar ) && Character . isUpperCase ( firstChar ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toLowerCase ( firstChar ) ; return String . valueOf ( chars ) ; } else { return str ; } }
 public static void quiet ( boolean err , Object ... objs ) { assert objs != null ; String time = SHORT_DATE_FMT . format ( new java . util . Date ( ) ) ; SB sb = new SB ( ) ; for ( Object obj : objs ) sb . a ( ' [ ' ) . a ( time ) . a ( " ] ▁ " ) . a ( obj . toString ( ) ) . a ( NL ) ; PrintStream ps = err ? System . err : System . out ; ps . print ( compact ( sb . toString ( ) ) ) ; }
 public static void warn ( @ Nullable IgniteLogger log , Object msg ) { assert msg != null ; String s = msg . toString ( ) ; warn ( log , s , s ) ; }
 public static < K , V , M extends Map < K , V > > M addAll ( M m , IgniteBiTuple < K , V > ... entries ) { for ( IgniteBiTuple < K , V > t : entries ) m . put ( t . get1 ( ) , t . get2 ( ) ) ; return m ; }
 public static IgniteCheckedException cast ( Throwable t ) { assert t != null ; while ( true ) { if ( t instanceof Error ) throw ( Error ) t ; if ( t instanceof GridClosureException ) { t = ( ( GridClosureException ) t ) . unwrap ( ) ; continue ; } if ( t instanceof IgniteCheckedException ) return ( IgniteCheckedException ) t ; if ( ! ( t instanceof IgniteException ) || t . getCause ( ) == null ) return new IgniteCheckedException ( t ) ; assert t . getCause ( ) != null ; t = t . getCause ( ) ; } }
 public static void awaitQuiet ( CountDownLatch latch ) { boolean interrupted = false ; while ( true ) { try { latch . await ( ) ; break ; } catch ( InterruptedException ignored ) { interrupted = true ; } } if ( interrupted ) Thread . currentThread ( ) . interrupt ( ) ; }
 public static String jdkName ( ) { return jdkName ; }
 public static final SafeImplicitOutputsFunction ANDROID_LIBRARY_IMPLICIT_OUTPUTS = new SafeImplicitOutputsFunction ( ) { @ Override public Iterable < String > getImplicitOutputs ( EventHandler eventHandler , AttributeMap attributes ) { ImmutableList . Builder < SafeImplicitOutputsFunction > implicitOutputs = ImmutableList . builder ( ) ; implicitOutputs . add ( AndroidRuleClasses . ANDROID_LIBRARY_class_JAR , AndroidRuleClasses . ANDROID_LIBRARY_SOURCE_JAR , AndroidRuleClasses . ANDROID_LIBRARY_AAR ) ; if ( AndroidResources . definesAndroidResources ( attributes ) ) { implicitOutputs . add ( AndroidRuleClasses . ANDROID_JAVA_SOURCE_JAR , AndroidRuleClasses . ANDROID_R_TXT , AndroidRuleClasses . ANDROID_RESOURCES_class_JAR ) ; } return fromFunctions ( implicitOutputs . build ( ) ) . getImplicitOutputs ( eventHandler , attributes ) ; } }
 public static String genDestFolderPath ( String destLoc , String suffixLoc ) { if ( isEmptyString ( destLoc ) ) { return destLoc ; } String destPath = toOSFilePath ( destLoc ) ; if ( ! isEmptyString ( suffixLoc ) ) { destPath = destPath + toOSFilePath ( suffixLoc ) ; } return destPath ; }
 public static byte directProtocolVersion ( GridKernalContext ctx , UUID nodeId ) throws IgniteCheckedException { assert nodeId != null ; ClusterNode node = ctx . discovery ( ) . node ( nodeId ) ; if ( node == null ) throw new IgniteCheckedException ( " Failed ▁ to ▁ define ▁ communication ▁ protocol ▁ version ▁ " + " ( has ▁ node ▁ left ▁ topology ? ) : ▁ " + nodeId ) ; assert ! node . isLocal ( ) ; Byte attr = node . attribute ( GridIoManager . DIRECT_PROTO_VER_ATTR ) ; byte rmtProtoVer = attr != null ? attr : 1 ; if ( rmtProtoVer < GridIoManager . DIRECT_PROTO_VER ) return rmtProtoVer ; else return GridIoManager . DIRECT_PROTO_VER ; }
 public static GridPeerDeployAware peerDeployAware0 ( Object obj ) { if ( obj instanceof Iterable ) return peerDeployAware0 ( ( Iterable ) obj ) ; if ( obj . getClass ( ) . isArray ( ) && ! U . isPrimitiveArray ( obj ) ) return peerDeployAware0 ( ( Object [ ] ) obj ) ; return peerDeployAware ( obj ) ; }
 @ Nullable public static IgniteUuid readGridUuid ( byte [ ] arr , long off ) { if ( UNSAFE . getBoolean ( arr , off ++ ) ) { long most = UNSAFE . getLong ( arr , off ) ; off += 8 ; long least = UNSAFE . getLong ( arr , off ) ; off += 8 ; UUID globalId = new UUID ( most , least ) ; long locId = UNSAFE . getLong ( arr , off ) ; return new IgniteUuid ( globalId , locId ) ; } return null ; }
 public static boolean isWindowsNt ( ) { return winNt ; }
 private static final SerializableAssert exComparator = new SerializableAssert ( ) { public void assertDeserialized ( Serializable initial , Serializable deserialized ) { SerializationTest . THROWABLE_COMPARATOR . assertDeserialized ( initial , deserialized ) ; MissingFormatWidthException initEx = ( MissingFormatWidthException ) initial ; MissingFormatWidthException desrEx = ( MissingFormatWidthException ) deserialized ; assertEquals ( " FormatSpecifier " , initEx . getFormatSpecifier ( ) , desrEx . getFormatSpecifier ( ) ) ; } }
 private static void skipPromotedIndex ( DataInputPlus in , Version version ) throws IOException { int size = version . storeRows ( ) ? ( int ) in . readUnsignedVInt ( ) : in . readInt ( ) ; if ( size <= 0 ) return ; FileUtils . skipBytesFully ( in , size ) ; }
 public static JMException jmException ( Throwable e ) { JMException x = new JMException ( ) ; x . initCause ( e ) ; return x ; }
 static public DataStreamMarshaller [ ] createMarshallerMap ( OpenWireFormat wireFormat ) { return marshaller ; }
 private static boolean hasCommonClassLoader ( Object obj , Iterable < ? > c ) { assert obj != null ; assert c != null ; ClassLoader ldr = obj instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj ) . classLoader ( ) : detectClassLoader ( obj . getClass ( ) ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String clsName = obj2 instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj2 ) . deployClass ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! isLoadableBy ( clsName , ldr ) ) { found = false ; break ; } } return found ; }
 public static void join ( Thread t ) throws IgniteInterruptedCheckedException { try { t . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static void quietAndInfo ( IgniteLogger log , String msg ) { if ( log . isQuiet ( ) ) U . quiet ( false , msg ) ; if ( log . isInfoEnabled ( ) ) log . info ( msg ) ; }
 public static IgniteLogger logger ( GridKernalContext ctx , AtomicReference < IgniteLogger > logRef , Class < ? > cls ) { IgniteLogger log = logRef . get ( ) ; if ( log == null ) { logRef . compareAndSet ( null , ctx . log ( cls ) ) ; log = logRef . get ( ) ; } return log ; }
 @ VisibleForTesting static Set < SSTableReader > overlapping ( SSTableReader sstable , Iterable < SSTableReader > others ) { return overlapping ( sstable . first . token , sstable . last . token , others ) ; }
 ) public static GridPeerDeployAware peerDeployAware0 ( @ Nullable Object ... c ) { if ( ! F . isEmpty ( c ) ) { assert c != null ; boolean notAllNulls = false ; for ( Object obj : c ) { if ( obj != null ) { notAllNulls = true ; ClassLoader ldr = obj instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj ) . classLoader ( ) : obj . getClass ( ) . getClassLoader ( ) ; boolean found = true ; for ( Object obj2 : c ) { if ( obj2 == null || obj2 == obj ) continue ; String clsName = obj2 instanceof GridPeerDeployAware ? ( ( GridPeerDeployAware ) obj2 ) . deployClass ( ) . getName ( ) : obj2 . getClass ( ) . getName ( ) ; if ( ! isLoadableBy ( clsName , ldr ) ) { found = false ; break ; } } if ( found ) return peerDeployAware0 ( obj ) ; } } if ( notAllNulls ) throw new IllegalArgumentException ( " Failed ▁ to ▁ find ▁ common ▁ class ▁ loader ▁ for ▁ all ▁ elements ▁ in ▁ " + " given ▁ collection . ▁ Peer ▁ deployment ▁ cannot ▁ be ▁ performed ▁ for ▁ such ▁ collection . " ) ; } return peerDeployAware ( new Object [ 0 ] ) ; }
 public static String formatMins ( long mins ) { assert mins >= 0 ; if ( mins == 0 ) return " < ▁ 1 ▁ min " ; SB sb = new SB ( ) ; long dd = mins / 1440 ; if ( dd > 0 ) sb . a ( dd ) . a ( dd == 1 ? " ▁ day ▁ " : " ▁ days ▁ " ) ; mins %= 1440 ; long hh = mins / 60 ; if ( hh > 0 ) sb . a ( hh ) . a ( hh == 1 ? " ▁ hour ▁ " : " ▁ hours ▁ " ) ; mins %= 60 ; if ( mins > 0 ) sb . a ( mins ) . a ( mins == 1 ? " ▁ min ▁ " : " ▁ mins ▁ " ) ; return sb . toString ( ) . trim ( ) ; }
 public static boolean isWindows2k ( ) { return win2k ; }
 public static GridCacheVersion readVersion ( byte [ ] arr , long off , boolean verEx ) { int topVer = UNSAFE . getInt ( arr , off ) ; off += 4 ; int nodeOrderDrId = UNSAFE . getInt ( arr , off ) ; off += 4 ; long globalTime = UNSAFE . getLong ( arr , off ) ; off += 8 ; long order = UNSAFE . getLong ( arr , off ) ; off += 8 ; GridCacheVersion ver = new GridCacheVersion ( topVer , nodeOrderDrId , globalTime , order ) ; if ( verEx ) { topVer = UNSAFE . getInt ( arr , off ) ; off += 4 ; nodeOrderDrId = UNSAFE . getInt ( arr , off ) ; off += 4 ; globalTime = UNSAFE . getLong ( arr , off ) ; off += 8 ; order = UNSAFE . getLong ( arr , off ) ; ver = new GridCacheVersionEx ( topVer , nodeOrderDrId , globalTime , order , ver ) ; } return ver ; }
 public static < K , V > HashMap < K , V > newHashMap ( int expSize ) { return new HashMap < > ( capacity ( expSize ) ) ; }
 public static StoreWriter createWriter ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } try { LOGGER . log ( Level . INFO , " Initialize ▁ writer ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; File parent = file . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( parent . mkdirs ( ) ) { LOGGER . log ( Level . INFO , " Creating ▁ directories ▁ for ▁ path ▁ { 0 } " , file . getName ( ) ) ; } else { throw new RuntimeException ( String . format ( " Couldn ' t ▁ create ▁ directory ▁ % s " , parent ) ) ; } } return new WriterImpl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
 public static File downloadUrl ( URL url , File file ) throws IOException { assert url != null ; assert file != null ; InputStream in = null ; OutputStream out = null ; try { URLConnection conn = url . openConnection ( ) ; if ( conn instanceof HttpsURLConnection ) { HttpsURLConnection https = ( HttpsURLConnection ) conn ; https . setHostnameVerifier ( new DeploymentHostnameVerifier ( ) ) ; SSLContext ctx = SSLContext . getInstance ( HTTPS_PROTOCOL ) ; ctx . init ( null , getTrustManagers ( ) , null ) ; https . setSSLSocketFactory ( ctx . getSocketFactory ( ) ) ; } in = conn . getInputStream ( ) ; if ( in == null ) throw new IOException ( " Failed ▁ to ▁ open ▁ connection : ▁ " + url . toString ( ) ) ; out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; copy ( in , out ) ; } catch ( NoSuchAlgorithmException | KeyManagementException e ) { throw new IOException ( " Failed ▁ to ▁ open ▁ HTTPs ▁ connection ▁ [ url = " + url . toString ( ) + " , ▁ msg = " + e + ' ] ' , e ) ; } finally { close ( in , null ) ; close ( out , null ) ; } return file ; }
 public static boolean isWindows98 ( ) { return win98 ; }
 public static byte [ ] join ( byte [ ] ... bufs ) { int size = 0 ; for ( byte [ ] buf : bufs ) { size += buf . length ; } byte [ ] res = new byte [ size ] ; int position = 0 ; for ( byte [ ] buf : bufs ) { arrayCopy ( buf , 0 , res , position , buf . length ) ; position += buf . length ; } return res ; }
 public static OperatingSystemMXBean getOsMx ( ) { return ManagementFactory . getOperatingSystemMXBean ( ) ; }
 public static String toShortString ( Collection < ? extends ClusterNode > ns ) { SB sb = new SB ( " Grid ▁ nodes ▁ [ cnt = " + ns . size ( ) ) ; for ( ClusterNode n : ns ) sb . a ( " , ▁ " ) . a ( toShortString ( n ) ) ; return sb . a ( ' ] ' ) . toString ( ) ; }
 private static int toLength ( long addrAndLen ) { return ( int ) ( addrAndLen & SIZE_MASK ) ; }
 public static boolean join ( Iterable < ? extends GridWorker > ws , IgniteLogger log ) { boolean retval = true ; if ( ws != null ) for ( GridWorker w : ws ) if ( ! join ( w , log ) ) retval = false ; return retval ; }
 public static Collection < Handler > addJavaNoOpLogger ( ) { Collection < Handler > savedHnds = new ArrayList < > ( ) ; Logger log = Logger . getLogger ( " " ) ; for ( Handler h : log . getHandlers ( ) ) { log . removeHandler ( h ) ; savedHnds . add ( h ) ; } ConsoleHandler hnd = new ConsoleHandler ( ) ; hnd . setLevel ( Level . OFF ) ; log . addHandler ( hnd ) ; return savedHnds ; }
 public static < E > List < E > sealList ( Collection < E > c ) { return Collections . unmodifiableList ( new ArrayList < > ( c ) ) ; }
 public static ObjectName makeCacheMBeanName ( @ Nullable String gridName , @ Nullable String cacheName , String name ) throws MalformedObjectNameException { SB sb = new SB ( JMX_DOMAIN + ' : ' ) ; appendClassLoaderHash ( sb ) ; appendJvmId ( sb ) ; if ( gridName != null && ! gridName . isEmpty ( ) ) sb . a ( " grid = " ) . a ( gridName ) . a ( ' , ' ) ; cacheName = maskName ( cacheName ) ; sb . a ( " group = " ) . a ( cacheName ) . a ( ' , ' ) ; sb . a ( " name = " ) . a ( name ) ; return new ObjectName ( sb . toString ( ) ) ; }
 public static boolean reachable ( NetworkInterface itf , InetAddress addr , int reachTimeout ) { try { return addr . isReachable ( itf , 0 , reachTimeout ) ; } catch ( IOException ignore ) { return false ; } }
 public static void writeToFile ( String destLoc , String fileName , String contents ) throws IOException { Writer fileWriter = null ; try { fileWriter = getFileWriter ( destLoc , fileName ) ; fileWriter . write ( contents ) ; } finally { closeQuietly ( fileWriter ) ; } }
 public static IgniteUuid bytesToIgniteUuid ( byte [ ] in , int off ) { long most = bytesToLong ( in , off ) ; long least = bytesToLong ( in , off + 8 ) ; long locId = bytesToLong ( in , off + 16 ) ; return new IgniteUuid ( IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) , locId ) ; }
 public static LeveledManifest create ( ColumnFamilyStore cfs , int maxSSTableSize , Iterable < SSTableReader > sstables , SizeTieredCompactionStrategyOptions options ) { LeveledManifest manifest = new LeveledManifest ( cfs , maxSSTableSize , options ) ; for ( SSTableReader ssTableReader : sstables ) { manifest . add ( ssTableReader ) ; } for ( int i = 1 ; i < manifest . getAllLevelSize ( ) . length ; i ++ ) { manifest . repairOverlappingSSTables ( i ) ; } return manifest ; }
 public static EncodingStats collect ( Row staticRow , Iterator < Row > rows , DeletionInfo deletionInfo ) { Collector collector = new Collector ( ) ; deletionInfo . collectStats ( collector ) ; if ( ! staticRow . isEmpty ( ) ) Rows . collectStats ( staticRow , collector ) ; while ( rows . hasNext ( ) ) Rows . collectStats ( rows . next ( ) , collector ) ; return collector . get ( ) ; }
 public static Intent createIntent ( Context context , boolean login ) { Intent intent = new Intent ( context , SendLoginStatusService . class ) ; intent . putExtra ( KEY_LOGIN , String . valueOf ( login ) ) ; return intent ; }
 private static double roundedHeapSize ( double heap , int precision ) { double rounded = new BigDecimal ( heap / ( 1024 * 1024 * 1024d ) ) . round ( new MathContext ( precision ) ) . doubleValue ( ) ; return rounded < 0.1 ? 0.1 : rounded ; }
 public static void main ( String [ ] args ) { junit . textui . TestRunner . run ( XGraphics2DRTest . class ) ; }
 ) public static < T > T [ ] toArray ( Collection < ? extends T > c , T [ ] arr ) { T [ ] a = c . toArray ( arr ) ; assert a == arr ; return arr ; }
 public static boolean p2pLoader ( Object o ) { return o != null && p2pLoader ( o . getClass ( ) . getClassLoader ( ) ) ; }
 public static int [ ] unique ( int [ ] a , int aLen , int [ ] b , int bLen ) { assert a != null ; assert b != null ; assert isIncreasingArray ( a , aLen ) ; assert isIncreasingArray ( b , bLen ) ; int [ ] res = new int [ aLen + bLen ] ; int resLen = 0 ; int i = 0 ; int j = 0 ; while ( i < aLen && j < bLen ) { if ( a [ i ] == b [ j ] ) i ++ ; else if ( a [ i ] < b [ j ] ) res [ resLen ++ ] = a [ i ++ ] ; else res [ resLen ++ ] = b [ j ++ ] ; } while ( i < aLen ) res [ resLen ++ ] = a [ i ++ ] ; while ( j < bLen ) res [ resLen ++ ] = b [ j ++ ] ; return copyIfExceeded ( res , resLen ) ; }
 public static < V , F extends Function < V , EncodingStats > > EncodingStats merge ( List < V > values , F function ) { if ( values . size ( ) == 1 ) return function . apply ( values . get ( 0 ) ) ; Collector collector = new Collector ( ) ; for ( int i = 0 , isize = values . size ( ) ; i < isize ; i ++ ) { V v = values . get ( i ) ; EncodingStats stats = function . apply ( v ) ; if ( stats . minTimestamp != TIMESTAMP_EPOCH ) collector . updateTimestamp ( stats . minTimestamp ) ; if ( stats . minLocalDeletionTime != DELETION_TIME_EPOCH ) collector . updateLocalDeletionTime ( stats . minLocalDeletionTime ) ; if ( stats . minTTL != TTL_EPOCH ) collector . updateTTL ( stats . minTTL ) ; } return collector . get ( ) ; }
 @ Nullable public static Constructor < ? > forceEmptyConstructor ( Class < ? > cls ) throws IgniteCheckedException { Constructor < ? > ctor = null ; try { return cls . getDeclaredConstructor ( ) ; } catch ( Exception ignore ) { Method ctorFac = U . ctorFactory ( ) ; Object sunRefFac = U . sunReflectionFactory ( ) ; if ( ctorFac != null && sunRefFac != null ) try { ctor = ( Constructor ) ctorFac . invoke ( sunRefFac , cls , U . objectConstructor ( ) ) ; } catch ( IllegalAccessException | InvocationTargetException e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ object ▁ constructor ▁ for ▁ class : ▁ " + cls , e ) ; } } return ctor ; }
 public static void close ( @ Nullable URLClassLoader clsLdr , @ Nullable IgniteLogger log ) { if ( clsLdr != null ) try { URLClassPath path = SharedSecrets . getJavaNetAccess ( ) . getURLClassPath ( clsLdr ) ; Field ldrFld = path . getClass ( ) . getDeclaredField ( " loaders " ) ; ldrFld . setAccessible ( true ) ; Iterable ldrs = ( Iterable ) ldrFld . get ( path ) ; for ( Object ldr : ldrs ) if ( ldr . getClass ( ) . getName ( ) . endsWith ( " JarLoader " ) ) try { Field jarFld = ldr . getClass ( ) . getDeclaredField ( " jar " ) ; jarFld . setAccessible ( true ) ; ZipFile jar = ( ZipFile ) jarFld . get ( ldr ) ; jar . close ( ) ; } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } } catch ( Exception e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static boolean isWindows95 ( ) { return win95 ; }
 public static String osArchitecture ( ) { return osArch ; }
 public static List < String > getValidValues ( ) { List < String > ans = Lists . newArrayList ( ) ; for ( MultidexMode mode : MultidexMode . values ( ) ) { ans . add ( mode . getAttributeValue ( ) ) ; } return ans ; }
 public static DataStream < Tuple3 < Integer , Long , String > > getSmall3TupleDataSet ( StreamExecutionEnvironment env ) { List < Tuple3 < Integer , Long , String > > data = new ArrayList < > ( ) ; data . add ( new Tuple3 < > ( 1 , 1L , " Hi " ) ) ; data . add ( new Tuple3 < > ( 2 , 2L , " Hello " ) ) ; data . add ( new Tuple3 < > ( 3 , 2L , " Hello ▁ world " ) ) ; Collections . shuffle ( data ) ; return env . fromCollection ( data ) ; }
 public static BufferedReader getFileReader ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File inFile = new File ( dir , fileName ) ; Charset defaultCharset = Charset . defaultCharset ( ) ; FileInputStream fileInStream = new FileInputStream ( inFile ) ; InputStreamReader bw = new InputStreamReader ( fileInStream , defaultCharset ) ; BufferedReader buffReader = new BufferedReader ( bw ) ; return buffReader ; }
 public static String [ ] getServiceLocations ( Definition wsdlDefinition ) { List < String > locations = new ArrayList < String > ( ) ; Service wsdlService = ( Service ) wsdlDefinition . getServices ( ) . values ( ) . iterator ( ) . next ( ) ; Map < ? , ? > wsdlPorts = wsdlService . getPorts ( ) ; for ( Iterator < ? > it = wsdlPorts . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Port wsdlPort = ( Port ) it . next ( ) ; Iterator < ? > itElements = wsdlPort . getExtensibilityElements ( ) . iterator ( ) ; while ( itElements . hasNext ( ) ) { Object obj = itElements . next ( ) ; String wsdlURI = null ; if ( obj instanceof SOAPAddress ) { SOAPAddress address = ( SOAPAddress ) obj ; wsdlURI = address . getLocationURI ( ) ; } else if ( obj instanceof SOAP12Address ) { SOAP12Address address = ( SOAP12Address ) obj ; wsdlURI = address . getLocationURI ( ) ; } else if ( obj instanceof HTTPAddress ) { HTTPAddress address = ( HTTPAddress ) obj ; wsdlURI = address . getLocationURI ( ) ; } if ( ! isEmptyString ( wsdlURI ) ) locations . add ( wsdlURI ) ; } } String arr [ ] = new String [ locations . size ( ) ] ; locations . toArray ( arr ) ; return arr ; }
 public static void quietAndWarn ( IgniteLogger log , Object msg ) { quietAndWarn ( log , msg , msg ) ; }
 public static < K , V , M extends Map < K , V > > M addAll ( M m , Map . Entry < K , V > ... entries ) { for ( Map . Entry < K , V > e : entries ) m . put ( e . getKey ( ) , e . getValue ( ) ) ; return m ; }
 public static final SafeImplicitOutputsFunction ANDROID_BINARY_IMPLICIT_OUTPUTS = new SafeImplicitOutputsFunction ( ) { @ Override public Iterable < String > getImplicitOutputs ( EventHandler eventHandler , AttributeMap rule ) { List < SafeImplicitOutputsFunction > functions = Lists . newArrayList ( ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_APK ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_UNSIGNED_APK ) ; functions . add ( AndroidRuleClasses . ANDROID_BINARY_DEPLOY_JAR ) ; if ( hasProguardSpecs ( rule ) ) { functions . add ( AndroidRuleClasses . ANDROID_BINARY_PROGUARD_JAR ) ; functions . add ( JavaSemantics . JAVA_BINARY_PROGUARD_CONFIG ) ; if ( ProguardHelper . genProguardMapping ( rule ) ) { functions . add ( JavaSemantics . JAVA_BINARY_PROGUARD_MAP ) ; } } return fromFunctions ( functions ) . getImplicitOutputs ( eventHandler , rule ) ; } }
 @ Nullable public static UUID readUuid ( DataInput in ) throws IOException { if ( ! in . readBoolean ( ) ) { long most = in . readLong ( ) ; long least = in . readLong ( ) ; return IgniteUuidCache . onIgniteUuidRead ( new UUID ( most , least ) ) ; } return null ; }
 public static boolean isVisorNodeStartProperty ( String name ) { return IGNITE_SSH_HOST . equals ( name ) || IGNITE_SSH_USER_NAME . equals ( name ) ; }
 public static < T > T invoke ( @ Nullable Class < ? > cls , @ Nullable Object obj , String mtdName , Class [ ] paramTypes , Object ... params ) throws IgniteCheckedException { assert cls != null || obj != null ; assert mtdName != null ; try { for ( Class < ? > c = cls != null ? cls : obj . getClass ( ) ; cls != Object . class ; cls = cls . getSuperclass ( ) ) { Method mtd ; try { mtd = c . getDeclaredMethod ( mtdName , paramTypes ) ; } catch ( NoSuchMethodException ignored ) { continue ; } boolean accessible = mtd . isAccessible ( ) ; T res ; try { mtd . setAccessible ( true ) ; res = ( T ) mtd . invoke ( obj , params ) ; } finally { if ( ! accessible ) mtd . setAccessible ( false ) ; } return res ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ invoke ▁ ( method ▁ was ▁ not ▁ found ) ▁ [ mtdName = " + mtdName + " , ▁ cls = " + cls + ' ] ' ) ; }
 public static void closeQuiet ( @ Nullable Selector rsrc ) { if ( rsrc != null ) try { if ( rsrc . isOpen ( ) ) rsrc . close ( ) ; } catch ( IOException ignored ) { } }
 public static IgniteCheckedException exceptionWithSuppressed ( String msg , @ Nullable Collection < Throwable > suppressed ) { IgniteCheckedException e = new IgniteCheckedException ( msg ) ; if ( suppressed != null ) { for ( Throwable th : suppressed ) e . addSuppressed ( th ) ; } return e ; }
 public static StoreWriter createWriter ( OutputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . info ( " Initialize ▁ writer ▁ from ▁ stream " ) ; return new WriterImpl ( config , stream ) ; }
 public static void sleep ( long ms ) throws IgniteInterruptedCheckedException { try { Thread . sleep ( ms ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String maskName ( @ Nullable String cacheName ) { return cacheName == null ? " default " : cacheName ; }
 public static < T > T staticField ( Class < ? > cls , String fieldName ) throws IgniteCheckedException { assert cls != null ; assert fieldName != null ; try { for ( Field field : cls . getDeclaredFields ( ) ) if ( field . getName ( ) . equals ( fieldName ) ) { boolean accessible = field . isAccessible ( ) ; if ( ! accessible ) field . setAccessible ( true ) ; T val = ( T ) field . get ( null ) ; if ( ! accessible ) field . setAccessible ( false ) ; return val ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' , e ) ; } throw new IgniteCheckedException ( " Failed ▁ to ▁ get ▁ field ▁ value ▁ [ fieldName = " + fieldName + " , ▁ cls = " + cls + ' ] ' ) ; }
 public static byte [ ] intToBytes ( int i ) { return GridClientByteUtils . intToBytes ( i ) ; }
 public static void join ( GridWorker w ) throws IgniteInterruptedCheckedException { try { if ( w != null ) w . join ( ) ; } catch ( InterruptedException e ) { Thread . currentThread ( ) . interrupt ( ) ; throw new IgniteInterruptedCheckedException ( e ) ; } }
 public static String setOrListToJsonString ( ByteBuffer buffer , AbstractType elementsType , int protocolVersion ) { StringBuilder sb = new StringBuilder ( " [ " ) ; int size = CollectionSerializer . readCollectionSize ( buffer , protocolVersion ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( i > 0 ) sb . append ( " , ▁ " ) ; sb . append ( elementsType . toJSONString ( CollectionSerializer . readValue ( buffer , protocolVersion ) , protocolVersion ) ) ; } return sb . append ( " ] " ) . toString ( ) ; }
 public static void close ( @ Nullable Context rsrc , @ Nullable IgniteLogger log ) { if ( rsrc != null ) try { rsrc . close ( ) ; } catch ( NamingException e ) { warn ( log , " Failed ▁ to ▁ close ▁ resource : ▁ " + e . getMessage ( ) ) ; } }
 public static ClassLoader detectClassLoader ( Class < ? > cls ) { return GridClassLoaderCache . classLoader ( cls ) ; }
 public static < T > Iterable < T > asIterable ( final Enumeration < T > e ) { return new Iterable < T > ( ) { @ Override public Iterator < T > iterator ( ) { return new Iterator < T > ( ) { @ Override public boolean hasNext ( ) { return e . hasMoreElements ( ) ; } @ SuppressWarnings ( { " IteratorNextCanNotThrowNoSuchElementException " } ) @ Override public T next ( ) { return e . nextElement ( ) ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; } } ; }
 public static byte [ ] shortToBytes ( short s ) { return GridClientByteUtils . shortToBytes ( s ) ; }
 public static short bytesToShort ( byte [ ] bytes , int off ) { assert bytes != null ; int bytesCnt = Short . SIZE >> 3 ; if ( off + bytesCnt > bytes . length ) bytesCnt = bytes . length - off ; short res = 0 ; for ( int i = 0 ; i < bytesCnt ; i ++ ) { int shift = bytesCnt - i - 1 << 3 ; res |= ( 0xffL & bytes [ off ++ ] ) << shift ; } return res ; }
 public static Exception convertExceptionNoWrap ( IgniteCheckedException e ) { C1 < IgniteCheckedException , IgniteException > converter = exceptionConverters . get ( e . getClass ( ) ) ; if ( converter != null ) return converter . apply ( e ) ; if ( e . getCause ( ) instanceof IgniteException ) return ( Exception ) e . getCause ( ) ; return e ; }
 public static boolean dirExists ( String path ) { if ( isEmptyString ( path ) ) { return false ; } File dir = new File ( path ) ; return dir . exists ( ) && dir . isDirectory ( ) ; }
 @ Nullable public static Object sunReflectionFactory ( ) { return SUN_REFLECT_FACTORY ; }
 public static boolean isEmptyString ( String str ) { return ( str == null || str . trim ( ) . length ( ) == 0 ) ; }
 @ Nullable public static < T > T firstNotNull ( @ Nullable T ... vals ) { if ( vals == null ) return null ; for ( T val : vals ) { if ( val != null ) return val ; } return null ; }
 public static long writeGridUuid ( byte [ ] arr , long off , @ Nullable IgniteUuid uid ) { UNSAFE . putBoolean ( arr , off ++ , uid != null ) ; if ( uid != null ) { UNSAFE . putLong ( arr , off , uid . globalId ( ) . getMostSignificantBits ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , uid . globalId ( ) . getLeastSignificantBits ( ) ) ; off += 8 ; UNSAFE . putLong ( arr , off , uid . localId ( ) ) ; off += 8 ; } return off ; }
 ) @ Deprecated public static void dumpStack ( Thread t , PrintStream s ) { synchronized ( s ) { s . println ( " Dumping ▁ stack ▁ trace ▁ for ▁ thread : ▁ " + t ) ; for ( StackTraceElement trace : t . getStackTrace ( ) ) s . println ( " \tat ▁ " + trace ) ; } }
 public static < T > ObjectName registerMBean ( MBeanServer mbeanSrv , @ Nullable String gridName , @ Nullable String grp , String name , T impl , @ Nullable Class < T > itf ) throws JMException { assert mbeanSrv != null ; assert name != null ; assert itf != null ; DynamicMBean mbean = new IgniteStandardMXBean ( impl , itf ) ; mbean . getMBeanInfo ( ) ; return mbeanSrv . registerMBean ( mbean , makeMBeanName ( gridName , grp , name ) ) . getObjectName ( ) ; }
 public static void writeGridUuid ( DataOutput out , IgniteUuid uid ) throws IOException { out . writeBoolean ( uid == null ) ; if ( uid != null ) { out . writeLong ( uid . globalId ( ) . getMostSignificantBits ( ) ) ; out . writeLong ( uid . globalId ( ) . getLeastSignificantBits ( ) ) ; out . writeLong ( uid . localId ( ) ) ; } }
 public static synchronized Collection < String > allLocalMACs ( ) { List < String > macs = new ArrayList < > ( 3 ) ; try { Enumeration < NetworkInterface > itfs = NetworkInterface . getNetworkInterfaces ( ) ; if ( itfs != null ) { for ( NetworkInterface itf : asIterable ( itfs ) ) { byte [ ] hwAddr = itf . getHardwareAddress ( ) ; if ( hwAddr != null && hwAddr . length > 0 ) { String mac = byteArray2HexString ( hwAddr ) ; if ( ! macs . contains ( mac ) ) macs . add ( mac ) ; } } } } catch ( SocketException ignore ) { return Collections . emptyList ( ) ; } Collections . sort ( macs ) ; return macs ; }
 @ Nullable public static File resolveIgnitePath ( String path ) { assert path != null ; String home = getIgniteHome ( ) ; if ( home != null ) { File file = new File ( home , path ) ; if ( file . exists ( ) ) return file ; } File file = new File ( path ) ; if ( file . exists ( ) ) return file ; return null ; }
 public static boolean isSolarisSparc ( ) { return solaris && sparc ; }
 public static List < byte [ ] > readBytesList ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size < 0 ) return null ; List < byte [ ] > res = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) res . add ( readByteArray ( in ) ) ; return res ; }
 public static List < PageData > setListDistance ( List < PageData > list , PageData pd ) { List < PageData > listReturn = new ArrayList < PageData > ( ) ; String user_longitude = " " ; String user_latitude = " " ; try { user_longitude = pd . get ( " user _ longitude " ) . toString ( ) ; user_latitude = pd . get ( " user _ latitude " ) . toString ( ) ; } catch ( Exception e ) { logger . error ( " 缺失参数 - - user _ longitude和user _ longitude " ) ; logger . error ( " lost ▁ param ： user _ longitude ▁ and ▁ user _ longitude " ) ; } PageData pdTemp = new PageData ( ) ; int size = list . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) { pdTemp = list . get ( i ) ; String longitude = pdTemp . get ( " longitude " ) . toString ( ) ; String latitude = pdTemp . get ( " latitude " ) . toString ( ) ; String distance = MapDistance . getDistance ( user_longitude , user_latitude , longitude , latitude ) ; pdTemp . put ( " distance " , distance ) ; pdTemp . put ( " size " , distance . length ( ) ) ; listReturn . add ( pdTemp ) ; } return listReturn ; }
 public static boolean isMacInvalidArgumentError ( Exception e ) { return U . isMacOs ( ) && e instanceof SocketException && e . getMessage ( ) != null && e . getMessage ( ) . toLowerCase ( ) . contains ( " invalid ▁ argument " ) ; }
 public static boolean isUnix ( ) { return unix ; }
 public static JsArrayBoolean wrapArray ( boolean [ ] srcArray ) { JsArrayBoolean result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
 public static void log ( @ Nullable IgniteLogger log , Object longMsg , Object shortMsg ) { assert longMsg != null ; assert shortMsg != null ; if ( log != null ) { if ( log . isInfoEnabled ( ) ) log . info ( compact ( longMsg . toString ( ) ) ) ; } else quiet ( false , shortMsg ) ; }
 public static void asyncLogError ( IgniteInternalFuture < ? > f , final IgniteLogger log ) { if ( f != null ) f . listen ( new CI1 < IgniteInternalFuture < ? > > ( ) { @ Override public void apply ( IgniteInternalFuture < ? > f ) { try { f . get ( ) ; } catch ( IgniteCheckedException e ) { U . error ( log , " Failed ▁ to ▁ execute ▁ future : ▁ " + f , e ) ; } } } ) ; }
 @ Nullable public static Collection < Integer > readIntCollection ( DataInput in ) throws IOException { int size = in . readInt ( ) ; if ( size == - 1 ) return null ; Collection < Integer > col = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) col . add ( in . readInt ( ) ) ; return col ; }
 public static Writer getFileWriter ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File outputFile = new File ( dir , fileName ) ; deleteFile ( outputFile ) ; Charset defaultCharset = Charset . defaultCharset ( ) ; FileOutputStream fileOutStream = new FileOutputStream ( outputFile ) ; OutputStreamWriter bw = new OutputStreamWriter ( fileOutStream , defaultCharset ) ; Writer buffWriter = new BufferedWriter ( bw ) ; return buffWriter ; }
 public static String jdkVendor ( ) { return jdkVendor ; }
 public static void error ( @ Nullable IgniteLogger log , Object shortMsg , @ Nullable Throwable e ) { assert shortMsg != null ; String s = shortMsg . toString ( ) ; error ( log , s , s , e ) ; }
 public static void main ( String [ ] args ) { System . out . println ( " Hello ▁ World " ) ; }
 public static byte [ ] hexString2ByteArray ( String hex ) throws IllegalArgumentException { if ( hex . length ( ) % 2 != 0 ) hex = '0' + hex ; char [ ] chars = hex . toCharArray ( ) ; byte [ ] bytes = new byte [ chars . length / 2 ] ; int byteCnt = 0 ; for ( int i = 0 ; i < chars . length ; i += 2 ) { int newByte = 0 ; newByte |= hexCharToByte ( chars [ i ] ) ; newByte <<= 4 ; newByte |= hexCharToByte ( chars [ i + 1 ] ) ; bytes [ byteCnt ] = ( byte ) newByte ; byteCnt ++ ; } return bytes ; }
 @ Deprecated public static void dumpStack ( String msg , PrintStream out ) { new Exception ( msg ) . printStackTrace ( out ) ; }
 public static void onGridStop ( ) throws InterruptedException { synchronized ( mux ) { if ( gridCnt == 0 ) return ; -- gridCnt ; Thread timer0 = timer ; if ( gridCnt == 0 && timer0 != null ) { timer = null ; timer0 . interrupt ( ) ; timer0 . join ( ) ; } } }
 public static String osJdkString ( ) { return osJdkStr ; }
 @ Nullable public static String getIgniteHome ( ) { GridTuple < String > ggHomeTup = ggHome ; String ggHome0 ; if ( ggHomeTup == null ) { synchronized ( IgniteUtils . class ) { ggHomeTup = ggHome ; if ( ggHomeTup == null ) { ggHome = F . t ( ggHome0 = resolveProjectHome ( ) ) ; if ( ggHome0 != null ) System . setProperty ( IGNITE_HOME , ggHome0 ) ; } else ggHome0 = ggHomeTup . get ( ) ; } } else ggHome0 = ggHomeTup . get ( ) ; return ggHome0 ; }
 public static void startLifecycleAware ( Iterable < ? > objs ) throws IgniteCheckedException { try { for ( Object obj : objs ) { if ( obj instanceof LifecycleAware ) ( ( LifecycleAware ) obj ) . start ( ) ; } } catch ( Exception e ) { throw new IgniteCheckedException ( " Failed ▁ to ▁ start ▁ component : ▁ " + e , e ) ; } }
 public static JsArrayInteger wrapArray ( byte [ ] srcArray ) { JsArrayInteger result = JavaScriptObject . createArray ( ) . cast ( ) ; for ( int i = 0 ; i < srcArray . length ; i ++ ) { result . set ( i , srcArray [ i ] ) ; } return result ; }
 public static boolean isVisorRequiredProperty ( String name ) { return " java . version " . equals ( name ) || " java . vm . name " . equals ( name ) || " os . arch " . equals ( name ) || " os . name " . equals ( name ) || " os . version " . equals ( name ) ; }
 public static void dumpStack ( @ Nullable IgniteLogger log , String msg ) { U . error ( log , " Dumping ▁ stack . " , new Exception ( msg ) ) ; }
 public static String getFolderPathFrompackageName ( String packageName ) { if ( packageName == null ) return null ; packageName = packageName . replace ( ' . ' , File . separatorChar ) ; return toOSFilePath ( packageName ) ; }
 static < T > BoundedSourceShard < T > of ( BoundedSource < T > source ) { return new AutoValue_BoundedReadEvaluatorFactory_BoundedSourceShard < > ( source ) ; }
 private static void appendJvmId ( SB sb ) { if ( getBoolean ( IGNITE_MBEAN_APPEND_JVM_ID ) ) { String jvmId = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; sb . a ( " jvmId = " ) . a ( jvmId ) . a ( ' , ' ) ; } }
 public static int floatToBytes ( float f , byte [ ] bytes , int off ) { return intToBytes ( Float . floatToIntBits ( f ) , bytes , off ) ; }
 public static boolean isFileExists ( String filePath ) { if ( isEmptyString ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return file . exists ( ) ; }
 public static ClassLoader gridClassLoader ( ) { return gridClassLoader ; }
 public static void closeQuietly ( FileHandler fileHandler ) { if ( fileHandler == null ) { return ; } fileHandler . close ( ) ; }
 public static synchronized boolean isLocalHostChanged ( ) throws IOException { InetAddress locHost0 = locHost ; return locHost0 != null && ! resetLocalHost ( ) . equals ( locHost0 ) ; }
 @ Deprecated public static void debug ( IgniteLogger log , String msg ) { log . info ( msg ) ; }
 public static boolean isParameterizedType ( Type type ) { return ( type instanceof ParameterizedType ) ; }
 public static RowIndexEntry < IndexHelper . IndexInfo > create ( long position , DeletionTime deletionTime , ColumnIndex index ) { assert index != null ; assert deletionTime != null ; if ( index . columnsIndex . size ( ) > 1 ) return new IndexedEntry ( position , deletionTime , index . partitionHeaderLength , index . columnsIndex ) ; else return new RowIndexEntry < > ( position ) ; }
