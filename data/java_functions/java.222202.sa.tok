Telecooperation/assistance-platform-client-sdk-android | public static void createTable ( Database db , boolean ifNotExists ) { String constraint = ifNotExists ? " IF ▁ NOT ▁ EXISTS ▁ " : " " ; db . execSQL ( " CREATE ▁ TABLE ▁ " + constraint + " \" contact _ email _ sensor \" ▁ ( " + " \" _ id \" ▁ INTEGER ▁ PRIMARY ▁ KEY ▁ AUTOINCREMENT ▁ , " + " \" MAIL _ ID \" ▁ INTEGER , " + " \" ADDRESS \" ▁ TEXT , " + " \" TYPE \" ▁ TEXT , " + " \" IS _ NEW \" ▁ INTEGER , " + " \" IS _ UPDATED \" ▁ INTEGER , " + " \" IS _ DELETED \" ▁ INTEGER , " + " \" CREATED \" ▁ TEXT ▁ NOT ▁ NULL ▁ , " + " \" CONTACT _ ID \" ▁ INTEGER ▁ NOT ▁ NULL ▁ , " + " \" DEVICE _ ID \" ▁ INTEGER ▁ NOT ▁ NULL ▁ ) ; " ) ; db . execSQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ _ id ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \" _ id \" ) ; " ) ; db . execSQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ CONTACT _ ID ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \" CONTACT _ ID \" ) ; " ) ; db . execSQL ( " CREATE ▁ INDEX ▁ " + constraint + " IDX _ contact _ email _ sensor _ DEVICE _ ID ▁ ON ▁ contact _ email _ sensor " + " ▁ ( \" DEVICE _ ID \" ) ; " ) ; }
Telecooperation/assistance-platform-client-sdk-android | public static void dropTable ( Database db , boolean ifExists ) { String sql = " DROP ▁ TABLE ▁ " + ( ifExists ? " IF ▁ EXISTS ▁ " : " " ) + " \" contact _ email _ sensor \" " ; db . execSQL ( sql ) ; }
codeck/XChange | public static Builder from ( KrakenUserTrade trade ) { Builder builder = new Builder ( ) . cost ( trade . getCost ( ) ) ; builder . orderId ( trade . getOrderId ( ) ) . feeAmount ( trade . getFeeAmount ( ) ) . feeCurrency ( trade . getFeeCurrency ( ) ) ; builder . type ( trade . getType ( ) ) . tradableAmount ( trade . getTradableAmount ( ) ) . currencyPair ( trade . getCurrencyPair ( ) ) . price ( trade . getPrice ( ) ) . timestamp ( trade . getTimestamp ( ) ) . id ( trade . getId ( ) ) ; return builder ; }
FHannes/intellij-community | private static final ThreadPoolExecutor EXECUTOR = new ThreadPoolExecutor ( 0 , Integer . MAX_VALUE , 1 , TimeUnit . SECONDS , new LinkedBlockingQueue < > ( ) , new ThreadFactory ( ) { private final AtomicInteger num = new AtomicInteger ( ) ; @ NotNull @ Override public Thread newThread ( @ NotNull Runnable r ) { return new Thread ( r , " Maven ▁ Artifact ▁ Downloader ▁ " + num . getAndIncrement ( ) ) ; } }
FHannes/intellij-community | public static DownloadResult download ( @ NotNull Project project , MavenProjectsTree projectsTree , Collection < MavenProject > mavenProjects , @ Nullable Collection < MavenArtifact > artifacts , boolean downloadSources , boolean downloadDocs , MavenEmbedderWrapper embedder , MavenProgressIndicator p ) throws MavenProcessCanceledException { return new MavenArtifactDownloader ( project , projectsTree , mavenProjects , artifacts , embedder , p ) . download ( downloadSources , downloadDocs ) ; }
FHannes/intellij-community | @ TestOnly public static void awaitQuiescence ( long timeout , @ NotNull TimeUnit unit ) { ConcurrencyUtil . awaitQuiescence ( EXECUTOR , timeout , unit ) ; }
cjellick/gdapi-java-server | public static final void throwValidationError ( String code , String fieldName ) { throw new ClientVisibleException ( new ValidationErrorImpl ( code , fieldName ) ) ; }
webos21/xi | public static Long decode ( String string ) throws NumberFormatException { int length = string . length ( ) , i = 0 ; if ( length == 0 ) { throw new NumberFormatException ( ) ; } char firstDigit = string . charAt ( i ) ; boolean negative = firstDigit == ' - ' ; if ( negative ) { if ( length == 1 ) { throw new NumberFormatException ( string ) ; } firstDigit = string . charAt ( ++ i ) ; } int base = 10 ; if ( firstDigit == '0' ) { if ( ++ i == length ) { return valueOf ( 0L ) ; } if ( ( firstDigit = string . charAt ( i ) ) == ' x ' || firstDigit == ' X ' ) { if ( i == length ) { throw new NumberFormatException ( string ) ; } i ++ ; base = 16 ; } else { base = 8 ; } } else if ( firstDigit == ' # ' ) { if ( i == length ) { throw new NumberFormatException ( string ) ; } i ++ ; base = 16 ; } long result = parse ( string , i , base , negative ) ; return valueOf ( result ) ; }
webos21/xi | public static Long getLong ( String string ) { if ( string == null || string . length ( ) == 0 ) { return null ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return null ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return null ; } }
webos21/xi | public static Long getLong ( String string , long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return valueOf ( defaultValue ) ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return valueOf ( defaultValue ) ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return valueOf ( defaultValue ) ; } }
webos21/xi | public static Long getLong ( String string , Long defaultValue ) { if ( string == null || string . length ( ) == 0 ) { return defaultValue ; } String prop = System . getProperty ( string ) ; if ( prop == null ) { return defaultValue ; } try { return decode ( prop ) ; } catch ( NumberFormatException ex ) { return defaultValue ; } }
webos21/xi | public static long parseLong ( String string ) throws NumberFormatException { return parseLong ( string , 10 ) ; }
webos21/xi | public static long parseLong ( String string , int radix ) throws NumberFormatException { if ( string == null || radix < Character . MIN_RADIX || radix > Character . MAX_RADIX ) { throw new NumberFormatException ( ) ; } int length = string . length ( ) , i = 0 ; if ( length == 0 ) { throw new NumberFormatException ( string ) ; } boolean negative = string . charAt ( i ) == ' - ' ; if ( negative && ++ i == length ) { throw new NumberFormatException ( string ) ; } return parse ( string , i , radix , negative ) ; }
webos21/xi | private static long parse ( String string , int offset , int radix , boolean negative ) { long max = Long . MIN_VALUE / radix ; long result = 0 , length = string . length ( ) ; while ( offset < length ) { int digit = Character . digit ( string . charAt ( offset ++ ) , radix ) ; if ( digit == - 1 ) { throw new NumberFormatException ( string ) ; } if ( max > result ) { throw new NumberFormatException ( string ) ; } long next = result * radix - digit ; if ( next > result ) { throw new NumberFormatException ( string ) ; } result = next ; } if ( ! negative ) { result = - result ; if ( result < 0 ) { throw new NumberFormatException ( string ) ; } } return result ; }
webos21/xi | public static String toBinaryString ( long v ) { return IntegralToString . longToBinaryString ( v ) ; }
webos21/xi | public static String toHexString ( long v ) { return IntegralToString . longToHexString ( v ) ; }
webos21/xi | public static String toOctalString ( long v ) { return IntegralToString . longToOctalString ( v ) ; }
webos21/xi | public static String toString ( long n ) { return IntegralToString . longToString ( n ) ; }
webos21/xi | public static String toString ( long v , int radix ) { return IntegralToString . longToString ( v , radix ) ; }
webos21/xi | public static Long valueOf ( String string ) throws NumberFormatException { return valueOf ( parseLong ( string ) ) ; }
webos21/xi | public static Long valueOf ( String string , int radix ) throws NumberFormatException { return valueOf ( parseLong ( string , radix ) ) ; }
webos21/xi | public static long highestOneBit ( long v ) { v |= ( v >> 1 ) ; v |= ( v >> 2 ) ; v |= ( v >> 4 ) ; v |= ( v >> 8 ) ; v |= ( v >> 16 ) ; v |= ( v >> 32 ) ; return v - ( v >>> 1 ) ; }
webos21/xi | public static long lowestOneBit ( long v ) { return v & - v ; }
webos21/xi | public static int numberOfLeadingZeros ( long v ) { if ( v < 0 ) { return 0 ; } if ( v == 0 ) { return 64 ; } int n = 1 ; int i = ( int ) ( v >>> 32 ) ; if ( i == 0 ) { n += 32 ; i = ( int ) v ; } if ( i >>> 16 == 0 ) { n += 16 ; i <<= 16 ; } if ( i >>> 24 == 0 ) { n += 8 ; i <<= 8 ; } if ( i >>> 28 == 0 ) { n += 4 ; i <<= 4 ; } if ( i >>> 30 == 0 ) { n += 2 ; i <<= 2 ; } return n - ( i >>> 31 ) ; }
webos21/xi | public static int numberOfTrailingZeros ( long v ) { int low = ( int ) v ; return low != 0 ? Integer . numberOfTrailingZeros ( low ) : 32 + Integer . numberOfTrailingZeros ( ( int ) ( v >>> 32 ) ) ; }
webos21/xi | public static int bitCount ( long v ) { v -= ( v >>> 1 ) & 0x5555555555555555L ; v = ( v & 0x3333333333333333L ) + ( ( v >>> 2 ) & 0x3333333333333333L ) ; int i = ( ( int ) ( v >>> 32 ) ) + ( int ) v ; i = ( i & 0x0F0F0F0F ) + ( ( i >>> 4 ) & 0x0F0F0F0F ) ; i += i >>> 8 ; i += i >>> 16 ; return i & 0x0000007F ; }
webos21/xi | public static long rotateLeft ( long v , int distance ) { return ( v << distance ) | ( v >>> - distance ) ; }
webos21/xi | public static long rotateRight ( long v , int distance ) { return ( v >>> distance ) | ( v << - distance ) ; }
webos21/xi | public static long reverseBytes ( long v ) { v = ( ( v >>> 8 ) & 0x00FF00FF00FF00FFL ) | ( ( v & 0x00FF00FF00FF00FFL ) << 8 ) ; v = ( ( v >>> 16 ) & 0x0000FFFF0000FFFFL ) | ( ( v & 0x0000FFFF0000FFFFL ) << 16 ) ; return ( ( v >>> 32 ) ) | ( ( v ) << 32 ) ; }
webos21/xi | public static long reverse ( long v ) { v = ( ( v >>> 1 ) & 0x5555555555555555L ) | ( ( v & 0x5555555555555555L ) << 1 ) ; v = ( ( v >>> 2 ) & 0x3333333333333333L ) | ( ( v & 0x3333333333333333L ) << 2 ) ; v = ( ( v >>> 4 ) & 0x0F0F0F0F0F0F0F0FL ) | ( ( v & 0x0F0F0F0F0F0F0F0FL ) << 4 ) ; v = ( ( v >>> 8 ) & 0x00FF00FF00FF00FFL ) | ( ( v & 0x00FF00FF00FF00FFL ) << 8 ) ; v = ( ( v >>> 16 ) & 0x0000FFFF0000FFFFL ) | ( ( v & 0x0000FFFF0000FFFFL ) << 16 ) ; return ( ( v >>> 32 ) ) | ( ( v ) << 32 ) ; }
webos21/xi | public static int signum ( long v ) { return v < 0 ? - 1 : ( v == 0 ? 0 : 1 ) ; }
webos21/xi | public static Long valueOf ( long v ) { return v >= 128 || v < - 128 ? new Long ( v ) : SMALL_VALUES [ ( ( int ) v ) + 128 ] ; }
Swrrt/Samza | public static < StreamMessageType > void containsInAnyOrder ( List < StreamMessageType > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; assertThat ( TestRunner . consumeStream ( outputDescriptor , timeout ) . entrySet ( ) . stream ( ) . flatMap ( entry -> entry . getValue ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) , IsIterableContainingInAnyOrder . containsInAnyOrder ( expected . toArray ( ) ) ) ; }
Swrrt/Samza | public static < StreamMessageType > void containsInAnyOrder ( Map < Integer , List < StreamMessageType > > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; Map < Integer , List < StreamMessageType > > actual = TestRunner . consumeStream ( outputDescriptor , timeout ) ; for ( Integer paritionId : expected . keySet ( ) ) { assertThat ( actual . get ( paritionId ) , IsIterableContainingInAnyOrder . containsInAnyOrder ( expected . get ( paritionId ) . toArray ( ) ) ) ; } }
Swrrt/Samza | public static < StreamMessageType > void containsInOrder ( List < StreamMessageType > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; assertThat ( TestRunner . consumeStream ( outputDescriptor , timeout ) . entrySet ( ) . stream ( ) . flatMap ( entry -> entry . getValue ( ) . stream ( ) ) . collect ( Collectors . toList ( ) ) , IsIterableContainingInOrder . contains ( expected . toArray ( ) ) ) ; }
Swrrt/Samza | public static < StreamMessageType > void containsInOrder ( Map < Integer , List < StreamMessageType > > expected , InMemoryOutputDescriptor < StreamMessageType > outputDescriptor , Duration timeout ) throws InterruptedException { Preconditions . checkNotNull ( outputDescriptor ) ; Map < Integer , List < StreamMessageType > > actual = TestRunner . consumeStream ( outputDescriptor , timeout ) ; for ( Integer paritionId : expected . keySet ( ) ) { assertThat ( actual . get ( paritionId ) , IsIterableContainingInOrder . contains ( expected . get ( paritionId ) . toArray ( ) ) ) ; } }
GDG-Korea/holo_to_material | public static final Parcelable . Creator < Category > CREATOR = new Parcelable . Creator < Category > ( ) { public Category createFromParcel ( Parcel in ) { return new Category ( in ) ; } public Category [ ] newArray ( int size ) { return new Category [ size ] ; } }
idea4bsd/idea4bsd | @ NotNull private static String getPresentableText ( @ NotNull VcsFullCommitDetails commit , boolean withMessage ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( commit . getId ( ) . toShortString ( ) ) . append ( " ▁ " ) ; sb . append ( commit . getAuthor ( ) . getName ( ) ) ; long time = commit . getAuthorTime ( ) ; sb . append ( " ▁ on ▁ " ) . append ( DateFormatUtil . formatDate ( time ) ) . append ( " ▁ at ▁ " ) . append ( DateFormatUtil . formatTime ( time ) ) ; if ( ! Comparing . equal ( commit . getAuthor ( ) , commit . getCommitter ( ) ) ) { sb . append ( " ▁ ( committed ▁ by ▁ " ) . append ( commit . getCommitter ( ) . getName ( ) ) . append ( " ) " ) ; } if ( withMessage ) { sb . append ( " ▁ " ) . append ( commit . getSubject ( ) ) ; } return sb . toString ( ) ; }
idea4bsd/idea4bsd | public static JBColor getRootBackgroundColor ( @ NotNull VirtualFile root , @ NotNull VcsLogColorManager colorManager ) { return VcsLogColorManagerImpl . getBackgroundColor ( colorManager . getRootColor ( root ) ) ; }
TelerikAcademy/SchoolAcademy | static BigInteger fibonacci ( int n ) { if ( fib [ n ] == null ) { if ( ( n == 1 ) || ( n == 2 ) ) { fib [ n ] = BigInteger . valueOf ( 1 ) ; } else { fib [ n ] = fibonacci ( n - 1 ) . add ( fibonacci ( n - 2 ) ) ; } } return fib [ n ] ; }
TelerikAcademy/SchoolAcademy | public static void main ( String [ ] args ) { System . out . println ( fibonacci ( 10 ) ) ; System . out . println ( fibonacci ( 300 ) ) ; }
daiqiquan/framework-base | private static IConnectivityManager getService ( ) { return IConnectivityManager . Stub . asInterface ( ServiceManager . getService ( Context . CONNECTIVITY_SERVICE ) ) ; }
daiqiquan/framework-base | public static Intent prepare ( Context context ) { try { if ( getService ( ) . prepareVpn ( context . getPackageName ( ) , null , UserHandle . myUserId ( ) ) ) { return null ; } } catch ( RemoteException e ) { } return VpnConfig . getIntentForConfirmation ( ) ; }
daiqiquan/framework-base | @ SystemApi public static void prepareAndAuthorize ( Context context ) { IConnectivityManager cm = getService ( ) ; String packageName = context . getPackageName ( ) ; try { int userId = UserHandle . myUserId ( ) ; if ( ! cm . prepareVpn ( packageName , null , userId ) ) { cm . prepareVpn ( null , packageName , userId ) ; } cm . setVpnPackageAuthorization ( packageName , userId , true ) ; } catch ( RemoteException e ) { } }
daiqiquan/framework-base | private static void check ( InetAddress address , int prefixLength ) { if ( address . isLoopbackAddress ( ) ) { throw new IllegalArgumentException ( " Bad ▁ address " ) ; } if ( address instanceof Inet4Address ) { if ( prefixLength < 0 || prefixLength > 32 ) { throw new IllegalArgumentException ( " Bad ▁ prefixLength " ) ; } } else if ( address instanceof Inet6Address ) { if ( prefixLength < 0 || prefixLength > 128 ) { throw new IllegalArgumentException ( " Bad ▁ prefixLength " ) ; } } else { throw new IllegalArgumentException ( " Unsupported ▁ family " ) ; } }
chrismattmann/drat | public static File unzip ( File zipped ) throws ZipException { ZipFile zipFile = new ZipFile ( zipped . getAbsolutePath ( ) ) ; zipFile . extractAll ( OUTPUT_FOLDER ) ; return new File ( OUTPUT_FOLDER ) ; }
3203317/ppp | public static void setDBType ( String dbType ) { contextHolder . set ( dbType ) ; }
3203317/ppp | public static String getDBType ( ) { return ( String ) contextHolder . get ( ) ; }
3203317/ppp | public static void clearDBType ( ) { contextHolder . remove ( ) ; }
1245816264/android-ndk | public static void setContext ( Context c ) { Log . i ( " NDKHelper " , " setContext : " + c ) ; context = c ; }
1245816264/android-ndk | public static String getNativeLibraryDirectory ( Context appContext ) { ApplicationInfo ai = context . getApplicationInfo ( ) ; Log . w ( " NDKHelper " , " ai . nativeLibraryDir : " + ai . nativeLibraryDir ) ; if ( ( ai . flags & ApplicationInfo . FLAG_UPDATED_SYSTEM_APP ) != 0 || ( ai . flags & ApplicationInfo . FLAG_SYSTEM ) == 0 ) { return ai . nativeLibraryDir ; } return " / system / lib / " ; }
triathematician/blaisemath | public static < E > NodeInGraph < E > create ( E node ) { return new NodeInGraph < > ( node , null ) ; }
StephanEwen/incubator-flink | @ BeforeClass public static void activateHBaseCluster ( ) throws IOException { prepareTables ( ) ; }
StephanEwen/incubator-flink | private static void prepareTables ( ) throws IOException { createHBaseTable1 ( ) ; createHBaseTable2 ( ) ; createHBaseTable3 ( ) ; }
StephanEwen/incubator-flink | private static void createHBaseTable1 ( ) throws IOException { TableName tableName = TableName . valueOf ( TEST_TABLE_1 ) ; createTable ( tableName , FAMILIES , SPLIT_KEYS ) ; Table table = openTable ( tableName ) ; List < Put > puts = new ArrayList < > ( ) ; puts . add ( putRow ( 1 , 10 , " Hello - 1" , 100L , 1.01 , false , " Welt - 1" , Timestamp . valueOf ( "2019-08-18 ▁ 19:00:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:00:00" ) , new BigDecimal ( "12345678.0001" ) ) ) ; puts . add ( putRow ( 2 , 20 , " Hello - 2" , 200L , 2.02 , true , " Welt - 2" , Timestamp . valueOf ( "2019-08-18 ▁ 19:01:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:01:00" ) , new BigDecimal ( "12345678.0002" ) ) ) ; puts . add ( putRow ( 3 , 30 , " Hello - 3" , 300L , 3.03 , false , " Welt - 3" , Timestamp . valueOf ( "2019-08-18 ▁ 19:02:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:02:00" ) , new BigDecimal ( "12345678.0003" ) ) ) ; puts . add ( putRow ( 4 , 40 , null , 400L , 4.04 , true , " Welt - 4" , Timestamp . valueOf ( "2019-08-18 ▁ 19:03:00" ) , Date . valueOf ( "2019-08-18" ) , Time . valueOf ( "19:03:00" ) , new BigDecimal ( "12345678.0004" ) ) ) ; puts . add ( putRow ( 5 , 50 , " Hello - 5" , 500L , 5.05 , false , " Welt - 5" , Timestamp . valueOf ( "2019-08-19 ▁ 19:10:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:10:00" ) , new BigDecimal ( "12345678.0005" ) ) ) ; puts . add ( putRow ( 6 , 60 , " Hello - 6" , 600L , 6.06 , true , " Welt - 6" , Timestamp . valueOf ( "2019-08-19 ▁ 19:20:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:20:00" ) , new BigDecimal ( "12345678.0006" ) ) ) ; puts . add ( putRow ( 7 , 70 , " Hello - 7" , 700L , 7.07 , false , " Welt - 7" , Timestamp . valueOf ( "2019-08-19 ▁ 19:30:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:30:00" ) , new BigDecimal ( "12345678.0007" ) ) ) ; puts . add ( putRow ( 8 , 80 , null , 800L , 8.08 , true , " Welt - 8" , Timestamp . valueOf ( "2019-08-19 ▁ 19:40:00" ) , Date . valueOf ( "2019-08-19" ) , Time . valueOf ( "19:40:00" ) , new BigDecimal ( "12345678.0008" ) ) ) ; table . put ( puts ) ; table . close ( ) ; }
StephanEwen/incubator-flink | private static void createHBaseTable2 ( ) { TableName tableName = TableName . valueOf ( TEST_TABLE_2 ) ; createTable ( tableName , FAMILIES , SPLIT_KEYS ) ; }
StephanEwen/incubator-flink | private static void createHBaseTable3 ( ) { byte [ ] [ ] families = new byte [ ] [ ] { Bytes . toBytes ( FAMILY1 ) , Bytes . toBytes ( FAMILY2 ) , Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( FAMILY4 ) , } ; TableName tableName = TableName . valueOf ( TEST_TABLE_3 ) ; createTable ( tableName , families , SPLIT_KEYS ) ; }
StephanEwen/incubator-flink | private static Put putRow ( int rowKey , int f1c1 , String f2c1 , long f2c2 , double f3c1 , boolean f3c2 , String f3c3 , Timestamp f4c1 , Date f4c2 , Time f4c3 , BigDecimal f4c4 ) { Put put = new Put ( Bytes . toBytes ( rowKey ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY1 ) , Bytes . toBytes ( F1COL1 ) , Bytes . toBytes ( f1c1 ) ) ; if ( f2c1 != null ) { put . addColumn ( Bytes . toBytes ( FAMILY2 ) , Bytes . toBytes ( F2COL1 ) , Bytes . toBytes ( f2c1 ) ) ; } put . addColumn ( Bytes . toBytes ( FAMILY2 ) , Bytes . toBytes ( F2COL2 ) , Bytes . toBytes ( f2c2 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( F3COL1 ) , Bytes . toBytes ( f3c1 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( F3COL2 ) , Bytes . toBytes ( f3c2 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY3 ) , Bytes . toBytes ( F3COL3 ) , Bytes . toBytes ( f3c3 ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL1 ) , Bytes . toBytes ( timestampToInternal ( f4c1 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL2 ) , Bytes . toBytes ( dateToInternal ( f4c2 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL3 ) , Bytes . toBytes ( timeToInternal ( f4c3 ) ) ) ; put . addColumn ( Bytes . toBytes ( FAMILY4 ) , Bytes . toBytes ( F4COL4 ) , Bytes . toBytes ( f4c4 ) ) ; return put ; }
micmiu/bigdata-tutorial | public static synchronized SimpleHiveConnManager getInstance ( ) { if ( instance == null ) { instance = new SimpleHiveConnManager ( ) ; } clients ++ ; return instance ; }
prajesh-ananthan/java_mastery | public static void main ( String [ ] args ) { System . out . println ( " Hello ▁ World " ) ; }
wouwouwou/2017_module_8 | public static void main ( String [ ] args ) { scan ( " while ▁ do " ) ; scan ( " while ▁ while ▁ do " ) ; scan ( " whiledo ▁ done " ) ; }
wouwouwou/2017_module_8 | public static void scan ( String text ) { CharStream stream = CharStreams . fromString ( text ) ; Lexer lexer = new Example ( stream ) ; for ( Token token : lexer . getAllTokens ( ) ) { System . out . print ( token . toString ( ) + " ▁ " ) ; } System . out . println ( ) ; }
avedensky/JavaRushTasks | public static void main ( String [ ] args ) { Solution solution = new Solution ( ) ; solution . users . put ( " Hubert " , new User ( 172 , " Hubert " ) ) ; solution . users . put ( " Zapp " , new User ( 41 , " Zapp " ) ) ; Solution clone = null ; try { clone = solution . clone ( ) ; System . out . println ( solution ) ; System . out . println ( clone ) ; System . out . println ( solution . users ) ; System . out . println ( clone . users ) ; } catch ( CloneNotSupportedException e ) { e . printStackTrace ( System . err ) ; } }
infobip/mobile-messaging-sdk-android | public static void setState ( Context context , boolean enabled , Class componentClass ) { int state = enabled ? PackageManager . COMPONENT_ENABLED_STATE_ENABLED : PackageManager . COMPONENT_ENABLED_STATE_DISABLED ; ComponentName componentName = new ComponentName ( context , componentClass ) ; try { context . getPackageManager ( ) . setComponentEnabledSetting ( componentName , state , PackageManager . DONT_KILL_APP ) ; } catch ( Exception e ) { throw new ConfigurationException ( ConfigurationException . Reason . MISSING_REQUIRED_COMPONENT , componentClass . getCanonicalName ( ) ) ; } }
infobip/mobile-messaging-sdk-android | public static void setSynchronizationReceiverStateEnabled ( Context context , MobileMessagingSynchronizationReceiver syncReceiver , boolean enabled ) { if ( enabled ) { LocalBroadcastManager . getInstance ( context ) . registerReceiver ( syncReceiver , new IntentFilter ( LocalEvent . APPLICATION_FOREGROUND . getKey ( ) ) ) ; } else { LocalBroadcastManager . getInstance ( context ) . unregisterReceiver ( syncReceiver ) ; } }
infobip/mobile-messaging-sdk-android | public static void setConnectivityComponentsStateEnabled ( Context context , boolean enabled ) { if ( Build . VERSION . SDK_INT < Build . VERSION_CODES . N ) { ComponentUtil . setState ( context , enabled , MobileMessagingConnectivityReceiver . class ) ; } else { ComponentUtil . setState ( context , enabled , MobileMessagingJobService . class ) ; } }
infobip/mobile-messaging-sdk-android | public static void verifyManifestComponentsForPush ( Context context ) { verifyManifestService ( context , MobileMessagingCloudService . class ) ; verifyManifestService ( context , MobileMessagingFirebaseService . class ) ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . N ) { verifyManifestService ( context , MobileMessagingJobService . class ) ; } else { verifyManifestReceiver ( context , MobileMessagingConnectivityReceiver . class ) ; } }
infobip/mobile-messaging-sdk-android | public static void enableComponent ( Context context , Class componentClass ) { try { ComponentUtil . setState ( context , true , componentClass ) ; MobileMessagingLogger . w ( " Enabled ▁ " + componentClass . getName ( ) + " ▁ for ▁ compatibility ▁ reasons " ) ; } catch ( Exception e ) { MobileMessagingLogger . d ( " Cannot ▁ enable ▁ " + componentClass . getName ( ) + " : ▁ " , e ) ; } }
infobip/mobile-messaging-sdk-android | public static void enableComponent ( Context context , String fullClassName ) { try { enableComponent ( context , Class . forName ( fullClassName ) ) ; } catch ( ClassNotFoundException ignored ) { } }
infobip/mobile-messaging-sdk-android | public static void verifyManifestService ( Context context , Class < ? extends Service > cls ) { try { context . getPackageManager ( ) . getServiceInfo ( new ComponentName ( context , cls ) , PackageManager . GET_DISABLED_COMPONENTS ) ; } catch ( Exception ignored ) { reportMissingComponent ( context , cls ) ; } }
infobip/mobile-messaging-sdk-android | public static void verifyManifestReceiver ( Context context , Class < ? extends BroadcastReceiver > cls ) { try { context . getPackageManager ( ) . getReceiverInfo ( new ComponentName ( context , cls ) , PackageManager . GET_DISABLED_COMPONENTS ) ; } catch ( Exception ignored ) { reportMissingComponent ( context , cls ) ; } }
infobip/mobile-messaging-sdk-android | private static void reportMissingComponent ( Context context , Class cls ) { ConfigurationException exception = new ConfigurationException ( ConfigurationException . Reason . MISSING_REQUIRED_COMPONENT , cls . getCanonicalName ( ) ) ; if ( SoftwareInformation . isDebuggableApplicationBuild ( context ) ) { throw exception ; } else { MobileMessagingLogger . e ( exception . getMessage ( ) ) ; } }
tzvetkoff/brkt-sdk-java | static long systemNanoTime ( ) { return System . nanoTime ( ) ; }
tzvetkoff/brkt-sdk-java | static CharMatcher precomputeCharMatcher ( CharMatcher matcher ) { return matcher . precomputedInternal ( ) ; }
guoyydev/CoolWeather | public static boolean handleProvinceResponse ( String response ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray allProvinces = new JSONArray ( response ) ; for ( int i = 0 ; i < allProvinces . length ( ) ; i ++ ) { JSONObject provinceObject = allProvinces . getJSONObject ( i ) ; Province province = new Province ( ) ; province . setProvinceName ( provinceObject . getString ( " name " ) ) ; province . setProvinceCode ( provinceObject . getInt ( " id " ) ) ; province . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
guoyydev/CoolWeather | public static boolean handleCityResponse ( String response , int provinceId ) { if ( ! TextUtils . isEmpty ( response ) ) { try { JSONArray allCities = new JSONArray ( response ) ; for ( int i = 0 ; i < allCities . length ( ) ; i ++ ) { JSONObject cityObject = allCities . getJSONObject ( i ) ; City city = new City ( ) ; city . setCityName ( cityObject . getString ( " name " ) ) ; city . setCityCode ( cityObject . getInt ( " id " ) ) ; city . setProvinceId ( provinceId ) ; city . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
guoyydev/CoolWeather | public static boolean handleCountryResponse ( String resonse , int cityId ) { if ( ! TextUtils . isEmpty ( resonse ) ) { try { JSONArray allCountries = new JSONArray ( resonse ) ; for ( int i = 0 ; i < allCountries . length ( ) ; i ++ ) { JSONObject countryObject = allCountries . getJSONObject ( i ) ; Country country = new Country ( ) ; country . setCountryName ( countryObject . getString ( " name " ) ) ; country . setWeatherId ( countryObject . getString ( " weather _ id " ) ) ; country . setCityId ( cityId ) ; country . save ( ) ; } return true ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } } return false ; }
guoyydev/CoolWeather | public static Weather handleWeatherResponse ( String response ) { try { JSONObject jsonObject = new JSONObject ( response ) ; JSONArray jsonArray = jsonObject . getJSONArray ( " HeWeather " ) ; String weatherContent = jsonArray . getJSONObject ( 0 ) . toString ( ) ; return new Gson ( ) . fromJson ( weatherContent , Weather . class ) ; } catch ( JSONException e ) { e . printStackTrace ( ) ; } return null ; }
ratimid/SoftUni | public static void main ( String [ ] args ) { Scanner console = new Scanner ( System . in ) ; int food = Integer . parseInt ( console . nextLine ( ) ) ; int foodInGrams = food * 1000 ; String command = console . nextLine ( ) ; int eatenFood = 0 ; int totalFood = 0 ; while ( ! command . equals ( " Adopted " ) ) { eatenFood = Integer . parseInt ( command ) ; totalFood += eatenFood ; command = console . nextLine ( ) ; } if ( foodInGrams >= totalFood ) { System . out . printf ( " Food ▁ is ▁ enough ! ▁ Leftovers : ▁ % s ▁ grams . " , foodInGrams - totalFood ) ; } else { System . out . printf ( " Food ▁ is ▁ not ▁ enough . ▁ You ▁ need ▁ % s ▁ grams ▁ more . " , totalFood - foodInGrams ) ; } }
freeVM/freeVM | private static final SerializableAssert exComparator = new SerializableAssert ( ) { public void assertDeserialized ( Serializable initial , Serializable deserialized ) { SerializationTest . THROWABLE_COMPARATOR . assertDeserialized ( initial , deserialized ) ; MissingFormatWidthException initEx = ( MissingFormatWidthException ) initial ; MissingFormatWidthException desrEx = ( MissingFormatWidthException ) deserialized ; assertEquals ( " FormatSpecifier " , initEx . getFormatSpecifier ( ) , desrEx . getFormatSpecifier ( ) ) ; } }
ldionmarcil/OSRSHelper | public static List < Item > fetch ( String itemName ) { Logger . add ( TAG , " : ▁ fetch : ▁ itemName = " , itemName ) ; List < Item > itemsSearch = new ArrayList < > ( ) ; HTTPResult httpResult = NetworkStack . getInstance ( ) . performGetRequest ( String . format ( API_URL , Uri . encode ( itemName ) ) ) ; if ( httpResult . statusCode == StatusCode . FOUND ) { try { JSONObject json = new JSONObject ( httpResult . output ) . getJSONObject ( KEY_MATCHES ) ; Iterator < String > keys = json . keys ( ) ; while ( keys . hasNext ( ) ) { String itemId = keys . next ( ) ; JSONObject itemJson = json . getJSONObject ( itemId ) ; Item item = new Item ( ) ; item . id = itemId ; item . description = itemJson . getString ( KEY_DESCRIPTION ) ; item . name = itemJson . getString ( KEY_NAME ) ; item . members = TextUtils . equals ( itemJson . getString ( KEY_MEMBERS ) , VALUE_TRUE ) ; item . iconLarge = ICON_ENDPOINT + itemId ; itemsSearch . add ( item ) ; } } catch ( JSONException e ) { Logger . addException ( TAG , e ) ; } } return itemsSearch ; }
kangaroo-server/kangaroo | @ ClassRule public static final TestRule TEST_DATA_RULE = new TestDataResource ( HIBERNATE_RESOURCE ) { @ Override protected void loadTestData ( final Session session ) { Map < String , String > githubConfig = new HashMap < > ( ) ; githubConfig . put ( CLIENT_ID_KEY , " id " ) ; githubConfig . put ( CLIENT_SECRET_KEY , " secret " ) ; context = ApplicationBuilder . newApplication ( session ) . client ( ClientType . AuthorizationGrant ) . role ( " some _ role " ) . authenticator ( Github , githubConfig ) . build ( ) ; } }
jisqyv/appinventor-sources | public static < T > T cast ( Object o , Class < T > tClass , String expected ) { if ( o == null ) { return null ; } else if ( tClass . isInstance ( o ) ) { return tClass . cast ( o ) ; } else { throw new DispatchableError ( ErrorMessages . ERROR_INVALID_TYPE , o . getClass ( ) . getSimpleName ( ) , expected ) ; } }
jisqyv/appinventor-sources | public static < T > T castNotNull ( Object o , Class < T > tClass , String expected ) { if ( o == null ) { throw new DispatchableError ( ErrorMessages . ERROR_INVALID_TYPE , " null " , expected ) ; } else { return cast ( o , tClass , expected ) ; } }
jisqyv/appinventor-sources | public static < T > OptionList < T > castToEnum ( T value , Symbol className ) { String classNameStr = stripEnumSuffix ( className . getName ( ) ) ; try { Class < ? > clazz = Class . forName ( classNameStr ) ; if ( ! OptionList . class . isAssignableFrom ( clazz ) ) { throw new IllegalArgumentException ( classNameStr + " ▁ does ▁ not ▁ identify ▁ an ▁ OptionList ▁ type . " ) ; } for ( Method m : clazz . getMethods ( ) ) { if ( " fromUnderlyingValue " . equals ( m . getName ( ) ) ) { return ( OptionList < T > ) m . invoke ( clazz , value ) ; } } return null ; } catch ( ClassNotFoundException e ) { return null ; } catch ( InvocationTargetException e ) { return null ; } catch ( IllegalAccessException e ) { return null ; } }
jisqyv/appinventor-sources | private static String stripEnumSuffix ( String className ) { if ( className . endsWith ( " Enum " ) ) { return className . substring ( 0 , className . length ( ) - 4 ) ; } return className ; }
Reimerei/flatbuffers | public static Stat getRootAsStat ( ByteBuffer _bb ) { return getRootAsStat ( _bb , new Stat ( ) ) ; }
Reimerei/flatbuffers | public static Stat getRootAsStat ( ByteBuffer _bb , Stat obj ) { _bb . order ( ByteOrder . LITTLE_ENDIAN ) ; return ( obj . __init ( _bb . getInt ( _bb . position ( ) ) + _bb . position ( ) , _bb ) ) ; }
Reimerei/flatbuffers | public static int createStat ( FlatBufferBuilder builder , int id , long val , int count ) { builder . startObject ( 3 ) ; Stat . addVal ( builder , val ) ; Stat . addId ( builder , id ) ; Stat . addCount ( builder , count ) ; return Stat . endStat ( builder ) ; }
Reimerei/flatbuffers | public static void startStat ( FlatBufferBuilder builder ) { builder . startObject ( 3 ) ; }
Reimerei/flatbuffers | public static void addId ( FlatBufferBuilder builder , int idOffset ) { builder . addOffset ( 0 , idOffset , 0 ) ; }
Reimerei/flatbuffers | public static void addVal ( FlatBufferBuilder builder , long val ) { builder . addLong ( 1 , val , 0 ) ; }
Reimerei/flatbuffers | public static void addCount ( FlatBufferBuilder builder , int count ) { builder . addShort ( 2 , ( short ) ( count & 0xFFFF ) , 0 ) ; }
Reimerei/flatbuffers | public static int endStat ( FlatBufferBuilder builder ) { int o = builder . endObject ( ) ; return o ; }
yuananf/presto | private static ConnectorTableMetadata getOrdersTable ( ) { return getOrdersTable ( ImmutableMap . of ( ) ) ; }
yuananf/presto | private static ConnectorTableMetadata getOrdersTable ( Map < String , Object > properties ) { return buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_ORDERS ) . column ( " orderkey " , BIGINT ) . column ( " custkey " , BIGINT ) . column ( " totalprice " , DOUBLE ) . column ( " orderdate " , DATE ) ) ; }
yuananf/presto | private static ConnectorTableMetadata getLineItemsTable ( Map < String , Object > properties ) { return buildTable ( properties , tableMetadataBuilder ( DEFAULT_TEST_LINEITEMS ) . column ( " orderkey " , BIGINT ) . column ( " partkey " , BIGINT ) . column ( " quantity " , DOUBLE ) . column ( " price " , DOUBLE ) ) ; }
yuananf/presto | private static ConnectorTableMetadata buildTable ( Map < String , Object > properties , TableMetadataBuilder builder ) { if ( ! properties . isEmpty ( ) ) { for ( Map . Entry < String , Object > entry : properties . entrySet ( ) ) { builder . property ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return builder . build ( ) ; }
yuananf/presto | private static void assertTableEqual ( ConnectorTableMetadata actual , ConnectorTableMetadata expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; List < ColumnMetadata > actualColumns = actual . getColumns ( ) . stream ( ) . filter ( columnMetadata -> ! columnMetadata . isHidden ( ) ) . collect ( Collectors . toList ( ) ) ; List < ColumnMetadata > expectedColumns = expected . getColumns ( ) ; assertEquals ( actualColumns . size ( ) , expectedColumns . size ( ) ) ; for ( int i = 0 ; i < actualColumns . size ( ) ; i ++ ) { ColumnMetadata actualColumn = actualColumns . get ( i ) ; ColumnMetadata expectedColumn = expectedColumns . get ( i ) ; assertEquals ( actualColumn . getName ( ) , expectedColumn . getName ( ) ) ; assertEquals ( actualColumn . getType ( ) , expectedColumn . getType ( ) ) ; } assertEquals ( actual . getProperties ( ) , expected . getProperties ( ) ) ; }
yuananf/presto | private static void assertTableColumnEqual ( TableColumn actual , TableColumn expected ) { assertEquals ( actual . getTable ( ) , expected . getTable ( ) ) ; assertEquals ( actual . getColumnId ( ) , expected . getColumnId ( ) ) ; assertEquals ( actual . getColumnName ( ) , expected . getColumnName ( ) ) ; assertEquals ( actual . getDataType ( ) , expected . getDataType ( ) ) ; assertEquals ( actual . getOrdinalPosition ( ) , expected . getOrdinalPosition ( ) ) ; assertEquals ( actual . getBucketOrdinal ( ) , expected . getBucketOrdinal ( ) ) ; assertEquals ( actual . getSortOrdinal ( ) , expected . getSortOrdinal ( ) ) ; assertEquals ( actual . isTemporal ( ) , expected . isTemporal ( ) ) ; }
yuananf/presto | private static void assertTableColumnsEqual ( List < TableColumn > actual , List < TableColumn > expected ) { assertEquals ( actual . size ( ) , expected . size ( ) ) ; for ( int i = 0 ; i < actual . size ( ) ; i ++ ) { assertTableColumnEqual ( actual . get ( i ) , expected . get ( i ) ) ; } }
yuananf/presto | private static void assertThrows ( String message , ThrowingRunnable runnable ) { try { runnable . run ( ) ; fail ( " expected ▁ exception " ) ; } catch ( Throwable t ) { assertEquals ( t . getMessage ( ) , message ) ; } }
anchela/jackrabbit-oak | static < T > void call ( Callable < T > callable ) throws Exception { callable . call ( ) ; }
111t8e/h2o-2 | static public void wrap ( ) { System . setErr ( new Wrapper ( System . err ) ) ; }
111t8e/h2o-2 | public static boolean flag ( Sys t ) { return t . _enable || printAll ; }
111t8e/h2o-2 | public static void setFlag ( Sys t ) { t . _enable = true ; }
111t8e/h2o-2 | public static void unsetFlag ( Sys t ) { t . _enable = false ; }
111t8e/h2o-2 | static Event make ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages ) { return make0 ( sys , kind , ouch , messages , null ) ; }
111t8e/h2o-2 | static Event make ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object message ) { return make0 ( sys , kind , ouch , null , message ) ; }
111t8e/h2o-2 | static private Event make0 ( Tag . Sys sys , Tag . Kind kind , Throwable ouch , Object [ ] messages , Object message ) { Event result = null ; try { result = new Event ( ) ; result . init ( sys , kind , ouch , messages , message , lastGoodTimer = new Timer ( ) ) ; } catch ( OutOfMemoryError e ) { synchronized ( Event . class ) { if ( lastEvent . printMe ) { missed ++ ; return null ; } result = lastEvent ; result . init ( sys , kind , ouch , messages , null , lastGoodTimer ) ; } } return result ; }
111t8e/h2o-2 | private static void write ( Event e , boolean printOnOut , boolean logToKV ) { try { write0 ( e , printOnOut , logToKV ) ; if ( Event . lastEvent . printMe || Event . missed > 0 ) { synchronized ( Event . class ) { if ( Event . lastEvent . printMe ) { Event ev = Event . lastEvent ; write0 ( ev , true , logToKV ) ; Event . lastEvent = new Event ( ) ; } if ( Event . missed > 0 ) { if ( Event . lastEvent . printMe == false ) { Event . lastEvent . init ( Sys . WATER , Kind . WARN , null , null , " Logging ▁ framework ▁ dropped ▁ a ▁ message " , Event . lastGoodTimer ) ; Event . missed -- ; } } } } } catch ( OutOfMemoryError xe ) { synchronized ( Event . class ) { if ( Event . lastEvent . printMe == false ) Event . lastEvent = e ; else Event . missed ++ ; } } }
111t8e/h2o-2 | public static String getLogDir ( ) { if ( LOG_DIR == null ) { return " unknown - log - dir " ; } return LOG_DIR ; }
111t8e/h2o-2 | public static String getLogPathFileNameStem ( ) { String ip ; if ( H2O . SELF_ADDRESS == null ) { ip = " UnknownIP " ; } else { ip = H2O . SELF_ADDRESS . getHostAddress ( ) ; } int port = H2O . API_PORT ; String portString = Integer . toString ( port ) ; String logFileName = getLogDir ( ) + File . separator + " h2o _ " + ip + " _ " + portString ; return logFileName ; }
111t8e/h2o-2 | public static String getLogPathFileName ( ) { return getLogPathFileNameStem ( ) + " - 2 - debug . log " ; }
111t8e/h2o-2 | private static org . apache . log4j . Logger getLog4jLogger ( ) { return _logger ; }
111t8e/h2o-2 | private static void setLog4jProperties ( String logDirParent , java . util . Properties p ) { LOG_DIR = logDirParent + File . separator + " h2ologs " ; String logPathFileName = getLogPathFileNameStem ( ) ; p . setProperty ( " log4j . rootLogger " , " TRACE , ▁ R1 , ▁ R2 , ▁ R3 , ▁ R4 , ▁ R5 , ▁ R6" ) ; p . setProperty ( " log4j . appender . R1" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R1 . Threshold " , " TRACE " ) ; p . setProperty ( " log4j . appender . R1 . File " , logPathFileName + " - 1 - trace . log " ) ; p . setProperty ( " log4j . appender . R1 . MaxFileSize " , "1MB " ) ; p . setProperty ( " log4j . appender . R1 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R1 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R1 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R2" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R2 . Threshold " , " DEBUG " ) ; p . setProperty ( " log4j . appender . R2 . File " , logPathFileName + " - 2 - debug . log " ) ; p . setProperty ( " log4j . appender . R2 . MaxFileSize " , "3MB " ) ; p . setProperty ( " log4j . appender . R2 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R2 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R2 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R3" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R3 . Threshold " , " INFO " ) ; p . setProperty ( " log4j . appender . R3 . File " , logPathFileName + " - 3 - info . log " ) ; p . setProperty ( " log4j . appender . R3 . MaxFileSize " , "2MB " ) ; p . setProperty ( " log4j . appender . R3 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R3 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R3 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R4" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R4 . Threshold " , " WARN " ) ; p . setProperty ( " log4j . appender . R4 . File " , logPathFileName + " - 4 - warn . log " ) ; p . setProperty ( " log4j . appender . R4 . MaxFileSize " , "256KB " ) ; p . setProperty ( " log4j . appender . R4 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R4 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R4 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R5" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R5 . Threshold " , " ERROR " ) ; p . setProperty ( " log4j . appender . R5 . File " , logPathFileName + " - 5 - error . log " ) ; p . setProperty ( " log4j . appender . R5 . MaxFileSize " , "256KB " ) ; p . setProperty ( " log4j . appender . R5 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R5 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R5 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . appender . R6" , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . R6 . Threshold " , " FATAL " ) ; p . setProperty ( " log4j . appender . R6 . File " , logPathFileName + " - 6 - fatal . log " ) ; p . setProperty ( " log4j . appender . R6 . MaxFileSize " , "256KB " ) ; p . setProperty ( " log4j . appender . R6 . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . R6 . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . R6 . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . logger . water . api . RequestServer " , " TRACE , ▁ HTTPD " ) ; p . setProperty ( " log4j . additivity . water . api . RequestServer " , " false " ) ; p . setProperty ( " log4j . appender . HTTPD " , " org . apache . log4j . RollingFileAppender " ) ; p . setProperty ( " log4j . appender . HTTPD . Threshold " , " TRACE " ) ; p . setProperty ( " log4j . appender . HTTPD . File " , logPathFileName + " - httpd . log " ) ; p . setProperty ( " log4j . appender . HTTPD . MaxFileSize " , "1MB " ) ; p . setProperty ( " log4j . appender . HTTPD . MaxBackupIndex " , "3" ) ; p . setProperty ( " log4j . appender . HTTPD . layout " , " org . apache . log4j . PatternLayout " ) ; p . setProperty ( " log4j . appender . HTTPD . layout . ConversionPattern " , " % m % n " ) ; p . setProperty ( " log4j . logger . org . apache . http " , " WARN " ) ; p . setProperty ( " log4j . logger . com . amazonaws " , " WARN " ) ; p . setProperty ( " log4j . logger . org . apache . hadoop " , " WARN " ) ; p . setProperty ( " log4j . logger . org . jets3t . service " , " WARN " ) ; }
111t8e/h2o-2 | private static org . apache . log4j . Logger createLog4jLogger ( String logDirParent ) { synchronized ( water . util . Log . class ) { if ( _logger != null ) { return _logger ; } String log4jProperties = System . getProperty ( " log4j . properties " ) ; if ( log4jProperties != null ) { PropertyConfigurator . configure ( log4jProperties ) ; } else { java . util . Properties p = new java . util . Properties ( ) ; setLog4jProperties ( logDirParent , p ) ; PropertyConfigurator . configure ( p ) ; } _logger = LogManager . getLogger ( Log . class . getName ( ) ) ; } return _logger ; }
111t8e/h2o-2 | public static void setLogLevel ( int log_level ) throws IllegalArgumentException { Level l ; switch ( log_level ) { case 1 : l = Level . TRACE ; break ; case 2 : l = Level . DEBUG ; break ; case 3 : l = Level . INFO ; break ; case 4 : l = Level . WARN ; break ; case 5 : l = Level . ERROR ; break ; case 6 : l = Level . FATAL ; break ; default : throw new IllegalArgumentException ( " Log ▁ level ▁ " + log_level + " ▁ is ▁ invalid " ) ; } _logger . setLevel ( l ) ; System . out . println ( " Set ▁ log ▁ level ▁ to ▁ " + l ) ; _logger . info ( " Set ▁ log ▁ level ▁ to ▁ " + l ) ; }
111t8e/h2o-2 | private static void log0 ( org . apache . log4j . Logger l4j , Event e ) { if ( e . sys == Sys . HTLOG ) { e . sys = Sys . HTTPD ; String s = " tid ( " + Thread . currentThread ( ) . getId ( ) + " ) ▁ " + e . toString ( ) ; org . apache . log4j . Logger httpdLogger = LogManager . getLogger ( " water . api . RequestServer " ) ; if ( e . kind == Kind . INFO ) { httpdLogger . info ( s ) ; } else { httpdLogger . error ( s ) ; } return ; } String s = e . toString ( ) ; if ( e . kind == Kind . FATL ) { l4j . fatal ( s ) ; } else if ( e . kind == Kind . ERRR ) { l4j . error ( s ) ; } else if ( e . kind == Kind . WARN ) { l4j . warn ( s ) ; } else if ( e . kind == Kind . INFO ) { l4j . info ( s ) ; } else if ( e . kind == Kind . DEBG ) { l4j . debug ( s ) ; } else if ( e . kind == Kind . TRAC ) { l4j . trace ( s ) ; } else { l4j . error ( s ) ; } }
111t8e/h2o-2 | private static void write0 ( Event e , boolean printOnOut , boolean logToKV ) { org . apache . log4j . Logger l4j = getLog4jLogger ( ) ; if ( ( l4j == null ) && ! loggerCreateWasCalled && ! H2O . DEBUG ) { if ( H2O . SELF != null ) { File dir ; boolean windowsPath = H2O . ICE_ROOT . toString ( ) . matches ( " ^ [ a - zA - Z ] : . * " ) ; if ( windowsPath ) dir = new File ( H2O . ICE_ROOT . toString ( ) ) ; else if ( H2O . ICE_ROOT . getScheme ( ) == null || Schemes . FILE . equals ( H2O . ICE_ROOT . getScheme ( ) ) ) dir = new File ( H2O . ICE_ROOT . getPath ( ) ) ; else dir = new File ( H2O . DEFAULT_ICE_ROOT ( ) ) ; loggerCreateWasCalled = true ; l4j = createLog4jLogger ( dir . toString ( ) ) ; } } if ( l4j == null ) { e . toString ( ) ; synchronized ( startupLogEventsLock ) { if ( startupLogEvents != null ) { startupLogEvents . add ( e ) ; } else { } } } else { if ( startupLogEvents != null ) { synchronized ( startupLogEventsLock ) { for ( int i = 0 ; i < startupLogEvents . size ( ) ; i ++ ) { Event bufferedEvent = startupLogEvents . get ( i ) ; log0 ( l4j , bufferedEvent ) ; } startupLogEvents = null ; } } log0 ( l4j , e ) ; } if ( printOnOut || printAll ) unwrap ( System . out , e . toShortString ( ) ) ; e . printMe = false ; }
111t8e/h2o-2 | private static void logToKV ( final String date , final String thr , final Kind kind , final Sys sys , final String msg ) { if ( LOG_KEY == null ) if ( ! Paxos . _cloudLocked ) return ; synchronized ( Log . class ) { if ( LOG_KEY == null ) LOG_KEY = Key . make ( " Log " , ( byte ) 0 , Key . BUILT_IN_KEY ) ; } final long pid = PID ; final H2ONode h2o = H2O . SELF ; new TAtomic < LogStr > ( ) { @ Override public LogStr atomic ( LogStr l ) { return new LogStr ( l , date , h2o , pid , thr , kind , sys , msg ) ; } } . fork ( LOG_KEY ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( Sys t , String msg , T exception ) { Event e = Event . make ( t , Kind . ERRR , exception , msg ) ; write ( e , true , false ) ; return exception ; }
111t8e/h2o-2 | static public void err ( Sys t , String msg ) { Event e = Event . make ( t , Kind . ERRR , null , msg ) ; write ( e , true , false ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( String msg , T exception ) { return err ( Sys . WATER , msg , exception ) ; }
111t8e/h2o-2 | static public void err ( String msg ) { err ( Sys . WATER , msg ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( Sys t , T exception ) { return err ( t , " " , exception ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T err ( T exception ) { return err ( Sys . WATER , " " , exception ) ; }
111t8e/h2o-2 | static public RuntimeException errRTExcept ( Throwable exception ) { return new RuntimeException ( err ( Sys . WATER , " " , exception ) ) ; }
111t8e/h2o-2 | static public < T extends Throwable > T warn ( Sys t , String msg , T exception ) { Event e = Event . make ( t , Kind . WARN , exception , msg ) ; write ( e , true , true ) ; return exception ; }
111t8e/h2o-2 | static public Throwable warn ( Sys t , String msg ) { return warn ( t , msg , null ) ; }
111t8e/h2o-2 | static public Throwable warn ( String msg ) { return warn ( Sys . WATER , msg , null ) ; }
111t8e/h2o-2 | static public void info_no_stdout ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void info_no_DKV ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , false , false ) ; }
111t8e/h2o-2 | static public void info ( Sys t , Object ... objects ) { Event e = Event . make ( t , Kind . INFO , null , objects ) ; write ( e , true , true ) ; }
111t8e/h2o-2 | static public void info_no_stdout ( Object ... objects ) { info_no_stdout ( Sys . WATER , objects ) ; }
111t8e/h2o-2 | static public void info ( Object ... objects ) { info ( Sys . WATER , objects ) ; }
111t8e/h2o-2 | static public void debug ( Object ... objects ) { if ( flag ( Sys . WATER ) == false ) return ; Event e = Event . make ( Sys . WATER , Kind . DEBG , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void debug ( Sys t , Object ... objects ) { if ( flag ( t ) == false ) return ; Event e = Event . make ( t , Kind . DEBG , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void trace ( Object ... objects ) { if ( flag ( Sys . WATER ) == false ) return ; Event e = Event . make ( Sys . WATER , Kind . TRAC , null , objects ) ; write ( e , false , true ) ; }
111t8e/h2o-2 | static public void tmp ( Object ... objects ) { info ( objects ) ; }
111t8e/h2o-2 | public static String fixedLength ( String s , int length ) { String r = padRight ( s , length ) ; if ( r . length ( ) > length ) { int a = Math . max ( r . length ( ) - length + 1 , 0 ) ; int b = Math . max ( a , r . length ( ) ) ; r = " # " + r . substring ( a , b ) ; } return r ; }
111t8e/h2o-2 | public static String padRight ( String stringToPad , int size ) { StringBuilder strb = new StringBuilder ( stringToPad ) ; while ( strb . length ( ) < size ) if ( strb . length ( ) < size ) strb . append ( ' ▁ ' ) ; return strb . toString ( ) ; }
111t8e/h2o-2 | private static long getPid ( ) { try { String n = ManagementFactory . getRuntimeMXBean ( ) . getName ( ) ; int i = n . indexOf ( ' @ ' ) ; if ( i == - 1 ) return - 1 ; return Long . parseLong ( n . substring ( 0 , i ) ) ; } catch ( Throwable t ) { return - 1 ; } }
111t8e/h2o-2 | public static void die ( String s ) { System . err . println ( s ) ; if ( ! _dontDie ) H2O . exit ( - 1 ) ; }
111t8e/h2o-2 | public static void unwrap ( PrintStream stream , String s ) { if ( stream instanceof Wrapper ) ( ( Wrapper ) stream ) . printlnParent ( s ) ; else stream . println ( s ) ; }
111t8e/h2o-2 | public static PrintStream unwrap ( PrintStream stream ) { return stream instanceof Wrapper ? ( ( Wrapper ) stream ) . parent : stream ; }
111t8e/h2o-2 | public static void log ( File file , PrintStream stream ) throws Exception { BufferedReader reader = new BufferedReader ( new FileReader ( file ) ) ; try { for ( ; ; ) { String line = reader . readLine ( ) ; if ( line == null ) break ; stream . println ( line ) ; } } finally { reader . close ( ) ; } }
111t8e/h2o-2 | private static String log ( Locale l , boolean nl , String format , Object ... args ) { String msg = String . format ( l , format , args ) ; Event e = Event . make ( Sys . WATER , Kind . INFO , null , msg ) ; Log . write ( e , false , true ) ; return e . toShortString ( ) + NL ; }
111t8e/h2o-2 | public static void POST ( int n , String s ) { return ; }
111t8e/h2o-2 | public static void POST ( int n , Exception e ) { if ( e . getMessage ( ) != null ) { POST ( n , e . getMessage ( ) ) ; } POST ( n , e . toString ( ) ) ; StackTraceElement [ ] els = e . getStackTrace ( ) ; for ( int i = 0 ; i < els . length ; i ++ ) { POST ( n , els [ i ] . toString ( ) ) ; } }
111t8e/h2o-2 | public static void POST ( int n ) { POST ( n , " " ) ; }
111t8e/h2o-2 | public static void main ( String [ ] args ) { Log . info ( " hi " ) ; Log . info ( " h " , " i " ) ; unwrap ( System . out , " hi " ) ; unwrap ( System . err , " hi " ) ; Log . info ( " ho ▁ " , new Object ( ) { int i ; public String toString ( ) { if ( i ++ == 0 ) throw new OutOfMemoryError ( ) ; else return super . toString ( ) ; } } ) ; Log . info ( " ha ▁ " , new Object ( ) { int i ; public String toString ( ) { if ( i ++ == 0 ) throw new OutOfMemoryError ( ) ; else return super . toString ( ) ; } } ) ; Log . info ( " hi " ) ; Log . info ( " hi " ) ; Log . info ( " hi " ) ; }
guard163/cassandra | public static synchronized < T > ListType < T > getInstance ( AbstractType < T > elements , boolean isMultiCell ) { Map < AbstractType < ? > , ListType > internMap = isMultiCell ? instances : frozenInstances ; ListType < T > t = internMap . get ( elements ) ; if ( t == null ) { t = new ListType < T > ( elements , isMultiCell ) ; internMap . put ( elements , t ) ; } return t ; }
guard163/cassandra | static int compareListOrSet ( AbstractType < ? > elementsComparator , ByteBuffer o1 , ByteBuffer o2 ) { if ( ! o1 . hasRemaining ( ) || ! o2 . hasRemaining ( ) ) return o1 . hasRemaining ( ) ? 1 : o2 . hasRemaining ( ) ? - 1 : 0 ; ByteBuffer bb1 = o1 . duplicate ( ) ; ByteBuffer bb2 = o2 . duplicate ( ) ; int size1 = CollectionSerializer . readCollectionSize ( bb1 , 3 ) ; int size2 = CollectionSerializer . readCollectionSize ( bb2 , 3 ) ; for ( int i = 0 ; i < Math . min ( size1 , size2 ) ; i ++ ) { ByteBuffer v1 = CollectionSerializer . readValue ( bb1 , 3 ) ; ByteBuffer v2 = CollectionSerializer . readValue ( bb2 , 3 ) ; int cmp = elementsComparator . compare ( v1 , v2 ) ; if ( cmp != 0 ) return cmp ; } return size1 == size2 ? 0 : ( size1 < size2 ? - 1 : 1 ) ; }
guard163/cassandra | public static String setOrListToJsonString ( ByteBuffer buffer , AbstractType elementsType , int protocolVersion ) { StringBuilder sb = new StringBuilder ( " [ " ) ; int size = CollectionSerializer . readCollectionSize ( buffer , protocolVersion ) ; for ( int i = 0 ; i < size ; i ++ ) { if ( i > 0 ) sb . append ( " , ▁ " ) ; sb . append ( elementsType . toJSONString ( CollectionSerializer . readValue ( buffer , protocolVersion ) , protocolVersion ) ) ; } return sb . append ( " ] " ) . toString ( ) ; }
PlanetWaves/clockworkengine | public static void initialize ( ) { idRegistrations . clear ( ) ; classRegistrations . clear ( ) ; registrations . clear ( ) ; nextAvailableId = - 2 ; locked = false ; registerClassForId ( DisconnectMessage . SERIALIZER_ID , DisconnectMessage . class , new DisconnectMessage . DisconnectSerializer ( ) ) ; registerClassForId ( ClientRegistrationMessage . SERIALIZER_ID , ClientRegistrationMessage . class , new ClientRegistrationMessage . ClientRegistrationSerializer ( ) ) ; registerClass ( boolean . class , new BooleanSerializer ( ) ) ; registerClass ( byte . class , new ByteSerializer ( ) ) ; registerClass ( char . class , new CharSerializer ( ) ) ; registerClass ( short . class , new ShortSerializer ( ) ) ; registerClass ( int . class , new IntSerializer ( ) ) ; registerClass ( long . class , new LongSerializer ( ) ) ; registerClass ( float . class , new FloatSerializer ( ) ) ; registerClass ( double . class , new DoubleSerializer ( ) ) ; registerClass ( Boolean . class , new BooleanSerializer ( ) ) ; registerClass ( Byte . class , new ByteSerializer ( ) ) ; registerClass ( Character . class , new CharSerializer ( ) ) ; registerClass ( Short . class , new ShortSerializer ( ) ) ; registerClass ( Integer . class , new IntSerializer ( ) ) ; registerClass ( Long . class , new LongSerializer ( ) ) ; registerClass ( Float . class , new FloatSerializer ( ) ) ; registerClass ( Double . class , new DoubleSerializer ( ) ) ; registerClass ( String . class , new StringSerializer ( ) ) ; registerClass ( Vector3f . class , new Vector3Serializer ( ) ) ; registerClass ( Date . class , new DateSerializer ( ) ) ; registerClass ( AbstractCollection . class , new CollectionSerializer ( ) ) ; registerClass ( AbstractList . class , new CollectionSerializer ( ) ) ; registerClass ( AbstractSet . class , new CollectionSerializer ( ) ) ; registerClass ( ArrayList . class , new CollectionSerializer ( ) ) ; registerClass ( HashSet . class , new CollectionSerializer ( ) ) ; registerClass ( LinkedHashSet . class , new CollectionSerializer ( ) ) ; registerClass ( LinkedList . class , new CollectionSerializer ( ) ) ; registerClass ( TreeSet . class , new CollectionSerializer ( ) ) ; registerClass ( Vector . class , new CollectionSerializer ( ) ) ; registerClass ( AbstractMap . class , new MapSerializer ( ) ) ; registerClass ( Attributes . class , new MapSerializer ( ) ) ; registerClass ( HashMap . class , new MapSerializer ( ) ) ; registerClass ( Hashtable . class , new MapSerializer ( ) ) ; registerClass ( IdentityHashMap . class , new MapSerializer ( ) ) ; registerClass ( TreeMap . class , new MapSerializer ( ) ) ; registerClass ( WeakHashMap . class , new MapSerializer ( ) ) ; registerClass ( Enum . class , new EnumSerializer ( ) ) ; registerClass ( GZIPCompressedMessage . class , new GZIPSerializer ( ) ) ; registerClass ( ZIPCompressedMessage . class , new ZIPSerializer ( ) ) ; registerClass ( ChannelInfoMessage . class ) ; }
PlanetWaves/clockworkengine | public static void setStrictRegistration ( boolean b ) { strictRegistration = b ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClass ( Class cls ) { return registerClass ( cls , true ) ; }
PlanetWaves/clockworkengine | public static void registerClasses ( Class ... classes ) { for ( Class c : classes ) { registerClass ( c ) ; } }
PlanetWaves/clockworkengine | private static short nextId ( ) { while ( idRegistrations . containsKey ( nextAvailableId ) ) { nextAvailableId -- ; } return nextAvailableId -- ; }
PlanetWaves/clockworkengine | public static void setReadOnly ( boolean b ) { locked = b ; }
PlanetWaves/clockworkengine | public static boolean isReadOnly ( ) { return locked ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClassForId ( short id , Class cls , Serializer serializer ) { if ( locked ) { throw new RuntimeException ( " Serializer ▁ registry ▁ locked ▁ trying ▁ to ▁ register ▁ class : " + cls ) ; } SerializerRegistration reg = new SerializerRegistration ( serializer , cls , id ) ; idRegistrations . put ( id , reg ) ; classRegistrations . put ( cls , reg ) ; log . log ( Level . FINE , " Registered ▁ class [ " + id + " ] : { 0 } ▁ to : " + serializer , cls ) ; serializer . initialize ( cls ) ; registrations . add ( reg ) ; return reg ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClass ( Class cls , boolean failOnMiss ) { if ( cls . isAnnotationPresent ( Serializable . class ) ) { Serializable serializable = ( Serializable ) cls . getAnnotation ( Serializable . class ) ; Class serializerClass = serializable . serializer ( ) ; short classId = serializable . id ( ) ; if ( classId == 0 ) classId = nextId ( ) ; Serializer serializer = getSerializer ( serializerClass , false ) ; if ( serializer == null ) serializer = fieldSerializer ; SerializerRegistration existingReg = getExactSerializerRegistration ( cls ) ; if ( existingReg != null ) classId = existingReg . getId ( ) ; SerializerRegistration reg = new SerializerRegistration ( serializer , cls , classId ) ; return registerClassForId ( classId , cls , serializer ) ; } if ( failOnMiss ) { throw new IllegalArgumentException ( " Class ▁ is ▁ not ▁ marked ▁ @ Serializable : " + cls ) ; } return null ; }
PlanetWaves/clockworkengine | @ Deprecated public static SerializerRegistration [ ] registerPackage ( String pkgName ) { try { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; String path = pkgName . replace ( ' . ' , ' / ' ) ; Enumeration < URL > resources = classLoader . getResources ( path ) ; List < File > dirs = new ArrayList < File > ( ) ; while ( resources . hasMoreElements ( ) ) { URL resource = resources . nextElement ( ) ; dirs . add ( new File ( resource . getFile ( ) ) ) ; } ArrayList < Class > classes = new ArrayList < Class > ( ) ; for ( File directory : dirs ) { classes . addAll ( findClasses ( directory , pkgName ) ) ; } SerializerRegistration [ ] registeredClasses = new SerializerRegistration [ classes . size ( ) ] ; for ( int i = 0 ; i != classes . size ( ) ; ++ i ) { Class clz = classes . get ( i ) ; registeredClasses [ i ] = registerClass ( clz , false ) ; } return registeredClasses ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return new SerializerRegistration [ 0 ] ; }
PlanetWaves/clockworkengine | private static List < Class > findClasses ( File dir , String pkgName ) throws ClassNotFoundException { List < Class > classes = new ArrayList < Class > ( ) ; if ( ! dir . exists ( ) ) { return classes ; } File [ ] files = dir . listFiles ( ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { assert ! file . getName ( ) . contains ( " . " ) ; classes . addAll ( findClasses ( file , pkgName + " . " + file . getName ( ) ) ) ; } else if ( file . getName ( ) . endsWith ( " . class " ) ) { classes . add ( Class . forName ( pkgName + ' . ' + file . getName ( ) . substring ( 0 , file . getName ( ) . length ( ) - 6 ) ) ) ; } } return classes ; }
PlanetWaves/clockworkengine | public static SerializerRegistration registerClass ( Class cls , Serializer serializer ) { SerializerRegistration existingReg = getExactSerializerRegistration ( cls ) ; short id ; if ( existingReg != null ) { id = existingReg . getId ( ) ; } else { id = nextId ( ) ; } return registerClassForId ( id , cls , serializer ) ; }
PlanetWaves/clockworkengine | public static Serializer getExactSerializer ( Class cls ) { return classRegistrations . get ( cls ) . getSerializer ( ) ; }
PlanetWaves/clockworkengine | public static Serializer getSerializer ( Class cls ) { return getSerializer ( cls , true ) ; }
PlanetWaves/clockworkengine | public static Serializer getSerializer ( Class cls , boolean failOnMiss ) { return getSerializerRegistration ( cls , failOnMiss ) . getSerializer ( ) ; }
PlanetWaves/clockworkengine | public static Collection < SerializerRegistration > getSerializerRegistrations ( ) { return registrations ; }
PlanetWaves/clockworkengine | public static SerializerRegistration getExactSerializerRegistration ( Class cls ) { return classRegistrations . get ( cls ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration getSerializerRegistration ( Class cls ) { return getSerializerRegistration ( cls , strictRegistration ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration getSerializerRegistration ( Class cls , boolean failOnMiss ) { SerializerRegistration reg = classRegistrations . get ( cls ) ; if ( reg != null ) return reg ; for ( Map . Entry < Class , SerializerRegistration > entry : classRegistrations . entrySet ( ) ) { if ( entry . getKey ( ) . isAssignableFrom ( Serializable . class ) ) continue ; if ( entry . getKey ( ) . isAssignableFrom ( cls ) ) return entry . getValue ( ) ; } if ( cls . isArray ( ) ) return registerClass ( cls , arraySerializer ) ; if ( Serializable . class . isAssignableFrom ( cls ) ) { return getExactSerializerRegistration ( java . io . Serializable . class ) ; } if ( cls . isAnnotationPresent ( Serializable . class ) ) { Serializable serializable = ( Serializable ) cls . getAnnotation ( Serializable . class ) ; short classId = serializable . id ( ) ; if ( classId != 0 ) { failOnMiss = false ; } } if ( failOnMiss ) { throw new IllegalArgumentException ( " Class ▁ has ▁ not ▁ been ▁ registered : " + cls ) ; } return registerClass ( cls , fieldSerializer ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration readClass ( ByteBuffer buffer ) { short classID = buffer . getShort ( ) ; if ( classID == - 1 ) return NULL_CLASS ; return idRegistrations . get ( classID ) ; }
PlanetWaves/clockworkengine | public static Object readClassAndObject ( ByteBuffer buffer ) throws IOException { SerializerRegistration reg = readClass ( buffer ) ; if ( reg == NULL_CLASS ) return null ; if ( reg == null ) throw new SerializerException ( " Class ▁ not ▁ found ▁ for ▁ buffer ▁ data . " ) ; return reg . getSerializer ( ) . readObject ( buffer , reg . getType ( ) ) ; }
PlanetWaves/clockworkengine | public static SerializerRegistration writeClass ( ByteBuffer buffer , Class type ) throws IOException { SerializerRegistration reg = getSerializerRegistration ( type ) ; if ( reg == null ) { throw new SerializerException ( " Class ▁ not ▁ registered : " + type ) ; } if ( log . isLoggable ( Level . FINER ) ) { log . log ( Level . FINER , " writing ▁ class : { 0 } ▁ with ▁ ID : { 1 } " , new Object [ ] { type , reg . getId ( ) } ) ; } buffer . putShort ( reg . getId ( ) ) ; return reg ; }
PlanetWaves/clockworkengine | public static void writeClassAndObject ( ByteBuffer buffer , Object object ) throws IOException { if ( object == null ) { buffer . putShort ( ( short ) - 1 ) ; return ; } SerializerRegistration reg = writeClass ( buffer , object . getClass ( ) ) ; if ( reg . getType ( ) != object . getClass ( ) ) { throw new IllegalArgumentException ( " Class ▁ has ▁ not ▁ been ▁ registered : " + object . getClass ( ) + " ▁ but ▁ resolved ▁ to ▁ generic ▁ serializer ▁ for : " + reg . getType ( ) ) ; } reg . getSerializer ( ) . writeObject ( buffer , object ) ; }
marktriggs/nyu-sakai-10.4 | private static SeqActivity buildActivityNode ( Node iNode , Node iColl ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " buildActivityNode " ) ; } SeqActivity act = new SeqActivity ( ) ; boolean error = false ; String tempVal = null ; act . setID ( ADLSeqUtilities . getAttribute ( iNode , " identifier " ) ) ; tempVal = ADLSeqUtilities . getAttribute ( iNode , " identifierref " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { act . setResourceID ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( iNode , " isvisible " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { act . setIsVisible ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " item " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ an ▁ < item > ▁ element " ) ; } SeqActivity nestedAct = ADLSeqUtilities . buildActivityNode ( curNode , iColl ) ; if ( nestedAct != null ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Adding ▁ child " ) ; } act . addChild ( nestedAct ) ; } else { error = true ; } } else if ( curNode . getLocalName ( ) . equals ( " title " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < title > ▁ element " ) ; } act . setTitle ( ADLSeqUtilities . getElementText ( curNode , null ) ) ; } else if ( curNode . getLocalName ( ) . equals ( " sequencing " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < sequencing > ▁ element " ) ; } Node seqInfo = curNode ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " IDRef " ) ; if ( tempVal != null ) { String search = " imsss : sequencing [ @ ID = ' " + tempVal + " ' ] " ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Looking ▁ for ▁ XPATH ▁ - - > ▁ " + search ) ; } Node seqGlobal = null ; XPathFactory pathFactory = XPathFactory . newInstance ( ) ; XPath path = pathFactory . newXPath ( ) ; try { seqGlobal = ( Node ) path . evaluate ( search , iColl , XPathConstants . NODE ) ; } catch ( Exception e ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ In ▁ transform " ) ; e . printStackTrace ( ) ; } } if ( seqGlobal != null ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ FOUND " ) ; } } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR : ▁ Not ▁ Found " ) ; } seqInfo = null ; error = true ; } if ( ! error ) { seqInfo = seqGlobal . cloneNode ( true ) ; NodeList seqChildren = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < seqChildren . getLength ( ) ; j ++ ) { Node curChild = seqChildren . item ( j ) ; if ( curChild . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Local ▁ definition " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ ▁ " + j ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ < " + curChild . getLocalName ( ) + " > " ) ; } try { seqInfo . appendChild ( curChild ) ; } catch ( org . w3c . dom . DOMException e ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR : ▁ " ) ; e . printStackTrace ( ) ; } error = true ; seqInfo = null ; } } } } } if ( seqInfo != null ) { error = ! ADLSeqUtilities . extractSeqInfo ( seqInfo , act ) ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Extracted ▁ Sequencing ▁ Info " ) ; } } } } } if ( act . getResourceID ( ) == null && ! act . hasChildren ( true ) ) { error = true ; } if ( error ) { act = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ error ▁ = = ▁ " + error ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " buildActivityNode " ) ; } return act ; }
marktriggs/nyu-sakai-10.4 | public static SeqActivityTree buildActivityTree ( Node iOrg , Node iColl ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " buildActivityTree " ) ; } SeqActivityTree tree = new SeqActivityTree ( ) ; SeqActivity root = ADLSeqUtilities . buildActivityNode ( iOrg , iColl ) ; if ( root != null ) { tree . setRoot ( root ) ; tree . setDepths ( ) ; tree . setTreeCount ( ) ; } else { tree = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " buildActivityTree " ) ; } return tree ; }
marktriggs/nyu-sakai-10.4 | public static void clearGlobalObjs ( String iLearnerID , String iScopeID , List < String > iObjList ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " clearGlobalObjs " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED : ▁ ADLSeqUtilities : clearGlobalObjs " ) ; }
marktriggs/nyu-sakai-10.4 | public static void createCourseStatus ( String iCourseID , String iLearnerID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " createCourseStatus " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iCourseID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iLearnerID ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : createCourseStatus " ) ; }
marktriggs/nyu-sakai-10.4 | public static void createGlobalObjs ( String iLearnerID , String iScopeID , List < String > iObjList ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " createGlobalObjs " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iScopeID ) ; } System . out . println ( " NOT ▁ IMPLEMENTED : ▁ ADLSeqUtilities : createGlobalObjs " ) ; }
marktriggs/nyu-sakai-10.4 | public static void deleteCourseStatus ( String iCourseID , String iLearnerID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " deleteCourseStatus " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : deleteCourseStatus " ) ; }
marktriggs/nyu-sakai-10.4 | public static void deleteGlobalObjs ( String iLearnerID , String iScopeID , List < String > iObjList ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " deleteGlobalObjs " ) ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : deleteGlobalObjs " ) ; }
marktriggs/nyu-sakai-10.4 | public static void dumpTOC ( List < ADLTOC > iTOC ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ dumpTOC " ) ; if ( iTOC != null ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iTOC . size ( ) ) ; ADLTOC temp = null ; for ( int i = 0 ; i < iTOC . size ( ) ; i ++ ) { temp = iTOC . get ( i ) ; temp . dumpState ( ) ; } } else { System . out . println ( " ▁ ▁ : : - - > ▁ NULL " ) ; } System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ dumpTOC " ) ; } }
marktriggs/nyu-sakai-10.4 | private static boolean extractSeqInfo ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " extractSeqInfo " ) ; } boolean ok = true ; String tempVal = null ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " controlMode " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < controlMode > ▁ element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " choice " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlModeChoice ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " choiceExit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlModeChoiceExit ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " flow " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlModeFlow ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " forwardOnly " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setControlForwardOnly ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " useCurrentAttemptObjectiveInfo " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setUseCurObjective ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " useCurrentAttemptProgressInfo " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setUseCurProgress ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " sequencingRules " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < sequencingRules > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getSequencingRules ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " limitConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < limitConditions > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " attemptLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setAttemptLimit ( Long . valueOf ( tempVal ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " attemptAbsoluteDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setAttemptAbDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " attemptExperiencedDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setAttemptExDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " activityAbsoluteDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setActivityAbDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " activityExperiencedDurationLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setActivityExDur ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " beginTimeLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setBeginTimeLimit ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " endTimeLimit " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setEndTimeLimit ( tempVal ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " auxiliaryResources " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < auxiliaryResourcees > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getAuxResources ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " rollupRules " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < rollupRules > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getRollupRules ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " objectives " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < objectives > ▁ " + " element " ) ; } ok = ADLSeqUtilities . getObjectives ( curNode , ioAct ) ; } else if ( curNode . getLocalName ( ) . equals ( " randomizationControls " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < randomizationControls > ▁ element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " randomizationTiming " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRandomTiming ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " selectCount " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSelectCount ( ( Integer . valueOf ( tempVal ) ) . intValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " reorderChildren " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setReorderChildren ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " selectionTiming " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSelectionTiming ( tempVal ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " deliveryControls " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ < deliveryControls > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " tracked " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setIsTracked ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " completionSetByContent " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSetCompletion ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " objectiveSetByContent " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSetObjective ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " constrainedChoiceConsiderations " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < constrainedChoiceConsiderations > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " preventActivation " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setPreventActivation ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " constrainChoice " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setConstrainChoice ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " rollupConsiderations " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ the ▁ " + " < rollupConsiderations > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForSatisfied " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForSatisfied ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForNotSatisfied " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForNotSatisfied ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForCompleted " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForCompleted ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " requiredForIncomplete " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setRequiredForIncomplete ( tempVal ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " measureSatisfactionIfActive " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setSatisfactionIfActive ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } } } } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + ok ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " extractSeqInfo " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static SeqConditionSet extractSeqRuleConditions ( Node iNode ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " extractSeqRuleConditions " ) ; } String tempVal = null ; SeqConditionSet condSet = new SeqConditionSet ( ) ; List < SeqCondition > conditions = new ArrayList < SeqCondition > ( ) ; tempVal = ADLSeqUtilities . getAttribute ( iNode , " conditionCombination " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { condSet . mCombination = tempVal ; } } else { condSet . mCombination = SeqConditionSet . COMBINATION_ALL ; } NodeList condInfo = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < condInfo . getLength ( ) ; i ++ ) { Node curCond = condInfo . item ( i ) ; if ( curCond . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curCond . getLocalName ( ) . equals ( " ruleCondition " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < Condition > ▁ " + " element " ) ; } SeqCondition cond = new SeqCondition ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curCond , " condition " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mCondition = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curCond , " referencedObjective " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curCond , " measureThreshold " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mThreshold = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curCond , " operator " ) ; if ( tempVal != null ) { if ( tempVal . equals ( " not " ) ) { cond . mNot = true ; } else { cond . mNot = false ; } } conditions . add ( cond ) ; } } } if ( conditions . size ( ) > 0 ) { condSet . mConditions = conditions ; } else { condSet = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " extractSeqRuleConditions " ) ; } return condSet ; }
marktriggs/nyu-sakai-10.4 | private static String getAttribute ( Node iNode , String iAttribute ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ getAttribute " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iAttribute ) ; } String value = null ; NamedNodeMap attrs = iNode . getAttributes ( ) ; if ( attrs != null ) { Node attr = attrs . getNamedItem ( iAttribute ) ; if ( attr != null ) { value = attr . getNodeValue ( ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ The ▁ attribute ▁ \" " + iAttribute + " \" ▁ does ▁ not ▁ exist . " ) ; } } } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ This ▁ node ▁ has ▁ no ▁ attributes . " ) ; } } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + value ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ - ▁ getAttribute " ) ; } return value ; }
marktriggs/nyu-sakai-10.4 | private static boolean getAuxResources ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getAuxResources " ) ; } boolean ok = true ; String tempVal = null ; List < ADLAuxiliaryResource > auxRes = new ArrayList < ADLAuxiliaryResource > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " auxiliaryResource " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < auxiliaryResource > ▁ " + " element " ) ; } ADLAuxiliaryResource res = new ADLAuxiliaryResource ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " purpose " ) ; if ( tempVal != null ) { res . mType = tempVal ; } tempVal = ADLSeqUtilities . getAttribute ( curNode , " auxiliaryResourceID " ) ; if ( tempVal != null ) { res . mResourceID = tempVal ; } auxRes . add ( res ) ; } } } ioAct . setAuxResources ( auxRes ) ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getAuxResources " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static String getElementText ( Node iNode , String iElement ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getElementText " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + iElement ) ; } StringBuilder value = new StringBuilder ( ) ; Node curNode = null ; NodeList children = null ; if ( iElement != null && iNode != null ) { children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ ▁ " + i ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ < " + curNode . getLocalName ( ) + " > " ) ; } if ( curNode . getLocalName ( ) . equals ( iElement ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ < " + iElement + " > " ) ; } break ; } } } if ( curNode != null ) { String comp = curNode . getLocalName ( ) ; if ( comp != null ) { if ( ! comp . equals ( iElement ) ) { curNode = null ; } } else { curNode = null ; } } } else { curNode = iNode ; } if ( curNode != null ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Looking ▁ at ▁ children " ) ; } children = curNode . getChildNodes ( ) ; if ( children != null ) { value = new StringBuilder ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { curNode = children . item ( i ) ; if ( ( curNode . getNodeType ( ) == Node . TEXT_NODE ) || ( curNode . getNodeType ( ) == Node . CDATA_SECTION_NODE ) ) { value . append ( curNode . getNodeValue ( ) ) ; } } } } if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + value ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getElementText " ) ; } return value . toString ( ) ; }
marktriggs/nyu-sakai-10.4 | public static String getGlobalObjMeasure ( String iObjID , String iLearnerID , String iScopeID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getGlobalObjMeasure " ) ; } String measure = null ; System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : getGlobalObjMeasure " ) ; return measure ; }
marktriggs/nyu-sakai-10.4 | public static String getGlobalObjSatisfied ( String iObjID , String iLearnerID , String iScopeID ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getGlobalObjSatisfied " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iObjID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iScopeID ) ; } String satisfiedStatus = null ; System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : getGlobalObjSatisfied " ) ; return satisfiedStatus ; }
marktriggs/nyu-sakai-10.4 | private static List < SeqObjectiveMap > getObjectiveMaps ( Node iNode ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getObjectiveMaps " ) ; } String tempVal = null ; List < SeqObjectiveMap > maps = new ArrayList < SeqObjectiveMap > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " mapInfo " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < mapInfo > ▁ " + " element " ) ; } SeqObjectiveMap map = new SeqObjectiveMap ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " targetObjectiveID " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mGlobalObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " readSatisfiedStatus " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mReadStatus = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " readNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mReadMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " writeSatisfiedStatus " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mWriteStatus = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " writeNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { map . mWriteMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } maps . add ( map ) ; } } } if ( maps . size ( ) == 0 ) { maps = null ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getObjectiveMaps " ) ; } return maps ; }
marktriggs/nyu-sakai-10.4 | private static boolean getObjectives ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getObjectives " ) ; } boolean ok = true ; String tempVal = null ; List < SeqObjective > objectives = new ArrayList < SeqObjective > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " primaryObjective " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < primaryObjective > ▁ " + " element " ) ; } SeqObjective obj = new SeqObjective ( ) ; obj . mContributesToRollup = true ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " objectiveID " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " satisfiedByMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mSatisfiedByMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = getElementText ( curNode , " minNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mMinMeasure = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } List < SeqObjectiveMap > maps = getObjectiveMaps ( curNode ) ; if ( maps != null ) { obj . mMaps = maps ; } obj . mContributesToRollup = true ; objectives . add ( obj ) ; } else if ( curNode . getLocalName ( ) . equals ( " objective " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < objective > ▁ " + " element " ) ; } SeqObjective obj = new SeqObjective ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " objectiveID " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mObjID = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " satisfiedByMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mSatisfiedByMeasure = ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ; } } tempVal = getElementText ( curNode , " minNormalizedMeasure " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { obj . mMinMeasure = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } List < SeqObjectiveMap > maps = getObjectiveMaps ( curNode ) ; if ( maps != null ) { obj . mMaps = maps ; } objectives . add ( obj ) ; } } } ioAct . setObjectives ( objectives ) ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getObjectives " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static boolean getRollupRules ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getRollupRules " ) ; } boolean ok = true ; String tempVal = null ; List < SeqRollupRule > rollupRules = new ArrayList < SeqRollupRule > ( ) ; tempVal = ADLSeqUtilities . getAttribute ( iNode , " rollupObjectiveSatisfied " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setIsObjRolledUp ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( iNode , " objectiveMeasureWeight " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setObjMeasureWeight ( ( new Double ( tempVal ) ) . doubleValue ( ) ) ; } } tempVal = ADLSeqUtilities . getAttribute ( iNode , " rollupProgressCompletion " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { ioAct . setIsProgressRolledUp ( ( Boolean . valueOf ( tempVal ) ) . booleanValue ( ) ) ; } } NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " rollupRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < rollupRule > ▁ " + " element " ) ; } SeqRollupRule rule = new SeqRollupRule ( ) ; tempVal = ADLSeqUtilities . getAttribute ( curNode , " childActivitySet " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mChildActivitySet = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " minimumCount " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mMinCount = ( Long . valueOf ( tempVal ) ) . longValue ( ) ; } } tempVal = ADLSeqUtilities . getAttribute ( curNode , " minimumPercent " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mMinPercent = ( new Double ( tempVal ) ) . doubleValue ( ) ; } } rule . mConditions = new SeqConditionSet ( true ) ; List < SeqCondition > conditions = new ArrayList < SeqCondition > ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < ruleInfo . getLength ( ) ; j ++ ) { Node curRule = ruleInfo . item ( j ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " rollupConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rollupConditions > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " conditionCombination " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mConditions . mCombination = tempVal ; } } else { rule . mConditions . mCombination = SeqConditionSet . COMBINATION_ANY ; } NodeList conds = curRule . getChildNodes ( ) ; for ( int k = 0 ; k < conds . getLength ( ) ; k ++ ) { Node con = conds . item ( k ) ; if ( con . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( con . getLocalName ( ) . equals ( " rollupCondition " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rollupCondition > ▁ " + " element " ) ; } SeqCondition cond = new SeqCondition ( ) ; tempVal = ADLSeqUtilities . getAttribute ( con , " condition " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { cond . mCondition = tempVal ; } } tempVal = ADLSeqUtilities . getAttribute ( con , " operator " ) ; if ( tempVal != null ) { if ( tempVal . equals ( " not " ) ) { cond . mNot = true ; } else { cond . mNot = false ; } } conditions . add ( cond ) ; } } } } else if ( curRule . getLocalName ( ) . equals ( " rollupAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < rollupAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . setRollupAction ( tempVal ) ; } } } } } rule . mConditions . mConditions = conditions ; rollupRules . add ( rule ) ; } } } if ( rollupRules != null ) { ISeqRollupRuleset rules = new SeqRollupRuleset ( rollupRules ) ; ioAct . setRollupRules ( rules ) ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getRollupRules " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static boolean getSequencingRules ( Node iNode , SeqActivity ioAct ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " getSequencingRules " ) ; } boolean ok = true ; String tempVal = null ; List < ISeqRule > preRules = new ArrayList < ISeqRule > ( ) ; List < ISeqRule > exitRules = new ArrayList < ISeqRule > ( ) ; List < ISeqRule > postRules = new ArrayList < ISeqRule > ( ) ; NodeList children = iNode . getChildNodes ( ) ; for ( int i = 0 ; i < children . getLength ( ) ; i ++ ) { Node curNode = children . item ( i ) ; if ( curNode . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curNode . getLocalName ( ) . equals ( " preConditionRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < preConditionRule > ▁ " + " element " ) ; } SeqRule rule = new SeqRule ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < ruleInfo . getLength ( ) ; j ++ ) { Node curRule = ruleInfo . item ( j ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " ruleConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < ruleConditions > ▁ element " ) ; } rule . mConditions = extractSeqRuleConditions ( curRule ) ; } else if ( curRule . getLocalName ( ) . equals ( " ruleAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < ruleAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { if ( ! isEmpty ( tempVal ) ) { rule . mAction = tempVal ; } } } } } if ( rule . mConditions != null && rule . mAction != null ) { preRules . add ( rule ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Invaild ▁ Pre ▁ SeqRule " ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " exitConditionRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < exitConditionRule > ▁ element " ) ; } SeqRule rule = new SeqRule ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int k = 0 ; k < ruleInfo . getLength ( ) ; k ++ ) { Node curRule = ruleInfo . item ( k ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " ruleConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < ruleConditions > ▁ element " ) ; } rule . mConditions = extractSeqRuleConditions ( curRule ) ; } else if ( curRule . getLocalName ( ) . equals ( " ruleAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < ruleAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { rule . mAction = tempVal ; } } } } if ( rule . mConditions != null && rule . mAction != null ) { exitRules . add ( rule ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Invaild ▁ Exit ▁ SeqRule " ) ; } } } else if ( curNode . getLocalName ( ) . equals ( " postConditionRule " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < postConditionRule > ▁ element " ) ; } SeqRule rule = new SeqRule ( ) ; NodeList ruleInfo = curNode . getChildNodes ( ) ; for ( int j = 0 ; j < ruleInfo . getLength ( ) ; j ++ ) { Node curRule = ruleInfo . item ( j ) ; if ( curRule . getNodeType ( ) == Node . ELEMENT_NODE ) { if ( curRule . getLocalName ( ) . equals ( " ruleConditions " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ " + " < ruleConditions > ▁ element " ) ; } rule . mConditions = extractSeqRuleConditions ( curRule ) ; } else if ( curRule . getLocalName ( ) . equals ( " ruleAction " ) ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Found ▁ a ▁ < ruleAction > ▁ " + " element " ) ; } tempVal = ADLSeqUtilities . getAttribute ( curRule , " action " ) ; if ( tempVal != null ) { rule . mAction = tempVal ; } } } } if ( rule . mConditions != null && rule . mAction != null ) { postRules . add ( rule ) ; } else { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ ERROR ▁ : ▁ Invaild ▁ Post ▁ SeqRule " ) ; } } } } } if ( preRules . size ( ) > 0 ) { ISeqRuleset rules = new SeqRuleset ( preRules ) ; ioAct . setPreSeqRules ( rules ) ; } if ( exitRules . size ( ) > 0 ) { ISeqRuleset rules = new SeqRuleset ( exitRules ) ; ioAct . setExitSeqRules ( rules ) ; } if ( postRules . size ( ) > 0 ) { ISeqRuleset rules = new SeqRuleset ( postRules ) ; ioAct . setPostSeqRules ( rules ) ; } if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getSequencingRules " ) ; } return ok ; }
marktriggs/nyu-sakai-10.4 | private static boolean isEmpty ( String iValue ) { return ( StringUtils . isBlank ( iValue ) ) ; }
marktriggs/nyu-sakai-10.4 | public static boolean setCourseStatus ( String iCourseID , String iLearnerID , String iSatisfied , String iMeasure , String iCompleted ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " setCourseStatus " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iCourseID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iSatisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iMeasure ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iCompleted ) ; } boolean success = true ; if ( ! ( iSatisfied . equals ( " unknown " ) || iSatisfied . equals ( " satisfied " ) || iSatisfied . equals ( " notSatisfied " ) ) ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iSatisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setCourseStatus " ) ; } return success ; } if ( ! ( iCompleted . equals ( " unknown " ) || iCompleted . equals ( " completed " ) || iCompleted . equals ( " incomplete " ) ) ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iCompleted ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setCourseStatus " ) ; } return success ; } try { double measure = Double . parseDouble ( iMeasure ) ; if ( measure < - 1.0 || measure > 1.0 ) { success = false ; } } catch ( Exception e ) { success = false ; } if ( ! success ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iMeasure ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setCourseStatus " ) ; } return success ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : setCourseStatus " ) ; return success ; }
marktriggs/nyu-sakai-10.4 | public static boolean setGlobalObjMeasure ( String iObjID , String iLearnerID , String iScopeID , String iMeasure ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " setGlobalObjMeasure " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iObjID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iScopeID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iMeasure ) ; } boolean goodMeasure = true ; boolean success = true ; if ( ! iMeasure . equals ( " unknown " ) ) { try { Double tempMeasure = new Double ( iMeasure ) ; double range = tempMeasure . doubleValue ( ) ; if ( range < - 1.0 || range > 1.0 ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ range : ▁ ▁ " + iMeasure ) ; } goodMeasure = false ; } } catch ( NumberFormatException e ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ ▁ " + iMeasure ) ; } goodMeasure = false ; } if ( ! goodMeasure ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " getGlobalObjMeasure " ) ; } return success ; } } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : setGlobalObjMeasure " ) ; return success ; }
marktriggs/nyu-sakai-10.4 | public static boolean setGlobalObjSatisfied ( String iObjID , String iLearnerID , String iScopeID , String iSatisfied ) { if ( _Debug ) { System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ BEGIN ▁ - ▁ " + " setGlobalObjSatisfied " ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iObjID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iLearnerID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iScopeID ) ; System . out . println ( " ▁ ▁ : : - - > ▁ " + iSatisfied ) ; } boolean success = true ; if ( ! ( iSatisfied . equals ( " unknown " ) || iSatisfied . equals ( " satisfied " ) || iSatisfied . equals ( " notSatisfied " ) ) ) { success = false ; if ( _Debug ) { System . out . println ( " ▁ ▁ : : - - > ▁ Invalid ▁ value : ▁ " + iSatisfied ) ; System . out . println ( " ▁ ▁ : : - - > ▁ ▁ " + success ) ; System . out . println ( " ▁ ▁ : : ▁ ADLSeqUtilities ▁ ▁ - - > ▁ END ▁ ▁ ▁ - ▁ " + " setSharedCompMastery " ) ; } return success ; } System . out . println ( " NOT ▁ IMPLEMENTED ▁ - ▁ ADLSeqUtilies : setGlobalObjSatisfied " ) ; return success ; }
shs96c/buck | public static Builder builder ( BuildTarget buildTarget , ProjectFilesystem projectFilesystem , ToolchainProvider toolchainProvider , BuildRuleParams params , ActionGraphBuilder graphBuilder , CellPathResolver cellPathResolver , JavaBuckConfig javaBuckConfig , JavacFactory javacFactory , JavacOptions javacOptions , CoreArg args , ConfiguredCompilerFactory compilerFactory ) { return new Builder ( buildTarget , projectFilesystem , toolchainProvider , params , graphBuilder , cellPathResolver , javaBuckConfig , javacFactory , javacOptions , args , compilerFactory ) ; }
MiracleWong/ThinkInJava | public static void main ( String [ ] args ) { ArrayList < Coffee > coffees = new ArrayList < Coffee > ( ) ; for ( Coffee c : new CoffeeGenerator ( 10 ) ) coffees . add ( c ) ; System . out . println ( coffees ) ; }
elect86/NvGlSamples | public static NvGLSLProgram createFromFiles ( GL4 gl4 , String root , String shaderName ) { return createFromFiles ( gl4 , root , shaderName , false ) ; }
elect86/NvGlSamples | public static NvGLSLProgram createFromFiles ( GL4 gl4 , String root , String shaderName , boolean strict ) { ShaderProgram shaderProgram = new ShaderProgram ( ) ; ShaderCode vertShaderCode = ShaderCode . create ( gl4 , GL_VERTEX_SHADER , NvGLSLProgram . class , root , null , shaderName , " vert " , null , true ) ; ShaderCode fragShaderCode = ShaderCode . create ( gl4 , GL_FRAGMENT_SHADER , NvGLSLProgram . class , root , null , shaderName , " frag " , null , true ) ; shaderProgram . add ( vertShaderCode ) ; shaderProgram . add ( fragShaderCode ) ; shaderProgram . init ( gl4 ) ; shaderProgram . link ( gl4 , System . out ) ; return new NvGLSLProgram ( shaderProgram . program ( ) , strict ) ; }
cybera/OpenConext-dashboard | public static PolicyBuilder of ( Policy policy ) { return new PolicyBuilder ( policy ) ; }
joewalnes/idea-community | @ Nullable public static SourcePosition getSourcePosition ( final StackFrameContext context ) { if ( context == null ) { return null ; } DebugProcessImpl debugProcess = ( DebugProcessImpl ) context . getDebugProcess ( ) ; if ( debugProcess == null ) { return null ; } final StackFrameProxy frameProxy = context . getFrameProxy ( ) ; if ( frameProxy == null ) { return null ; } Location location = null ; try { location = frameProxy . location ( ) ; } catch ( Throwable th ) { LOG . debug ( th ) ; } final CompoundPositionManager positionManager = debugProcess . getPositionManager ( ) ; if ( positionManager == null ) { return null ; } try { return positionManager . getSourcePosition ( location ) ; } catch ( IndexNotReadyException e ) { return null ; } }
joewalnes/idea-community | @ Nullable public static PsiElement getContextElement ( final StackFrameContext context ) { return getContextElement ( context , getSourcePosition ( context ) ) ; }
joewalnes/idea-community | @ Nullable protected static PsiElement getContextElement ( final StackFrameContext context , final SourcePosition position ) { if ( LOG . isDebugEnabled ( ) ) { final SourcePosition sourcePosition = getSourcePosition ( context ) ; LOG . assertTrue ( Comparing . equal ( sourcePosition , position ) ) ; } final PsiElement element = getContextElement ( position ) ; if ( element == null ) { return null ; } final StackFrameProxyImpl frameProxy = ( StackFrameProxyImpl ) context . getFrameProxy ( ) ; if ( frameProxy == null ) { return element ; } final StringBuilder buf = StringBuilderSpinAllocator . alloc ( ) ; try { List < LocalVariableProxyImpl > list = frameProxy . visibleVariables ( ) ; PsiResolveHelper resolveHelper = JavaPsiFacade . getInstance ( element . getProject ( ) ) . getResolveHelper ( ) ; buf . append ( ' { ' ) ; for ( LocalVariableProxyImpl localVariable : list ) { final String varName = localVariable . name ( ) ; if ( resolveHelper . resolveReferencedVariable ( varName , element ) == null ) { buf . append ( localVariable . getVariable ( ) . typeName ( ) ) . append ( " ▁ " ) . append ( varName ) . append ( " ; " ) ; } } buf . append ( ' } ' ) ; if ( buf . length ( ) <= 2 ) { return element ; } final PsiElementFactory elementFactory = JavaPsiFacade . getInstance ( element . getProject ( ) ) . getElementFactory ( ) ; final PsiCodeBlock codeBlockFromText = elementFactory . createCodeBlockFromText ( buf . toString ( ) , element ) ; final PsiStatement [ ] statements = codeBlockFromText . getStatements ( ) ; for ( PsiStatement statement : statements ) { if ( statement instanceof PsiDeclarationStatement ) { PsiDeclarationStatement declStatement = ( PsiDeclarationStatement ) statement ; PsiElement [ ] declaredElements = declStatement . getDeclaredElements ( ) ; for ( PsiElement declaredElement : declaredElements ) { declaredElement . putUserData ( IS_JSP_IMPLICIT , Boolean . TRUE ) ; } } } return codeBlockFromText ; } catch ( IncorrectOperationException e ) { return element ; } catch ( EvaluateException e ) { return element ; } finally { StringBuilderSpinAllocator . dispose ( buf ) ; } }
joewalnes/idea-community | @ Nullable public static PsiElement getContextElement ( final SourcePosition position ) { if ( position == null ) { return null ; } return getContextElementInText ( position . getFile ( ) , position . getLine ( ) ) ; }
joewalnes/idea-community | @ Nullable private static PsiElement getContextElementInText ( PsiFile psiFile , int lineNumber ) { if ( lineNumber < 0 ) { return psiFile ; } final Document document = PsiDocumentManager . getInstance ( psiFile . getProject ( ) ) . getDocument ( psiFile ) ; if ( document == null ) { return null ; } if ( lineNumber >= document . getLineCount ( ) ) { return psiFile ; } int startOffset = document . getLineStartOffset ( lineNumber ) ; if ( startOffset == - 1 ) { return null ; } PsiElement element ; PsiElement rootElement = psiFile ; List < PsiFile > allFiles = psiFile . getViewProvider ( ) . getAllFiles ( ) ; if ( allFiles . size ( ) > 1 ) { PsiClassOwner owner = ContainerUtil . findInstance ( allFiles , PsiClassOwner . class ) ; if ( owner != null ) { PsiClass [ ] classes = owner . getClasses ( ) ; if ( classes . length == 1 && classes [ 0 ] instanceof SyntheticElement ) { rootElement = classes [ 0 ] ; } } } while ( true ) { final CharSequence charsSequence = document . getCharsSequence ( ) ; for ( ; startOffset < charsSequence . length ( ) ; startOffset ++ ) { char c = charsSequence . charAt ( startOffset ) ; if ( c != ' ▁ ' && c != ' \t ' ) { break ; } } element = rootElement . findElementAt ( startOffset ) ; if ( element instanceof PsiComment ) { startOffset = element . getTextRange ( ) . getEndOffset ( ) + 1 ; } else { break ; } } if ( element != null && element . getParent ( ) instanceof PsiForStatement ) { return ( ( PsiForStatement ) element . getParent ( ) ) . getInitialization ( ) ; } else { return element ; } }
joewalnes/idea-community | public static boolean isJspImplicit ( PsiElement element ) { return Boolean . TRUE . equals ( element . getUserData ( IS_JSP_IMPLICIT ) ) ; }
RotaruDan/OpenLRS | public static Map < String , String > decodeAuthorization ( String authorization ) { Map < String , String > oauthParameters = new HashMap < String , String > ( ) ; if ( authorization != null ) { Matcher m = AUTHORIZATION_PATTERN . matcher ( authorization ) ; if ( m . matches ( ) ) { if ( " oauth " . equalsIgnoreCase ( m . group ( 1 ) ) ) { for ( String keyValuePair : m . group ( 2 ) . split ( " \\ s * , \\ s * " ) ) { m = KEYVALUEPAIR_PATTERN . matcher ( keyValuePair ) ; if ( m . matches ( ) ) { String key = OAuthUtils . decodePercent ( m . group ( 1 ) ) ; String value = OAuthUtils . decodePercent ( m . group ( 2 ) ) ; oauthParameters . put ( key , value ) ; } } } } } return oauthParameters ; }
RotaruDan/OpenLRS | public static String sign ( String secret , Map < String , String > oauthParameters , String algorithm , String method , String url ) { StringBuilder signatureBase = new StringBuilder ( OAuthUtils . percentEncode ( method ) ) ; signatureBase . append ( " & " ) ; signatureBase . append ( OAuthUtils . percentEncode ( url ) ) ; signatureBase . append ( " & " ) ; Map < String , String > treeMap = new TreeMap < String , String > ( oauthParameters ) ; treeMap . remove ( " oauth _ signature " ) ; treeMap . remove ( " realm " ) ; boolean first = true ; for ( Map . Entry < String , String > entry : treeMap . entrySet ( ) ) { if ( ! first ) signatureBase . append ( OAuthUtils . percentEncode ( " & " ) ) ; else first = false ; signatureBase . append ( OAuthUtils . percentEncode ( entry . getKey ( ) + " = " + entry . getValue ( ) ) ) ; } Mac mac = null ; try { SecretKeySpec secretKeySpec = new SecretKeySpec ( ( OAuthUtils . percentEncode ( secret ) + " & " ) . getBytes ( ) , algorithm ) ; mac = Mac . getInstance ( secretKeySpec . getAlgorithm ( ) ) ; mac . init ( secretKeySpec ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( " signatureBaseString : ▁ " + signatureBase . toString ( ) ) ; } byte [ ] bytes = mac . doFinal ( signatureBase . toString ( ) . getBytes ( ) ) ; byte [ ] encodedMacBytes = Base64 . encodeBase64 ( bytes ) ; return new String ( encodedMacBytes ) ; }
RotaruDan/OpenLRS | public static final String mapToJava ( String name ) { String algorithm = algorithms . get ( name ) ; if ( algorithm == null ) { throw new UnsupportedOperationException ( " Signature ▁ algorithm ▁ of ▁ " + name + " ▁ is ▁ unsupported . " ) ; } return algorithm ; }
RotaruDan/OpenLRS | private static String percentEncode ( String s ) { if ( s == null ) { return " " ; } try { return URLEncoder . encode ( s , " UTF - 8" ) . replace ( " + " , " % 20" ) . replace ( " * " , " % 2A " ) . replace ( " % 7E " , " ~ " ) ; } catch ( UnsupportedEncodingException uee ) { throw new RuntimeException ( uee . getMessage ( ) , uee ) ; } }
RotaruDan/OpenLRS | private static String decodePercent ( String s ) { try { return URLDecoder . decode ( s , " UTF - 8" ) ; } catch ( java . io . UnsupportedEncodingException e ) { throw new RuntimeException ( e . getMessage ( ) , e ) ; } }
google/differential-privacy | private static BoundedSumSummary getSummary ( BoundedSum sum ) { byte [ ] nonParsedSummary = sum . getSerializableSummary ( ) ; try { return BoundedSumSummary . parseFrom ( nonParsedSummary ) ; } catch ( InvalidProtocolBufferException pbe ) { throw new IllegalArgumentException ( pbe ) ; } }
prabodhprakash/problemsolving | public static void main ( String [ ] args ) { Solution solution = new Solution ( ) ; solution . readInput ( ) ; solution . calculateLCS ( 0 , 0 ) ; solution . printLCS ( ) ; }
aws/aws-sdk-java | public static ListTagsForResourceResultJsonUnmarshaller getInstance ( ) { if ( instance == null ) instance = new ListTagsForResourceResultJsonUnmarshaller ( ) ; return instance ; }
donovanmuller/spring-cloud-dataflow | public static String getTaskPrefix ( String taskName ) { return taskName + " - " ; }
llenterak/eulers | private static int [ ] genDigitFactorials ( ) { int [ ] res = new int [ 10 ] ; res [ 0 ] = 1 ; int f = 1 ; for ( int i = 1 ; i < 10 ; i ++ ) { f *= i ; res [ i ] = f ; } return res ; }
FHannes/intellij-community | @ Nullable private static PsiElement getPsiElement ( InspectionResultsView view ) { final RefEntity [ ] selectedElements = view . getTree ( ) . getSelectedElements ( ) ; final PsiElement psiElement ; if ( selectedElements . length > 0 && selectedElements [ 0 ] instanceof RefElement ) { psiElement = ( ( RefElement ) selectedElements [ 0 ] ) . getElement ( ) ; } else { psiElement = null ; } return psiElement ; }
0359xiaodong/blink | public static Group newInstance ( ) { Group group = new Group ( ) ; group . setAttributableType ( ATTRIBUTABLE_TYPE ) ; return group ; }
0359xiaodong/blink | public static void addNewGroup ( String name , final long [ ] ids ) { final Group group = Group . newInstance ( ) ; group . setName ( name ) ; group . setState ( BlinkApp . STATE_ADDED ) ; BlinkApp . getDaoSession ( ) . getGroupDao ( ) . insert ( group ) ; Event . broadcast ( Group . KEY ) ; Event . observe ( Group . KEY , new Observer ( ) { @ Override public void update ( Observable observable , Object data ) { Event . ignore ( Group . KEY , this ) ; for ( long id : ids ) { group . addDevice ( id ) ; } } } ) ; Syncro . getInstance ( ) . syncDevices ( ) ; }
bunjlabs/jed2d | public static Vector4b create ( ) { return new Vector4b ( ) ; }
bunjlabs/jed2d | public static Vector4b create ( boolean v ) { return new Vector4b ( v ) ; }
bunjlabs/jed2d | public static Vector4b create ( boolean x1 , boolean x2 , boolean x3 , boolean x4 ) { return new Vector4b ( x1 , x2 , x3 , x4 ) ; }
bunjlabs/jed2d | public static Vector4b create ( Vector4b v ) { return new Vector4b ( v ) ; }
GunoH/intellij-community | @ NotNull protected static Promise < String > getTextToEvaluate ( DataContext dataContext , XDebugSession session ) { final Editor editor = CommonDataKeys . EDITOR . getData ( dataContext ) ; if ( editor == null ) { return Promises . resolvedPromise ( null ) ; } String text = editor . getSelectionModel ( ) . getSelectedText ( ) ; if ( text != null ) { return Promises . resolvedPromise ( StringUtil . nullize ( text , true ) ) ; } XDebuggerEvaluator evaluator = session . getDebugProcess ( ) . getEvaluator ( ) ; if ( evaluator != null ) { return XDebuggerEvaluateActionHandler . getExpressionText ( evaluator , editor . getProject ( ) , editor ) . then ( s -> StringUtil . nullize ( s , true ) ) ; } return Promises . resolvedPromise ( null ) ; }
numixproject/com.numix.calculator | public static boolean isExternalStorageWritable ( ) { return Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) ; }
numixproject/com.numix.calculator | public static boolean isExternalStorageReadable ( ) { String state = Environment . getExternalStorageState ( ) ; return Environment . MEDIA_MOUNTED . equals ( state ) || Environment . MEDIA_MOUNTED_READ_ONLY . equals ( state ) ; }
nkolban/jpigpio | public static void main ( String args [ ] ) { System . out . println ( " Test _ SocketListen " ) ; Test_SocketListen app = new Test_SocketListen ( ) ; app . run ( ) ; }
goodwinnk/intellij-community | public static boolean isEndVariable ( @ NotNull String name ) { return name . startsWith ( END_PREFIX ) ; }
dubuyuye/tetris | public static void draw_String_Value ( int rowY , Image img , int x_img , int num , int x_num , int maxNumLength , Graphics g ) { g . drawImage ( img , x_img , rowY , null ) ; NumberRenderer . drawNumber ( num , x_num , rowY , maxNumLength , g ) ; }
jexp/idea2 | public static boolean isEDT ( String name ) { return name . startsWith ( " AWT - EventQueue " ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( SIGMA sigma , float mu , int nPoints ) { float s = SIGMA . getValue ( sigma ) ; return getKernel ( s , mu , nPoints ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( float sigma , float mu , int nPoints ) { float normalization = ( float ) ( Math . pow ( sigma , 5 ) * Math . sqrt ( 2.f * Math . PI ) ) ; if ( sigma < 1 ) { int power = MiscMath . findPowerOf10 ( sigma * sigma ) ; normalization *= ( 1. / ( sigma * sigma ) ) * Math . pow ( 10 , - 1 * power ) ; } int halfWidthInPixels = nPoints >> 1 ; int start = ( int ) ( mu - halfWidthInPixels ) ; int stopExcl = ( int ) mu + halfWidthInPixels + 1 ; float d , dsq ; int count = 0 ; float [ ] yPoints = new float [ nPoints ] ; for ( int i = start ; i < stopExcl ; i ++ ) { if ( count >= nPoints ) { break ; } float x = i ; d = ( x - mu ) ; dsq = d * d ; float y = ( dsq - sigma * sigma ) * ( float ) ( Math . exp ( - 1.f * dsq / ( 2.f * sigma * sigma ) ) ) ; yPoints [ count ] = y / normalization ; count ++ ; } return yPoints ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( SIGMA sigma , float mu ) { return getKernel ( SIGMA . getValue ( sigma ) , mu ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( float sigma , float mu ) { float hwi = estimateHWZI ( sigma , 0.001f ) ; if ( hwi < 0 ) { hwi *= - 1.f ; } int halfWidthInPixels = ( int ) Math . ceil ( hwi ) ; int nPoints = 2 * halfWidthInPixels + 1 ; return getKernel ( sigma , mu , nPoints ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( float sigma ) { return getKernel ( sigma , 0 ) ; }
dukson/curvature-scale-space-corners-and-transformations | public static float [ ] getKernel ( SIGMA sigma ) { if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTSEVENONE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointSevenOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONE . ordinal ( ) ) { return getBinomialKernelSigmaOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOneSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWO . ordinal ( ) ) { return getBinomialKernelSigmaTwo ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFiveSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOSQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaTwoSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . THREE . ordinal ( ) ) { return getBinomialKernelSigmaThree ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . FOUR . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . FOURSQRT2 . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . EIGHT . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . EIGHT . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } else if ( sigma . ordinal ( ) == SIGMA . EIGHTSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 87 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTEEN . ordinal ( ) ) { return getKernel ( sigma , 0 , 121 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTEENSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 171 ) ; } else if ( sigma . ordinal ( ) == SIGMA . THIRTYTWO . ordinal ( ) ) { return getKernel ( sigma , 0 , 239 ) ; } else if ( sigma . ordinal ( ) == SIGMA . THIRTYTWOSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 339 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTYFOUR . ordinal ( ) ) { return getKernel ( sigma , 0 , 477 ) ; } else if ( sigma . ordinal ( ) == SIGMA . SIXTYFOURSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 675 ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEHUNDREDANDTWENTYEIGHT . ordinal ( ) ) { return getKernel ( sigma , 0 , 953 ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEHUNDREDANDTWENTYEIGHTSQRT2 . ordinal ( ) ) { return getKernel ( sigma , 0 , 1347 ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOHUNDREDANDFIFTYSIX . ordinal ( ) ) { return getKernel ( sigma , 0 , 1905 ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOHUNDREDANDFIFTYSIX . ordinal ( ) ) { return getKernel ( SIGMA . getValue ( sigma ) ) ; } throw new IllegalArgumentException ( " haven ' t ▁ implemented ▁ a ▁ method ▁ for ▁ " + " ▁ sigma = " + sigma ) ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernel ( SIGMA sigma ) { if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ZEROPOINTSEVENONE . ordinal ( ) ) { return getBinomialKernelSigmaZeroPointSevenOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONE . ordinal ( ) ) { return getBinomialKernelSigmaOne ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOneSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVE . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFive ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWO . ordinal ( ) ) { return getBinomialKernelSigmaTwo ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . ONEPOINTFIVESQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaOnePointFiveSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . TWOSQRT2 . ordinal ( ) ) { return getBinomialKernelSigmaTwoSQRT2 ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . THREE . ordinal ( ) ) { return getBinomialKernelSigmaThree ( ) ; } else if ( sigma . ordinal ( ) == SIGMA . FOUR . ordinal ( ) ) { return getBinomialKernelSigmaFour ( ) ; } else { return null ; } }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaZeroPointFive ( ) { return new float [ ] { 0.037f , - 0.074f , 0.037f } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getKernelSigmaZeroPointSevenOne ( ) { return new float [ ] { 0 , 0.0072334423f , 0.020755375f , - 0.05641896f , 0.020755375f , 0.0072334423f , 0 } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaZeroPointSevenOne ( ) { float a = 1.f / 141.8f ; return new float [ ] { a , 3 * a , - 8 * a , 3 * a , a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getKernelSigmaOne ( ) { return new float [ ] { 0.0020074535f , 0.035454787f , 0.16197291f , - 0.0f , - 0.3989423f , 0.0f , 0.16197291f , 0.035454787f , 0.0020074535f } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOne ( ) { float a = 1.f / 30.f ; return new float [ ] { a , 5 * a , 0 , - 12 * a , 0 , 5 * a , a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOneSQRT2 ( ) { float a = 1.f / 256.f ; return new float [ ] { 1 * a , 5 * a , 13 * a , 13 * a , - 14 * a , - 36 * a , - 14 * a , 13 * a , 13 * a , 5 * a , 1 * a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOnePointFive ( ) { float a = 1.f / 256.f ; return new float [ ] { 1 * a , 5 * a , 12 * a , 10 * a , - 13 * a , - 30 * a , - 13 * a , 10 * a , 12 * a , 5 * a , 1 * a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaTwo ( ) { float a = 1.f / 64000.f ; return new float [ ] { 1 * a , 14 * a , 89 * a , 336 * a , 820 * a , 1288 * a , 1092 * a , - 208 * a , - 2002 * a , - 2860 * a , - 2002 * a , - 208 * a , 1092 * a , a * 1288 , a * 820 , a * 336 , a * 89 , a * 14 , a } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaOnePointFiveSQRT2 ( ) { double a = 1. / 245000l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 16l * a ) , ( float ) ( 118l * a ) , ( float ) ( 528l * a ) , ( float ) ( 1581l * a ) , ( float ) ( 3264l * a ) , ( float ) ( 4488l * a ) , ( float ) ( 3264l * a ) , ( float ) ( - 1326l * a ) , ( float ) ( - 7072l * a ) , ( float ) ( - 9724l * a ) , ( float ) ( - 7072l * a ) , ( float ) ( - 1326l * a ) , ( float ) ( 3264l * a ) , ( float ) ( 4488l * a ) , ( float ) ( 3264l * a ) , ( float ) ( 1581l * a ) , ( float ) ( 528l * a ) , ( float ) ( 118l * a ) , ( float ) ( 16l * a ) , ( float ) ( 1l * a ) } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaTwoSQRT2 ( ) { double a = 1. / 4100000000l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 30l * a ) , ( float ) ( 433l * a ) , ( float ) ( 4000l * a ) , ( float ) ( 26536l * a ) , ( float ) ( 134416l * a ) , ( float ) ( 539400l * a ) , ( float ) ( 1754848l * a ) , ( float ) ( 4692780l * a ) , ( float ) ( 10378056l * a ) , ( float ) ( 18932940l * a ) , ( float ) ( 28048800l * a ) , ( float ) ( 32256120l * a ) , ( float ) ( 24812400l * a ) , ( float ) ( 2481240l * a ) , ( float ) ( - 29774880l * a ) , ( float ) ( - 58929450l * a ) , ( float ) ( - 70715340l * a ) , ( float ) ( - 58929450l * a ) , ( float ) ( - 29774880l * a ) , ( float ) ( 2481240l * a ) , ( float ) ( 24812400l * a ) , ( float ) ( 32256120l * a ) , ( float ) ( 28048800l * a ) , ( float ) ( 18932940l * a ) , ( float ) ( 10378056l * a ) , ( float ) ( 4692780l * a ) , ( float ) ( 1754848l * a ) , ( float ) ( 539400l * a ) , ( float ) ( 134416l * a ) , ( float ) ( 26536l * a ) , ( float ) ( 4000l * a ) , ( float ) ( 433l * a ) , ( float ) ( 30l * a ) , ( float ) ( 1l * a ) } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaThree ( ) { double a = 1. / 65000000000l ; return new float [ ] { ( float ) ( 1l * a ) , ( float ) ( 34l * a ) , ( float ) ( 559l * a ) , ( float ) ( 5916l * a ) , ( float ) ( 45255l * a ) , ( float ) ( 266322l * a ) , ( float ) ( 1252713l * a ) , ( float ) ( 4829088l * a ) , ( float ) ( 15512772l * a ) , ( float ) ( 41970280l * a ) , ( float ) ( 96160636l * a ) , ( float ) ( 186574864l * a ) , ( float ) ( 304253964l * a ) , ( float ) ( 408239496l * a ) , ( float ) ( 426395700l * a ) , ( float ) ( 286097760l * a ) , ( float ) ( - 31635810l * a ) , ( float ) ( - 450345060l * a ) , ( float ) ( - 811985790l * a ) , ( float ) ( - 955277400l * a ) , ( float ) ( - 811985790l * a ) , ( float ) ( - 450345060l * a ) , ( float ) ( - 31635810l * a ) , ( float ) ( 286097760l * a ) , ( float ) ( 426395700l * a ) , ( float ) ( 408239496l * a ) , ( float ) ( 304253964l * a ) , ( float ) ( 186574864l * a ) , ( float ) ( 96160636l * a ) , ( float ) ( 41970280l * a ) , ( float ) ( 15512772l * a ) , ( float ) ( 4829088l * a ) , ( float ) ( 1252713l * a ) , ( float ) ( 266322l * a ) , ( float ) ( 45255l * a ) , ( float ) ( 5916l * a ) , ( float ) ( 559l * a ) , ( float ) ( 34l * a ) , ( float ) ( 1l * a ) } ; }
dukson/curvature-scale-space-corners-and-transformations | protected static float [ ] getBinomialKernelSigmaFour ( ) { float a = 1.f / 315.f ; return new float [ ] { ( float ) ( 0.0013496157933984045 ) * a , ( float ) ( 0.003812253148120798 ) * a , ( float ) ( 0.00985466410118652 ) * a , ( float ) ( 0.023354250937084688 ) * a , ( float ) ( 0.050793931240985246 ) * a , ( float ) ( 0.10141062660346886 ) * a , ( float ) ( 0.18571762697885447 ) * a , ( float ) ( 0.31132423871622195 ) * a , ( float ) ( 0.4757716476259789 ) * a , ( float ) ( 0.6580431670807847 ) * a , ( float ) ( 0.8130047466820091 ) * a , ( float ) ( 0.8746801742701372 ) * a , ( float ) ( 0.7727267283900054 ) * a , ( float ) ( 0.4606218146694771 ) * a , ( float ) ( 0.05400657042753325 ) * a , ( float ) ( - 0.6908945681321693 ) * a , ( float ) ( - 1.2995036536356718 ) * a , ( float ) ( - 1.682898921828288 ) * a , ( float ) ( - 1.9582123932012366 ) * a , ( float ) ( - 1.682898921828288 ) * a , ( float ) ( - 1.2995036536356718 ) * a , ( float ) ( - 0.6908945681321693 ) * a , ( float ) ( 0.05400657042753325 ) * a , ( float ) ( 0.4606218146694771 ) * a , ( float ) ( 0.7727267283900054 ) * a , ( float ) ( 0.8746801742701372 ) * a , ( float ) ( 0.8130047466820091 ) * a , ( float ) ( 0.6580431670807847 ) * a , ( float ) ( 0.4757716476259789 ) * a , ( float ) ( 0.31132423871622195 ) * a , ( float ) ( 0.18577391691321074 ) * a , ( float ) ( 0.10141612056970953 ) * a , ( float ) ( 0.050794238557124116 ) * a , ( float ) ( 0.023354255369729467 ) * a , ( float ) ( 0.00985466410118652 ) * a , ( float ) ( 0.003812253148120798 ) * a , ( float ) ( 0.0013496157933984045 ) * a } ; }
MattSi/Game2048 | public static double log2 ( int x ) { return ( Math . log ( x ) / Math . log ( 2 ) ) ; }
google/or-tools | public static void main ( String [ ] args ) throws Exception { Loader . loadNativeLibraries ( ) ; CpModel model = new CpModel ( ) ; int numVals = 3 ; IntVar x = model . newIntVar ( 0 , numVals - 1 , " x " ) ; IntVar y = model . newIntVar ( 0 , numVals - 1 , " y " ) ; IntVar z = model . newIntVar ( 0 , numVals - 1 , " z " ) ; model . addDifferent ( x , y ) ; CpSolver solver = new CpSolver ( ) ; VarArraySolutionPrinter cb = new VarArraySolutionPrinter ( new IntVar [ ] { x , y , z } ) ; solver . getParameters ( ) . setEnumerateAllSolutions ( true ) ; solver . solve ( model , cb ) ; System . out . println ( cb . getSolutionCount ( ) + " ▁ solutions ▁ found . " ) ; }
Estructuras-ITESM/Anpharos | public static void init ( ) { PApplet . main ( " anpharos . gui . Graph . GraphParent " ) ; }
Estructuras-ITESM/Anpharos | public static void main ( String [ ] args ) { GraphParent tmp = new GraphParent ( ) ; tmp . init ( ) ; }
CYDpeter/104021003 | public static void main ( String [ ] args ) { Scanner scn = new Scanner ( System . in ) ; int sum = 0 ; for ( int i = 13 ; i <= 1399 ; i = i + 1 ) { sum = sum + i ; } System . out . print ( " Sum = " + sum ) ; }
thedevgeek/ANDROID-APPs | public static ContentValues statusToContentValues ( Status status ) { ContentValues cv = new ContentValues ( ) ; cv . put ( C_ID , status . id ) ; cv . put ( C_CREATED_AT , status . createdAt . getTime ( ) ) ; cv . put ( C_TEXT , status . text ) ; cv . put ( C_USER , status . user . screenName ) ; return cv ; }
vsddev/Player_Glow_Sponge | public static void create ( String name , String text ) throws IOException { File dir = PlayerGlow . getInstance ( ) . getConfigDir ( ) ; dir . mkdirs ( ) ; FileWriter file = new FileWriter ( new File ( dir , name ) ) ; file . write ( text ) ; file . flush ( ) ; file . close ( ) ; }
vsddev/Player_Glow_Sponge | public static void createJson ( ) { String CreateString = " { } " ; File file = new File ( PlayerGlow . getInstance ( ) . getConfigDir ( ) , " colorData . json " ) ; if ( ! file . exists ( ) ) { try { create ( " colorData . json " , CreateString ) ; } catch ( IOException e1 ) { PlayerGlow . getInstance ( ) . getLogger ( ) . error ( " [ PlayerGlow ] ▁ Error ▁ writing ▁ config ▁ file ! " ) ; } } }
vsddev/Player_Glow_Sponge | public static void readJson ( ) { JsonParser parser = new JsonParser ( ) ; try { Object obj = parser . parse ( new FileReader ( new File ( PlayerGlow . getInstance ( ) . getConfigDir ( ) , " colorData . json " ) ) ) ; ColorData = ( JsonObject ) obj ; } catch ( IOException e2 ) { PlayerGlow . getInstance ( ) . getLogger ( ) . error ( " [ PlayerGlow ] ▁ Error ▁ reading ▁ config ▁ file ! " ) ; } }
anishek/hive | public static boolean isApplicable ( ASTNode node ) { return ( node . getToken ( ) . getType ( ) == HiveParser . TOK_REPLICATION ) ; }
anishek/hive | public static String getLastReplicatedStateFromParameters ( Map < String , String > m ) { if ( ( m != null ) && ( m . containsKey ( KEY . CURR_STATE_ID . toString ( ) ) ) ) { return m . get ( KEY . CURR_STATE_ID . toString ( ) ) ; } return null ; }
anishek/hive | public static void copyLastReplId ( Map < String , String > srcParameter , Map < String , String > destParameter ) { String lastReplId = srcParameter . get ( ReplicationSpec . KEY . CURR_STATE_ID . toString ( ) ) ; if ( lastReplId != null ) { destParameter . put ( ReplicationSpec . KEY . CURR_STATE_ID . toString ( ) , lastReplId ) ; } }
weiwenqiang/GitHub | public static VersionedGestureDetector newInstance ( Context context , OnGestureListener listener ) { final int sdkVersion = Build . VERSION . SDK_INT ; VersionedGestureDetector detector = null ; if ( sdkVersion < Build . VERSION_CODES . ECLAIR ) { detector = new CupcakeDetector ( context ) ; } else if ( sdkVersion < Build . VERSION_CODES . FROYO ) { detector = new EclairDetector ( context ) ; } else { detector = new FroyoDetector ( context ) ; } detector . mListener = listener ; return detector ; }
bclozel/spring-boot | public static void main ( String [ ] args ) { SpringApplication . run ( TestConfiguration . class , args ) ; }
udayinfy/ECommerce-Java | public static void main ( String [ ] args ) { FulfillmentClient client = new FulfillmentClient ( ) ; client . recieveMessages ( ) ; }
ebayopensource/turmeric-runtime | private static CallTrackingLogger getLogger ( ) { return logger ; }
ebayopensource/turmeric-runtime | public static boolean isEmptyString ( String str ) { return ( str == null || str . trim ( ) . length ( ) == 0 ) ; }
ebayopensource/turmeric-runtime | public static String toQualifiedClassName ( String javaFilePath ) { String filePathNoExt = null ; if ( javaFilePath == null ) { return null ; } boolean isJavaExtensionPresent = javaFilePath . endsWith ( " . java " ) ; if ( isJavaExtensionPresent ) { filePathNoExt = javaFilePath . substring ( 0 , javaFilePath . length ( ) - 5 ) ; } boolean isClassExtensionPresent = javaFilePath . endsWith ( " . class " ) ; if ( isClassExtensionPresent ) { filePathNoExt = javaFilePath . substring ( 0 , javaFilePath . length ( ) - 6 ) ; } if ( filePathNoExt == null ) filePathNoExt = javaFilePath ; return filePathNoExt . replace ( ' \ \' , ' . ' ) . replace ( ' / ' , ' . ' ) ; }
ebayopensource/turmeric-runtime | public static String getQualifiedClassName ( String javaFilePath , String srcLocation ) { int pkgStartPos = javaFilePath . indexOf ( srcLocation ) ; String qualifiedJavaFile = null ; if ( pkgStartPos > - 1 ) { String normalizedSrcLoc = CodeGenUtil . normalizePath ( srcLocation ) ; int startPos = pkgStartPos + normalizedSrcLoc . length ( ) ; qualifiedJavaFile = javaFilePath . substring ( startPos ) ; } else { qualifiedJavaFile = javaFilePath ; } return toQualifiedClassName ( qualifiedJavaFile ) ; }
ebayopensource/turmeric-runtime | public static String getPackageName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( 0 , idx ) ; }
ebayopensource/turmeric-runtime | private static String normalizePath ( String path ) { if ( path == null ) { return null ; } if ( path . endsWith ( " \ \" ) || path . endsWith ( " / " ) ) { return path ; } else { return path + File . separatorChar ; } }
ebayopensource/turmeric-runtime | public static String toOSFilePath ( String path ) { if ( path == null ) { return null ; } String normaliedOSPath = path . replace ( ' \ \' , File . separatorChar ) . replace ( ' / ' , File . separatorChar ) ; return normalizePath ( normaliedOSPath ) ; }
ebayopensource/turmeric-runtime | public static String getFilePath ( String dir , String fileName ) { if ( dir == null || fileName == null ) { return null ; } String filePath = toOSFilePath ( dir ) + fileName ; return filePath ; }
ebayopensource/turmeric-runtime | public static String toJavaSrcFilePath ( String srcDir , Class < ? > clazz ) { if ( srcDir == null || clazz == null ) { return null ; } String filePath = toJavaSrcFilePath ( srcDir , clazz . getName ( ) ) ; return filePath ; }
ebayopensource/turmeric-runtime | public static String toJavaSrcFilePath ( String srcDir , String qualifiedJavaName ) { if ( srcDir == null || qualifiedJavaName == null ) { return null ; } String filePath = toOSFilePath ( srcDir ) + convertToJavaSrcFilePath ( qualifiedJavaName ) ; return filePath ; }
ebayopensource/turmeric-runtime | private static String convertToJavaSrcFilePath ( String qualifiedJavaName ) { if ( isEmptyString ( qualifiedJavaName ) ) { return qualifiedJavaName ; } int dotJavaPos = qualifiedJavaName . lastIndexOf ( " . java " ) ; if ( dotJavaPos > - 1 ) { return convertToFilePath ( qualifiedJavaName . substring ( 0 , dotJavaPos ) , " . java " ) ; } else { return convertToFilePath ( qualifiedJavaName , " . java " ) ; } }
ebayopensource/turmeric-runtime | public static String convertToFilePath ( String qualifiedJavaName , String suffix ) { return qualifiedJavaName . replace ( ' . ' , File . separatorChar ) + suffix ; }
ebayopensource/turmeric-runtime | public static String normalizePackageName ( String packageName ) { if ( isEmptyString ( packageName ) || ! packageName . endsWith ( " . " ) ) { return packageName ; } else { return packageName . substring ( 0 , packageName . length ( ) - 1 ) ; } }
ebayopensource/turmeric-runtime | public static boolean isParameterizedType ( Type type ) { return ( type instanceof ParameterizedType ) ; }
ebayopensource/turmeric-runtime | public static boolean isWildCardType ( Type type ) { return ( type instanceof WildcardType ) ; }
ebayopensource/turmeric-runtime | public static boolean isGenericArrayType ( Type type ) { return ( type instanceof GenericArrayType ) ; }
ebayopensource/turmeric-runtime | public static String makeFirstLetterUpper ( String str ) { if ( isEmptyString ( str ) ) { return str ; } char firstChar = str . charAt ( 0 ) ; if ( Character . isLetter ( firstChar ) && Character . isLowerCase ( firstChar ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toUpperCase ( firstChar ) ; return String . valueOf ( chars ) ; } else { return str ; } }
ebayopensource/turmeric-runtime | public static String makeFirstLetterLower ( String str ) { if ( isEmptyString ( str ) ) { return str ; } char firstChar = str . charAt ( 0 ) ; if ( Character . isLetter ( firstChar ) && Character . isUpperCase ( firstChar ) ) { char [ ] chars = str . toCharArray ( ) ; chars [ 0 ] = Character . toLowerCase ( firstChar ) ; return String . valueOf ( chars ) ; } else { return str ; } }
ebayopensource/turmeric-runtime | public static File getDir ( String destDir ) throws IOException { if ( destDir == null ) { return null ; } File dir = new File ( destDir ) ; if ( ! dir . exists ( ) || ! dir . isDirectory ( ) ) { throw new IOException ( destDir + " : ▁ non - existent ▁ directory " ) ; } return dir ; }
ebayopensource/turmeric-runtime | public static String genDestFolderPath ( String destLoc , String serviceName , String suffixPath ) { StringBuilder destFolderPath = new StringBuilder ( ) ; destFolderPath . append ( toOSFilePath ( destLoc ) ) ; destFolderPath . append ( toOSFilePath ( suffixPath ) ) ; destFolderPath . append ( serviceName ) ; return destFolderPath . toString ( ) ; }
ebayopensource/turmeric-runtime | public static String genDestFolderPath ( String destLoc , String suffixLoc ) { if ( isEmptyString ( destLoc ) ) { return destLoc ; } String destPath = toOSFilePath ( destLoc ) ; if ( ! isEmptyString ( suffixLoc ) ) { destPath = destPath + toOSFilePath ( suffixLoc ) ; } return destPath ; }
ebayopensource/turmeric-runtime | public static String getNSFromPackageName ( String packageName ) { StringBuffer strBuf = new StringBuffer ( ) ; int prevIndex = packageName . length ( ) ; int currentIndex = packageName . lastIndexOf ( PACKAGE_class_DELIMITER ) ; if ( currentIndex > 0 ) { strBuf . append ( HTTP ) ; } else if ( prevIndex > 0 ) { strBuf . append ( HTTP ) ; strBuf . append ( packageName ) ; return strBuf . toString ( ) ; } else if ( currentIndex == - 1 ) { return strBuf . toString ( ) ; } while ( currentIndex != - 1 ) { strBuf . append ( packageName . substring ( currentIndex + 1 , prevIndex ) ) ; prevIndex = currentIndex ; currentIndex = packageName . lastIndexOf ( PACKAGE_class_DELIMITER , prevIndex - 1 ) ; strBuf . append ( PACKAGE_class_DELIMITER ) ; if ( currentIndex == - 1 ) { strBuf . append ( packageName . substring ( 0 , prevIndex ) ) ; } } return strBuf . toString ( ) ; }
ebayopensource/turmeric-runtime | public static File createDir ( String dirPath ) throws IOException { File dir = new File ( dirPath ) ; if ( dir . exists ( ) ) { return dir ; } if ( dir . mkdirs ( ) == false ) { throw new IOException ( " Failed ▁ to ▁ create ▁ dir ( s ) ▁ : ▁ " + dirPath ) ; } return dir ; }
ebayopensource/turmeric-runtime | public static boolean isFileExists ( String filePath ) { if ( isEmptyString ( filePath ) ) { return false ; } File file = new File ( filePath ) ; return file . exists ( ) ; }
ebayopensource/turmeric-runtime | public static boolean dirExists ( String path ) { if ( isEmptyString ( path ) ) { return false ; } File dir = new File ( path ) ; return dir . exists ( ) && dir . isDirectory ( ) ; }
ebayopensource/turmeric-runtime | public static void deleteFile ( File file ) throws IOException { if ( file == null || ! file . exists ( ) ) { return ; } if ( ! file . delete ( ) ) { throw new IOException ( " Can ' t ▁ delete ▁ file ▁ : ▁ " + file . getPath ( ) ) ; } }
ebayopensource/turmeric-runtime | public static boolean deleteDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return dir . delete ( ) ; }
ebayopensource/turmeric-runtime | public static boolean deleteContentsOfDir ( File dir ) { if ( dir . isDirectory ( ) ) { String [ ] children = dir . list ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { boolean success = deleteDir ( new File ( dir , children [ i ] ) ) ; if ( ! success ) { return false ; } } } return true ; }
ebayopensource/turmeric-runtime | public static Writer getFileWriter ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File outputFile = new File ( dir , fileName ) ; deleteFile ( outputFile ) ; Charset defaultCharset = Charset . defaultCharset ( ) ; FileOutputStream fileOutStream = new FileOutputStream ( outputFile ) ; OutputStreamWriter bw = new OutputStreamWriter ( fileOutStream , defaultCharset ) ; Writer buffWriter = new BufferedWriter ( bw ) ; return buffWriter ; }
ebayopensource/turmeric-runtime | public static BufferedReader getFileReader ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File inFile = new File ( dir , fileName ) ; Charset defaultCharset = Charset . defaultCharset ( ) ; FileInputStream fileInStream = new FileInputStream ( inFile ) ; InputStreamReader bw = new InputStreamReader ( fileInStream , defaultCharset ) ; BufferedReader buffReader = new BufferedReader ( bw ) ; return buffReader ; }
ebayopensource/turmeric-runtime | public static OutputStream getFileOutputStream ( String destDir , String fileName ) throws IOException { if ( isEmptyString ( destDir ) || isEmptyString ( fileName ) ) { return null ; } File dir = createDir ( destDir ) ; File outputFile = new File ( dir , fileName ) ; deleteFile ( outputFile ) ; FileOutputStream fileOutStream = new FileOutputStream ( outputFile ) ; return fileOutStream ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( InputSource inputSource ) { if ( inputSource == null ) { return ; } closeQuietly ( inputSource . getCharacterStream ( ) ) ; closeQuietly ( inputSource . getByteStream ( ) ) ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( WSDLLocator locator ) { if ( locator == null ) { return ; } locator . close ( ) ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( XMLStreamWriter writer ) { if ( writer == null ) { return ; } try { writer . close ( ) ; } catch ( XMLStreamException ignore ) { } }
ebayopensource/turmeric-runtime | public static void closeQuietly ( JarFile jarfile ) { if ( jarfile == null ) { return ; } try { jarfile . close ( ) ; } catch ( IOException ignore ) { } }
ebayopensource/turmeric-runtime | public static void closeQuietly ( FileHandler fileHandler ) { if ( fileHandler == null ) { return ; } fileHandler . close ( ) ; }
ebayopensource/turmeric-runtime | public static void closeQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { closeable . close ( ) ; } catch ( IOException ignore ) { } }
ebayopensource/turmeric-runtime | public static void flushAndCloseQuietly ( Closeable closeable ) { if ( closeable == null ) { return ; } try { if ( closeable instanceof Flushable ) { ( ( Flushable ) closeable ) . flush ( ) ; } } catch ( IOException e ) { } try { closeable . close ( ) ; } catch ( IOException ignore ) { } }
ebayopensource/turmeric-runtime | public static void move ( String srcFilePath , String destLoc , boolean override ) throws IOException { File srcFile = new File ( srcFilePath ) ; File destDir = createDir ( destLoc ) ; File newFile = new File ( destDir , srcFile . getName ( ) ) ; if ( newFile . exists ( ) ) { if ( override == false ) { return ; } else { deleteFile ( newFile ) ; } } boolean success = srcFile . renameTo ( newFile ) ; if ( success == false ) { throw new IOException ( " Failed ▁ to ▁ move ▁ file ▁ : ▁ " + srcFilePath + " ▁ to ▁ " + destLoc ) ; } }
ebayopensource/turmeric-runtime | public static void addAllFiles ( File dir , List < String > files ) { if ( dir . isDirectory ( ) ) { if ( ! dir . getName ( ) . equals ( " . " ) && ! dir . getName ( ) . equals ( " . . " ) ) { File [ ] children = dir . listFiles ( ) ; for ( int i = 0 ; i < children . length ; i ++ ) { if ( children [ i ] . isDirectory ( ) ) { addAllFiles ( children [ i ] , files ) ; } else { files . add ( children [ i ] . getAbsolutePath ( ) ) ; } } } } }
ebayopensource/turmeric-runtime | public static String getTemplateContent ( String templateName ) throws IOException { ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; InputStream inputStream = classLoader . getResourceAsStream ( templateName ) ; if ( inputStream == null ) { throw new IOException ( " Failed ▁ to ▁ load ▁ resource ▁ : ▁ " + templateName ) ; } String templateContent = readContent ( inputStream ) ; return templateContent ; }
ebayopensource/turmeric-runtime | private static String readContent ( InputStream input ) throws IOException { Charset defaultCharset = Charset . defaultCharset ( ) ; InputStreamReader isr = new InputStreamReader ( input , defaultCharset ) ; BufferedReader reader = new BufferedReader ( isr ) ; StringBuilder strBuff = new StringBuilder ( ) ; try { char [ ] charBuff = new char [ 512 ] ; int charsRead = - 1 ; while ( ( charsRead = reader . read ( charBuff ) ) > - 1 ) { strBuff . append ( charBuff , 0 , charsRead ) ; } } finally { reader . close ( ) ; } return strBuff . toString ( ) ; }
ebayopensource/turmeric-runtime | public static String getFileContents ( String filePath ) throws IOException { FileInputStream fileInStream = new FileInputStream ( filePath ) ; return readContent ( fileInStream ) ; }
ebayopensource/turmeric-runtime | public static void writeToFile ( String destLoc , String fileName , String contents ) throws IOException { Writer fileWriter = null ; try { fileWriter = getFileWriter ( destLoc , fileName ) ; fileWriter . write ( contents ) ; } finally { closeQuietly ( fileWriter ) ; } }
ebayopensource/turmeric-runtime | public static Map < String , String > createNS2PackageMap ( InputOptions inputOptions ) { Map < String , String > ns2PkgMap = new HashMap < String , String > ( ) ; PkgToNSMappingList pkgNsMapList = inputOptions . getPkgNSMappings ( ) ; if ( pkgNsMapList != null && ! pkgNsMapList . getPkgNsMap ( ) . isEmpty ( ) ) { for ( PkgNSMappingType pkgNsMapType : pkgNsMapList . getPkgNsMap ( ) ) { ns2PkgMap . put ( pkgNsMapType . getNamespace ( ) , pkgNsMapType . getPackage ( ) ) ; } } return ns2PkgMap ; }
ebayopensource/turmeric-runtime | public static String getJavaClassName ( String className ) { int idx = className . lastIndexOf ( " . " ) ; if ( idx <= 0 ) { return " " ; } return className . substring ( idx + 1 ) ; }
ebayopensource/turmeric-runtime | public static String getFolderPathFrompackageName ( String packageName ) { if ( packageName == null ) return null ; packageName = packageName . replace ( ' . ' , File . separatorChar ) ; return toOSFilePath ( packageName ) ; }
ebayopensource/turmeric-runtime | public static File urlToFile ( URL url ) { File file = null ; try { file = new File ( url . toURI ( ) ) ; } catch ( Exception exception ) { file = new File ( url . getPath ( ) ) ; } return file ; }
ebayopensource/turmeric-runtime | public static InputStream getInputStreamForAFileFromClasspath ( String relativeFilePath , ClassLoader parentClassLoader ) { relativeFilePath = relativeFilePath . replace ( " \ \" , " / " ) ; getLogger ( ) . log ( Level . INFO , " call ▁ to ▁ getInputStreamForAFileFromClasspath ▁ for ▁ path ▁ : ▁ " + relativeFilePath ) ; InputStream inStream = null ; if ( parentClassLoader != null ) inStream = parentClassLoader . getResourceAsStream ( relativeFilePath ) ; if ( inStream == null ) { ClassLoader myClassLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; inStream = myClassLoader . getResourceAsStream ( relativeFilePath ) ; } if ( inStream == null ) inStream = CodeGenUtil . class . getClassLoader ( ) . getResourceAsStream ( relativeFilePath ) ; if ( inStream == null ) getLogger ( ) . log ( Level . WARNING , " Could ▁ not ▁ find ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relativeFilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInputStreamForAFileFromClasspath " ) ; else getLogger ( ) . log ( Level . INFO , " Found ▁ the ▁ file ▁ from ▁ classpath ▁ : ▁ " + relativeFilePath + " ▁ ▁ in ▁ the ▁ method ▁ getInputStreamForAFileFromClasspath " ) ; return inStream ; }
ebayopensource/turmeric-runtime | public static File getFileFromInputStream ( InputStream inputStream , String fileExtension ) { FileOutputStream fileOutputStream = null ; File file = null ; try { file = File . createTempFile ( " ebayCodegen " , fileExtension ) ; byte [ ] bytes = new byte [ 10000 ] ; fileOutputStream = new FileOutputStream ( file ) ; int readCount = 0 ; while ( ( readCount = inputStream . read ( bytes ) ) > 0 ) { fileOutputStream . write ( bytes , 0 , readCount ) ; } } catch ( IOException e ) { getLogger ( ) . log ( Level . INFO , " exception ▁ while ▁ trying ▁ to ▁ create ▁ the ▁ tekmp ▁ file ▁ : ▁ exception ▁ is ▁ : ▁ " + e . getMessage ( ) ) ; } finally { if ( fileOutputStream != null ) { try { fileOutputStream . close ( ) ; } catch ( IOException e ) { getLogger ( ) . log ( Level . FINE , " Exception ▁ while ▁ closing ▁ the ▁ file ▁ outut ▁ stream ▁ for ▁ the ▁ file ▁ " ) ; } } } return file ; }
ebayopensource/turmeric-runtime | public static String [ ] getServiceLocations ( Definition wsdlDefinition ) { List < String > locations = new ArrayList < String > ( ) ; Service wsdlService = ( Service ) wsdlDefinition . getServices ( ) . values ( ) . iterator ( ) . next ( ) ; Map < ? , ? > wsdlPorts = wsdlService . getPorts ( ) ; for ( Iterator < ? > it = wsdlPorts . values ( ) . iterator ( ) ; it . hasNext ( ) ; ) { Port wsdlPort = ( Port ) it . next ( ) ; Iterator < ? > itElements = wsdlPort . getExtensibilityElements ( ) . iterator ( ) ; while ( itElements . hasNext ( ) ) { Object obj = itElements . next ( ) ; String wsdlURI = null ; if ( obj instanceof SOAPAddress ) { SOAPAddress address = ( SOAPAddress ) obj ; wsdlURI = address . getLocationURI ( ) ; } else if ( obj instanceof SOAP12Address ) { SOAP12Address address = ( SOAP12Address ) obj ; wsdlURI = address . getLocationURI ( ) ; } else if ( obj instanceof HTTPAddress ) { HTTPAddress address = ( HTTPAddress ) obj ; wsdlURI = address . getLocationURI ( ) ; } if ( ! isEmptyString ( wsdlURI ) ) locations . add ( wsdlURI ) ; } } String arr [ ] = new String [ locations . size ( ) ] ; locations . toArray ( arr ) ; return arr ; }
VHAINNOVATIONS/Telepathology | public static synchronized ImageExchangeApplicationContext getSingleton ( String [ ] contexts ) { if ( singleton == null && contexts == null ) throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ may ▁ not ▁ be ▁ explicitly ▁ initialized ▁ with ▁ a ▁ null ▁ context . " ) ; if ( singleton != null ) { if ( contexts . length != effectiveApplicationContext . length ) throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ may ▁ not ▁ be ▁ re - initialized ▁ with ▁ a ▁ different ▁ context . " ) ; for ( int index = 0 ; index < contexts . length ; ++ index ) if ( ! contexts [ index ] . equalsIgnoreCase ( effectiveApplicationContext [ index ] ) ) throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ may ▁ not ▁ be ▁ re - initialized ▁ with ▁ a ▁ different ▁ context . " ) ; log . warn ( " ImageExchangeApplicationContext . getSingleton ▁ was ▁ called ▁ twice ▁ with ▁ the ▁ same ▁ context . " ) ; } if ( singleton == null ) { effectiveApplicationContext = contexts ; singleton = new ImageExchangeApplicationContext ( ) ; } return singleton ; }
VHAINNOVATIONS/Telepathology | public static ImageExchangeApplicationContext getSingleton ( ) { if ( singleton == null ) { log . error ( " ImageExchangeApplicationContext ▁ was ▁ not ▁ initialized ▁ when ▁ getSingleton ( ) ▁ was ▁ called . " ) ; throw new ImageExchangeApplicationContextInitializationError ( " ImageExchangeApplicationContext ▁ was ▁ not ▁ initialized ▁ when ▁ getSingleton ( ) ▁ was ▁ called . " ) ; } return singleton ; }
shigengyu/Hyperion | public static < K , V > ListHashMap < K , V > newListHashMap ( ) { return new ListHashMap < K , V > ( ) ; }
asposemarketplace/Aspose-Pdf-Java | public static void main ( String [ ] args ) throws Exception { String dataDir = " src / programmersguide / workingwithasposepdffacades / workingwithtext / extracttextfromindividualpages / data / " ; com . aspose . pdf . facades . PdfExtractor pdfExtractor = new com . aspose . pdf . facades . PdfExtractor ( ) ; pdfExtractor . bindPdf ( dataDir + " Input1 . pdf " ) ; pdfExtractor . extractText ( ) ; int pageNumber = 1 ; while ( pdfExtractor . hasNextPageText ( ) ) { pdfExtractor . getNextPageText ( dataDir + " output " + pageNumber + " . txt " ) ; pageNumber ++ ; } }
Ossit/SenseBack | public static SensorDbHelper initialize ( Context context ) { if ( dbHelper == null ) { synchronized ( SensorDbHelper . class ) { if ( dbHelper == null ) { dbHelper = new SensorDbHelper ( context ) ; } } } return dbHelper ; }
Ossit/SenseBack | public static SensorDbHelper getInstance ( ) { return dbHelper ; }
Alluxio/alluxio | protected static KodoUnderFileSystem creatInstance ( AlluxioURI uri , UnderFileSystemConfiguration conf ) { String bucketName = UnderFileSystemUtils . getBucketName ( uri ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_ACCESS_KEY ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_ACCESS_KEY ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_SECRET_KEY ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_SECRET_KEY ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_DOWNLOAD_HOST ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_DOWNLOAD_HOST ) ; Preconditions . checkArgument ( conf . isSet ( PropertyKey . KODO_ENDPOINT ) , " Property ▁ % s ▁ is ▁ required ▁ to ▁ connect ▁ to ▁ Kodo " , PropertyKey . KODO_ENDPOINT ) ; String accessKey = conf . getString ( PropertyKey . KODO_ACCESS_KEY ) ; String secretKey = conf . getString ( PropertyKey . KODO_SECRET_KEY ) ; String endPoint = conf . getString ( PropertyKey . KODO_ENDPOINT ) ; String souceHost = conf . getString ( PropertyKey . KODO_DOWNLOAD_HOST ) ; Auth auth = Auth . create ( accessKey , secretKey ) ; Configuration configuration = new Configuration ( ) ; OkHttpClient . Builder okHttpBuilder = initializeKodoClientConfig ( conf ) ; OkHttpClient okHttpClient = okHttpBuilder . build ( ) ; KodoClient kodoClient = new KodoClient ( auth , bucketName , souceHost , endPoint , configuration , okHttpClient ) ; return new KodoUnderFileSystem ( uri , kodoClient , conf ) ; }
Alluxio/alluxio | private static Builder initializeKodoClientConfig ( UnderFileSystemConfiguration conf ) { OkHttpClient . Builder builder = new OkHttpClient . Builder ( ) ; Dispatcher dispatcher = new Dispatcher ( ) ; dispatcher . setMaxRequests ( conf . getInt ( PropertyKey . UNDERFS_KODO_REQUESTS_MAX ) ) ; builder . connectTimeout ( conf . getMs ( PropertyKey . UNDERFS_KODO_CONNECT_TIMEOUT ) , TimeUnit . SECONDS ) ; return builder ; }
onders86/camel | protected static BraintreeApiName getApiName ( Class < ? extends ApiMethod > apiMethod ) { return BraintreeApiCollection . getCollection ( ) . getApiName ( apiMethod ) ; }
onders86/camel | protected static String getApiNameAsString ( Class < ? extends ApiMethod > apiMethod ) { return getApiName ( apiMethod ) . getName ( ) ; }
EnigmaCurry/cassandra | private static void setScores ( DynamicEndpointSnitch dsnitch , int rounds , List < InetAddress > hosts , Integer ... scores ) throws InterruptedException { for ( int round = 0 ; round < rounds ; round ++ ) { for ( int i = 0 ; i < hosts . size ( ) ; i ++ ) dsnitch . receiveTiming ( hosts . get ( i ) , scores [ i ] ) ; } Thread . sleep ( 150 ) ; }
benchakalaka/DrawingMagic | public static void showWithFontAwesomeImage ( Activity activity , String message , String fatImageString , NotificationType type ) { switch ( type ) { case SUCCESS : SimpleToast . ok ( activity , message , fatImageString ) ; break ; case ERROR : SimpleToast . error ( activity , message , fatImageString ) ; break ; case MUTED : SimpleToast . muted ( activity , message , fatImageString ) ; break ; case WARNING : SimpleToast . warning ( activity , message , fatImageString ) ; break ; case INFO : SimpleToast . info ( activity , message , fatImageString ) ; break ; } }
benchakalaka/DrawingMagic | public static void showMuted ( Activity activity , String message ) { SimpleToast . muted ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showMuted ( Activity activity , int message ) { SimpleToast . muted ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showWarning ( Activity activity , String message ) { SimpleToast . warning ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showWarning ( Activity activity , int message ) { SimpleToast . warning ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showError ( Activity activity , String message ) { SimpleToast . error ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showError ( Activity activity , int message ) { SimpleToast . error ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showSuccess ( Activity activity , String message ) { SimpleToast . ok ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showSuccess ( Activity activity , int message ) { SimpleToast . ok ( activity , activity . getResources ( ) . getString ( message ) ) ; }
benchakalaka/DrawingMagic | public static void showInfo ( Activity activity , String message ) { SimpleToast . info ( activity , message ) ; }
benchakalaka/DrawingMagic | public static void showInfo ( Activity activity , int message ) { SimpleToast . info ( activity , activity . getResources ( ) . getString ( message ) ) ; }
osinstom/onos | static PiFieldMatch translateCriterion ( Criterion criterion , PiMatchFieldId fieldId , PiMatchType matchType , int bitWidth ) throws PiTranslationException { if ( ! TRANSLATORS . containsKey ( criterion . getClass ( ) ) ) { throw new PiTranslationException ( format ( " Translation ▁ of ▁ criterion ▁ class ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . getClass ( ) . getSimpleName ( ) ) ) ; } CriterionTranslator translator = TRANSLATORS . get ( criterion . getClass ( ) ) ; try { translator . init ( criterion , bitWidth ) ; switch ( matchType ) { case EXACT : return new PiExactFieldMatch ( fieldId , translator . exactMatch ( ) ) ; case TERNARY : Pair < ImmutableByteSequence , ImmutableByteSequence > tp = translator . ternaryMatch ( ) ; return new PiTernaryFieldMatch ( fieldId , tp . getLeft ( ) , tp . getRight ( ) ) ; case LPM : Pair < ImmutableByteSequence , Integer > lp = translator . lpmMatch ( ) ; return new PiLpmFieldMatch ( fieldId , lp . getLeft ( ) , lp . getRight ( ) ) ; default : throw new PiTranslationException ( format ( " Translation ▁ of ▁ criterion ▁ % s ▁ ( % s ▁ class ) ▁ to ▁ match ▁ type ▁ % s ▁ is ▁ not ▁ implemented . " , criterion . type ( ) . name ( ) , criterion . getClass ( ) . getSimpleName ( ) , matchType . name ( ) ) ) ; } } catch ( ByteSequenceTrimException e ) { throw new PiTranslationException ( format ( " Size ▁ mismatch ▁ for ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } catch ( CriterionTranslatorException e ) { throw new PiTranslationException ( format ( " Unable ▁ to ▁ translate ▁ criterion ▁ % s : ▁ % s " , criterion . type ( ) , e . getMessage ( ) ) ) ; } }
Rikkola/drools | private static ProcessRuntimeFactoryService initializeProvider ( ) { return ServiceRegistry . getInstance ( ) . get ( ProcessRuntimeFactoryService . class ) ; }
Rikkola/drools | public static synchronized void reInitializeProvider ( ) { provider = initializeProvider ( ) ; }
Rikkola/drools | public static InternalProcessRuntime newProcessRuntime ( StatefulKnowledgeSessionImpl workingMemory ) { return provider == null ? null : provider . newProcessRuntime ( workingMemory ) ; }
Rikkola/drools | public static void setProcessRuntimeFactoryService ( ProcessRuntimeFactoryService provider ) { ProcessRuntimeFactory . provider = provider ; }
Rikkola/drools | public static ProcessRuntimeFactoryService getProcessRuntimeFactoryService ( ) { return provider ; }
simplaapliko/Trips | public static Intent getCallingIntent ( Context context , long tripId ) { Intent callingIntent = new Intent ( context , TripActivity . class ) ; callingIntent . putExtra ( TRIP_ID_KEY , tripId ) ; return callingIntent ; }
BladeRunnerJS/closure-compiler | public static char toBase64 ( int value ) { assert ( value <= 63 && value >= 0 ) : " value ▁ out ▁ of ▁ range : " + value ; return BASE64_MAP . charAt ( value ) ; }
BladeRunnerJS/closure-compiler | public static int fromBase64 ( char c ) { int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - 1 ) : " invalid ▁ char " ; return BASE64_DECODE_MAP [ c ] ; }
BladeRunnerJS/closure-compiler | public static String base64EncodeInt ( int value ) { char [ ] c = new char [ 6 ] ; for ( int i = 0 ; i < 5 ; i ++ ) { c [ i ] = Base64 . toBase64 ( ( value >> ( 26 - i * 6 ) ) & 0x3f ) ; } c [ 5 ] = Base64 . toBase64 ( ( value << 4 ) & 0x3f ) ; return new String ( c ) ; }
alect/Puzzledice | public static DatabaseModel createModelFromXML ( File xmlFile ) { DatabaseModel model = new DatabaseModel ( ) ; DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; try { DocumentBuilder builder = dbf . newDocumentBuilder ( ) ; Document dom = builder . parse ( xmlFile ) ; Element docElement = dom . getDocumentElement ( ) ; NodeList propertyGroups = docElement . getElementsByTagName ( " Properties " ) ; if ( propertyGroups . getLength ( ) == 0 ) return null ; for ( int i = 0 ; i < propertyGroups . getLength ( ) ; i ++ ) { Element propertyList = ( Element ) propertyGroups . item ( i ) ; NodeList properties = propertyList . getChildNodes ( ) ; for ( int j = 0 ; j < properties . getLength ( ) ; j ++ ) { if ( properties . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element propertyElem = ( Element ) properties . item ( j ) ; DatabaseProperty propertyTemplate = parsePropertyTemplate ( propertyElem ) ; model . addPropertyToDatabase ( propertyTemplate ) ; } } NodeList itemGroups = docElement . getElementsByTagName ( " Items " ) ; if ( itemGroups . getLength ( ) == 0 ) return null ; Map < String , DatabaseItem > itemMap = new HashMap < String , DatabaseItem > ( ) ; for ( int i = 0 ; i < itemGroups . getLength ( ) ; i ++ ) { Element itemList = ( Element ) itemGroups . item ( i ) ; NodeList items = itemList . getChildNodes ( ) ; for ( int j = 0 ; j < items . getLength ( ) ; j ++ ) { if ( items . item ( j ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element itemElem = ( Element ) items . item ( j ) ; DatabaseItem item = parseItem ( itemElem ) ; model . addItemToDatabase ( item ) ; itemMap . put ( item . getName ( ) , item ) ; } } for ( DatabaseItem item : model . getItemList ( ) ) { item . resolveNamesToItems ( itemMap ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } return model ; }
alect/Puzzledice | private static DatabaseItem parseItem ( Element itemElem ) { String itemName = itemElem . getAttribute ( " name " ) ; DatabaseItem item = new DatabaseItem ( itemName ) ; NodeList itemProperties = itemElem . getChildNodes ( ) ; for ( int i = 0 ; i < itemProperties . getLength ( ) ; i ++ ) { if ( itemProperties . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element propertyElem = ( Element ) itemProperties . item ( i ) ; DatabaseProperty property = parseFullProperty ( propertyElem ) ; item . addProperty ( property . getName ( ) , property ) ; } return item ; }
alect/Puzzledice | private static DatabaseProperty parseFullProperty ( Element propertyElem ) { String propertyName = propertyElem . getAttribute ( " name " ) ; DatabaseProperty property ; String propertyType = propertyElem . getTagName ( ) ; if ( propertyType . equals ( " BooleanProperty " ) ) { property = new BooleanDatabaseProperty ( propertyName ) ; boolean value = propertyElem . getAttribute ( " value " ) . equals ( " true " ) ; ( ( BooleanDatabaseProperty ) property ) . setValue ( value ) ; } else if ( propertyType . equals ( " IntegerProperty " ) ) { property = new IntegerDatabaseProperty ( propertyName ) ; int value = Integer . parseInt ( propertyElem . getAttribute ( " value " ) ) ; ( ( IntegerDatabaseProperty ) property ) . setValue ( value ) ; } else if ( propertyType . equals ( " TextProperty " ) ) { property = new TextDatabaseProperty ( propertyName ) ; String text = propertyElem . getAttribute ( " text " ) ; ( ( TextDatabaseProperty ) property ) . setText ( text ) ; } else if ( propertyType . equals ( " ItemListProperty " ) ) { property = new ItemListDatabaseProperty ( propertyName ) ; NodeList itemRefs = propertyElem . getElementsByTagName ( " ItemReference " ) ; for ( int i = 0 ; i < itemRefs . getLength ( ) ; i ++ ) { Element itemRef = ( Element ) itemRefs . item ( i ) ; String itemName = itemRef . getAttribute ( " name " ) ; ( ( ItemListDatabaseProperty ) property ) . addItemName ( itemName ) ; } } else if ( propertyType . equals ( " StringListProperty " ) ) { property = new StringListDatabaseProperty ( propertyName ) ; NodeList stringRefs = propertyElem . getElementsByTagName ( " String " ) ; String [ ] stringList = new String [ stringRefs . getLength ( ) ] ; for ( int i = 0 ; i < stringRefs . getLength ( ) ; i ++ ) { Element stringRef = ( Element ) stringRefs . item ( i ) ; stringList [ i ] = stringRef . getAttribute ( " string " ) ; } ( ( StringListDatabaseProperty ) property ) . setStringList ( stringList ) ; } else if ( propertyType . equals ( " StringPairListProperty " ) ) { property = new StringPairListDatabaseProperty ( propertyName ) ; NodeList pairRefs = propertyElem . getElementsByTagName ( " StringPair " ) ; StringPair [ ] pairList = new StringPair [ pairRefs . getLength ( ) ] ; for ( int i = 0 ; i < pairRefs . getLength ( ) ; i ++ ) { Element pairRef = ( Element ) pairRefs . item ( i ) ; String string1 = pairRef . getAttribute ( " string1" ) ; String string2 = pairRef . getAttribute ( " string2" ) ; pairList [ i ] = new StringPair ( string1 , string2 ) ; } ( ( StringPairListDatabaseProperty ) property ) . setStringPairs ( pairList ) ; } else if ( propertyType . equals ( " CustomProperty " ) ) { NodeList subPropertyElems = propertyElem . getChildNodes ( ) ; List < DatabaseProperty > subProperties = new ArrayList < DatabaseProperty > ( ) ; for ( int i = 0 ; i < subPropertyElems . getLength ( ) ; i ++ ) { if ( subPropertyElems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element subPropertyElem = ( Element ) subPropertyElems . item ( i ) ; subProperties . add ( parseFullProperty ( subPropertyElem ) ) ; } DatabaseProperty [ ] subPropertyArray = new DatabaseProperty [ subProperties . size ( ) ] ; property = new CustomProperty ( propertyName , subProperties . toArray ( subPropertyArray ) ) ; } else property = null ; return property ; }
alect/Puzzledice | private static DatabaseProperty parsePropertyTemplate ( Element propertyElem ) { String propertyName = propertyElem . getAttribute ( " name " ) ; DatabaseProperty property ; String propertyType = propertyElem . getTagName ( ) ; if ( propertyType . equals ( " BooleanProperty " ) ) property = new BooleanDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " IntegerProperty " ) ) property = new IntegerDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " TextProperty " ) ) property = new TextDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " ItemListProperty " ) ) property = new ItemListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " StringListProperty " ) ) property = new StringListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " StringPairListProperty " ) ) property = new StringPairListDatabaseProperty ( propertyName ) ; else if ( propertyType . equals ( " CustomProperty " ) ) { NodeList subPropertyElems = propertyElem . getChildNodes ( ) ; List < DatabaseProperty > subProperties = new ArrayList < DatabaseProperty > ( ) ; for ( int i = 0 ; i < subPropertyElems . getLength ( ) ; i ++ ) { if ( subPropertyElems . item ( i ) . getNodeType ( ) != Node . ELEMENT_NODE ) continue ; Element subPropertyElem = ( Element ) subPropertyElems . item ( i ) ; subProperties . add ( parsePropertyTemplate ( subPropertyElem ) ) ; } DatabaseProperty [ ] subPropertyArray = new DatabaseProperty [ subProperties . size ( ) ] ; property = new CustomProperty ( propertyName , subProperties . toArray ( subPropertyArray ) ) ; } else property = null ; return property ; }
dagnir/aws-sdk-java | public static StartLambdaFunctionFailedEventAttributesMarshaller getInstance ( ) { return instance ; }
AlanJinTS/zstack | public static NetworkServiceType valueOf ( String typeName ) { NetworkServiceType type = types . get ( typeName ) ; if ( type == null ) { throw new IllegalArgumentException ( " NetworkServiceType ▁ type : ▁ " + typeName + " ▁ was ▁ not ▁ provided ▁ by ▁ any ▁ NetworkServiceProvider " ) ; } return type ; }
ZhernakovMikhail/fax4j | public static ProcessOutput executeProcess ( ConfigurationHolder configurationHolder , String command ) { String className = configurationHolder . getConfigurationValue ( ProcessExecutor . PROCESS_EXECUTER_class_NAME_PROPERTY_KEY ) ; if ( className == null ) { className = DefaultProcessExecutor . class . getName ( ) ; } ProcessExecutor processExecutor = ProcessExecutorHelper . PROCESS_EXECUTERS . get ( className ) ; if ( processExecutor == null ) { processExecutor = ( ProcessExecutor ) ReflectionHelper . createInstance ( className ) ; ProcessExecutorHelper . PROCESS_EXECUTERS . put ( className , processExecutor ) ; } ProcessOutput processOutput = null ; try { processOutput = processExecutor . executeProcess ( configurationHolder , command ) ; } catch ( RuntimeException exception ) { throw exception ; } catch ( Exception exception ) { throw new FaxException ( " Error ▁ while ▁ invoking ▁ process , ▁ command : ▁ " + command , exception ) ; } return processOutput ; }
AdamPD/drill | public static Schema < DrillServiceInstance > getSchema ( ) { return DEFAULT_INSTANCE ; }
AdamPD/drill | public static DrillServiceInstance getDefaultInstance ( ) { return DEFAULT_INSTANCE ; }
jrbeaumont/workcraft | @ BeforeClass public static void init ( ) { final Framework framework = Framework . getInstance ( ) ; framework . init ( ) ; }
sameyasu/simplejdbc | public static final void open ( String directoryPath ) { String osName = System . getProperty ( " os . name " ) ; System . out . println ( " os . name ▁ = ▁ " + osName ) ; if ( osName != null && osName . startsWith ( " Windows " ) ) { Runtime runtime = Runtime . getRuntime ( ) ; String command = " explorer . exe ▁ " + EXPLORER_OPTION + convPath ( directoryPath ) ; System . out . println ( command ) ; try { runtime . exec ( command ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else { System . out . println ( " エクスプローラ起動しない 。 " ) ; } }
sameyasu/simplejdbc | private static final String convPath ( String slashPath ) { return " \" " + slashPath . replaceAll ( " \\ / " , " \\ \ \" ) + " \" " ; }
Mikuz/Boarder | public static void init ( Context context ) { settings = context . getSharedPreferences ( GLOBAL_SETTINGS_NAME , 0 ) ; }
Mikuz/Boarder | public static int getFadeInDuration ( ) { return settings . getInt ( GLOBAL_SETTING_FADE_IN_DURATION , 0 ) ; }
Mikuz/Boarder | public static void setFadeInDuration ( int fadeInDuration ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putInt ( GLOBAL_SETTING_FADE_IN_DURATION , fadeInDuration ) ; editor . commit ( ) ; }
Mikuz/Boarder | public static int getFadeOutDuration ( ) { return settings . getInt ( GLOBAL_SETTING_FADE_OUT_DURATION , 0 ) ; }
Mikuz/Boarder | public static void setFadeOutDuration ( int fadeOutDuration ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putInt ( GLOBAL_SETTING_FADE_OUT_DURATION , fadeOutDuration ) ; editor . commit ( ) ; }
Mikuz/Boarder | public static boolean getSensitiveLogging ( ) { return settings . getBoolean ( GLOBAL_SETTING_SENSITIVE_LOGGING , false ) ; }
Mikuz/Boarder | public static void setSensitiveLogging ( boolean sensitiveLogging ) { SharedPreferences . Editor editor = settings . edit ( ) ; editor . putBoolean ( GLOBAL_SETTING_SENSITIVE_LOGGING , sensitiveLogging ) ; editor . commit ( ) ; }
droolsjbpm/droolsjbpm-integration | @ BeforeClass public static void loadKieContainer ( ) { kieContainer = KIE_SERVICES . newKieContainer ( RELEASE_ID ) ; }
Dooooooooo21/HFUT | public static void addActivity ( Activity activity ) { activities . add ( activity ) ; }
Dooooooooo21/HFUT | public static void removeActivity ( Activity activity ) { activities . remove ( activity ) ; }
Dooooooooo21/HFUT | public static void finishAll ( ) { for ( Activity activity : activities ) { if ( ! activity . isFinishing ( ) ) { activity . finish ( ) ; } } }
yafengguo/Apache-beam | static < T > BoundedSourceShard < T > of ( BoundedSource < T > source ) { return new AutoValue_BoundedReadEvaluatorFactory_BoundedSourceShard < > ( source ) ; }
pac4j/pac4j | public static Authenticator getAuthenticator ( final LdapAuthenticationProperties l ) { if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . AD ) { LOGGER . debug ( " Creating ▁ active ▁ directory ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getActiveDirectoryAuthenticator ( l ) ; } if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . DIRECT ) { LOGGER . debug ( " Creating ▁ direct - bind ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getDirectBindAuthenticator ( l ) ; } if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . SASL ) { LOGGER . debug ( " Creating ▁ SASL ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getSaslAuthenticator ( l ) ; } if ( l . getType ( ) == LdapAuthenticationProperties . AuthenticationTypes . AUTHENTICATED ) { LOGGER . debug ( " Creating ▁ authenticated ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getAuthenticatedOrAnonSearchAuthenticator ( l ) ; } LOGGER . debug ( " Creating ▁ anonymous ▁ authenticator ▁ for ▁ { } " , l . getLdapUrl ( ) ) ; return getAuthenticatedOrAnonSearchAuthenticator ( l ) ; }
pac4j/pac4j | private static Authenticator getSaslAuthenticator ( final LdapAuthenticationProperties l ) { final var resolver = new SearchDnResolver ( ) ; resolver . setBaseDn ( l . getBaseDn ( ) ) ; resolver . setSubtreeSearch ( l . isSubtreeSearch ( ) ) ; resolver . setAllowMultipleDns ( l . isAllowMultipleDns ( ) ) ; resolver . setConnectionFactory ( newPooledConnectionFactory ( l ) ) ; resolver . setUserFilter ( l . getUserFilter ( ) ) ; return new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; }
pac4j/pac4j | private static Authenticator getAuthenticatedOrAnonSearchAuthenticator ( final LdapAuthenticationProperties l ) { final var resolver = new SearchDnResolver ( ) ; resolver . setBaseDn ( l . getBaseDn ( ) ) ; resolver . setSubtreeSearch ( l . isSubtreeSearch ( ) ) ; resolver . setAllowMultipleDns ( l . isAllowMultipleDns ( ) ) ; resolver . setConnectionFactory ( newPooledConnectionFactory ( l ) ) ; resolver . setUserFilter ( l . getUserFilter ( ) ) ; final Authenticator auth ; if ( CommonHelper . isBlank ( l . getPrincipalAttributePassword ( ) ) ) { auth = new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; } else { auth = new Authenticator ( resolver , getPooledCompareAuthenticationHandler ( l ) ) ; } if ( l . isEnhanceWithEntryResolver ( ) ) { auth . setEntryResolver ( newSearchEntryResolver ( l ) ) ; } return auth ; }
pac4j/pac4j | private static Authenticator getDirectBindAuthenticator ( final LdapAuthenticationProperties l ) { if ( CommonHelper . isBlank ( l . getDnFormat ( ) ) ) { throw new IllegalArgumentException ( " Dn ▁ format ▁ cannot ▁ be ▁ empty / blank ▁ for ▁ direct ▁ bind ▁ authentication " ) ; } final var resolver = new FormatDnResolver ( l . getDnFormat ( ) ) ; final var authenticator = new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; if ( l . isEnhanceWithEntryResolver ( ) ) { authenticator . setEntryResolver ( newSearchEntryResolver ( l ) ) ; } return authenticator ; }
pac4j/pac4j | private static Authenticator getActiveDirectoryAuthenticator ( final LdapAuthenticationProperties l ) { if ( CommonHelper . isBlank ( l . getDnFormat ( ) ) ) { throw new IllegalArgumentException ( " Dn ▁ format ▁ cannot ▁ be ▁ empty / blank ▁ for ▁ active ▁ directory ▁ authentication " ) ; } final var resolver = new FormatDnResolver ( l . getDnFormat ( ) ) ; final var authn = new Authenticator ( resolver , getPooledBindAuthenticationHandler ( l ) ) ; if ( l . isEnhanceWithEntryResolver ( ) ) { authn . setEntryResolver ( newSearchEntryResolver ( l ) ) ; } return authn ; }
pac4j/pac4j | private static SimpleBindAuthenticationHandler getPooledBindAuthenticationHandler ( final LdapAuthenticationProperties l ) { final var handler = new SimpleBindAuthenticationHandler ( newPooledConnectionFactory ( l ) ) ; handler . setAuthenticationControls ( new PasswordPolicyControl ( ) ) ; return handler ; }
pac4j/pac4j | private static CompareAuthenticationHandler getPooledCompareAuthenticationHandler ( final LdapAuthenticationProperties l ) { final var handler = new CompareAuthenticationHandler ( newPooledConnectionFactory ( l ) ) ; handler . setPasswordAttribute ( l . getPrincipalAttributePassword ( ) ) ; return handler ; }
pac4j/pac4j | public static EntryResolver newSearchEntryResolver ( final LdapAuthenticationProperties l ) { final var entryResolver = new SearchEntryResolver ( ) ; entryResolver . setBaseDn ( l . getBaseDn ( ) ) ; entryResolver . setUserFilter ( l . getUserFilter ( ) ) ; entryResolver . setSubtreeSearch ( l . isSubtreeSearch ( ) ) ; entryResolver . setConnectionFactory ( LdaptiveAuthenticatorBuilder . newPooledConnectionFactory ( l ) ) ; return entryResolver ; }
pac4j/pac4j | public static ConnectionConfig newConnectionConfig ( final AbstractLdapProperties l ) { final var cc = new ConnectionConfig ( ) ; final var urls = Arrays . stream ( l . getLdapUrl ( ) . split ( " , " ) ) . collect ( Collectors . joining ( " ▁ " ) ) ; LOGGER . debug ( " Transformed ▁ LDAP ▁ urls ▁ from ▁ [ { } ] ▁ to ▁ [ { } ] " , l . getLdapUrl ( ) , urls ) ; cc . setLdapUrl ( urls ) ; cc . setUseStartTLS ( l . isUseStartTls ( ) ) ; cc . setConnectTimeout ( newDuration ( l . getConnectTimeout ( ) ) ) ; if ( l . getTrustCertificates ( ) != null ) { final var cfg = new X509CredentialConfig ( ) ; cfg . setTrustCertificates ( l . getTrustCertificates ( ) ) ; cc . setSslConfig ( new SslConfig ( cfg ) ) ; } else if ( l . getKeystore ( ) != null ) { final var cfg = new KeyStoreCredentialConfig ( ) ; cfg . setKeyStore ( l . getKeystore ( ) ) ; cfg . setKeyStorePassword ( l . getKeystorePassword ( ) ) ; cfg . setKeyStoreType ( l . getKeystoreType ( ) ) ; cc . setSslConfig ( new SslConfig ( cfg ) ) ; } else { cc . setSslConfig ( new SslConfig ( ) ) ; } if ( l . getSaslMechanism ( ) != null ) { final var bc = new BindConnectionInitializer ( ) ; final SaslConfig sc ; switch ( l . getSaslMechanism ( ) ) { case DIGEST_MD5 : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . DIGEST_MD5 ) . realm ( l . getSaslRealm ( ) ) . build ( ) ; break ; case CRAM_MD5 : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . CRAM_MD5 ) . build ( ) ; break ; case EXTERNAL : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . EXTERNAL ) . build ( ) ; break ; case GSSAPI : sc = SaslConfig . builder ( ) . mechanism ( Mechanism . GSSAPI ) . realm ( l . getSaslRealm ( ) ) . build ( ) ; break ; default : throw new IllegalArgumentException ( " Unknown ▁ SASL ▁ mechanism ▁ " + l . getSaslMechanism ( ) . name ( ) ) ; } sc . setAuthorizationId ( l . getSaslAuthorizationId ( ) ) ; sc . setMutualAuthentication ( l . getSaslMutualAuth ( ) ) ; sc . setQualityOfProtection ( l . getSaslQualityOfProtection ( ) ) ; sc . setSecurityStrength ( l . getSaslSecurityStrength ( ) ) ; bc . setBindSaslConfig ( sc ) ; cc . setConnectionInitializers ( bc ) ; } else if ( CommonHelper . areEquals ( l . getBindCredential ( ) , " * " ) && CommonHelper . areEquals ( l . getBindDn ( ) , " * " ) ) { cc . setConnectionInitializers ( new FastBindConnectionInitializer ( ) ) ; } else if ( CommonHelper . isNotBlank ( l . getBindDn ( ) ) && CommonHelper . isNotBlank ( l . getBindCredential ( ) ) ) { cc . setConnectionInitializers ( new BindConnectionInitializer ( l . getBindDn ( ) , new Credential ( l . getBindCredential ( ) ) ) ) ; } return cc ; }
pac4j/pac4j | public static PooledConnectionFactory newPooledConnectionFactory ( final AbstractLdapProperties l ) { final var cc = newConnectionConfig ( l ) ; final var cf = new PooledConnectionFactory ( cc ) ; cf . setBlockWaitTime ( newDuration ( l . getBlockWaitTime ( ) ) ) ; cf . setMinPoolSize ( l . getMinPoolSize ( ) ) ; cf . setMaxPoolSize ( l . getMaxPoolSize ( ) ) ; cf . setValidateOnCheckOut ( l . isValidateOnCheckout ( ) ) ; cf . setValidatePeriodically ( l . isValidatePeriodically ( ) ) ; final var strategy = new IdlePruneStrategy ( ) ; strategy . setIdleTime ( newDuration ( l . getIdleTime ( ) ) ) ; strategy . setPrunePeriod ( newDuration ( l . getPrunePeriod ( ) ) ) ; cf . setPruneStrategy ( strategy ) ; cf . setFailFastInitialize ( l . isFailFast ( ) ) ; final var validator = new SearchConnectionValidator ( ) ; validator . setValidatePeriod ( newDuration ( l . getValidatePeriod ( ) ) ) ; cf . setValidator ( validator ) ; if ( CommonHelper . isNotBlank ( l . getPoolPassivator ( ) ) ) { final var pass = AbstractLdapProperties . LdapConnectionPoolPassivator . valueOf ( l . getPoolPassivator ( ) . toUpperCase ( ) ) ; switch ( pass ) { case CLOSE : cf . setPassivator ( conn -> { conn . close ( ) ; return true ; } ) ; break ; case BIND : LOGGER . debug ( " Creating ▁ a ▁ bind ▁ passivator ▁ instance ▁ for ▁ the ▁ connection ▁ pool " ) ; final var bindRequest = new SimpleBindRequest ( l . getBindDn ( ) , new Credential ( l . getBindCredential ( ) ) ) ; cf . setPassivator ( new BindConnectionPassivator ( bindRequest ) ) ; break ; default : break ; } } LOGGER . debug ( " Initializing ▁ ldap ▁ connection ▁ pool ▁ for ▁ { } ▁ and ▁ bindDn ▁ { } " , l . getLdapUrl ( ) , l . getBindDn ( ) ) ; cf . initialize ( ) ; return cf ; }
pac4j/pac4j | public static Duration newDuration ( final long length ) { return Duration . ofSeconds ( length ) ; }
pac4j/pac4j | public static SearchRequest newSearchRequest ( final String baseDn , final FilterTemplate filter ) { final var sr = new SearchRequest ( baseDn , filter ) ; sr . setReturnAttributes ( ReturnAttributes . ALL_USER . value ( ) ) ; sr . setSearchScope ( SearchScope . SUBTREE ) ; return sr ; }
pac4j/pac4j | public static FilterTemplate newSearchFilter ( final String filterQuery , final String ... params ) { final var filter = new FilterTemplate ( ) ; filter . setFilter ( filterQuery ) ; if ( params != null ) { for ( var i = 0 ; i < params . length ; i ++ ) { if ( filter . getFilter ( ) . contains ( " { " + i + " } " ) ) { filter . setParameter ( i , params [ i ] ) ; } else { filter . setParameter ( " user " , params [ i ] ) ; } } } LOGGER . debug ( " Constructed ▁ LDAP ▁ search ▁ filter ▁ [ { } ] " , filter . format ( ) ) ; return filter ; }
pac4j/pac4j | public static SearchOperation newSearchOperation ( final String baseDn , final String filterQuery , final String ... params ) { final var operation = new SearchOperation ( ) ; operation . setRequest ( SearchRequest . builder ( ) . dn ( baseDn ) . filter ( newSearchFilter ( filterQuery , params ) ) . returnAttributes ( ReturnAttributes . ALL . value ( ) ) . scope ( SearchScope . SUBTREE ) . build ( ) ) ; return operation ; }
Xylus/pinpoint | private static byte [ ] checkBytes ( byte [ ] bytes ) { if ( bytes == null ) { throw new NullPointerException ( " bytes " ) ; } return bytes ; }
Scottmitch/netty | static void runInChannel ( Channel channel , final Http2Runnable runnable ) { channel . eventLoop ( ) . execute ( new Runnable ( ) { @ Override public void run ( ) { try { runnable . run ( ) ; } catch ( Http2Exception e ) { throw new RuntimeException ( e ) ; } } } ) ; }
Scottmitch/netty | public static byte [ ] randomBytes ( ) { return randomBytes ( 100 ) ; }
Scottmitch/netty | public static byte [ ] randomBytes ( int size ) { byte [ ] data = new byte [ size ] ; new Random ( ) . nextBytes ( data ) ; return data ; }
Scottmitch/netty | public static AsciiString randomString ( ) { return new AsciiString ( randomBytes ( ) ) ; }
Scottmitch/netty | public static CharSequence of ( String s ) { return s ; }
Scottmitch/netty | public static Http2Stream getOrCreateStream ( Http2Connection connection , int streamId , boolean halfClosed ) throws Http2Exception { if ( connection != null ) { Http2Stream stream = connection . stream ( streamId ) ; if ( stream == null ) { if ( connection . isServer ( ) && streamId % 2 == 0 || ! connection . isServer ( ) && streamId % 2 != 0 ) { stream = connection . local ( ) . createStream ( streamId , halfClosed ) ; } else { stream = connection . remote ( ) . createStream ( streamId , halfClosed ) ; } } return stream ; } return null ; }
hovsepm/azure-sdk-for-java | private static void validateMultiCreation ( String database2Name , String database1InEPName , String database2InEPName , String elasticPool1Name , String elasticPool2Name , String elasticPool3Name , SqlServer sqlServer , boolean deleteUsingUpdate ) { validateSqlServer ( sqlServer ) ; validateSqlServer ( sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) ) ; validateSqlDatabase ( sqlServer . databases ( ) . get ( SQL_DATABASE_NAME ) , SQL_DATABASE_NAME ) ; validateSqlFirewallRule ( sqlServer . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) , SQL_FIREWALLRULE_NAME ) ; List < SqlFirewallRule > firewalls = sqlServer . firewallRules ( ) . list ( ) ; Assert . assertEquals ( 3 , firewalls . size ( ) ) ; int startIPAddress = 0 ; int endIPAddress = 0 ; for ( SqlFirewallRule firewall : firewalls ) { if ( ! firewall . name ( ) . equalsIgnoreCase ( SQL_FIREWALLRULE_NAME ) ) { Assert . assertEquals ( firewall . startIPAddress ( ) , START_IPADDRESS ) ; if ( firewall . endIPAddress ( ) . equalsIgnoreCase ( START_IPADDRESS ) ) { startIPAddress ++ ; } else if ( firewall . endIPAddress ( ) . equalsIgnoreCase ( END_IPADDRESS ) ) { endIPAddress ++ ; } } } Assert . assertEquals ( startIPAddress , 1 ) ; Assert . assertEquals ( endIPAddress , 1 ) ; Assert . assertNotNull ( sqlServer . databases ( ) . get ( database2Name ) ) ; Assert . assertNotNull ( sqlServer . databases ( ) . get ( database1InEPName ) ) ; Assert . assertNotNull ( sqlServer . databases ( ) . get ( database2InEPName ) ) ; SqlElasticPool ep1 = sqlServer . elasticPools ( ) . get ( elasticPool1Name ) ; validateSqlElasticPool ( ep1 , elasticPool1Name ) ; SqlElasticPool ep2 = sqlServer . elasticPools ( ) . get ( elasticPool2Name ) ; Assert . assertNotNull ( ep2 ) ; Assert . assertEquals ( ep2 . edition ( ) , ElasticPoolEditions . PREMIUM ) ; Assert . assertEquals ( ep2 . listDatabases ( ) . size ( ) , 2 ) ; Assert . assertNotNull ( ep2 . getDatabase ( database1InEPName ) ) ; Assert . assertNotNull ( ep2 . getDatabase ( database2InEPName ) ) ; SqlElasticPool ep3 = sqlServer . elasticPools ( ) . get ( elasticPool3Name ) ; Assert . assertNotNull ( ep3 ) ; Assert . assertEquals ( ep3 . edition ( ) , ElasticPoolEditions . STANDARD ) ; if ( ! deleteUsingUpdate ) { sqlServer . databases ( ) . delete ( database2Name ) ; sqlServer . databases ( ) . delete ( database1InEPName ) ; sqlServer . databases ( ) . delete ( database2InEPName ) ; sqlServer . databases ( ) . delete ( SQL_DATABASE_NAME ) ; Assert . assertEquals ( ep1 . listDatabases ( ) . size ( ) , 0 ) ; Assert . assertEquals ( ep2 . listDatabases ( ) . size ( ) , 0 ) ; Assert . assertEquals ( ep3 . listDatabases ( ) . size ( ) , 0 ) ; sqlServer . elasticPools ( ) . delete ( elasticPool1Name ) ; sqlServer . elasticPools ( ) . delete ( elasticPool2Name ) ; sqlServer . elasticPools ( ) . delete ( elasticPool3Name ) ; firewalls = sqlServer . firewallRules ( ) . list ( ) ; for ( SqlFirewallRule firewallRule : firewalls ) { firewallRule . delete ( ) ; } } else { sqlServer . update ( ) . withoutDatabase ( database2Name ) . withoutElasticPool ( elasticPool1Name ) . withoutElasticPool ( elasticPool2Name ) . withoutElasticPool ( elasticPool3Name ) . withoutElasticPool ( elasticPool1Name ) . withoutDatabase ( database1InEPName ) . withoutDatabase ( SQL_DATABASE_NAME ) . withoutDatabase ( database2InEPName ) . withoutFirewallRule ( SQL_FIREWALLRULE_NAME ) . apply ( ) ; Assert . assertEquals ( sqlServer . elasticPools ( ) . list ( ) . size ( ) , 0 ) ; firewalls = sqlServer . firewallRules ( ) . list ( ) ; Assert . assertEquals ( firewalls . size ( ) , 2 ) ; for ( SqlFirewallRule firewallRule : firewalls ) { firewallRule . delete ( ) ; } } Assert . assertEquals ( sqlServer . elasticPools ( ) . list ( ) . size ( ) , 0 ) ; Assert . assertEquals ( sqlServer . databases ( ) . list ( ) . size ( ) , 1 ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlFirewallRuleNotFound ( ) { Assert . assertNull ( sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) . firewallRules ( ) . get ( SQL_FIREWALLRULE_NAME ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlElasticPoolNotFound ( SqlServer sqlServer , String elasticPoolName ) { Assert . assertNull ( sqlServer . elasticPools ( ) . get ( elasticPoolName ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlDatabaseNotFound ( String newDatabase ) { Assert . assertNull ( sqlServerManager . sqlServers ( ) . getByResourceGroup ( RG_NAME , SQL_SERVER_NAME ) . databases ( ) . get ( newDatabase ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlServerNotFound ( SqlServer sqlServer ) { Assert . assertNull ( sqlServerManager . sqlServers ( ) . getById ( sqlServer . id ( ) ) ) ; }
hovsepm/azure-sdk-for-java | private static SqlServer createSqlServer ( ) { return createSqlServer ( SQL_SERVER_NAME ) ; }
hovsepm/azure-sdk-for-java | private static SqlServer createSqlServer ( String SQL_SERVER_NAME ) { return sqlServerManager . sqlServers ( ) . define ( SQL_SERVER_NAME ) . withRegion ( Region . US_CENTRAL ) . withNewResourceGroup ( RG_NAME ) . withAdministratorLogin ( " userName " ) . withAdministratorPassword ( " P @ ssword ~ 1" ) . create ( ) ; }
hovsepm/azure-sdk-for-java | private static void validateListSqlFirewallRule ( List < SqlFirewallRule > sqlFirewallRules ) { boolean found = false ; for ( SqlFirewallRule firewallRule : sqlFirewallRules ) { if ( firewallRule . name ( ) . equals ( SQL_FIREWALLRULE_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlFirewallRule ( SqlFirewallRule sqlFirewallRule , String firewallName ) { Assert . assertNotNull ( sqlFirewallRule ) ; Assert . assertEquals ( firewallName , sqlFirewallRule . name ( ) ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlFirewallRule . sqlServerName ( ) ) ; Assert . assertEquals ( START_IPADDRESS , sqlFirewallRule . startIPAddress ( ) ) ; Assert . assertEquals ( END_IPADDRESS , sqlFirewallRule . endIPAddress ( ) ) ; Assert . assertEquals ( RG_NAME , sqlFirewallRule . resourceGroupName ( ) ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlFirewallRule . sqlServerName ( ) ) ; Assert . assertEquals ( Region . US_CENTRAL , sqlFirewallRule . region ( ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateListSqlElasticPool ( List < SqlElasticPool > sqlElasticPools ) { boolean found = false ; for ( SqlElasticPool elasticPool : sqlElasticPools ) { if ( elasticPool . name ( ) . equals ( SQL_ELASTIC_POOL_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlElasticPool ( SqlElasticPool sqlElasticPool ) { validateSqlElasticPool ( sqlElasticPool , SQL_ELASTIC_POOL_NAME ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlElasticPool ( SqlElasticPool sqlElasticPool , String elasticPoolName ) { Assert . assertNotNull ( sqlElasticPool ) ; Assert . assertEquals ( RG_NAME , sqlElasticPool . resourceGroupName ( ) ) ; Assert . assertEquals ( elasticPoolName , sqlElasticPool . name ( ) ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlElasticPool . sqlServerName ( ) ) ; Assert . assertEquals ( ElasticPoolEditions . STANDARD , sqlElasticPool . edition ( ) ) ; Assert . assertNotNull ( sqlElasticPool . creationDate ( ) ) ; Assert . assertNotEquals ( 0 , sqlElasticPool . databaseDtuMax ( ) ) ; Assert . assertNotEquals ( 0 , sqlElasticPool . dtu ( ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateListSqlDatabase ( List < SqlDatabase > sqlDatabases ) { boolean found = false ; for ( SqlDatabase database : sqlDatabases ) { if ( database . name ( ) . equals ( SQL_DATABASE_NAME ) ) { found = true ; } } Assert . assertTrue ( found ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlServer ( SqlServer sqlServer ) { Assert . assertNotNull ( sqlServer ) ; Assert . assertEquals ( RG_NAME , sqlServer . resourceGroupName ( ) ) ; Assert . assertNotNull ( sqlServer . fullyQualifiedDomainName ( ) ) ; Assert . assertEquals ( ServerVersion . ONE_TWO_FULL_STOP_ZERO , sqlServer . version ( ) ) ; Assert . assertEquals ( " userName " , sqlServer . administratorLogin ( ) ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlDatabase ( SqlDatabase sqlDatabase , String databaseName ) { Assert . assertNotNull ( sqlDatabase ) ; Assert . assertEquals ( sqlDatabase . name ( ) , databaseName ) ; Assert . assertEquals ( SQL_SERVER_NAME , sqlDatabase . sqlServerName ( ) ) ; Assert . assertEquals ( sqlDatabase . collation ( ) , COLLATION ) ; Assert . assertEquals ( sqlDatabase . edition ( ) , DatabaseEditions . STANDARD ) ; }
hovsepm/azure-sdk-for-java | private static void validateSqlDatabaseWithElasticPool ( SqlDatabase sqlDatabase , String databaseName ) { validateSqlDatabase ( sqlDatabase , databaseName ) ; Assert . assertEquals ( SQL_ELASTIC_POOL_NAME , sqlDatabase . elasticPoolName ( ) ) ; }
hazendaz/assertj-core | private static boolean [ ] toPrimitiveBooleanArray ( Boolean [ ] values ) { boolean [ ] booleans = new boolean [ values . length ] ; range ( 0 , values . length ) . forEach ( i -> booleans [ i ] = values [ i ] ) ; return booleans ; }
anilgursel/squbs | static Optional < SSLContext > sslContext ( String store , String pw ) { try { char [ ] password = pw . toCharArray ( ) ; KeyStore ks = KeyStore . getInstance ( " JKS " ) ; InputStream keystore = ClientFlowHttpsTest . class . getClassLoader ( ) . getResourceAsStream ( " ClientFlowHttpsSpec / " + store ) ; assert keystore != null ; ks . load ( keystore , password ) ; KeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( " SunX509" ) ; keyManagerFactory . init ( ks , password ) ; TrustManagerFactory tmf = TrustManagerFactory . getInstance ( " SunX509" ) ; tmf . init ( ks ) ; SSLContext sslContext = SSLContext . getInstance ( " TLS " ) ; sslContext . init ( keyManagerFactory . getKeyManagers ( ) , tmf . getTrustManagers ( ) , new SecureRandom ( ) ) ; return Optional . of ( sslContext ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return Optional . empty ( ) ; } }
anilgursel/squbs | @ AfterClass public static void afterAll ( ) { serverBinding . unbind ( ) . thenAccept ( u -> system . terminate ( ) ) ; }
intrack/BoofCV-master | public static void main ( String args [ ] ) { ShowLensDistortion < ImageUInt8 > app = new ShowLensDistortion < ImageUInt8 > ( ImageUInt8 . class ) ; List < PathLabel > inputs = new ArrayList < PathLabel > ( ) ; inputs . add ( new PathLabel ( " shapes " , " . . / data / evaluation / shapes01 . png " ) ) ; inputs . add ( new PathLabel ( " beach " , " . . / data / evaluation / scale / beach02 . jpg " ) ) ; inputs . add ( new PathLabel ( " sunflowers " , " . . / data / evaluation / sunflowers . png " ) ) ; app . setInputList ( inputs ) ; while ( ! app . getHasProcessedImage ( ) ) { Thread . yield ( ) ; } ShowImages . showWindow ( app , " Lens ▁ Distortion " ) ; }
ivakegg/accumulo | @ Parameters public static Object [ ] [ ] parameters ( ) { IteratorTestInput input = getIteratorInput ( ) ; IteratorTestOutput output = getIteratorOutput ( ) ; List < IteratorTestCase > tests = IteratorTestCaseFinder . findAllTestCases ( ) ; return BaseJUnit4IteratorTest . createParameters ( input , output , tests ) ; }
ivakegg/accumulo | private static TreeMap < Key , Value > createInputData ( ) { TreeMap < Key , Value > data = new TreeMap < > ( ) ; data . put ( new Key ( "1" , " a " , " a " , 1 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " a " , 5 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " a " , 10 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " b " , 1 ) , new Value ( bytes ( "5" ) ) ) ; data . put ( new Key ( "1" , " a " , " b " , 5 ) , new Value ( bytes ( "2" ) ) ) ; data . put ( new Key ( "1" , " a " , " f " , 1 ) , new Value ( bytes ( "0" ) ) ) ; data . put ( new Key ( "1" , " a " , " g " , 5 ) , new Value ( bytes ( "1" ) ) ) ; data . put ( new Key ( "1" , " a " , " g " , 10 ) , new Value ( bytes ( " - 11" ) ) ) ; data . put ( new Key ( "1" , " b " , " d " , 10 ) , new Value ( bytes ( " - 5" ) ) ) ; data . put ( new Key ( "1" , " b " , " e " , 10 ) , new Value ( bytes ( Long . toString ( Long . MAX_VALUE ) ) ) ) ; data . put ( new Key ( "1" , " d " , " d " , 10 ) , new Value ( bytes ( Long . toString ( Long . MIN_VALUE ) ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 1 ) , new Value ( bytes ( "5" ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 5 ) , new Value ( bytes ( "10" ) ) ) ; data . put ( new Key ( "2" , " a " , " a " , 10 ) , new Value ( bytes ( "15" ) ) ) ; return data ; }
ivakegg/accumulo | private static final byte [ ] bytes ( String value ) { return requireNonNull ( value ) . getBytes ( UTF_8 ) ; }
ivakegg/accumulo | private static TreeMap < Key , Value > createOutputData ( ) { TreeMap < Key , Value > data = new TreeMap < > ( ) ; Key lastKey = null ; long sum = 0 ; for ( Entry < Key , Value > entry : INPUT_DATA . entrySet ( ) ) { if ( null == lastKey ) { lastKey = entry . getKey ( ) ; sum += Long . parseLong ( entry . getValue ( ) . toString ( ) ) ; } else { if ( 0 != lastKey . compareTo ( entry . getKey ( ) , PartialKey . ROW_COLFAM_COLQUAL_COLVIS ) ) { data . put ( lastKey , new Value ( Long . toString ( sum ) ) ) ; lastKey = entry . getKey ( ) ; sum = 0 ; } sum += Long . parseLong ( entry . getValue ( ) . toString ( ) ) ; } } data . put ( lastKey , new Value ( Long . toString ( sum ) ) ) ; return data ; }
ivakegg/accumulo | private static IteratorTestInput getIteratorInput ( ) { IteratorSetting setting = new IteratorSetting ( 50 , SummingCombiner . class ) ; LongCombiner . setEncodingType ( setting , LongCombiner . Type . STRING ) ; Combiner . setCombineAllColumns ( setting , true ) ; return new IteratorTestInput ( SummingCombiner . class , setting . getOptions ( ) , new Range ( ) , INPUT_DATA ) ; }
ivakegg/accumulo | private static IteratorTestOutput getIteratorOutput ( ) { return new IteratorTestOutput ( OUTPUT_DATA ) ; }
mingjian2049/zstack | public static void generateDocTemplate ( String path , DocumentGenerator . DocMode mode ) { DocumentGenerator rg = GroovyUtils . newInstance ( " scripts / RestDocumentationGenerator . groovy " ) ; rg . generateDocTemplates ( path , mode ) ; }
mingjian2049/zstack | public static void generateMarkdownDoc ( String path ) { DocumentGenerator rg = GroovyUtils . newInstance ( " scripts / RestDocumentationGenerator . groovy " ) ; rg . generateMarkDown ( path , PathUtil . join ( System . getProperty ( " user . home " ) , " zstack - markdown " ) ) ; }
mingjian2049/zstack | public static void generateJavaSdk ( ) { String path = PathUtil . join ( System . getProperty ( " user . home " ) , " zstack - sdk / java " ) ; File folder = new File ( path ) ; if ( ! folder . exists ( ) ) { folder . mkdirs ( ) ; } try { Class clz = GroovyUtils . getClass ( " scripts / SdkApiTemplate . groovy " , RestServer . class . getClassLoader ( ) ) ; Set < Class < ? > > apiClasses = Platform . getReflections ( ) . getTypesAnnotatedWith ( RestRequest . class ) . stream ( ) . filter ( it -> it . isAnnotationPresent ( RestRequest . class ) ) . collect ( Collectors . toSet ( ) ) ; List < SdkFile > allFiles = new ArrayList < > ( ) ; for ( Class apiClz : apiClasses ) { if ( Modifier . isAbstract ( apiClz . getModifiers ( ) ) ) { continue ; } SdkTemplate tmp = ( SdkTemplate ) clz . getConstructor ( Class . class ) . newInstance ( apiClz ) ; allFiles . addAll ( tmp . generate ( ) ) ; } SdkTemplate tmp = GroovyUtils . newInstance ( " scripts / SdkDataStructureGenerator . groovy " , RestServer . class . getClassLoader ( ) ) ; allFiles . addAll ( tmp . generate ( ) ) ; for ( SdkFile f : allFiles ) { String fpath = PathUtil . join ( path , f . getFileName ( ) ) ; FileUtils . writeStringToFile ( new File ( fpath ) , f . getContent ( ) ) ; } } catch ( Exception e ) { logger . warn ( e . getMessage ( ) , e ) ; throw new CloudRuntimeException ( e ) ; } }
PG85/OpenTerrainGenerator | static PlottedChunksRegion getFilledRegion ( ) { boolean [ ] [ ] plottedChunks = new boolean [ Constants . REGION_SIZE ] [ Constants . REGION_SIZE ] ; for ( int i = 0 ; i < Constants . REGION_SIZE ; i ++ ) { Arrays . fill ( plottedChunks [ i ] , true ) ; } return new PlottedChunksRegion ( plottedChunks ) ; }
vam-google/google-cloud-java | public static void main ( String args [ ] ) { Logger . getLogger ( " " ) . setLevel ( Level . WARNING ) ; try { executeNoCatch ( getProjectId ( ) ) ; System . out . println ( " OK " ) ; } catch ( Exception e ) { System . err . println ( " Failed ▁ with ▁ exception : " ) ; e . printStackTrace ( System . err ) ; System . exit ( 1 ) ; } }
vam-google/google-cloud-java | public static void executeNoCatch ( String projectId ) throws Exception { try ( ClusterControllerClient client = ClusterControllerClient . create ( ) ) { String projectId2 = projectId ; String region = " global " ; ListClustersPagedResponse pagedResponse = client . listClusters ( projectId2 , region ) ; } }
vam-google/google-cloud-java | private static String getProjectId ( ) { String projectId = System . getProperty ( PROJECT_ENV_NAME , System . getenv ( PROJECT_ENV_NAME ) ) ; if ( projectId == null ) { projectId = System . getProperty ( LEGACY_PROJECT_ENV_NAME , System . getenv ( LEGACY_PROJECT_ENV_NAME ) ) ; } Preconditions . checkArgument ( projectId != null , " A ▁ project ▁ ID ▁ is ▁ required . " ) ; return projectId ; }
suntion/suns_build | private static final byte [ ] getByteKey ( Serializable sessionId ) { String keys = ConstantsShiro . SHIRO_CACHE_SESSION + " : " + sessionId . toString ( ) ; return keys . getBytes ( ) ; }
suntion/suns_build | private static final String getStringKey ( byte [ ] keyByte ) { try { return new String ( keyByte , " UTF - 8" ) ; } catch ( UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } return null ; }
suntion/suns_build | private static final String getHourMinuteSecend ( long l ) { long secend = l / 1000 ; long hour = secend / 3600 ; long minute = ( secend - ( 3600 * hour ) ) / 60 ; secend = secend - ( hour * 60 * 60 ) - ( minute * 60 ) ; return " [ ▁ " + hour + " ▁ hour , ▁ " + minute + " ▁ minute , ▁ " + secend + " ▁ secend ▁ ] " ; }
thorinii/PacAndroid | public static Level makeBlankLevel ( ) { Level l = new Level ( ) ; fillGrid ( l . getGrid ( ) , Grid . GRID_WALL ) ; return l ; }
thorinii/PacAndroid | private static void fillGrid ( Grid g , int type ) { for ( int i = 0 ; i < g . getWidth ( ) ; i ++ ) { for ( int j = 0 ; j < g . getHeight ( ) ; j ++ ) { g . set ( i , j , type ) ; } } }
glameyzhou/training | public static void main ( String [ ] args ) { TreeNode tree = generate ( ) ; int [ ] postOrder = getPostOrder ( tree ) ; boolean verifyBSTPostOrder = verifyBSTPostOrder ( postOrder ) ; System . out . println ( verifyBSTPostOrder ) ; }
glameyzhou/training | private static TreeNode generate ( ) { TreeNode t6 = new TreeNode ( 6 ) ; TreeNode t9 = new TreeNode ( 9 ) ; TreeNode t8 = new TreeNode ( 8 ) ; t8 . left = t6 ; t8 . right = t9 ; TreeNode t13 = new TreeNode ( 13 ) ; TreeNode t11 = new TreeNode ( 11 ) ; t11 . right = t13 ; TreeNode root = new TreeNode ( 10 ) ; root . left = t8 ; root . right = t11 ; return root ; }
glameyzhou/training | private static int [ ] getPostOrder ( TreeNode root ) { List < Integer > list = new ArrayList < > ( ) ; getPostOrderByRecursion ( root , list ) ; return list . stream ( ) . mapToInt ( Integer :: intValue ) . toArray ( ) ; }
glameyzhou/training | private static void getPostOrderByRecursion ( TreeNode root , List < Integer > list ) { if ( root == null ) { return ; } getPostOrderByRecursion ( root . left , list ) ; getPostOrderByRecursion ( root . right , list ) ; list . add ( root . val ) ; }
glameyzhou/training | private static boolean verifyBSTPostOrder ( int [ ] nums ) { if ( nums == null || nums . length == 0 ) { return false ; } if ( nums . length == 1 ) { return true ; } return process ( nums , 0 , nums . length - 1 ) ; }
glameyzhou/training | private static boolean process ( int [ ] nums , int start , int end ) { if ( start >= end ) { return true ; } int rootVal = nums [ end ] ; int i = start ; while ( nums [ i ] < rootVal ) { i ++ ; } int j = end - 1 ; while ( nums [ j ] > rootVal ) { j ++ ; } return process ( nums , start , i - 1 ) && process ( nums , j , end - 1 ) ; }
BadWaka/SmallDianPing | public static void init ( Context context ) { if ( cameraManager == null ) { cameraManager = new CameraManager ( context ) ; } }
BadWaka/SmallDianPing | public static CameraManager get ( ) { return cameraManager ; }
lwd1815/Transition | public static FourFragment getInstance ( ) { FourFragment fragment = new FourFragment ( ) ; Bundle args = new Bundle ( ) ; fragment . setArguments ( args ) ; return fragment ; }
artem-aliev/tinkerpop | private static GraphTraversal < Vertex , Long > getTraversalWithLambda ( final GraphTraversalSource g ) { assumeThat ( " This ▁ test ▁ is ▁ not ▁ enabled ▁ for ▁ this ▁ ScriptEngine : ▁ " + ENGINE_TO_TEST , ENGINE_TO_TEST , anyOf ( is ( " gremlin - python " ) , is ( " gremlin - jython " ) , is ( " gremlin - groovy " ) ) ) ; if ( ENGINE_TO_TEST . equals ( " gremlin - groovy " ) ) return g . V ( ) . out ( " created " ) . map ( Lambda . function ( " { x ▁ - > ▁ x . get ( ) . values ( ' name ' ) } " ) ) . count ( ) ; else if ( ENGINE_TO_TEST . equals ( " gremlin - python " ) || ENGINE_TO_TEST . equals ( " gremlin - jython " ) ) return g . V ( ) . out ( " created " ) . map ( Lambda . function ( " x ▁ : ▁ x . get ( ) . values ( ' name ' ) " ) ) . count ( ) ; else throw new RuntimeException ( " The ▁ " + ENGINE_TO_TEST + " ▁ ScriptEngine ▁ is ▁ not ▁ supported ▁ by ▁ this ▁ test " ) ; }
artem-aliev/tinkerpop | private static void assertTraversals ( final GraphTraversal t , final Traversal evald ) { final List < Step > steps = t . asAdmin ( ) . getSteps ( ) ; for ( int ix = 0 ; ix < steps . size ( ) ; ix ++ ) { assertEquals ( steps . get ( ix ) . getClass ( ) , evald . asAdmin ( ) . getSteps ( ) . get ( ix ) . getClass ( ) ) ; } }
flipkart-incubator/Poseidon | public static void main ( String [ ] args ) { try { final String customValidatorClass = System . getProperty ( " poseidon . validator . block . custom " ) ; CustomBlocksValidator customValidator = null ; if ( StringUtils . isNotEmpty ( customValidatorClass ) ) { try { final Class < ? > aClass = Class . forName ( customValidatorClass ) ; final Object constructedInstance = aClass . newInstance ( ) ; if ( constructedInstance instanceof CustomBlocksValidator ) { customValidator = ( CustomBlocksValidator ) constructedInstance ; } else { throw new IllegalArgumentException ( " Wrong ▁ class ▁ supplied " ) ; } } catch ( Exception e ) { logger . error ( " Wrong ▁ CustomBlockValidator ▁ passed " , e ) ; System . exit ( - 1 ) ; } } Set < ClassPath . ClassInfo > classInfos = ClassPathHelper . getPackageClasses ( Thread . currentThread ( ) . getContextClassLoader ( ) , Arrays . asList ( args ) ) ; System . out . println ( " Classes ▁ in ▁ ClassLoader : ▁ " + classInfos . size ( ) ) ; Map < String , List < String > > errors = new HashMap < > ( ) ; for ( ClassPath . ClassInfo classInfo : classInfos ) { Class < ? extends DataSource < ? > > clazz = ( Class < ? extends DataSource < ? > > ) Class . forName ( classInfo . getName ( ) ) ; if ( Modifier . isAbstract ( clazz . getModifiers ( ) ) ) { continue ; } final List < String > classErrors = new ArrayList < > ( ) ; if ( DataSource . class . isAssignableFrom ( clazz ) ) { classErrors . addAll ( AnnotationValidator . validateDataSource ( clazz ) ) ; classErrors . addAll ( DatasourceValidator . validate ( clazz ) ) ; if ( customValidator != null ) { classErrors . addAll ( customValidator . validateDatasource ( clazz ) ) ; } } if ( ! classErrors . isEmpty ( ) ) { errors . put ( clazz . getName ( ) , classErrors ) ; } } if ( ! errors . isEmpty ( ) ) { logger . error ( ValidatorUtils . getFormattedErrorMessages ( errors ) ) ; System . exit ( - 1 ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
facebook/presto | public static TestingPrivilege privilege ( String entityName , TestingPrivilegeType type ) { return new TestingPrivilege ( Optional . empty ( ) , entityName , type ) ; }
facebook/presto | public static TestingPrivilege privilege ( String userName , String entityName , TestingPrivilegeType type ) { return new TestingPrivilege ( Optional . of ( userName ) , entityName , type ) ; }
KiviMao/kivi | public static void createTestJar ( File file ) throws Exception { createTestJar ( file , false ) ; }
KiviMao/kivi | public static void createTestJar ( File file , boolean unpackNested ) throws Exception { FileOutputStream fileOutputStream = new FileOutputStream ( file ) ; try ( JarOutputStream jarOutputStream = new JarOutputStream ( fileOutputStream ) ) { writeManifest ( jarOutputStream , " j1" ) ; writeEntry ( jarOutputStream , "1 . dat " , 1 ) ; writeEntry ( jarOutputStream , "2 . dat " , 2 ) ; writeDirEntry ( jarOutputStream , " d / " ) ; writeEntry ( jarOutputStream , " d / 9 . dat " , 9 ) ; writeDirEntry ( jarOutputStream , " special / " ) ; writeEntry ( jarOutputStream , " special / \u00EB . dat " , ' \u00EB ' ) ; writeNestedEntry ( " nested . jar " , unpackNested , jarOutputStream ) ; writeNestedEntry ( " another - nested . jar " , unpackNested , jarOutputStream ) ; } }
KiviMao/kivi | private static byte [ ] getNestedJarData ( ) throws Exception { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; JarOutputStream jarOutputStream = new JarOutputStream ( byteArrayOutputStream ) ; writeManifest ( jarOutputStream , " j2" ) ; writeEntry ( jarOutputStream , "3 . dat " , 3 ) ; writeEntry ( jarOutputStream , "4 . dat " , 4 ) ; writeEntry ( jarOutputStream , " \u00E4 . dat " , ' \u00E4' ) ; jarOutputStream . close ( ) ; return byteArrayOutputStream . toByteArray ( ) ; }
KiviMao/kivi | private static void writeManifest ( JarOutputStream jarOutputStream , String name ) throws Exception { writeDirEntry ( jarOutputStream , " META - INF / " ) ; Manifest manifest = new Manifest ( ) ; manifest . getMainAttributes ( ) . putValue ( " Built - By " , name ) ; manifest . getMainAttributes ( ) . put ( Attributes . Name . MANIFEST_VERSION , "1.0" ) ; jarOutputStream . putNextEntry ( new ZipEntry ( " META - INF / MANIFEST . MF " ) ) ; manifest . write ( jarOutputStream ) ; jarOutputStream . closeEntry ( ) ; }
KiviMao/kivi | private static void writeDirEntry ( JarOutputStream jarOutputStream , String name ) throws IOException { jarOutputStream . putNextEntry ( new JarEntry ( name ) ) ; jarOutputStream . closeEntry ( ) ; }
KiviMao/kivi | private static void writeEntry ( JarOutputStream jarOutputStream , String name , int data ) throws IOException { jarOutputStream . putNextEntry ( new JarEntry ( name ) ) ; jarOutputStream . write ( new byte [ ] { ( byte ) data } ) ; jarOutputStream . closeEntry ( ) ; }
markzhai/InterestingTitleBar | public static String get ( String key , String defValue ) { if ( TextUtils . isEmpty ( key ) ) { return defValue ; } String value = getWithReflect ( key , null ) ; if ( TextUtils . isEmpty ( value ) ) { value = getWithCmd ( key , null ) ; } if ( TextUtils . isEmpty ( value ) ) { value = defValue ; } return value ; }
markzhai/InterestingTitleBar | public static String getQuickly ( String key , String defValue ) { if ( TextUtils . isEmpty ( key ) ) { return defValue ; } return getWithReflect ( key , defValue ) ; }
markzhai/InterestingTitleBar | private static String getWithReflect ( String key , String defValue ) { if ( sClassSystemProperties == null || sMethodGetString == null ) { return defValue ; } String value = defValue ; try { value = ( String ) sMethodGetString . invoke ( sClassSystemProperties , key , defValue ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } return value ; }
markzhai/InterestingTitleBar | private static String getWithCmd ( String key , String defValue ) { String value = defValue ; try { Process process = Runtime . getRuntime ( ) . exec ( CMD_GET_PROP + " ▁ " + key ) ; BufferedReader reader = null ; try { reader = new BufferedReader ( new InputStreamReader ( process . getInputStream ( ) ) ) ; StringBuilder builder = new StringBuilder ( ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { builder . append ( line ) ; } String readValue = builder . toString ( ) ; if ( ! TextUtils . isEmpty ( readValue ) ) { value = readValue ; } } catch ( IOException e ) { } finally { if ( reader != null ) { reader . close ( ) ; } } process . destroy ( ) ; } catch ( Throwable e ) { e . printStackTrace ( ) ; } return value ; }
11xor6/presto | public static String getSimplifiedDomainString ( long low , long high , int rangeCount , Type type ) { String formattedValues ; if ( rangeCount == 1 ) { formattedValues = format ( " { [ % d ] } " , low ) ; } else if ( rangeCount == 2 ) { formattedValues = LongStream . of ( low , high ) . mapToObj ( value -> " [ " + value + " ] " ) . collect ( Collectors . joining ( " , ▁ " , " { " , " } " ) ) ; } else { formattedValues = format ( " { [ % d ] , ▁ . . . , ▁ [ % d ] } " , low , high ) ; } return " [ ▁ " + new StringJoiner ( " , ▁ " , SortedRangeSet . class . getSimpleName ( ) + " [ " , " ] " ) . add ( " type = " + type ) . add ( " ranges = " + rangeCount ) . add ( formattedValues ) + " ▁ ] " ; }
FAU-Inf2/spongycastle | public static OCSPResponse getInstance ( ASN1TaggedObject obj , boolean explicit ) { return getInstance ( ASN1Sequence . getInstance ( obj , explicit ) ) ; }
FAU-Inf2/spongycastle | public static OCSPResponse getInstance ( Object obj ) { if ( obj instanceof OCSPResponse ) { return ( OCSPResponse ) obj ; } else if ( obj != null ) { return new OCSPResponse ( ASN1Sequence . getInstance ( obj ) ) ; } return null ; }
JIGAsoftSTP/NICON | public static ArrayList < String > likeStart ( List < String > list , String like ) { if ( like == null || list == null ) return null ; ArrayList < String > likeList = new ArrayList < > ( ) ; if ( like . length ( ) == 0 ) { likeList . addAll ( list ) ; return likeList ; } String aux ; for ( String s : list ) { aux = s ; if ( s . length ( ) >= like . length ( ) ) { s = s . substring ( 0 , like . length ( ) ) ; if ( s . toUpperCase ( ) . contains ( like . toUpperCase ( ) ) ) { likeList . add ( aux ) ; } } } return likeList ; }
x-meta/xworker | public static void doAction ( ActionContext actionContext ) throws IOException { World world = World . getInstance ( ) ; HttpServletRequest request = ( HttpServletRequest ) actionContext . get ( " request " ) ; String dataObjectPath = request . getParameter ( " dataObjectPath " ) ; Thing dataObjectConfig = world . getThing ( dataObjectPath ) ; if ( ! SecurityManager . doCheck ( " WEB " , PermissionConstants . XWORKER_DATAOBJECT , " read " , dataObjectPath , actionContext ) ) { return ; } String record = " { } " ; Map < String , Object > result = UtilMap . toMap ( new Object [ ] { " success " , " true " , " msg " , " " } ) ; actionContext . peek ( ) . put ( " result " , result ) ; if ( dataObjectConfig == null ) { result . put ( " success " , " false " ) ; result . put ( " msg " , " 数据对象定义不存在 ， dataObject = " + request . getParameter ( " dataObjectPath " ) ) ; } else { try { DataObject theData = new DataObject ( dataObjectConfig ) ; Thing keyThing = ( Thing ) theData . getKeyAndDatas ( ) [ 0 ] [ 0 ] ; theData . put ( keyThing . getString ( " name " ) , request . getParameter ( " id " ) ) ; theData . doAction ( " load " , actionContext ) ; Thing jsonFactory = world . getThing ( " xworker . text . JsonDataFormat " ) ; record = ( String ) jsonFactory . doAction ( " format " , actionContext , UtilMap . toMap ( new Object [ ] { " data " , theData } ) ) ; if ( result . get ( " msg " ) == null ) { result . put ( " msg " , " 数据读取成功 " ) ; } } catch ( Exception e ) { Executor . error ( TAG , " 数据读取失败 " , e ) ; result . put ( " success " , " false " ) ; result . put ( " msg " , JsonFormator . formatString ( ExceptionUtil . getRootMessage ( e ) ) ) ; } } HttpServletResponse response = ( HttpServletResponse ) actionContext . get ( " response " ) ; if ( ServletFileUpload . isMultipartContent ( request ) ) { response . setContentType ( " text / html ; ▁ charset = utf - 8" ) ; } else { response . setContentType ( " text / plain ; ▁ charset = utf - 8" ) ; } String code = " { \n " + " \" success \" : " + result . get ( " success " ) + " , \n " + " \" msg \" : \" " + result . get ( " msg " ) + " \" , \n " + " \" data \" : " + record + " \n " + " } " ; response . getWriter ( ) . println ( code ) ; }
Venryx/LucidLink | public static int [ ] readBioData ( byte [ ] decobbed ) { int [ ] bioBytes = new int [ 2 ] ; if ( decobbed . length > 1 ) { bioBytes [ 0 ] = decobbed [ 0 ] & MotionEventCompat . ACTION_MASK ; bioBytes [ 0 ] = bioBytes [ 0 ] | ( ( decobbed [ 1 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ; if ( decobbed . length > 3 ) { bioBytes [ 1 ] = decobbed [ 2 ] & MotionEventCompat . ACTION_MASK ; bioBytes [ 1 ] = ( decobbed [ 3 ] & MotionEventCompat . ACTION_MASK ) << 8 ; } } return bioBytes ; }
Venryx/LucidLink | public static int [ ] [ ] readBioData ( byte [ ] decobbed , int packetSize ) { int [ ] [ ] tempChannelData = ( int [ ] [ ] ) Array . newInstance ( Integer . TYPE , new int [ ] { 2 , packetSize - 8 } ) ; int indexSamples = 0 ; int nrBytesToIgnore = 0 ; for ( int j = decobbed . length - 1 ; j >= 0 ; j -- ) { nrBytesToIgnore ++ ; if ( decobbed [ j ] != ( byte ) 0 ) { break ; } } int i = 0 ; while ( i < decobbed . length - nrBytesToIgnore ) { int bioMQValue = 0 ; try { int bioMIValue = ( decobbed [ i ] & MotionEventCompat . ACTION_MASK ) | ( ( decobbed [ i + 1 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ; if ( decobbed . length > i + 2 && decobbed . length > i + 3 ) { bioMQValue = ( decobbed [ i + 2 ] & MotionEventCompat . ACTION_MASK ) | ( ( decobbed [ i + 3 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ; } tempChannelData [ 0 ] [ indexSamples ] = bioMIValue ; tempChannelData [ 1 ] [ indexSamples ] = bioMQValue ; if ( ! ( bioMIValue == BIO_IGNORE_PATTERN || bioMQValue == BIO_IGNORE_PATTERN ) ) { indexSamples ++ ; } } catch ( ArrayIndexOutOfBoundsException e ) { e . printStackTrace ( ) ; } i += 4 ; } int [ ] [ ] validSamples = ( int [ ] [ ] ) Array . newInstance ( Integer . TYPE , new int [ ] { 2 , indexSamples } ) ; for ( i = 0 ; i < indexSamples ; i ++ ) { validSamples [ 0 ] [ i ] = tempChannelData [ 0 ] [ i ] ; validSamples [ 1 ] [ i ] = tempChannelData [ 1 ] [ i ] ; } return validSamples ; }
Venryx/LucidLink | public static int getStoreLocalEnv ( byte [ ] bytes ) { if ( bytes . length > 7 ) { return ( ( ( bytes [ 4 ] & MotionEventCompat . ACTION_MASK ) | ( ( bytes [ 5 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ) | ( ( bytes [ 6 ] & MotionEventCompat . ACTION_MASK ) << 16 ) ) | ( ( bytes [ 7 ] & MotionEventCompat . ACTION_MASK ) << 24 ) ; } return 0 ; }
Venryx/LucidLink | public static int getStoreLocalBio ( byte [ ] bytes ) { if ( bytes . length > 7 ) { return ( ( ( bytes [ 0 ] & MotionEventCompat . ACTION_MASK ) | ( ( bytes [ 1 ] & MotionEventCompat . ACTION_MASK ) << 8 ) ) | ( ( bytes [ 2 ] & MotionEventCompat . ACTION_MASK ) << 16 ) ) | ( ( bytes [ 3 ] & MotionEventCompat . ACTION_MASK ) << 24 ) ; } return 0 ; }
Venryx/LucidLink | public static int readIlluminanceValue ( byte [ ] bytes ) { if ( bytes . length < 2 ) { return 0 ; } return decompress_light ( bytes [ 1 ] & MotionEventCompat . ACTION_MASK ) ; }
Venryx/LucidLink | public static float readTemperatureValue ( byte [ ] bytes ) { if ( bytes . length > 0 ) { return ( ( float ) ( bytes [ 0 ] & MotionEventCompat . ACTION_MASK ) ) / 4.0f ; } return 0.0f ; }
Venryx/LucidLink | public static float [ ] readTemperatureValues ( byte [ ] bytes ) { List < Byte > bList = new ArrayList ( ) ; int i = 0 ; while ( i < bytes . length ) { if ( i % 2 == 0 && ( bytes [ i ] & MotionEventCompat . ACTION_MASK ) != 250 ) { bList . add ( Byte . valueOf ( bytes [ i ] ) ) ; } i ++ ; } float [ ] bArray = new float [ bList . size ( ) ] ; for ( int x = 0 ; x < bList . size ( ) ; x ++ ) { bArray [ x ] = ( ( float ) ( ( ( Byte ) bList . get ( x ) ) . byteValue ( ) & MotionEventCompat . ACTION_MASK ) ) / 4.0f ; } return bArray ; }
Venryx/LucidLink | public static int [ ] readIlluminanceValues ( byte [ ] bytes ) { List < Byte > bList = new ArrayList ( ) ; int i = 0 ; while ( i < bytes . length ) { if ( ! ( i % 2 == 0 || ( bytes [ i ] & MotionEventCompat . ACTION_MASK ) == 250 ) ) { bList . add ( Byte . valueOf ( bytes [ i ] ) ) ; } i ++ ; } int [ ] bArray = new int [ bList . size ( ) ] ; for ( int x = 0 ; x < bList . size ( ) ; x ++ ) { bArray [ x ] = Math . round ( ( float ) ( ( ( Byte ) bList . get ( x ) ) . byteValue ( ) & MotionEventCompat . ACTION_MASK ) ) ; } return bArray ; }
Venryx/LucidLink | public static void saveToEDF ( byte [ ] decobbed , FileOutputStream output ) { try { output . write ( decobbed ) ; output . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
Venryx/LucidLink | public static int decompress_light ( int input ) { if ( input < 64 ) { return input ; } if ( input < 96 ) { return ( ( input - 64 ) * 2 ) + 64 ; } if ( input < 128 ) { return ( ( input - 96 ) * 4 ) + 128 ; } if ( input < 160 ) { return ( ( input - 128 ) * 8 ) + 256 ; } if ( input < 192 ) { return ( ( input - 160 ) * 16 ) + 512 ; } if ( input < 240 ) { return ( ( input - 192 ) * 64 ) + 1024 ; } if ( input < 255 ) { return ( ( input - 240 ) * 128 ) + 4096 ; } return 6000 ; }
Nexmo/nexmo-java-sdk | public static PricingResponse fromJson ( String json ) { try { return new ObjectMapper ( ) . readValue ( json , PricingResponse . class ) ; } catch ( IOException jpe ) { throw new VonageUnexpectedException ( " Failed ▁ to ▁ produce ▁ PricingResponse ▁ from ▁ json . " , jpe ) ; } }
cdeange/WKRPTapp | private static < T > T get ( final RequestFuture < T > future ) throws IOException { T response ; try { response = future . get ( ) ; } catch ( final Exception e ) { throw new IOException ( e ) ; } return response ; }
eschwert/ontop | public static void main ( String [ ] args ) { try { ABoxMaterializerExample example = new ABoxMaterializerExample ( ) ; example . generateTriples ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } }
jjculber/defcoinj | public static synchronized TestNet3Params get ( ) { if ( instance == null ) { instance = new TestNet3Params ( ) ; } return instance ; }
kiall/ExoPlayer | @ SuppressLint ( " InlinedApi " ) @ TargetApi ( 16 ) private static void testConversionToFrameworkMediaFormatV16 ( Format in ) { MediaFormat out = in . getFrameworkMediaFormatV16 ( ) ; assertThat ( out . getString ( MediaFormat . KEY_MIME ) ) . isEqualTo ( in . sampleMimeType ) ; assertOptionalV16 ( out , MediaFormat . KEY_LANGUAGE , in . language ) ; assertOptionalV16 ( out , MediaFormat . KEY_MAX_INPUT_SIZE , in . maxInputSize ) ; assertOptionalV16 ( out , MediaFormat . KEY_WIDTH , in . width ) ; assertOptionalV16 ( out , MediaFormat . KEY_HEIGHT , in . height ) ; assertOptionalV16 ( out , MediaFormat . KEY_CHANNEL_COUNT , in . channelCount ) ; assertOptionalV16 ( out , MediaFormat . KEY_SAMPLE_RATE , in . sampleRate ) ; assertOptionalV16 ( out , MediaFormat . KEY_FRAME_RATE , in . frameRate ) ; for ( int i = 0 ; i < in . initializationData . size ( ) ; i ++ ) { byte [ ] originalData = in . initializationData . get ( i ) ; ByteBuffer frameworkBuffer = out . getByteBuffer ( " csd - " + i ) ; byte [ ] frameworkData = Arrays . copyOf ( frameworkBuffer . array ( ) , frameworkBuffer . limit ( ) ) ; assertThat ( frameworkData ) . isEqualTo ( originalData ) ; } }
kiall/ExoPlayer | @ TargetApi ( 16 ) private static void assertOptionalV16 ( MediaFormat format , String key , String value ) { if ( value == null ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getString ( key ) ) . isEqualTo ( value ) ; } }
kiall/ExoPlayer | @ TargetApi ( 16 ) private static void assertOptionalV16 ( MediaFormat format , String key , int value ) { if ( value == Format . NO_VALUE ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getInteger ( key ) ) . isEqualTo ( value ) ; } }
kiall/ExoPlayer | @ TargetApi ( 16 ) private static void assertOptionalV16 ( MediaFormat format , String key , float value ) { if ( value == Format . NO_VALUE ) { assertThat ( format . containsKey ( key ) ) . isEqualTo ( false ) ; } else { assertThat ( format . getFloat ( key ) ) . isEqualTo ( value ) ; } }
jk1/intellij-community | @ NotNull private static Collection < FoldingDescriptor > getCustomFoldingDescriptors ( @ NotNull Editor editor , @ NotNull Project project ) { Set < FoldingDescriptor > foldingDescriptors = new HashSet < > ( ) ; final Document document = editor . getDocument ( ) ; PsiDocumentManager documentManager = PsiDocumentManager . getInstance ( project ) ; PsiFile file = documentManager != null ? documentManager . getPsiFile ( document ) : null ; if ( file != null ) { final FileViewProvider viewProvider = file . getViewProvider ( ) ; for ( final Language language : viewProvider . getLanguages ( ) ) { final PsiFile psi = viewProvider . getPsi ( language ) ; final FoldingBuilder foldingBuilder = LanguageFolding . INSTANCE . forLanguage ( language ) ; if ( psi != null ) { for ( FoldingDescriptor descriptor : LanguageFolding . buildFoldingDescriptors ( foldingBuilder , psi , document , false ) ) { CustomFoldingBuilder customFoldingBuilder = getCustomFoldingBuilder ( foldingBuilder , descriptor ) ; if ( customFoldingBuilder != null ) { if ( customFoldingBuilder . isCustomRegionStart ( descriptor . getElement ( ) ) ) { foldingDescriptors . add ( descriptor ) ; } } } } } } return foldingDescriptors ; }
jk1/intellij-community | @ Nullable private static CustomFoldingBuilder getCustomFoldingBuilder ( FoldingBuilder builder , FoldingDescriptor descriptor ) { if ( builder instanceof CustomFoldingBuilder ) return ( CustomFoldingBuilder ) builder ; FoldingBuilder originalBuilder = descriptor . getElement ( ) . getUserData ( CompositeFoldingBuilder . FOLDING_BUILDER ) ; if ( originalBuilder instanceof CustomFoldingBuilder ) return ( CustomFoldingBuilder ) originalBuilder ; return null ; }
jk1/intellij-community | private static void notifyCustomRegionsUnavailable ( @ NotNull Editor editor , @ NotNull Project project ) { final JBPopupFactory popupFactory = JBPopupFactory . getInstance ( ) ; Balloon balloon = popupFactory . createHtmlTextBalloonBuilder ( IdeBundle . message ( " goto . custom . region . message . unavailable " ) , MessageType . INFO , null ) . setFadeoutTime ( 2000 ) . setHideOnClickOutside ( true ) . setHideOnKeyOutside ( true ) . createBalloon ( ) ; Disposer . register ( project , balloon ) ; balloon . show ( popupFactory . guessBestPopupLocation ( editor ) , Balloon . Position . below ) ; }
JuntaoZhang/myhadoop-2.2.0 | @ BeforeClass public static void createOriginalFSImage ( ) throws IOException { MiniDFSCluster cluster = null ; try { Configuration conf = new HdfsConfiguration ( ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_MAX_LIFETIME_KEY , 10000 ) ; conf . setLong ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_RENEW_INTERVAL_KEY , 5000 ) ; conf . setBoolean ( DFSConfigKeys . DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY , true ) ; conf . set ( CommonConfigurationKeysPublic . HADOOP_SECURITY_AUTH_TO_LOCAL , " RULE : [2 : $ 1 @ $ 0 ] ( JobTracker @ . * FOO . COM ) s / @ . * // " + " DEFAULT " ) ; cluster = new MiniDFSCluster . Builder ( conf ) . numDataNodes ( 4 ) . build ( ) ; cluster . waitActive ( ) ; FileSystem hdfs = cluster . getFileSystem ( ) ; int filesize = 256 ; for ( int i = 0 ; i < NUM_DIRS ; i ++ ) { Path dir = new Path ( " / dir " + i ) ; hdfs . mkdirs ( dir ) ; writtenFiles . put ( dir . toString ( ) , pathToFileEntry ( hdfs , dir . toString ( ) ) ) ; for ( int j = 0 ; j < FILES_PER_DIR ; j ++ ) { Path file = new Path ( dir , " file " + j ) ; FSDataOutputStream o = hdfs . create ( file ) ; o . write ( new byte [ filesize ++ ] ) ; o . close ( ) ; writtenFiles . put ( file . toString ( ) , pathToFileEntry ( hdfs , file . toString ( ) ) ) ; } } Token < ? > [ ] delegationTokens = hdfs . addDelegationTokens ( TEST_RENEWER , null ) ; for ( Token < ? > t : delegationTokens ) { LOG . debug ( " got ▁ token ▁ " + t ) ; } cluster . getNameNodeRpc ( ) . setSafeMode ( SafeModeAction . SAFEMODE_ENTER , false ) ; cluster . getNameNodeRpc ( ) . saveNamespace ( ) ; originalFsimage = FSImageTestUtil . findLatestImageFile ( FSImageTestUtil . getFSImage ( cluster . getNameNode ( ) ) . getStorage ( ) . getStorageDir ( 0 ) ) ; if ( originalFsimage == null ) { throw new RuntimeException ( " Didn ' t ▁ generate ▁ or ▁ can ' t ▁ find ▁ fsimage " ) ; } LOG . debug ( " original ▁ FS ▁ image ▁ file ▁ is ▁ " + originalFsimage ) ; } finally { if ( cluster != null ) cluster . shutdown ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | @ AfterClass public static void deleteOriginalFSImage ( ) throws IOException { if ( originalFsimage != null && originalFsimage . exists ( ) ) { originalFsimage . delete ( ) ; } }
JuntaoZhang/myhadoop-2.2.0 | private static FileStatus pathToFileEntry ( FileSystem hdfs , String file ) throws IOException { return hdfs . getFileStatus ( new Path ( file ) ) ; }
xiwc/thymeleaf.test | public static boolean isNumber ( String str ) { if ( isEmpty ( str ) ) { return false ; } else { try { Double . parseDouble ( str ) ; return true ; } catch ( Exception e ) { return false ; } } }
xiwc/thymeleaf.test | public static String limitLength ( String str , int i ) { if ( isEmpty ( str ) ) { return " " ; } else { if ( str . length ( ) <= i ) { return str ; } else { return str . substring ( 0 , i - 3 ) + " . . . " ; } } }
xiwc/thymeleaf.test | public static String replace ( String tpl , Object ... vals ) { if ( tpl != null ) { for ( int i = 1 ; i <= vals . length ; i ++ ) { tpl = tpl . replace ( " { ? " + i + " } " , String . valueOf ( vals [ i - 1 ] ) ) ; } } return tpl ; }
xiwc/thymeleaf.test | public static String replaceByMap ( String tpl , Map < String , Object > map ) { if ( tpl != null && map != null && map . size ( ) > 0 ) { for ( String key : map . keySet ( ) ) { tpl = tpl . replace ( " { " + key + " } " , String . valueOf ( map . get ( key ) ) ) ; } } return tpl ; }
xiwc/thymeleaf.test | public static String replaceByKV ( String tpl , Object ... vals ) { Map < String , Object > map = new HashMap < String , Object > ( ) ; for ( int i = 0 ; i < vals . length ; i += 2 ) { if ( i + 1 < vals . length ) { map . put ( String . valueOf ( vals [ i ] ) , vals [ i + 1 ] ) ; } } return replaceByMap ( tpl , map ) ; }
xiwc/thymeleaf.test | public static String join ( String connector , Object ... objects ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( Object object : objects ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String join ( String connector , String [ ] arr ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( Object object : arr ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String join2 ( String connector , String ... strs ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( Object object : strs ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String join ( String connector , List < String > objects ) { StringBuffer sBuffer = new StringBuffer ( ) ; for ( String object : objects ) { sBuffer . append ( object ) . append ( connector ) ; } if ( sBuffer . length ( ) > 0 ) { sBuffer . delete ( sBuffer . length ( ) - connector . length ( ) , sBuffer . length ( ) ) ; } return sBuffer . toString ( ) ; }
xiwc/thymeleaf.test | public static String toString ( Object object ) { return object == null ? EMPTY : object . toString ( ) ; }
xiwc/thymeleaf.test | public static String getString ( Map < String , Object > map , String key ) { if ( map == null || ! map . containsKey ( key ) ) { return null ; } return toString ( map . get ( key ) ) ; }
xiwc/thymeleaf.test | public static String getNotNullString ( Map < String , Object > map , String key ) { if ( map == null || ! map . containsKey ( key ) ) { return EMPTY ; } return toString ( map . get ( key ) ) ; }
xiwc/thymeleaf.test | public static boolean isEmpty ( Object str ) { return str == null || str . equals ( EMPTY ) ; }
xiwc/thymeleaf.test | public static boolean isNotEmpty ( Object str ) { return ! isEmpty ( str ) ; }
xiwc/thymeleaf.test | public static boolean isValid ( String str ) { return ! isEmpty ( str ) ; }
xiwc/thymeleaf.test | public static List < String > array2List ( String ... values ) { List < String > list = new ArrayList < String > ( ) ; for ( String value : values ) { list . add ( value ) ; } return list ; }
xiwc/thymeleaf.test | public static Map < String , Object > array2Map ( Object ... values ) { Map < String , Object > map = new HashMap < > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i += 2 ) { if ( i + 1 < values . length ) { map . put ( String . valueOf ( values [ i ] ) , values [ i + 1 ] ) ; } } } return map ; }
xiwc/thymeleaf.test | public static Map < String , String > stringArr2Map ( String ... values ) { Map < String , String > map = new HashMap < > ( ) ; if ( values . length > 0 ) { for ( int i = 0 ; i < values . length ; i += 2 ) { if ( i + 1 < values . length ) { map . put ( values [ i ] , values [ i + 1 ] ) ; } } } return map ; }
xiwc/thymeleaf.test | public static String [ ] split ( String val , String decollator ) { if ( ! isEmpty ( val ) ) { return val . split ( decollator ) ; } return null ; }
xiwc/thymeleaf.test | public static String [ ] getValues ( Map < String , String > map , String ... keyArr ) { String [ ] objArr = new String [ keyArr . length ] ; if ( keyArr . length > 0 && map != null && map . size ( ) > 0 ) { int i = 0 ; for ( String key : keyArr ) { objArr [ i ++ ] = map . get ( key ) ; } } return objArr ; }
xiwc/thymeleaf.test | public static String html ( String content ) { if ( content == null ) { return " " ; } String html = content ; html = html . replace ( " ' " , " & apos ; " ) ; html = html . replace ( " \" " , " & quot ; " ) ; html = html . replace ( " \t " , " & nbsp ; & nbsp ; " ) ; html = html . replace ( " < " , " & lt ; " ) ; html = html . replace ( " > " , " & gt ; " ) ; return html ; }
scouter-project/scouter | public static String getCountryName ( String code ) { return table . get ( code ) ; }
scouter-project/scouter | public static void main ( String [ ] args ) { System . out . println ( load ( ) ) ; }
scouter-project/scouter | private static Map < String , String > load ( ) { Map < String , String > map = new HashMap < String , String > ( ) ; InputStream in = null ; try { in = CountryCode . class . getResourceAsStream ( " countrycode . txt " ) ; if ( in == null ) return map ; BufferedReader reader = new BufferedReader ( new InputStreamReader ( in ) ) ; String line = reader . readLine ( ) ; while ( line != null ) { String name = line . substring ( 0 , 48 ) . trim ( ) ; String [ ] cd = StringUtil . tokenizer ( line . substring ( 48 ) , " ▁ \t " ) ; map . put ( cd [ 0 ] , name ) ; line = reader . readLine ( ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } finally { FileUtil . close ( in ) ; } return map ; }
Muyangmin/Android-PLog | static String parseActualPath ( Context context , String path ) throws IllegalStateException { String [ ] supportedPath = new String [ ] { DIR_EXT_ROOT , DIR_EXT_FILES , DIR_INT_FILES } ; for ( String s : supportedPath ) { String regex = " ^ " + s . replace ( " $ " , " \\ $ " ) . replace ( " { " , " \\ { " ) . replace ( " } " , " \\ } " ) ; Matcher matcher = Pattern . compile ( regex ) . matcher ( path ) ; if ( ! matcher . find ( ) ) { continue ; } String param = matcher . group ( ) ; String actualPath = null ; switch ( param ) { case DIR_EXT_ROOT : File root = Environment . getExternalStorageDirectory ( ) ; if ( ( ! Environment . MEDIA_MOUNTED . equals ( Environment . getExternalStorageState ( ) ) ) || root == null ) { throw new IllegalStateException ( " External ▁ storage ▁ is ▁ not ▁ available ! " ) ; } actualPath = matcher . replaceFirst ( root . getAbsolutePath ( ) ) ; break ; case DIR_EXT_FILES : File filesDir = context . getExternalFilesDir ( null ) ; if ( filesDir == null ) { throw new IllegalStateException ( " External ▁ storage ▁ is ▁ not ▁ available ! " ) ; } actualPath = matcher . replaceFirst ( filesDir . getAbsolutePath ( ) ) ; break ; case DIR_INT_FILES : actualPath = matcher . replaceFirst ( context . getFilesDir ( ) . getAbsolutePath ( ) ) ; break ; } return actualPath ; } return path ; }
Muyangmin/Android-PLog | @ Nullable static File resolveDirOrCreate ( @ NonNull String path ) throws SecurityException { File file = new File ( path ) ; if ( ! file . exists ( ) && ! file . mkdirs ( ) ) { return null ; } if ( ! file . isDirectory ( ) ) { return null ; } if ( ! file . canRead ( ) || ! file . canWrite ( ) ) { return null ; } return file ; }
Cangol/Cangol-appcore | public static DownloadHttpClient build ( String group ) { return build ( group , true ) ; }
Cangol/Cangol-appcore | public static DownloadHttpClient build ( String group , boolean safe ) { return new DownloadHttpClient ( group , safe ) ; }
Cangol/Cangol-appcore | public static void setThreadPool ( PoolManager . Pool pool ) { threadPool = pool ; }
gfyoung/elasticsearch | private static void validateAliasFilter ( XContentParser parser , QueryShardContext queryShardContext ) throws IOException { QueryBuilder parseInnerQueryBuilder = parseInnerQueryBuilder ( parser ) ; QueryBuilder queryBuilder = Rewriteable . rewrite ( parseInnerQueryBuilder , queryShardContext , true ) ; queryBuilder . toFilter ( queryShardContext ) ; }
whiskeysierra/riptide | private static MappingJackson2HttpMessageConverter createJsonConverter ( ) { final MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter ( ) ; converter . setObjectMapper ( new ObjectMapper ( ) . findAndRegisterModules ( ) . disable ( DeserializationFeature . FAIL_ON_UNKNOWN_PROPERTIES ) ) ; return converter ; }
samuelfac/portalunico.siscomex.gov.br | private static String toIndentedString ( java . lang . Object o ) { if ( o == null ) { return " null " ; } return o . toString ( ) . replace ( " \n " , " \n ▁ ▁ ▁ ▁ " ) ; }
apache/incubator-asterixdb | private static String getComponentFileName ( ) { final String sequence = String . valueOf ( COMPONENT_SEQUENCE ++ ) ; return sequence + ' _ ' + sequence ; }
jasonstack/cassandra | public static < V , F extends Function < V , EncodingStats > > EncodingStats merge ( List < V > values , F function ) { if ( values . size ( ) == 1 ) return function . apply ( values . get ( 0 ) ) ; Collector collector = new Collector ( ) ; for ( int i = 0 , isize = values . size ( ) ; i < isize ; i ++ ) { V v = values . get ( i ) ; EncodingStats stats = function . apply ( v ) ; if ( stats . minTimestamp != TIMESTAMP_EPOCH ) collector . updateTimestamp ( stats . minTimestamp ) ; if ( stats . minLocalDeletionTime != DELETION_TIME_EPOCH ) collector . updateLocalDeletionTime ( stats . minLocalDeletionTime ) ; if ( stats . minTTL != TTL_EPOCH ) collector . updateTTL ( stats . minTTL ) ; } return collector . get ( ) ; }
jasonstack/cassandra | public static EncodingStats collect ( Row staticRow , Iterator < Row > rows , DeletionInfo deletionInfo ) { Collector collector = new Collector ( ) ; deletionInfo . collectStats ( collector ) ; if ( ! staticRow . isEmpty ( ) ) Rows . collectStats ( staticRow , collector ) ; while ( rows . hasNext ( ) ) Rows . collectStats ( rows . next ( ) , collector ) ; return collector . get ( ) ; }
jmockit/jmockit2 | @ Nonnull private static String getGenericClassSignature ( @ Nonnull Type mockedType ) { StringBuilder signature = new StringBuilder ( 100 ) ; if ( mockedType instanceof ParameterizedType ) { ParameterizedType parameterizedType = ( ParameterizedType ) mockedType ; Type [ ] typeArguments = parameterizedType . getActualTypeArguments ( ) ; if ( typeArguments . length > 0 ) { signature . append ( ' < ' ) ; for ( Type typeArg : typeArguments ) { if ( typeArg instanceof Class < ? > ) { Class < ? > classArg = ( Class < ? > ) typeArg ; signature . append ( ' L ' ) . append ( classArg . getName ( ) . replace ( ' . ' , ' / ' ) ) . append ( ' ; ' ) ; } else { signature . append ( ' * ' ) ; } } signature . append ( ' > ' ) ; } } signature . append ( ' ; ' ) ; return signature . toString ( ) ; }
giraudsa/serialisation | public static < U > ActionAbstrait < U > getInstance ( ) { return ( ActionAbstrait < U > ) new ActionJsonSimpleComportement < > ( Object . class , null ) ; }
aws/aws-sdk-java | public static boolean isMetricAdminMBeanRegistered ( ) { SdkMBeanRegistry registry = SdkMBeanRegistry . Factory . getMBeanRegistry ( ) ; return registeredAdminMbeanName != null && registry . isMBeanRegistered ( registeredAdminMbeanName ) ; }
aws/aws-sdk-java | public static String getRegisteredAdminMbeanName ( ) { return registeredAdminMbeanName ; }
aws/aws-sdk-java | public static boolean registerMetricAdminMBean ( ) { SdkMBeanRegistry registry = SdkMBeanRegistry . Factory . getMBeanRegistry ( ) ; synchronized ( AwsSdkMetrics . class ) { if ( registeredAdminMbeanName != null ) return false ; boolean registered = registry . registerMetricAdminMBean ( MBEAN_OBJECT_NAME ) ; if ( registered ) { registeredAdminMbeanName = MBEAN_OBJECT_NAME ; } else { String mbeanName = MBEAN_OBJECT_NAME ; int count = 0 ; while ( registry . isMBeanRegistered ( mbeanName ) ) { mbeanName = MBEAN_OBJECT_NAME + " / " + ++ count ; } registered = registry . registerMetricAdminMBean ( mbeanName ) ; if ( registered ) registeredAdminMbeanName = mbeanName ; } if ( registered ) log . debug ( " Admin ▁ mbean ▁ registered ▁ under ▁ " + registeredAdminMbeanName ) ; return registered ; } }
aws/aws-sdk-java | public static boolean unregisterMetricAdminMBean ( ) { SdkMBeanRegistry registry = SdkMBeanRegistry . Factory . getMBeanRegistry ( ) ; synchronized ( AwsSdkMetrics . class ) { if ( registeredAdminMbeanName == null ) return true ; boolean success = registry . unregisterMBean ( registeredAdminMbeanName ) ; if ( success ) registeredAdminMbeanName = null ; return success ; } }
aws/aws-sdk-java | public static < T extends RequestMetricCollector > T getRequestMetricCollector ( ) { if ( mc == null ) { if ( isDefaultMetricsEnabled ( ) ) enableDefaultMetrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? RequestMetricCollector . NONE : mc . getRequestMetricCollector ( ) ) ; return t ; }
aws/aws-sdk-java | public static < T extends ServiceMetricCollector > T getServiceMetricCollector ( ) { if ( mc == null ) { if ( isDefaultMetricsEnabled ( ) ) enableDefaultMetrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? ServiceMetricCollector . NONE : mc . getServiceMetricCollector ( ) ) ; return t ; }
aws/aws-sdk-java | static MetricCollector getInternalMetricCollector ( ) { return mc ; }
aws/aws-sdk-java | public static < T extends MetricCollector > T getMetricCollector ( ) { if ( mc == null ) { if ( isDefaultMetricsEnabled ( ) ) enableDefaultMetrics ( ) ; } @ SuppressWarnings ( " unchecked " ) T t = ( T ) ( mc == null ? MetricCollector . NONE : mc ) ; return t ; }
aws/aws-sdk-java | public static synchronized void setMetricCollector ( MetricCollector mc ) { MetricCollector old = AwsSdkMetrics . mc ; AwsSdkMetrics . mc = mc ; if ( old != null ) { old . stop ( ) ; } }
aws/aws-sdk-java | public static void setMachineMetricsExcluded ( boolean excludeMachineMetrics ) { AwsSdkMetrics . machineMetricsExcluded = excludeMachineMetrics ; }
aws/aws-sdk-java | public static void setPerHostMetricsIncluded ( boolean includePerHostMetrics ) { AwsSdkMetrics . perHostMetricsIncluded = includePerHostMetrics ; }
aws/aws-sdk-java | public static void enableHttpSocketReadMetric ( ) { AwsSdkMetrics . httpSocketReadMetricEnabled = true ; }
aws/aws-sdk-java | public static boolean isDefaultMetricsEnabled ( ) { return defaultMetricsEnabled ; }
aws/aws-sdk-java | public static boolean isSingleMetricNamespace ( ) { return singleMetricNamespace ; }
aws/aws-sdk-java | public static void setSingleMetricNamespace ( boolean singleMetricNamespace ) { AwsSdkMetrics . singleMetricNamespace = singleMetricNamespace ; }
aws/aws-sdk-java | public static boolean isMetricsEnabled ( ) { MetricCollector mc = AwsSdkMetrics . mc ; return mc != null && mc . isEnabled ( ) ; }
aws/aws-sdk-java | public static boolean isMachineMetricExcluded ( ) { return machineMetricsExcluded ; }
aws/aws-sdk-java | public static boolean isPerHostMetricIncluded ( ) { return perHostMetricsIncluded ; }
aws/aws-sdk-java | public static boolean isPerHostMetricEnabled ( ) { if ( perHostMetricsIncluded ) return true ; String host = hostMetricName ; host = host == null ? " " : host . trim ( ) ; return host . length ( ) > 0 ; }
aws/aws-sdk-java | public static boolean isHttpSocketReadMetricEnabled ( ) { return httpSocketReadMetricEnabled ; }
aws/aws-sdk-java | public static synchronized boolean enableDefaultMetrics ( ) { if ( mc == null || ! mc . isEnabled ( ) ) { if ( dirtyEnabling ) { throw new IllegalStateException ( " Reentrancy ▁ is ▁ not ▁ allowed " ) ; } dirtyEnabling = true ; try { Class < ? > c = Class . forName ( DEFAULT_METRIC_COLLECTOR_FACTORY ) ; MetricCollector . Factory f = ( MetricCollector . Factory ) c . newInstance ( ) ; MetricCollector instance = f . getInstance ( ) ; if ( instance != null ) { setMetricCollector ( instance ) ; return true ; } } catch ( Exception e ) { LogFactory . getLog ( AwsSdkMetrics . class ) . warn ( " Failed ▁ to ▁ enable ▁ the ▁ default ▁ metrics " , e ) ; } finally { dirtyEnabling = false ; } } return false ; }
aws/aws-sdk-java | public static void disableMetrics ( ) { setMetricCollector ( MetricCollector . NONE ) ; }
aws/aws-sdk-java | public static boolean add ( MetricType type ) { return type == null ? false : registry . addMetricType ( type ) ; }
aws/aws-sdk-java | public static < T extends MetricType > boolean addAll ( Collection < T > types ) { return types == null || types . size ( ) == 0 ? false : registry . addMetricTypes ( types ) ; }
aws/aws-sdk-java | public static < T extends MetricType > void set ( Collection < T > types ) { registry . setMetricTypes ( types ) ; }
aws/aws-sdk-java | public static boolean remove ( MetricType type ) { return type == null ? false : registry . removeMetricType ( type ) ; }
aws/aws-sdk-java | public static Set < MetricType > getPredefinedMetrics ( ) { return registry . predefinedMetrics ( ) ; }
aws/aws-sdk-java | public static AWSCredentialsProvider getCredentialProvider ( ) { StackTraceElement [ ] e = Thread . currentThread ( ) . getStackTrace ( ) ; for ( int i = 0 ; i < e . length ; i ++ ) { if ( e [ i ] . getClassName ( ) . equals ( DEFAULT_METRIC_COLLECTOR_FACTORY ) ) { return credentialProvider ; } } SecurityException ex = new SecurityException ( ) ; LogFactory . getLog ( AwsSdkMetrics . class ) . warn ( " Illegal ▁ attempt ▁ to ▁ access ▁ the ▁ credential ▁ provider " , ex ) ; throw ex ; }
aws/aws-sdk-java | public static synchronized void setCredentialProvider ( AWSCredentialsProvider provider ) { credentialProvider = provider ; }
aws/aws-sdk-java | public static Regions getRegion ( ) throws IllegalArgumentException { return Regions . fromName ( region . getName ( ) ) ; }
aws/aws-sdk-java | public static String getRegionName ( ) { return region == null ? null : region . getName ( ) ; }
aws/aws-sdk-java | public static void setRegion ( Regions region ) { AwsSdkMetrics . region = RegionUtils . getRegion ( region . getName ( ) ) ; }
aws/aws-sdk-java | public static void setRegion ( String region ) { AwsSdkMetrics . region = RegionUtils . getRegion ( region ) ; }
aws/aws-sdk-java | @ Deprecated public static String getCredentailFile ( ) { return credentialFile ; }
aws/aws-sdk-java | public static String getCredentialFile ( ) { return credentialFile ; }
aws/aws-sdk-java | public static Integer getMetricQueueSize ( ) { return metricQueueSize ; }
aws/aws-sdk-java | public static void setMetricQueueSize ( Integer size ) { metricQueueSize = size ; }
aws/aws-sdk-java | public static Long getQueuePollTimeoutMilli ( ) { return queuePollTimeoutMilli ; }
aws/aws-sdk-java | public static void setQueuePollTimeoutMilli ( Long timeoutMilli ) { queuePollTimeoutMilli = timeoutMilli ; }
aws/aws-sdk-java | public static String getMetricNameSpace ( ) { return metricNameSpace ; }
aws/aws-sdk-java | public static void setMetricNameSpace ( String metricNameSpace ) { if ( metricNameSpace == null || metricNameSpace . trim ( ) . length ( ) == 0 ) throw new IllegalArgumentException ( ) ; AwsSdkMetrics . metricNameSpace = metricNameSpace ; }
aws/aws-sdk-java | public static String getJvmMetricName ( ) { return jvmMetricName ; }
aws/aws-sdk-java | public static void setJvmMetricName ( String jvmMetricName ) { AwsSdkMetrics . jvmMetricName = jvmMetricName ; }
aws/aws-sdk-java | public static String getHostMetricName ( ) { return hostMetricName ; }
aws/aws-sdk-java | public static void setHostMetricName ( String hostMetricName ) { AwsSdkMetrics . hostMetricName = hostMetricName ; }
linkedin/PalDB | public static StoreReader createReader ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new ReaderImpl ( config , file ) ; }
linkedin/PalDB | public static StoreReader createReader ( InputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . log ( Level . INFO , " Initialize ▁ reader ▁ from ▁ stream , ▁ copying ▁ into ▁ temp ▁ folder " ) ; try { File file = TempUtils . copyIntoTempFile ( " paldbtempreader " , stream ) ; LOGGER . log ( Level . INFO , " Copied ▁ stream ▁ into ▁ temp ▁ file ▁ { 0 } " , file . getName ( ) ) ; return new ReaderImpl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
linkedin/PalDB | public static StoreWriter createWriter ( File file , Configuration config ) { if ( file == null || config == null ) { throw new NullPointerException ( ) ; } try { LOGGER . log ( Level . INFO , " Initialize ▁ writer ▁ from ▁ file ▁ { 0 } " , file . getName ( ) ) ; File parent = file . getParentFile ( ) ; if ( parent != null && ! parent . exists ( ) ) { if ( parent . mkdirs ( ) ) { LOGGER . log ( Level . INFO , " Creating ▁ directories ▁ for ▁ path ▁ { 0 } " , file . getName ( ) ) ; } else { throw new RuntimeException ( String . format ( " Couldn ' t ▁ create ▁ directory ▁ % s " , parent ) ) ; } } return new WriterImpl ( config , file ) ; } catch ( IOException ex ) { throw new RuntimeException ( ex ) ; } }
linkedin/PalDB | public static StoreWriter createWriter ( OutputStream stream , Configuration config ) { if ( stream == null || config == null ) { throw new NullPointerException ( ) ; } LOGGER . info ( " Initialize ▁ writer ▁ from ▁ stream " ) ; return new WriterImpl ( config , stream ) ; }
jamalgithub/workdev | public static void main ( String [ ] args ) { boolean gameOver = true ; int score = 800 ; int levelCompleted = 5 ; int bonus = 100 ; int highScore = calculateScore ( gameOver , score , levelCompleted , bonus ) ; System . out . println ( " Your ▁ final ▁ score ▁ was ▁ " + highScore ) ; score = 10000 ; levelCompleted = 8 ; bonus = 200 ; highScore = calculateScore ( gameOver , score , levelCompleted , bonus ) ; System . out . println ( " Your ▁ final ▁ score ▁ was ▁ " + highScore ) ; int highScorePosition = calculateHighScorePosition ( 1500 ) ; displayHighScorePosition ( " Tim " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 900 ) ; displayHighScorePosition ( " Bob " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 400 ) ; displayHighScorePosition ( " Percy " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 50 ) ; displayHighScorePosition ( " Gilbert " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 1000 ) ; displayHighScorePosition ( " Louise " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 500 ) ; displayHighScorePosition ( " Carol " , highScorePosition ) ; highScorePosition = calculateHighScorePosition ( 100 ) ; displayHighScorePosition ( " Frank " , highScorePosition ) ; }
jamalgithub/workdev | public static void displayHighScorePosition ( String playerName , int highScorePosition ) { System . out . println ( playerName + " ▁ managed ▁ to ▁ get ▁ into ▁ position ▁ " + highScorePosition + " ▁ on ▁ the ▁ high ▁ score ▁ table " ) ; }
jamalgithub/workdev | public static int calculateHighScorePosition ( int playerScore ) { int position = 4 ; if ( playerScore >= 1000 ) { position = 1 ; } else if ( playerScore >= 500 ) { position = 2 ; } else if ( playerScore >= 100 ) { position = 3 ; } return position ; }
jamalgithub/workdev | public static int calculateScore ( boolean gameOver , int score , int levelCompleted , int bonus ) { if ( gameOver ) { int finalScore = score + ( levelCompleted * bonus ) ; finalScore += 2000 ; return finalScore ; } return - 1 ; }
ZiglioNZ/construct | public static byte [ ] int_to_bin ( int number ) { return int_to_bin ( number , 32 ) ; }
ZiglioNZ/construct | public static byte [ ] int_to_bin ( int number , int width ) { if ( number < 0 ) { number += ( 1 << width ) ; } int i = width - 1 ; byte [ ] bits = new byte [ width ] ; while ( i >= 0 ) { bits [ i ] = ( byte ) ( number & 1 ) ; number >>= 1 ; i -= 1 ; } return bits ; }
ZiglioNZ/construct | public static int bin_to_int ( byte [ ] bits ) { return bin_to_int ( bits , false ) ; }
ZiglioNZ/construct | public static int bin_to_int ( byte [ ] bits , boolean signed ) { int number = 0 ; int bias = 0 ; int i = 0 ; if ( bits . length == 0 ) return 0 ; if ( signed && bits [ 0 ] == ( byte ) 1 ) { i ++ ; bias = 1 << ( bits . length - 1 ) ; } for ( int j = i ; j < bits . length ; j ++ ) { number <<= 1 ; number |= bits [ j ] ; } return number - bias ; }
ZiglioNZ/construct | public static byte [ ] swap_bytes ( byte [ ] bits ) { return swap_bytes ( bits , 8 ) ; }
ZiglioNZ/construct | public static byte [ ] swap_bytes ( byte [ ] bits , int bytesize ) { final int L = bits . length ; byte [ ] output = new byte [ L ] ; int j = L - bytesize ; for ( int i = 0 ; i < L ; i ++ , j ++ ) { if ( j == L ) { j = 0 ; } output [ j ] = bits [ i ] ; } return output ; }
ZiglioNZ/construct | public static Encoder BinaryEncoder ( ) { return data -> decode_bin ( data . getBytes ( ) ) ; }
ZiglioNZ/construct | public static Decoder BinaryDecoder ( ) { return data -> encode_bin ( data ) ; }
ZiglioNZ/construct | public static byte [ ] encode_bin ( byte [ ] data ) { byte [ ] out = new byte [ 8 * data . length ] ; for ( int i = 0 ; i < data . length ; i ++ ) { int ch = ( int ) data [ i ] ; if ( ch < 0 ) ch = 256 + ch ; byte [ ] conv = _char_to_bin [ ch ] ; System . arraycopy ( conv , 0 , out , i * 8 , 8 ) ; } return out ; }
ZiglioNZ/construct | public static byte [ ] decode_bin ( byte [ ] data ) { if ( ( data . length & 7 ) != 0 ) throw new ValueError ( " Data ▁ length ▁ must ▁ be ▁ a ▁ multiple ▁ of ▁ 8" ) ; byte [ ] sb = new byte [ data . length / 8 ] ; for ( int i = 0 ; i < data . length ; i += 8 ) { byte ch = 0 ; for ( int j = 0 ; j < 8 ; j ++ ) { ch = ( byte ) ( ch << 1 ) ; ch |= data [ i + j ] ; } sb [ i / 8 ] = ch ; } return sb ; }
ZiglioNZ/construct | public static byte [ ] hexStringToByteArray ( String s ) { int len = s . length ( ) ; byte [ ] data = new byte [ len / 2 ] ; for ( int i = 0 ; i < len ; i += 2 ) { data [ i / 2 ] = ( byte ) ( ( Character . digit ( s . charAt ( i ) , 16 ) << 4 ) + Character . digit ( s . charAt ( i + 1 ) , 16 ) ) ; } return data ; }
ZiglioNZ/construct | public static String byteArrayToHexString ( byte [ ] raw , int linesize ) { if ( raw == null ) return null ; final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; hex . append ( ' \n ' ) ; int i = 0 ; for ( final byte b : raw ) { hex . append ( HEXES [ ( b >> 4 ) & 0xF ] ) . append ( HEXES [ ( b ) & 0xF ] ) ; i ++ ; hex . append ( ' ▁ ' ) ; if ( i == linesize ) { hex . append ( ' \n ' ) ; i = 0 ; } } hex . append ( ' \n ' ) ; return hex . toString ( ) ; }
ZiglioNZ/construct | public static String byteArrayToHexString ( byte [ ] raw ) { if ( raw == null ) return null ; final StringBuilder hex = new StringBuilder ( 2 * raw . length ) ; for ( final byte b : raw ) { hex . append ( HEXES [ ( b >> 4 ) & 0xF ] ) . append ( HEXES [ ( b ) & 0xF ] ) ; } return hex . toString ( ) ; }
issei-m/idea-php-symfony2-plugin | static public List < ResolveResult > getClassInterfaceResolveResult ( Project project , String fqnClassOrInterfaceName ) { if ( ! fqnClassOrInterfaceName . startsWith ( " \ \" ) ) { fqnClassOrInterfaceName = " \ \" + fqnClassOrInterfaceName ; } List < ResolveResult > results = new ArrayList < ResolveResult > ( ) ; for ( PhpClass phpClass : PhpIndex . getInstance ( project ) . getAnyByFQN ( fqnClassOrInterfaceName ) ) { results . add ( new PsiElementResolveResult ( phpClass ) ) ; } return results ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Collection < String > getArrayCreationKeys ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { return getArrayCreationKeyMap ( arrayCreationExpression ) . keySet ( ) ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Map < String , PsiElement > getArrayCreationKeyMap ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { Map < String , PsiElement > keys = new HashMap < String , PsiElement > ( ) ; for ( ArrayHashElement arrayHashElement : arrayCreationExpression . getHashElements ( ) ) { PhpPsiElement child = arrayHashElement . getKey ( ) ; if ( child instanceof StringLiteralExpression ) { keys . put ( ( ( StringLiteralExpression ) child ) . getContents ( ) , child ) ; } } return keys ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Set < String > getArrayValuesAsString ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { return getArrayValuesAsMap ( arrayCreationExpression ) . keySet ( ) ; }
issei-m/idea-php-symfony2-plugin | @ NotNull static public Map < String , PsiElement > getArrayValuesAsMap ( @ NotNull ArrayCreationExpression arrayCreationExpression ) { List < PsiElement > arrayValues = PhpPsiUtil . getChildren ( arrayCreationExpression , new Condition < PsiElement > ( ) { @ Override public boolean value ( PsiElement psiElement ) { return psiElement . getNode ( ) . getElementType ( ) == PhpElementTypes . ARRAY_VALUE ; } } ) ; if ( arrayValues == null ) { return Collections . emptyMap ( ) ; } Map < String , PsiElement > keys = new HashMap < String , PsiElement > ( ) ; for ( PsiElement child : arrayValues ) { String stringValue = PhpElementsUtil . getStringValue ( child . getFirstChild ( ) ) ; if ( stringValue != null && StringUtils . isNotBlank ( stringValue ) ) { keys . put ( stringValue , child ) ; } } return keys ; }
issei-m/idea-php-symfony2-plugin | static public HashMap < String , String > getArrayKeyValueMap ( ArrayCreationExpression arrayCreationExpression ) { HashMap < String , String > keys = new HashMap < String , String > ( ) ; for ( ArrayHashElement arrayHashElement : arrayCreationExpression . getHashElements ( ) ) { PhpPsiElement child = arrayHashElement . getKey ( ) ; if ( child != null && ( ( child instanceof StringLiteralExpression ) || PhpPatterns . psiElement ( PhpElementTypes . NUMBER ) . accepts ( child ) ) ) { String key ; if ( child instanceof StringLiteralExpression ) { key = ( ( StringLiteralExpression ) child ) . getContents ( ) ; } else { key = child . getText ( ) ; } String value = null ; if ( arrayHashElement . getValue ( ) instanceof StringLiteralExpression ) { value = ( ( StringLiteralExpression ) arrayHashElement . getValue ( ) ) . getContents ( ) ; } keys . put ( key , value ) ; } } return keys ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpPsiElement getArrayValue ( ArrayCreationExpression arrayCreationExpression , String name ) { for ( ArrayHashElement arrayHashElement : arrayCreationExpression . getHashElements ( ) ) { PhpPsiElement child = arrayHashElement . getKey ( ) ; if ( child instanceof StringLiteralExpression ) { if ( ( ( StringLiteralExpression ) child ) . getContents ( ) . equals ( name ) ) { return arrayHashElement . getValue ( ) ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayValueString ( ArrayCreationExpression arrayCreationExpression , String name ) { PhpPsiElement phpPsiElement = getArrayValue ( arrayCreationExpression , name ) ; if ( phpPsiElement == null ) { return null ; } if ( phpPsiElement instanceof StringLiteralExpression ) { return ( ( StringLiteralExpression ) phpPsiElement ) . getContents ( ) ; } return null ; }
issei-m/idea-php-symfony2-plugin | static public PsiElement [ ] getPsiElementsBySignature ( Project project , @ Nullable String signature ) { if ( signature == null ) { return new PsiElement [ 0 ] ; } Collection < ? extends PhpNamedElement > phpNamedElementCollections = PhpIndex . getInstance ( project ) . getBySignature ( signature , null , 0 ) ; return phpNamedElementCollections . toArray ( new PsiElement [ phpNamedElementCollections . size ( ) ] ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PsiElement getPsiElementsBySignatureSingle ( Project project , @ Nullable String signature ) { PsiElement [ ] psiElements = getPsiElementsBySignature ( project , signature ) ; if ( psiElements . length == 0 ) { return null ; } return psiElements [ 0 ] ; }
issei-m/idea-php-symfony2-plugin | @ Deprecated static public PsiElement [ ] getClassInterfacePsiElements ( Project project , String FQNClassOrInterfaceName ) { List < PsiElement > results = new ArrayList < PsiElement > ( ) ; for ( ResolveResult result : getClassInterfaceResolveResult ( project , FQNClassOrInterfaceName ) ) { results . add ( result . getElement ( ) ) ; } return results . toArray ( new PsiElement [ results . size ( ) ] ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public Method getClassMethod ( PhpClass phpClass , String methodName ) { return phpClass . findMethodByName ( methodName ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public Method getClassMethod ( Project project , String phpClassName , String methodName ) { for ( PhpClass phpClass : PhpIndex . getInstance ( project ) . getClassesByFQN ( phpClassName ) ) { Method method = getClassMethod ( phpClass , methodName ) ; if ( method != null ) { return method ; } } return null ; }
issei-m/idea-php-symfony2-plugin | static public boolean isMethodWithFirstString ( PsiElement psiElement , String ... methodName ) { if ( ! PlatformPatterns . psiElement ( PhpElementTypes . METHOD_REFERENCE ) . withChild ( PlatformPatterns . psiElement ( PhpElementTypes . PARAMETER_LIST ) . withFirstChild ( PlatformPatterns . psiElement ( PhpElementTypes . STRING ) ) ) . accepts ( psiElement ) ) { return false ; } String methodRefName = ( ( MethodReference ) psiElement ) . getName ( ) ; return null != methodRefName && Arrays . asList ( methodName ) . contains ( methodRefName ) ; }
issei-m/idea-php-symfony2-plugin | static public boolean isMethodWithFirstStringOrFieldReference ( PsiElement psiElement , String ... methodName ) { if ( ! PlatformPatterns . psiElement ( PhpElementTypes . METHOD_REFERENCE ) . withChild ( PlatformPatterns . psiElement ( PhpElementTypes . PARAMETER_LIST ) . withFirstChild ( PlatformPatterns . or ( PlatformPatterns . psiElement ( PhpElementTypes . STRING ) , PlatformPatterns . psiElement ( PhpElementTypes . FIELD_REFERENCE ) , PlatformPatterns . psiElement ( PhpElementTypes . class_CONSTANT_REFERENCE ) ) ) ) . accepts ( psiElement ) ) { return false ; } String methodRefName = ( ( MethodReference ) psiElement ) . getName ( ) ; return null != methodRefName && Arrays . asList ( methodName ) . contains ( methodRefName ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < StringLiteralExpression > methodWithFirstStringPattern ( ) { return PlatformPatterns . psiElement ( StringLiteralExpression . class ) . withParent ( PlatformPatterns . psiElement ( PhpElementTypes . PARAMETER_LIST ) . withFirstChild ( PlatformPatterns . psiElement ( PhpElementTypes . STRING ) ) . withParent ( PlatformPatterns . psiElement ( PhpElementTypes . METHOD_REFERENCE ) ) ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < PsiElement > getClassNamePattern ( ) { return PlatformPatterns . psiElement ( PhpTokenTypes . IDENTIFIER ) . afterLeafSkipping ( PlatformPatterns . psiElement ( PsiWhiteSpace . class ) , PlatformPatterns . psiElement ( PhpTokenTypes . kwCLASS ) ) . withParent ( PhpClass . class ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < PsiElement > getActionMethodPattern ( ) { return PlatformPatterns . psiElement ( PhpTokenTypes . IDENTIFIER ) . withText ( PlatformPatterns . string ( ) . endsWith ( " Action " ) ) . afterLeafSkipping ( PlatformPatterns . psiElement ( PsiWhiteSpace . class ) , PlatformPatterns . psiElement ( PhpTokenTypes . kwFUNCTION ) ) . inside ( Method . class ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElementPattern . Capture < StringLiteralExpression > getMethodReturnPattern ( ) { return PlatformPatterns . psiElement ( StringLiteralExpression . class ) . withParent ( PlatformPatterns . psiElement ( PhpReturn . class ) . inside ( Method . class ) ) . withLanguage ( PhpLanguage . INSTANCE ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getMethodReturnAsString ( @ NotNull PhpClass phpClass , @ NotNull String methodName ) { Method method = phpClass . findMethodByName ( methodName ) ; if ( method == null ) { return null ; } final Set < String > values = new HashSet < String > ( ) ; method . acceptChildren ( new PsiRecursiveElementWalkingVisitor ( ) { @ Override public void visitElement ( PsiElement element ) { if ( PhpElementsUtil . getMethodReturnPattern ( ) . accepts ( element ) ) { String value = PhpElementsUtil . getStringValue ( element ) ; if ( value != null && StringUtils . isNotBlank ( value ) ) { values . add ( value ) ; } } super . visitElement ( element ) ; } } ) ; if ( values . size ( ) == 0 ) { return null ; } return values . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getClass ( Project project , String className ) { return getClass ( PhpIndex . getInstance ( project ) , className ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getClass ( PhpIndex phpIndex , String className ) { Collection < PhpClass > classes = phpIndex . getClassesByFQN ( className ) ; return classes . isEmpty ( ) ? null : classes . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getInterface ( PhpIndex phpIndex , String className ) { if ( ! className . startsWith ( " \ \" ) ) { className = " \ \" + className ; } Collection < PhpClass > classes = phpIndex . getInterfacesByFQN ( className ) ; return classes . isEmpty ( ) ? null : classes . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public PhpClass getClassInterface ( Project project , @ NotNull String className ) { if ( ! className . startsWith ( " \ \" ) ) { className = " \ \" + className ; } Collection < PhpClass > phpClasses = PhpIndex . getInstance ( project ) . getAnyByFQN ( className ) ; return phpClasses . size ( ) == 0 ? null : phpClasses . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | static public Collection < PhpClass > getClassesInterface ( Project project , @ NotNull String className ) { if ( ! className . startsWith ( " \ \" ) ) { className = " \ \" + className ; } return PhpIndex . getInstance ( project ) . getAnyByFQN ( className ) ; }
issei-m/idea-php-symfony2-plugin | static public void addClassPublicMethodCompletion ( CompletionResultSet completionResultSet , PhpClass phpClass ) { for ( Method method : getClassPublicMethod ( phpClass ) ) { completionResultSet . addElement ( new PhpLookupElement ( method ) ) ; } }
issei-m/idea-php-symfony2-plugin | static public ArrayList < Method > getClassPublicMethod ( PhpClass phpClass ) { ArrayList < Method > methods = new ArrayList < Method > ( ) ; for ( Method method : phpClass . getMethods ( ) ) { if ( method . getAccess ( ) . isPublic ( ) && ! method . getName ( ) . startsWith ( " _ _ " ) ) { methods . add ( method ) ; } } return methods ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayHashValue ( ArrayCreationExpression arrayCreationExpression , String keyName ) { ArrayHashElement translationArrayHashElement = PsiElementUtils . getChildrenOfType ( arrayCreationExpression , PlatformPatterns . psiElement ( ArrayHashElement . class ) . withFirstChild ( PlatformPatterns . psiElement ( PhpElementTypes . ARRAY_KEY ) . withText ( PlatformPatterns . string ( ) . oneOf ( " ' " + keyName + " ' " , " \" " + keyName + " \" " ) ) ) ) ; if ( translationArrayHashElement == null ) { return null ; } if ( ! ( translationArrayHashElement . getValue ( ) instanceof StringLiteralExpression ) ) { return null ; } StringLiteralExpression valueString = ( StringLiteralExpression ) translationArrayHashElement . getValue ( ) ; if ( valueString == null ) { return null ; } return valueString . getContents ( ) ; }
issei-m/idea-php-symfony2-plugin | static public boolean isEqualMethodReferenceName ( MethodReference methodReference , String methodName ) { String name = methodReference . getName ( ) ; return name != null && name . equals ( methodName ) ; }
issei-m/idea-php-symfony2-plugin | static public PsiElement findArrayKeyValueInsideReference ( PsiElement psiElement , String methodReferenceName , String keyName ) { if ( psiElement == null ) { return null ; } Collection < MethodReference > tests = PsiTreeUtil . findChildrenOfType ( psiElement , MethodReference . class ) ; for ( MethodReference methodReference : tests ) { if ( PhpElementsUtil . isEqualMethodReferenceName ( methodReference , methodReferenceName ) ) { PsiElement [ ] parameters = methodReference . getParameters ( ) ; if ( parameters . length > 0 && parameters [ 0 ] instanceof ArrayCreationExpression ) { PsiElement keyValue = PhpElementsUtil . getArrayValue ( ( ArrayCreationExpression ) parameters [ 0 ] , keyName ) ; if ( keyValue != null ) { return keyValue ; } } } } return null ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayKeyValueInsideSignature ( PsiElement psiElementInsideClass , String callTo , String methodName , String keyName ) { return getArrayKeyValueInsideSignature ( psiElementInsideClass , new String [ ] { callTo } , methodName , keyName ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayKeyValueInsideSignature ( PsiElement psiElementInsideClass , String callTo [ ] , String methodName , String keyName ) { PhpClass phpClass = PsiTreeUtil . getParentOfType ( psiElementInsideClass , PhpClass . class ) ; if ( phpClass == null ) { return null ; } String className = phpClass . getPresentableFQN ( ) ; if ( className == null ) { return null ; } for ( String s : callTo ) { String arrayKeyValueInsideSignature = PhpElementsUtil . getArrayKeyValueInsideSignature ( psiElementInsideClass . getProject ( ) , " # M # C\ \" + className + " . " + s , methodName , keyName ) ; if ( arrayKeyValueInsideSignature != null ) { return arrayKeyValueInsideSignature ; } } return null ; }
issei-m/idea-php-symfony2-plugin | @ Nullable static public String getArrayKeyValueInsideSignature ( Project project , String signature , String methodName , String keyName ) { PsiElement psiElement = PhpElementsUtil . getPsiElementsBySignatureSingle ( project , signature ) ; if ( psiElement == null ) { return null ; } for ( MethodReference methodReference : PsiTreeUtil . findChildrenOfType ( psiElement , MethodReference . class ) ) { if ( PhpElementsUtil . isEqualMethodReferenceName ( methodReference , methodName ) ) { PsiElement [ ] parameters = methodReference . getParameters ( ) ; if ( parameters . length > 0 && parameters [ 0 ] instanceof ArrayCreationExpression ) { return PhpElementsUtil . getArrayValueString ( ( ArrayCreationExpression ) parameters [ 0 ] , keyName ) ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | public static Method [ ] getImplementedMethods ( @ NotNull Method method ) { ArrayList < Method > items = getImplementedMethods ( method . getContainingClass ( ) , method , new ArrayList < Method > ( ) ) ; return items . toArray ( new Method [ items . size ( ) ] ) ; }
issei-m/idea-php-symfony2-plugin | private static ArrayList < Method > getImplementedMethods ( @ Nullable PhpClass phpClass , @ NotNull Method method , ArrayList < Method > implementedMethods ) { if ( phpClass == null ) { return implementedMethods ; } Method [ ] methods = phpClass . getOwnMethods ( ) ; for ( Method ownMethod : methods ) { if ( PhpLangUtil . equalsMethodNames ( ownMethod . getName ( ) , method . getName ( ) ) ) { implementedMethods . add ( ownMethod ) ; } } for ( PhpClass interfaceClass : phpClass . getImplementedInterfaces ( ) ) { getImplementedMethods ( interfaceClass , method , implementedMethods ) ; } getImplementedMethods ( phpClass . getSuperClass ( ) , method , implementedMethods ) ; return implementedMethods ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static String getStringValue ( @ Nullable PsiElement psiElement ) { return getStringValue ( psiElement , 0 ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable private static String getStringValue ( @ Nullable PsiElement psiElement , int depth ) { if ( psiElement == null || ++ depth > 5 ) { return null ; } if ( psiElement instanceof StringLiteralExpression ) { String resolvedString = ( ( StringLiteralExpression ) psiElement ) . getContents ( ) ; if ( StringUtils . isEmpty ( resolvedString ) ) { return null ; } return resolvedString ; } if ( psiElement instanceof Field ) { return getStringValue ( ( ( Field ) psiElement ) . getDefaultValue ( ) , depth ) ; } if ( psiElement instanceof PhpReference ) { PsiReference psiReference = psiElement . getReference ( ) ; if ( psiReference == null ) { return null ; } PsiElement ref = psiReference . resolve ( ) ; if ( ref instanceof PhpReference ) { return getStringValue ( psiElement , depth ) ; } if ( ref instanceof Field ) { PsiElement resolved = ( ( Field ) ref ) . getDefaultValue ( ) ; if ( resolved instanceof StringLiteralExpression ) { return ( ( StringLiteralExpression ) resolved ) . getContents ( ) ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | public static String getPrevSiblingAsTextUntil ( PsiElement psiElement , ElementPattern pattern , boolean includeMatching ) { String prevText = " " ; for ( PsiElement child = psiElement . getPrevSibling ( ) ; child != null ; child = child . getPrevSibling ( ) ) { if ( pattern . accepts ( child ) ) { if ( includeMatching ) { return child . getText ( ) + prevText ; } return prevText ; } else { prevText = child . getText ( ) + prevText ; } } return prevText ; }
issei-m/idea-php-symfony2-plugin | public static String getPrevSiblingAsTextUntil ( PsiElement psiElement , ElementPattern pattern ) { return getPrevSiblingAsTextUntil ( psiElement , pattern , false ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static ArrayCreationExpression getCompletableArrayCreationElement ( PsiElement psiElement ) { if ( PhpPatterns . psiElement ( PhpElementTypes . ARRAY_KEY ) . accepts ( psiElement . getContext ( ) ) ) { PsiElement arrayKey = psiElement . getContext ( ) ; if ( arrayKey != null ) { PsiElement arrayHashElement = arrayKey . getContext ( ) ; if ( arrayHashElement instanceof ArrayHashElement ) { PsiElement arrayCreationExpression = arrayHashElement . getContext ( ) ; if ( arrayCreationExpression instanceof ArrayCreationExpression ) { return ( ArrayCreationExpression ) arrayCreationExpression ; } } } } if ( PhpPatterns . psiElement ( PhpElementTypes . ARRAY_VALUE ) . accepts ( psiElement . getContext ( ) ) ) { PsiElement arrayKey = psiElement . getContext ( ) ; if ( arrayKey != null ) { PsiElement arrayCreationExpression = arrayKey . getContext ( ) ; if ( arrayCreationExpression instanceof ArrayCreationExpression ) { return ( ArrayCreationExpression ) arrayCreationExpression ; } } } return null ; }
issei-m/idea-php-symfony2-plugin | public static Collection < PhpClass > getClassFromPhpTypeSet ( Project project , Set < String > types ) { PhpType phpType = new PhpType ( ) ; phpType . add ( types ) ; List < PhpClass > phpClasses = new ArrayList < PhpClass > ( ) ; for ( String typeName : PhpIndex . getInstance ( project ) . completeType ( project , phpType , new HashSet < String > ( ) ) . getTypes ( ) ) { if ( typeName . startsWith ( " \ \" ) ) { PhpClass phpClass = PhpElementsUtil . getClassInterface ( project , typeName ) ; if ( phpClass != null ) { phpClasses . add ( phpClass ) ; } } } return phpClasses ; }
issei-m/idea-php-symfony2-plugin | public static Collection < PhpClass > getClassFromPhpTypeSetArrayClean ( Project project , Set < String > types ) { PhpType phpType = new PhpType ( ) ; phpType . add ( types ) ; ArrayList < PhpClass > phpClasses = new ArrayList < PhpClass > ( ) ; for ( String typeName : PhpIndex . getInstance ( project ) . completeType ( project , phpType , new HashSet < String > ( ) ) . getTypes ( ) ) { if ( typeName . startsWith ( " \ \" ) ) { if ( typeName . endsWith ( " [ ] " ) ) { typeName = typeName . substring ( 0 , typeName . length ( ) - 2 ) ; } PhpClass phpClass = PhpElementsUtil . getClassInterface ( project , typeName ) ; if ( phpClass != null ) { phpClasses . add ( phpClass ) ; } } } return phpClasses ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static PhpClass getFirstClassFromFile ( PhpFile phpFile ) { Collection < PhpClass > phpClasses = PsiTreeUtil . collectElementsOfType ( phpFile , PhpClass . class ) ; return phpClasses . size ( ) == 0 ? null : phpClasses . iterator ( ) . next ( ) ; }
issei-m/idea-php-symfony2-plugin | public static boolean isEqualClassName ( @ Nullable PhpClass phpClass , @ Nullable String ... compareClassNames ) { for ( String className : compareClassNames ) { if ( isEqualClassName ( phpClass , className ) ) { return true ; } } return false ; }
issei-m/idea-php-symfony2-plugin | public static boolean isEqualClassName ( @ NotNull PhpClass phpClass , @ NotNull PhpClass compareClassName ) { return isEqualClassName ( phpClass , compareClassName . getPresentableFQN ( ) ) ; }
issei-m/idea-php-symfony2-plugin | public static boolean isEqualClassName ( @ Nullable PhpClass phpClass , @ Nullable String compareClassName ) { if ( phpClass == null || compareClassName == null ) { return false ; } String phpClassName = phpClass . getPresentableFQN ( ) ; if ( phpClassName == null ) { return false ; } if ( phpClassName . startsWith ( " \ \" ) ) { phpClassName = phpClassName . substring ( 1 ) ; } if ( compareClassName . startsWith ( " \ \" ) ) { compareClassName = compareClassName . substring ( 1 ) ; } return phpClassName . equals ( compareClassName ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static PsiElement [ ] getMethodParameterReferences ( Method method , int parameterIndex ) { Parameter [ ] parameters = method . getParameters ( ) ; if ( parameters . length == 0 || parameterIndex >= parameters . length ) { return null ; } final String tempVariableName = parameters [ parameterIndex ] . getName ( ) ; return PsiTreeUtil . collectElements ( method . getLastChild ( ) , new PsiElementFilter ( ) { @ Override public boolean isAccepted ( PsiElement element ) { return element instanceof Variable && tempVariableName . equals ( ( ( Variable ) element ) . getName ( ) ) ; } } ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static MethodReferenceBag getMethodParameterReferenceBag ( PsiElement psiElement , int wantIndex ) { PsiElement variableContext = psiElement . getContext ( ) ; if ( ! ( variableContext instanceof ParameterList ) ) { return null ; } ParameterList parameterList = ( ParameterList ) variableContext ; if ( ! ( parameterList . getContext ( ) instanceof MethodReference ) ) { return null ; } ParameterBag currentIndex = PsiElementUtils . getCurrentParameterIndex ( psiElement ) ; if ( currentIndex == null ) { return null ; } if ( wantIndex >= 0 && currentIndex . getIndex ( ) != wantIndex ) { return null ; } return new MethodReferenceBag ( parameterList , ( MethodReference ) parameterList . getContext ( ) , currentIndex ) ; }
issei-m/idea-php-symfony2-plugin | @ Nullable public static MethodReferenceBag getMethodParameterReferenceBag ( PsiElement psiElement ) { return getMethodParameterReferenceBag ( psiElement , - 1 ) ; }
issei-m/idea-php-symfony2-plugin | public static List < Variable > getVariableReferencesInScope ( final Variable variable , final boolean includeSelf ) { final List < Variable > variables = new ArrayList < Variable > ( ) ; Variable variableDecl = null ; if ( ! variable . isDeclaration ( ) ) { PsiElement psiElement = variable . resolve ( ) ; if ( psiElement instanceof Variable ) { variableDecl = ( Variable ) psiElement ; } } else { variableDecl = variable ; } if ( variableDecl == null ) { return variables ; } Method method = PsiTreeUtil . getParentOfType ( variable , Method . class ) ; PhpPsiUtil . hasReferencesInSearchScope ( method . getUseScope ( ) , variableDecl , new CommonProcessors . FindProcessor < PsiReference > ( ) { @ Override protected boolean accept ( PsiReference psiReference ) { PsiElement variableRef = psiReference . getElement ( ) ; if ( variableRef instanceof Variable ) { if ( includeSelf ) { variables . add ( ( Variable ) variableRef ) ; } else { if ( ! variableRef . equals ( variable ) ) { variables . add ( ( Variable ) variableRef ) ; } } } return false ; } } ) ; return variables ; }
issei-m/idea-php-symfony2-plugin | public static void visitNamespaceClassForCompletion ( PsiElement psiElement , int cursorOffset , ClassForCompletionVisitor visitor ) { int cursorOffsetClean = cursorOffset - psiElement . getTextOffset ( ) ; if ( cursorOffsetClean < 1 ) { return ; } String content = psiElement . getText ( ) ; int length = content . length ( ) ; if ( ! ( length >= cursorOffsetClean ) ) { return ; } String beforeCursor = content . substring ( 0 , cursorOffsetClean ) ; boolean isValid ; String namespace = beforeCursor ; int lastSlash = beforeCursor . lastIndexOf ( " \ \" ) ; if ( lastSlash <= 0 ) { isValid = PhpIndexUtil . hasNamespace ( psiElement . getProject ( ) , beforeCursor ) ; } else { isValid = true ; namespace = beforeCursor . substring ( 0 , lastSlash ) ; } if ( ! isValid ) { return ; } String prefix = " " ; if ( namespace . startsWith ( " \ \" ) ) { prefix = " \ \" ; } else { namespace = " \ \" + namespace ; } for ( PhpClass phpClass : PhpIndexUtil . getPhpClassInsideNamespace ( psiElement . getProject ( ) , namespace ) ) { String presentableFQN = phpClass . getPresentableFQN ( ) ; if ( presentableFQN != null && fr . adrienbrault . idea . symfony2plugin . util . StringUtils . startWithEqualClassname ( presentableFQN , beforeCursor ) ) { visitor . visit ( phpClass , presentableFQN , prefix ) ; } } }
issei-m/idea-php-symfony2-plugin | @ Nullable private static PhpClass getNewExpressionPhpClass ( @ NotNull NewExpression newExpression ) { ClassReference classReference = newExpression . getClassReference ( ) ; if ( classReference != null ) { String fqn = classReference . getFQN ( ) ; if ( fqn != null ) { return PhpElementsUtil . getClass ( newExpression . getProject ( ) , fqn ) ; } } return null ; }
issei-m/idea-php-symfony2-plugin | public static PhpClass getNewExpressionPhpClassWithInstance ( @ NotNull NewExpression newExpression , @ NotNull String instance ) { PhpClass phpClass = getNewExpressionPhpClass ( newExpression ) ; if ( phpClass != null && new Symfony2InterfacesUtil ( ) . isInstanceOf ( phpClass , instance ) ) { return phpClass ; } return null ; }
issei-m/idea-php-symfony2-plugin | public static boolean isNewExpressionPhpClassWithInstance ( @ NotNull NewExpression newExpression , @ NotNull String instance ) { return getNewExpressionPhpClassWithInstance ( newExpression , instance ) != null ; }
issei-m/idea-php-symfony2-plugin | @ NotNull public static Collection < PsiElement > collectMethodElementsWithParents ( final @ NotNull Method method , @ NotNull final Processor < PsiElement > processor ) { Collection < PsiElement > elements = new HashSet < PsiElement > ( ) ; collectMethodElementsWithParents ( method , 3 , elements , processor ) ; return elements ; }
issei-m/idea-php-symfony2-plugin | private static void collectMethodElementsWithParents ( final @ NotNull Method method , final int depth , @ NotNull final Collection < PsiElement > elements , @ NotNull final Processor < PsiElement > processor ) { method . acceptChildren ( new PsiRecursiveElementWalkingVisitor ( ) { @ Override public void visitElement ( PsiElement psiElement ) { if ( processor . process ( psiElement ) ) { elements . add ( psiElement ) ; } if ( psiElement instanceof MethodReference && ( ( MethodReference ) psiElement ) . getReferenceType ( ) == PhpModifier . State . PARENT && method . getName ( ) . equals ( ( ( MethodReference ) psiElement ) . getName ( ) ) ) { PsiElement resolve = ( ( MethodReference ) psiElement ) . resolve ( ) ; if ( depth > 0 && resolve instanceof Method ) { collectMethodElementsWithParents ( ( Method ) resolve , depth - 1 , elements , processor ) ; } } super . visitElement ( psiElement ) ; } } ) ; }
issei-m/idea-php-symfony2-plugin | @ NotNull public static Parameter [ ] getFunctionRequiredParameter ( @ NotNull Function function ) { Parameter [ ] parameters = function . getParameters ( ) ; if ( parameters . length == 0 ) { return new Parameter [ 0 ] ; } int last = - 1 ; for ( int i = parameters . length - 1 ; i >= 0 ; i -- ) { if ( ! parameters [ i ] . isOptional ( ) ) { last = i ; break ; } } if ( last == - 1 ) { return new Parameter [ 0 ] ; } return Arrays . copyOfRange ( parameters , 0 , last + 1 ) ; }
issei-m/idea-php-symfony2-plugin | public static boolean isTestClass ( @ NotNull PhpClass phpClass ) { if ( PhpUnitUtil . isTestClass ( phpClass ) ) { return true ; } String fqn = phpClass . getPresentableFQN ( ) ; if ( fqn == null ) { return false ; } return fqn . contains ( " \\ Test\ \" ) || fqn . contains ( " \\ Tests\ \" ) ; }
jjhaggar/libGDX-flixel-test-autogenerated | public static void main ( String [ ] args ) { new FlxDesktopApplication ( new com . yourname . flixelgame . examples . bloom . FlxBloom ( ) , 640 , 480 ) ; }
username115/FRCScouting | public static String getSavedPassword ( Context context ) { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " passPref " , " " ) ; }
username115/FRCScouting | public static String getScoutingURL ( Context context ) { String ret = PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " databaseURLPref " , URL ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } return ret ; }
username115/FRCScouting | public static String getScoutingURLNoDefault ( Context context ) { String ret = PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " databaseURLPref " , " " ) ; if ( ret . length ( ) > 0 && ! ret . contains ( " : // " ) ) { ret = " https : // " + ret ; } return ret ; }
username115/FRCScouting | public static String getEvent ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " eventPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getRobotPicPref ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " robotPicPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getPracticeMatch ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " practiceMatchPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static String getDefaultTeamNumber ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " teamPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getAutoSync ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " enableSyncPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static String getPosition ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " positionPref " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static Boolean getRedLeft ( Context context , Boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " redLeft " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static void setRedLeft ( Context context , boolean redLeft ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( " redLeft " , redLeft ) ; editor . apply ( ) ; }
username115/FRCScouting | public static int getMilliSecondsBetweenSyncs ( Context context , final int defaultValue ) { try { String val = PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " syncFreqPref " , " " ) ; int secs ; if ( val == null || val . length ( ) == 0 ) return defaultValue ; try { secs = Integer . parseInt ( val . split ( " ▁ " ) [ 0 ] ) * 60 * 1000 ; } catch ( NumberFormatException e ) { return defaultValue ; } return secs ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static boolean getDontPrompt ( Context context , boolean defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getBoolean ( " doNotAskURL " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
username115/FRCScouting | public static void setDontPrompt ( Context context , boolean dontPrompt ) { SharedPreferences prefs = PreferenceManager . getDefaultSharedPreferences ( context ) ; SharedPreferences . Editor editor = prefs . edit ( ) ; editor . putBoolean ( " doNotAskURL " , dontPrompt ) ; editor . apply ( ) ; }
username115/FRCScouting | public static String getDeviceName ( Context context , String defaultValue ) { try { return PreferenceManager . getDefaultSharedPreferences ( context ) . getString ( " deviceName " , defaultValue ) ; } catch ( NullPointerException e ) { return defaultValue ; } }
jk1/intellij-community | public static boolean match ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull TypeEvalContext context ) { return match ( expected , actual , new MatchContext ( context , new HashMap < > ( ) ) ) . orElse ( true ) ; }
jk1/intellij-community | public static boolean match ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull TypeEvalContext context , @ NotNull Map < PyGenericType , PyType > substitutions ) { return match ( expected , actual , new MatchContext ( context , substitutions ) ) . orElse ( true ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull MatchContext context ) { final Pair < PyType , PyType > types = Pair . create ( expected , actual ) ; if ( context . matching . contains ( types ) ) return Optional . of ( true ) ; context . matching . add ( types ) ; final Optional < Boolean > result = matchImpl ( expected , actual , context ) ; context . matching . remove ( types ) ; return result ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > matchImpl ( @ Nullable PyType expected , @ Nullable PyType actual , @ NotNull MatchContext context ) { if ( expected instanceof PyClassType ) { Optional < Boolean > match = matchObject ( ( PyClassType ) expected , actual ) ; if ( match . isPresent ( ) ) { return match ; } } if ( expected instanceof PyInstantiableType && actual instanceof PyInstantiableType ) { Optional < Boolean > match = match ( ( PyInstantiableType ) expected , ( PyInstantiableType ) actual , context ) ; if ( match . isPresent ( ) ) { return match ; } } if ( expected instanceof PyGenericType ) { return Optional . of ( match ( ( PyGenericType ) expected , actual , context ) ) ; } if ( expected == null || actual == null || isUnknown ( actual , context . context ) ) { return Optional . of ( true ) ; } if ( actual instanceof PyUnionType ) { return Optional . of ( match ( expected , ( PyUnionType ) actual , context ) ) ; } if ( expected instanceof PyUnionType ) { return Optional . of ( match ( ( PyUnionType ) expected , actual , context ) ) ; } if ( expected instanceof PyClassType && actual instanceof PyClassType ) { Optional < Boolean > match = match ( ( PyClassType ) expected , ( PyClassType ) actual , context ) ; if ( match . isPresent ( ) ) { return match ; } } if ( actual instanceof PyStructuralType && ( ( PyStructuralType ) actual ) . isInferredFromUsages ( ) ) { return Optional . of ( true ) ; } if ( expected instanceof PyStructuralType ) { return Optional . of ( match ( ( PyStructuralType ) expected , actual , context . context ) ) ; } if ( actual instanceof PyStructuralType && expected instanceof PyClassType ) { final Set < String > expectedAttributes = ( ( PyClassType ) expected ) . getMemberNames ( true , context . context ) ; return Optional . of ( expectedAttributes . containsAll ( ( ( PyStructuralType ) actual ) . getAttributeNames ( ) ) ) ; } if ( actual instanceof PyCallableType && expected instanceof PyCallableType ) { final PyCallableType expectedCallable = ( PyCallableType ) expected ; final PyCallableType actualCallable = ( PyCallableType ) actual ; final Optional < Boolean > match = match ( expectedCallable , actualCallable , context ) ; if ( match . isPresent ( ) ) { return match ; } } return Optional . of ( matchNumericTypes ( expected , actual ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > matchObject ( @ NotNull PyClassType expected , @ Nullable PyType actual ) { if ( ArrayUtil . contains ( expected . getName ( ) , PyNames . OBJECT , PyNames . TYPE ) ) { final PyBuiltinCache builtinCache = PyBuiltinCache . getInstance ( expected . getPyClass ( ) ) ; if ( expected . equals ( builtinCache . getObjectType ( ) ) ) { return Optional . of ( true ) ; } if ( expected . equals ( builtinCache . getTypeType ( ) ) && actual instanceof PyInstantiableType && ( ( PyInstantiableType ) actual ) . isDefinition ( ) ) { return Optional . of ( true ) ; } } return Optional . empty ( ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyInstantiableType expected , @ NotNull PyInstantiableType actual , @ NotNull MatchContext context ) { if ( expected instanceof PyGenericType && typeVarAcceptsBothClassAndInstanceTypes ( ( PyGenericType ) expected ) ) { return Optional . empty ( ) ; } if ( expected . isDefinition ( ) ^ actual . isDefinition ( ) ) { if ( actual . isDefinition ( ) && actual instanceof PyClassLikeType && matchClassObjectAndMetaclass ( expected , ( PyClassLikeType ) actual , context ) ) { return Optional . of ( true ) ; } return Optional . of ( false ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyGenericType expected , @ Nullable PyType actual , @ NotNull MatchContext context ) { final PyType substitution = context . substitutions . get ( expected ) ; PyType bound = expected . getBound ( ) ; if ( expected . isDefinition ( ) && bound instanceof PyInstantiableType ) { bound = ( ( PyInstantiableType ) bound ) . toClass ( ) ; } Optional < Boolean > match = match ( bound , actual , context ) ; if ( match . isPresent ( ) && ! match . get ( ) ) { return false ; } if ( substitution != null ) { if ( expected . equals ( actual ) || substitution . equals ( expected ) ) { return true ; } if ( context . recursive ) { Optional < Boolean > recursiveMatch = match ( substitution , actual , context . notRecursive ( ) ) ; if ( recursiveMatch . isPresent ( ) ) { return recursiveMatch . get ( ) ; } } return false ; } if ( actual != null ) { context . substitutions . put ( expected , actual ) ; } else if ( bound != null ) { context . substitutions . put ( expected , bound ) ; } return true ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyType expected , @ NotNull PyUnionType actual , @ NotNull MatchContext context ) { if ( expected instanceof PyTupleType ) { Optional < Boolean > match = match ( ( PyTupleType ) expected , actual , context ) ; if ( match . isPresent ( ) ) { return match . get ( ) ; } } return StreamEx . of ( actual . getMembers ( ) ) . anyMatch ( type -> match ( expected , type , context ) . orElse ( false ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyTupleType expected , @ NotNull PyUnionType actual , @ NotNull MatchContext context ) { final int elementCount = expected . getElementCount ( ) ; if ( ! expected . isHomogeneous ( ) && consistsOfSameElementNumberTuples ( actual , elementCount ) ) { return Optional . of ( substituteExpectedElementsWithUnions ( expected , elementCount , actual , context ) ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyUnionType expected , @ NotNull PyType actual , @ NotNull MatchContext context ) { return StreamEx . of ( expected . getMembers ( ) ) . anyMatch ( type -> match ( type , actual , context ) . orElse ( true ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyClassType expected , @ NotNull PyClassType actual , @ NotNull MatchContext context ) { if ( expected . equals ( actual ) ) { return Optional . of ( true ) ; } if ( expected instanceof PyTupleType && actual instanceof PyTupleType ) { return match ( ( PyTupleType ) expected , ( PyTupleType ) actual , context ) ; } final PyClass superClass = expected . getPyClass ( ) ; final PyClass subClass = actual . getPyClass ( ) ; final boolean matchClasses = matchClasses ( superClass , subClass , context . context ) ; if ( PyProtocolsKt . isProtocol ( expected , context . context ) && ! matchClasses ) { if ( expected instanceof PyCollectionType && ! matchGenerics ( ( PyCollectionType ) expected , actual , context ) ) { return Optional . of ( false ) ; } for ( kotlin . Pair < PyTypedElement , List < RatedResolveResult > > pair : inspectProtocolSubclass ( expected , actual , context . context ) ) { final List < RatedResolveResult > subclassElements = pair . getSecond ( ) ; if ( ContainerUtil . isEmpty ( subclassElements ) ) { return Optional . of ( false ) ; } final PyType protocolElementType = context . context . getType ( pair . getFirst ( ) ) ; final boolean elementResult = StreamEx . of ( subclassElements ) . map ( ResolveResult :: getElement ) . select ( PyTypedElement . class ) . map ( context . context :: getType ) . anyMatch ( subclassElementType -> match ( protocolElementType , subclassElementType , context ) . orElse ( true ) ) ; if ( ! elementResult ) { return Optional . of ( false ) ; } } final PyType originalProtocolGenericType = StreamEx . of ( Extensions . getExtensions ( PyTypeProvider . EP_NAME ) ) . map ( provider -> provider . getGenericType ( superClass , context . context ) ) . findFirst ( Objects :: nonNull ) . orElse ( null ) ; match ( expected , originalProtocolGenericType , context ) ; return Optional . of ( true ) ; } if ( expected instanceof PyCollectionType ) { return Optional . of ( match ( ( PyCollectionType ) expected , actual , context ) ) ; } if ( matchClasses ) { if ( expected instanceof PyTypingNewType && ! expected . equals ( actual ) && superClass . equals ( subClass ) ) { return Optional . of ( actual . getAncestorTypes ( context . context ) . contains ( expected ) ) ; } return Optional . of ( true ) ; } if ( expected . equals ( actual ) ) { return Optional . of ( true ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyTupleType expected , @ NotNull PyTupleType actual , @ NotNull MatchContext context ) { if ( ! expected . isHomogeneous ( ) && ! actual . isHomogeneous ( ) ) { if ( expected . getElementCount ( ) != actual . getElementCount ( ) ) { return Optional . of ( false ) ; } for ( int i = 0 ; i < expected . getElementCount ( ) ; i ++ ) { if ( ! match ( expected . getElementType ( i ) , actual . getElementType ( i ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } return Optional . of ( true ) ; } if ( expected . isHomogeneous ( ) && ! actual . isHomogeneous ( ) ) { final PyType expectedElementType = expected . getIteratedItemType ( ) ; for ( int i = 0 ; i < actual . getElementCount ( ) ; i ++ ) { if ( ! match ( expectedElementType , actual . getElementType ( i ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } return Optional . of ( true ) ; } if ( ! expected . isHomogeneous ( ) && actual . isHomogeneous ( ) ) { return Optional . of ( false ) ; } return match ( expected . getIteratedItemType ( ) , actual . getIteratedItemType ( ) , context ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyCollectionType expected , @ NotNull PyClassType actual , @ NotNull MatchContext context ) { if ( actual instanceof PyTupleType ) { return match ( expected , ( PyTupleType ) actual , context ) ; } final PyClass superClass = expected . getPyClass ( ) ; final PyClass subClass = actual . getPyClass ( ) ; return matchClasses ( superClass , subClass , context . context ) && matchGenerics ( expected , actual , context ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyCollectionType expected , @ NotNull PyTupleType actual , @ NotNull MatchContext context ) { if ( ! matchClasses ( expected . getPyClass ( ) , actual . getPyClass ( ) , context . context ) ) { return false ; } final PyType superElementType = expected . getIteratedItemType ( ) ; final PyType subElementType = actual . getIteratedItemType ( ) ; if ( ! match ( superElementType , subElementType , context ) . orElse ( true ) ) { return false ; } return true ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyStructuralType expected , @ NotNull PyType actual , @ NotNull TypeEvalContext context ) { if ( actual instanceof PyStructuralType ) { return match ( expected , ( PyStructuralType ) actual ) ; } if ( actual instanceof PyClassType ) { return match ( expected , ( PyClassType ) actual , context ) ; } if ( actual instanceof PyModuleType ) { final PyFile module = ( ( PyModuleType ) actual ) . getModule ( ) ; if ( module . getLanguageLevel ( ) . isAtLeast ( LanguageLevel . PYTHON37 ) && definesGetAttr ( module , context ) ) { return true ; } } final PyResolveContext resolveContext = PyResolveContext . noImplicits ( ) . withTypeEvalContext ( context ) ; return StreamEx . of ( expected . getAttributeNames ( ) ) . noneMatch ( attribute -> ContainerUtil . isEmpty ( actual . resolveMember ( attribute , null , AccessDirection . READ , resolveContext ) ) ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyStructuralType expected , @ NotNull PyStructuralType actual ) { if ( expected . isInferredFromUsages ( ) ) { return true ; } return expected . getAttributeNames ( ) . containsAll ( actual . getAttributeNames ( ) ) ; }
jk1/intellij-community | private static boolean match ( @ NotNull PyStructuralType expected , @ NotNull PyClassType actual , @ NotNull TypeEvalContext context ) { if ( overridesGetAttr ( actual . getPyClass ( ) , context ) ) { return true ; } final Set < String > actualAttributes = actual . getMemberNames ( true , context ) ; return actualAttributes . containsAll ( expected . getAttributeNames ( ) ) ; }
jk1/intellij-community | @ NotNull private static Optional < Boolean > match ( @ NotNull PyCallableType expected , @ NotNull PyCallableType actual , @ NotNull MatchContext context ) { if ( expected . isCallable ( ) && actual . isCallable ( ) ) { final List < PyCallableParameter > expectedParameters = expected . getParameters ( context . context ) ; final List < PyCallableParameter > actualParameters = actual . getParameters ( context . context ) ; if ( expectedParameters != null && actualParameters != null ) { final int size = Math . min ( expectedParameters . size ( ) , actualParameters . size ( ) ) ; for ( int i = 0 ; i < size ; i ++ ) { final PyCallableParameter expectedParam = expectedParameters . get ( i ) ; final PyCallableParameter actualParam = actualParameters . get ( i ) ; if ( ! match ( expectedParam . getType ( context . context ) , actualParam . getType ( context . context ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } } } if ( ! match ( expected . getReturnType ( context . context ) , actual . getReturnType ( context . context ) , context ) . orElse ( true ) ) { return Optional . of ( false ) ; } return Optional . of ( true ) ; } return Optional . empty ( ) ; }
jk1/intellij-community | private static boolean matchClassObjectAndMetaclass ( @ NotNull PyType expected , @ NotNull PyClassLikeType actual , @ NotNull MatchContext context ) { if ( ! actual . isDefinition ( ) ) { return false ; } final PyClassLikeType metaClass = actual . getMetaClassType ( context . context , true ) ; return metaClass != null && match ( expected , metaClass , context ) . orElse ( true ) ; }
jk1/intellij-community | private static boolean typeVarAcceptsBothClassAndInstanceTypes ( @ NotNull PyGenericType typeVar ) { return ! typeVar . isDefinition ( ) && typeVar . getBound ( ) == null ; }
jk1/intellij-community | private static boolean consistsOfSameElementNumberTuples ( @ NotNull PyUnionType unionType , int elementCount ) { for ( PyType type : unionType . getMembers ( ) ) { if ( type instanceof PyTupleType ) { final PyTupleType tupleType = ( PyTupleType ) type ; if ( ! tupleType . isHomogeneous ( ) && elementCount != tupleType . getElementCount ( ) ) { return false ; } } else { return false ; } } return true ; }
jk1/intellij-community | private static boolean substituteExpectedElementsWithUnions ( @ NotNull PyTupleType expected , int elementCount , @ NotNull PyUnionType actual , @ NotNull MatchContext context ) { for ( int i = 0 ; i < elementCount ; i ++ ) { final int currentIndex = i ; final PyType elementType = PyUnionType . union ( StreamEx . of ( actual . getMembers ( ) ) . select ( PyTupleType . class ) . map ( type -> type . getElementType ( currentIndex ) ) . toList ( ) ) ; if ( ! match ( expected . getElementType ( i ) , elementType , context ) . orElse ( true ) ) { return false ; } } return true ; }
jk1/intellij-community | private static boolean matchGenerics ( @ NotNull PyCollectionType expected , @ NotNull PyType actual , @ NotNull MatchContext context ) { final List < PyType > superElementTypes = expected . getElementTypes ( ) ; final PyCollectionType actualCollectionType = as ( actual , PyCollectionType . class ) ; final List < PyType > subElementTypes = actualCollectionType != null ? actualCollectionType . getElementTypes ( ) : Collections . emptyList ( ) ; for ( int i = 0 ; i < superElementTypes . size ( ) ; i ++ ) { final PyType subElementType = i < subElementTypes . size ( ) ? subElementTypes . get ( i ) : null ; if ( ! match ( superElementTypes . get ( i ) , subElementType , context ) . orElse ( true ) ) { return false ; } } return true ; }
jk1/intellij-community | private static boolean matchNumericTypes ( PyType expected , PyType actual ) { final String superName = expected . getName ( ) ; final String subName = actual . getName ( ) ; final boolean subIsBool = " bool " . equals ( subName ) ; final boolean subIsInt = PyNames . TYPE_INT . equals ( subName ) ; final boolean subIsLong = PyNames . TYPE_LONG . equals ( subName ) ; final boolean subIsFloat = " float " . equals ( subName ) ; final boolean subIsComplex = " complex " . equals ( subName ) ; if ( superName == null || subName == null || superName . equals ( subName ) || ( PyNames . TYPE_INT . equals ( superName ) && subIsBool ) || ( ( PyNames . TYPE_LONG . equals ( superName ) || PyNames . ABC_INTEGRAL . equals ( superName ) ) && ( subIsBool || subIsInt ) ) || ( ( " float " . equals ( superName ) || PyNames . ABC_REAL . equals ( superName ) ) && ( subIsBool || subIsInt || subIsLong ) ) || ( ( " complex " . equals ( superName ) || PyNames . ABC_COMPLEX . equals ( superName ) ) && ( subIsBool || subIsInt || subIsLong || subIsFloat ) ) || ( PyNames . ABC_NUMBER . equals ( superName ) && ( subIsBool || subIsInt || subIsLong || subIsFloat || subIsComplex ) ) ) { return true ; } return false ; }
jk1/intellij-community | public static boolean isUnknown ( @ Nullable PyType type , @ NotNull TypeEvalContext context ) { return isUnknown ( type , true , context ) ; }
jk1/intellij-community | public static boolean isUnknown ( @ Nullable PyType type , boolean genericsAreUnknown , @ NotNull TypeEvalContext context ) { if ( type == null || ( genericsAreUnknown && type instanceof PyGenericType ) ) { return true ; } if ( type instanceof PyFunctionType ) { final PyCallable callable = ( ( PyFunctionType ) type ) . getCallable ( ) ; if ( callable instanceof PyDecoratable && PyKnownDecoratorUtil . hasUnknownOrChangingReturnTypeDecorator ( ( PyDecoratable ) callable , context ) ) { return true ; } } if ( type instanceof PyUnionType ) { final PyUnionType union = ( PyUnionType ) type ; for ( PyType t : union . getMembers ( ) ) { if ( isUnknown ( t , genericsAreUnknown , context ) ) { return true ; } } } return false ; }
jk1/intellij-community | @ Nullable public static PyType toNonWeakType ( @ Nullable PyType type , @ NotNull TypeEvalContext context ) { if ( type instanceof PyUnionType ) { final PyUnionType unionType = ( PyUnionType ) type ; if ( unionType . isWeak ( ) ) { return unionType . excludeNull ( context ) ; } } return type ; }
jk1/intellij-community | public static boolean hasGenerics ( @ Nullable PyType type , @ NotNull TypeEvalContext context ) { final Set < PyGenericType > collected = new HashSet < > ( ) ; collectGenerics ( type , context , collected , new HashSet < > ( ) ) ; return ! collected . isEmpty ( ) ; }
jk1/intellij-community | private static void collectGenerics ( @ Nullable PyType type , @ NotNull TypeEvalContext context , @ NotNull Set < PyGenericType > collected , @ NotNull Set < PyType > visited ) { if ( visited . contains ( type ) ) { return ; } visited . add ( type ) ; if ( type instanceof PyGenericType ) { collected . add ( ( PyGenericType ) type ) ; } else if ( type instanceof PyUnionType ) { final PyUnionType union = ( PyUnionType ) type ; for ( PyType t : union . getMembers ( ) ) { collectGenerics ( t , context , collected , visited ) ; } } else if ( type instanceof PyTupleType ) { final PyTupleType tuple = ( PyTupleType ) type ; final int n = tuple . isHomogeneous ( ) ? 1 : tuple . getElementCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { collectGenerics ( tuple . getElementType ( i ) , context , collected , visited ) ; } } else if ( type instanceof PyCollectionType ) { final PyCollectionType collection = ( PyCollectionType ) type ; for ( PyType elementType : collection . getElementTypes ( ) ) { collectGenerics ( elementType , context , collected , visited ) ; } } else if ( type instanceof PyCallableType ) { final PyCallableType callable = ( PyCallableType ) type ; final List < PyCallableParameter > parameters = callable . getParameters ( context ) ; if ( parameters != null ) { for ( PyCallableParameter parameter : parameters ) { if ( parameter != null ) { collectGenerics ( parameter . getType ( context ) , context , collected , visited ) ; } } } collectGenerics ( callable . getReturnType ( context ) , context , collected , visited ) ; } }
jk1/intellij-community | @ Nullable public static PyType substitute ( @ Nullable PyType type , @ NotNull Map < PyGenericType , PyType > substitutions , @ NotNull TypeEvalContext context ) { if ( hasGenerics ( type , context ) ) { if ( type instanceof PyGenericType ) { final PyGenericType typeVar = ( PyGenericType ) type ; PyType substitution = substitutions . get ( typeVar ) ; if ( substitution == null ) { if ( ! typeVar . isDefinition ( ) ) { final PyInstantiableType < ? > classType = as ( substitutions . get ( typeVar . toClass ( ) ) , PyInstantiableType . class ) ; if ( classType != null ) { substitution = classType . toInstance ( ) ; } } else { final PyInstantiableType < ? > instanceType = as ( substitutions . get ( typeVar . toInstance ( ) ) , PyInstantiableType . class ) ; if ( instanceType != null ) { substitution = instanceType . toClass ( ) ; } } } if ( substitution instanceof PyGenericType && ! typeVar . equals ( substitution ) && substitutions . containsKey ( substitution ) ) { return substitute ( substitution , substitutions , context ) ; } return substitution ; } else if ( type instanceof PyUnionType ) { final PyUnionType union = ( PyUnionType ) type ; final List < PyType > results = new ArrayList < > ( ) ; for ( PyType t : union . getMembers ( ) ) { final PyType subst = substitute ( t , substitutions , context ) ; results . add ( subst ) ; } return PyUnionType . union ( results ) ; } else if ( type instanceof PyCollectionTypeImpl ) { final PyCollectionTypeImpl collection = ( PyCollectionTypeImpl ) type ; final List < PyType > elementTypes = collection . getElementTypes ( ) ; final List < PyType > substitutes = new ArrayList < > ( ) ; for ( PyType elementType : elementTypes ) { substitutes . add ( substitute ( elementType , substitutions , context ) ) ; } return new PyCollectionTypeImpl ( collection . getPyClass ( ) , collection . isDefinition ( ) , substitutes ) ; } else if ( type instanceof PyTupleType ) { final PyTupleType tupleType = ( PyTupleType ) type ; final PyClass tupleClass = tupleType . getPyClass ( ) ; final List < PyType > oldElementTypes = tupleType . isHomogeneous ( ) ? Collections . singletonList ( tupleType . getIteratedItemType ( ) ) : tupleType . getElementTypes ( ) ; final List < PyType > newElementTypes = ContainerUtil . map ( oldElementTypes , elementType -> substitute ( elementType , substitutions , context ) ) ; return new PyTupleType ( tupleClass , newElementTypes , tupleType . isHomogeneous ( ) ) ; } else if ( type instanceof PyCallableType ) { final PyCallableType callable = ( PyCallableType ) type ; List < PyCallableParameter > substParams = null ; final List < PyCallableParameter > parameters = callable . getParameters ( context ) ; if ( parameters != null ) { substParams = new ArrayList < > ( ) ; for ( PyCallableParameter parameter : parameters ) { final PyType substType = substitute ( parameter . getType ( context ) , substitutions , context ) ; final PyParameter psi = parameter . getParameter ( ) ; final PyCallableParameter subst = psi != null ? PyCallableParameterImpl . psi ( psi , substType ) : PyCallableParameterImpl . nonPsi ( parameter . getName ( ) , substType , parameter . getDefaultValue ( ) ) ; substParams . add ( subst ) ; } } final PyType substResult = substitute ( callable . getReturnType ( context ) , substitutions , context ) ; return new PyCallableTypeImpl ( substParams , substResult ) ; } } return type ; }
jk1/intellij-community | @ Nullable public static Map < PyGenericType , PyType > unifyGenericCall ( @ Nullable PyExpression receiver , @ NotNull Map < PyExpression , PyCallableParameter > arguments , @ NotNull TypeEvalContext context ) { final Map < PyGenericType , PyType > substitutions = unifyReceiver ( receiver , context ) ; for ( Map . Entry < PyExpression , PyCallableParameter > entry : getRegularMappedParameters ( arguments ) . entrySet ( ) ) { final PyCallableParameter paramWrapper = entry . getValue ( ) ; PyType actualType = context . getType ( entry . getKey ( ) ) ; if ( paramWrapper . isSelf ( ) ) { final PyParameter param = paramWrapper . getParameter ( ) ; final PyFunction function = as ( ScopeUtil . getScopeOwner ( param ) , PyFunction . class ) ; if ( function != null && function . getModifier ( ) == PyFunction . Modifier . CLASSMETHOD ) { final StreamEx < PyType > types ; if ( actualType instanceof PyUnionType ) { types = StreamEx . of ( ( ( PyUnionType ) actualType ) . getMembers ( ) ) ; } else { types = StreamEx . of ( actualType ) ; } actualType = types . select ( PyClassLikeType . class ) . map ( PyClassLikeType :: toClass ) . select ( PyType . class ) . foldLeft ( PyUnionType :: union ) . orElse ( actualType ) ; } } final PyType expectedType = paramWrapper . getArgumentType ( context ) ; if ( ! match ( expectedType , actualType , context , substitutions ) ) { return null ; } } if ( ! matchContainer ( getMappedPositionalContainer ( arguments ) , getArgumentsMappedToPositionalContainer ( arguments ) , substitutions , context ) ) { return null ; } if ( ! matchContainer ( getMappedKeywordContainer ( arguments ) , getArgumentsMappedToKeywordContainer ( arguments ) , substitutions , context ) ) { return null ; } return substitutions ; }
jk1/intellij-community | private static boolean matchContainer ( @ Nullable PyCallableParameter container , @ NotNull List < PyExpression > arguments , @ NotNull Map < PyGenericType , PyType > substitutions , @ NotNull TypeEvalContext context ) { if ( container == null ) { return true ; } final List < PyType > types = ContainerUtil . map ( arguments , context :: getType ) ; return match ( container . getArgumentType ( context ) , PyUnionType . union ( types ) , context , substitutions ) ; }
jk1/intellij-community | @ NotNull public static Map < PyGenericType , PyType > unifyReceiver ( @ Nullable PyExpression receiver , @ NotNull TypeEvalContext context ) { final Map < PyGenericType , PyType > substitutions = new LinkedHashMap < > ( ) ; final Set < PyGenericType > generics = new LinkedHashSet < > ( ) ; final PyType qualifierType = receiver != null ? context . getType ( receiver ) : null ; collectGenerics ( qualifierType , context , generics , new HashSet < > ( ) ) ; for ( PyGenericType t : generics ) { substitutions . put ( t , t ) ; } if ( qualifierType != null ) { for ( PyClassType type : toPossibleClassTypes ( qualifierType ) ) { for ( PyTypeProvider provider : Extensions . getExtensions ( PyTypeProvider . EP_NAME ) ) { final PyType genericType = provider . getGenericType ( type . getPyClass ( ) , context ) ; final Set < PyGenericType > providedTypeGenerics = new LinkedHashSet < > ( ) ; if ( genericType != null ) { match ( genericType , type , context , substitutions ) ; collectGenerics ( genericType , context , providedTypeGenerics , new HashSet < > ( ) ) ; } for ( Map . Entry < PyType , PyType > entry : provider . getGenericSubstitutions ( type . getPyClass ( ) , context ) . entrySet ( ) ) { final PyGenericType genericKey = as ( entry . getKey ( ) , PyGenericType . class ) ; final PyType value = entry . getValue ( ) ; if ( genericKey != null && value != null && ! substitutions . containsKey ( genericKey ) && ! providedTypeGenerics . contains ( genericKey ) ) { substitutions . put ( genericKey , value ) ; } } } } } replaceUnresolvedGenericsWithAny ( substitutions ) ; return substitutions ; }
jk1/intellij-community | @ NotNull private static List < PyClassType > toPossibleClassTypes ( @ NotNull PyType type ) { final PyClassType classType = as ( type , PyClassType . class ) ; if ( classType != null ) { return Collections . singletonList ( classType ) ; } final PyUnionType unionType = as ( type , PyUnionType . class ) ; if ( unionType != null ) { return StreamEx . of ( unionType . getMembers ( ) ) . nonNull ( ) . flatMap ( t -> toPossibleClassTypes ( t ) . stream ( ) ) . toList ( ) ; } return Collections . emptyList ( ) ; }
jk1/intellij-community | private static void replaceUnresolvedGenericsWithAny ( @ NotNull Map < PyGenericType , PyType > substitutions ) { final List < PyType > unresolvedGenerics = ContainerUtil . filter ( substitutions . values ( ) , type -> type instanceof PyGenericType && ! substitutions . containsKey ( type ) ) ; for ( PyType unresolvedGeneric : unresolvedGenerics ) { substitutions . put ( ( PyGenericType ) unresolvedGeneric , null ) ; } }
jk1/intellij-community | private static boolean matchClasses ( @ Nullable PyClass superClass , @ Nullable PyClass subClass , @ NotNull TypeEvalContext context ) { if ( superClass == null || subClass == null || subClass . isSubclass ( superClass , context ) || PyABCUtil . isSubclass ( subClass , superClass , context ) || isStrUnicodeMatch ( subClass , superClass ) || isBytearrayBytesStringMatch ( subClass , superClass ) || PyUtil . hasUnresolvedAncestors ( subClass , context ) ) { return true ; } else { final String superName = superClass . getName ( ) ; return superName != null && superName . equals ( subClass . getName ( ) ) ; } }
jk1/intellij-community | private static boolean isStrUnicodeMatch ( @ NotNull PyClass subClass , @ NotNull PyClass superClass ) { return PyNames . TYPE_STR . equals ( subClass . getName ( ) ) && PyNames . TYPE_UNICODE . equals ( superClass . getName ( ) ) ; }
jk1/intellij-community | private static boolean isBytearrayBytesStringMatch ( @ NotNull PyClass subClass , @ NotNull PyClass superClass ) { if ( ! PyNames . TYPE_BYTEARRAY . equals ( subClass . getName ( ) ) ) return false ; final PsiFile subClassFile = subClass . getContainingFile ( ) ; final boolean isPy2 = subClassFile instanceof PyiFile ? PyBuiltinCache . getInstance ( subClass ) . getObjectType ( PyNames . TYPE_UNICODE ) != null : LanguageLevel . forElement ( subClass ) . isPython2 ( ) ; final String superClassName = superClass . getName ( ) ; return isPy2 && PyNames . TYPE_STR . equals ( superClassName ) || ! isPy2 && PyNames . TYPE_BYTES . equals ( superClassName ) ; }
jk1/intellij-community | @ Nullable public static Boolean isCallable ( @ Nullable PyType type ) { if ( type == null ) { return null ; } if ( type instanceof PyUnionType ) { return isUnionCallable ( ( PyUnionType ) type ) ; } if ( type instanceof PyCallableType ) { return ( ( PyCallableType ) type ) . isCallable ( ) ; } if ( type instanceof PyStructuralType && ( ( PyStructuralType ) type ) . isInferredFromUsages ( ) ) { return true ; } return false ; }
jk1/intellij-community | @ Nullable private static Boolean isUnionCallable ( @ NotNull final PyUnionType type ) { for ( final PyType member : type . getMembers ( ) ) { final Boolean callable = isCallable ( member ) ; if ( callable == null ) { return null ; } if ( callable ) { return true ; } } return false ; }
jk1/intellij-community | public static boolean definesGetAttr ( @ NotNull PyFile file , @ NotNull TypeEvalContext context ) { if ( file instanceof PyTypedElement ) { final PyType type = context . getType ( ( PyTypedElement ) file ) ; if ( type != null ) { return resolveTypeMember ( type , PyNames . GETATTR , context ) != null ; } } return false ; }
jk1/intellij-community | public static boolean overridesGetAttr ( @ NotNull PyClass cls , @ NotNull TypeEvalContext context ) { final PyType type = context . getType ( cls ) ; if ( type != null ) { if ( resolveTypeMember ( type , PyNames . GETATTR , context ) != null ) { return true ; } final PsiElement method = resolveTypeMember ( type , PyNames . GETATTRIBUTE , context ) ; if ( method != null && ! PyBuiltinCache . getInstance ( cls ) . isBuiltin ( method ) ) { return true ; } } return false ; }
jk1/intellij-community | @ Nullable private static PsiElement resolveTypeMember ( @ NotNull PyType type , @ NotNull String name , @ NotNull TypeEvalContext context ) { final PyResolveContext resolveContext = PyResolveContext . noImplicits ( ) . withTypeEvalContext ( context ) ; final List < ? extends RatedResolveResult > results = type . resolveMember ( name , null , AccessDirection . READ , resolveContext ) ; return ! ContainerUtil . isEmpty ( results ) ? results . get ( 0 ) . getElement ( ) : null ; }
jk1/intellij-community | @ Nullable public static PyType getTargetTypeFromTupleAssignment ( @ NotNull PyTargetExpression target , @ NotNull PyTupleExpression parentTuple , @ NotNull PyType assignedType , @ NotNull TypeEvalContext context ) { if ( assignedType instanceof PyTupleType ) { return getTargetTypeFromTupleAssignment ( target , parentTuple , ( PyTupleType ) assignedType ) ; } else if ( assignedType instanceof PyClassLikeType ) { return StreamEx . of ( ( ( PyClassLikeType ) assignedType ) . getAncestorTypes ( context ) ) . select ( PyNamedTupleType . class ) . findFirst ( ) . map ( t -> getTargetTypeFromTupleAssignment ( target , parentTuple , t ) ) . orElse ( null ) ; } return null ; }
jk1/intellij-community | @ Nullable public static PyType getTargetTypeFromTupleAssignment ( @ NotNull PyTargetExpression target , @ NotNull PyTupleExpression parentTuple , @ NotNull PyTupleType assignedTupleType ) { final int count = assignedTupleType . getElementCount ( ) ; final PyExpression [ ] elements = parentTuple . getElements ( ) ; if ( elements . length == count || assignedTupleType . isHomogeneous ( ) ) { final int index = ArrayUtil . indexOf ( elements , target ) ; if ( index >= 0 ) { return assignedTupleType . getElementType ( index ) ; } for ( int i = 0 ; i < count ; i ++ ) { PyExpression element = elements [ i ] ; while ( element instanceof PyParenthesizedExpression ) { element = ( ( PyParenthesizedExpression ) element ) . getContainedExpression ( ) ; } if ( element instanceof PyTupleExpression ) { final PyType elementType = assignedTupleType . getElementType ( i ) ; if ( elementType instanceof PyTupleType ) { final PyType result = getTargetTypeFromTupleAssignment ( target , ( PyTupleExpression ) element , ( PyTupleType ) elementType ) ; if ( result != null ) { return result ; } } } } } return null ; }
ButterflyNetwork/bazel | public static final ActionCache AMNESIAC_CACHE = new ActionCache ( ) { @ Override public void put ( String fingerprint , Entry entry ) { } @ Override public Entry get ( String fingerprint ) { return null ; } @ Override public void remove ( String key ) { } @ Override public long save ( ) { return - 1 ; } @ Override public void clear ( ) { } @ Override public void dump ( PrintStream out ) { } @ Override public void accountHit ( ) { } @ Override public void accountMiss ( MissReason reason ) { } @ Override public void mergeIntoActionCacheStatistics ( ActionCacheStatistics . Builder builder ) { } @ Override public void resetStatistics ( ) { } }
orioncode/orionplatform | public static synchronized int run ( Vector x ) { VectorRules . isValid ( x ) ; int n = x . getDimensions ( ) ; int length = 1 ; int numberOfIncreasingElements = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( x . get ( i ) . isLessThan ( x . get ( i + 1 ) ) ) { numberOfIncreasingElements += 1 ; if ( i == n - 2 ) { length = getUpdatedLength ( length , numberOfIncreasingElements ) ; } continue ; } else { length = getUpdatedLength ( length , numberOfIncreasingElements ) ; numberOfIncreasingElements = 1 ; } } return length ; }
orioncode/orionplatform | private static synchronized int getUpdatedLength ( int length , int numberOfIncreasingElements ) { if ( numberOfIncreasingElements > length ) { return numberOfIncreasingElements ; } else { return length ; } }
rvillablanca/java-notes | public static void alimentarAnimales ( Jaula < ? extends Animal > jaulaAnimales ) { List < ? extends Animal > listaAnimales = jaulaAnimales . getLista ( ) ; for ( Animal a : listaAnimales ) a . alimentar ( ) ; System . out . println ( " \n " ) ; }
rvillablanca/java-notes | public static void main ( String [ ] args ) { Jaula < Animal > jaulaAnimales = new Jaula < Animal > ( ) ; Jaula < Leon > jaulaLeon = new Jaula < Leon > ( ) ; Jaula < Mariposa > jaulaMariposa = new Jaula < Mariposa > ( ) ; Animal animal = new Animal ( ) ; Leon leon = new Leon ( ) ; Mariposa mariposa = new Mariposa ( ) ; jaulaAnimales . add ( animal ) ; jaulaAnimales . add ( leon ) ; jaulaAnimales . add ( mariposa ) ; jaulaLeon . add ( leon ) ; jaulaMariposa . add ( mariposa ) ; Jaula < ? extends Animal > jaulaAnimalesGenerica ; jaulaAnimalesGenerica = jaulaAnimales ; jaulaAnimalesGenerica = jaulaLeon ; jaulaAnimalesGenerica = jaulaMariposa ; PruebaGenerics . alimentarAnimales ( jaulaAnimales ) ; PruebaGenerics . alimentarAnimales ( jaulaMariposa ) ; PruebaGenerics . alimentarAnimales ( jaulaLeon ) ; PruebaGenerics . alimentarAnimales ( jaulaAnimalesGenerica ) ; }
chooco13/scribejava | public static ForceTypeOfHttpRequest getForceTypeOfHttpRequests ( ) { return forceTypeOfHttpRequests ; }
chooco13/scribejava | public static void setForceTypeOfHttpRequests ( ForceTypeOfHttpRequest forceTypeOfHttpRequests ) { ScribeJavaConfig . forceTypeOfHttpRequests = forceTypeOfHttpRequests ; }
aqiu202/qiu-commons | public static String getSecurityCode ( ) { return getSecurityCode ( 4 , SecurityCodeLevel . Medium , false ) ; }
aqiu202/qiu-commons | public static String getSecurityCode ( int length , SecurityCodeLevel level , boolean isCanRepeat ) { int len = length ; char [ ] codes = { '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ' a ' , ' b ' , ' c ' , ' d ' , ' e ' , ' f ' , ' g ' , ' h ' , ' i ' , ' j ' , ' k ' , ' m ' , ' n ' , ' p ' , ' q ' , ' r ' , ' s ' , ' t ' , ' u ' , ' v ' , ' w ' , ' x ' , ' y ' , ' z ' , ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' , ' G ' , ' H ' , ' I ' , ' J ' , ' K ' , ' L ' , ' M ' , ' N ' , ' P ' , ' Q ' , ' R ' , ' S ' , ' T ' , ' U ' , ' V ' , ' W ' , ' X ' , ' Y ' , ' Z ' } ; if ( level == SecurityCodeLevel . Simple ) { codes = Arrays . copyOfRange ( codes , 0 , 9 ) ; } else if ( level == SecurityCodeLevel . Medium ) { codes = Arrays . copyOfRange ( codes , 0 , 33 ) ; } int n = codes . length ; if ( len > n && isCanRepeat == false ) { throw new RuntimeException ( String . format ( " 调用SecurityCode . getSecurityCode ( %1 $ s , %2 $ s , %3 $ s ) 出现异常 ， " + " 当isCanRepeat为 % 3 $ s时 ， 传入参数 % 1 $ s不能大于 % 4 $ s " , len , level , isCanRepeat , n ) ) ; } char [ ] result = new char [ len ] ; if ( isCanRepeat ) { for ( int i = 0 ; i < result . length ; i ++ ) { int r = ( int ) ( Math . random ( ) * n ) ; result [ i ] = codes [ r ] ; } } else { for ( int i = 0 ; i < result . length ; i ++ ) { int r = ( int ) ( Math . random ( ) * n ) ; result [ i ] = codes [ r ] ; codes [ r ] = codes [ -- n ] ; } } return String . valueOf ( result ) ; }
aqiu202/qiu-commons | public static void main ( String [ ] ag ) { String resultCode = getSecurityCode ( 6 , SecurityCodeLevel . Medium , true ) ; System . out . println ( resultCode ) ; }
jennyqujy/GitHubApp | public static void setRepo ( Repo newRepo ) { repo = newRepo ; }
1yvT0s/buck | private static final TypeReference < List < TestResultSummary > > SUMMARIES_REFERENCE = new TypeReference < List < TestResultSummary > > ( ) { }
jixieshi999/juahya | public static void addIFlateViewAdapter ( IJuahyaFlateViewInFlaterAdapter ifl ) { if ( null == list ) list = new ArrayList < IJuahyaFlateViewInFlaterAdapter > ( ) ; if ( ! list . contains ( ifl ) ) list . add ( ifl ) ; }
GJL/flink | private static MemorySegment [ ] listToArray ( List < MemorySegment > list ) { if ( list != null ) { return list . toArray ( new MemorySegment [ 0 ] ) ; } return null ; }
GJL/flink | private static int getBucketBuffersByRowCount ( long rowCount , int maxSegs , int segmentSize ) { int minNumBuckets = ( int ) Math . ceil ( ( rowCount / 0.5 ) ) ; Preconditions . checkArgument ( segmentSize % 16 == 0 ) ; return MathUtils . roundDownToPowerOf2 ( ( int ) Math . max ( 1 , Math . min ( maxSegs , Math . ceil ( ( ( double ) minNumBuckets ) * 16 / segmentSize ) ) ) ) ; }
GJL/flink | private static long toAddrAndLen ( long address , int size ) { return ( address << SIZE_BITS ) | size ; }
GJL/flink | private static long toAddress ( long addrAndLen ) { return addrAndLen >>> SIZE_BITS ; }
GJL/flink | private static int toLength ( long addrAndLen ) { return ( int ) ( addrAndLen & SIZE_MASK ) ; }
GJL/flink | private static boolean shouldAdvance ( int available , BinaryRowDataSerializer serializer ) { return available < 8 + serializer . getFixedLengthPartSize ( ) ; }
GJL/flink | static void deserializeFromPages ( BinaryRowData reuse , ChannelReaderInputView inView , BinaryRowDataSerializer buildSideSerializer ) throws IOException { if ( shouldAdvance ( inView . getCurrentSegmentLimit ( ) - inView . getCurrentPositionInSegment ( ) , buildSideSerializer ) ) { inView . advance ( ) ; } MemorySegment segment = ( reuse . getSegments ( ) != null ) ? reuse . getSegments ( ) [ 0 ] : null ; int length = toLength ( inView . getCurrentSegment ( ) . getLong ( inView . getCurrentPositionInSegment ( ) ) ) ; inView . skipBytesToRead ( 8 ) ; if ( segment == null || segment . size ( ) < length ) { segment = MemorySegmentFactory . wrap ( new byte [ length ] ) ; } inView . readFully ( segment . getHeapMemory ( ) , 0 , length ) ; reuse . pointTo ( segment , 0 , length ) ; }
OpenHFT/Chronicle-Wire | " ) public static Collection < Object [ ] > data ( ) { return Arrays . asList ( new Object [ ] [ ] { { WireType . TEXT } , { WireType . BINARY } } ) ; }
guard163/cassandra | public static RowIndexEntry < IndexHelper . IndexInfo > create ( long position , DeletionTime deletionTime , ColumnIndex index ) { assert index != null ; assert deletionTime != null ; if ( index . columnsIndex . size ( ) > 1 ) return new IndexedEntry ( position , deletionTime , index . partitionHeaderLength , index . columnsIndex ) ; else return new RowIndexEntry < > ( position ) ; }
guard163/cassandra | public static long readPosition ( DataInputPlus in , Version version ) throws IOException { return version . storeRows ( ) ? in . readUnsignedVInt ( ) : in . readLong ( ) ; }
guard163/cassandra | public static void skip ( DataInputPlus in , Version version ) throws IOException { readPosition ( in , version ) ; skipPromotedIndex ( in , version ) ; }
guard163/cassandra | private static void skipPromotedIndex ( DataInputPlus in , Version version ) throws IOException { int size = version . storeRows ( ) ? ( int ) in . readUnsignedVInt ( ) : in . readInt ( ) ; if ( size <= 0 ) return ; FileUtils . skipBytesFully ( in , size ) ; }
aborg0/hits | private static String [ ] [ ] [ ] readAnnotations ( final int plateCount , final int rows , final int cols , final String annotationFileName ) throws IOException { final String [ ] [ ] [ ] ret = new String [ plateCount ] [ rows * cols ] [ 2 ] ; if ( annotationFileName . isEmpty ( ) ) { return ret ; } InputStream stream ; try { stream = OpenStream . open ( OpenStream . convertURI ( annotationFileName ) ) ; } catch ( final URISyntaxException e ) { throw new RuntimeException ( e ) ; } try { final Reader fileReader = new InputStreamReader ( stream ) ; try { final BufferedReader br = new BufferedReader ( fileReader ) ; try { String line = null ; while ( ( line = br . readLine ( ) ) != null ) { final int [ ] indices = getIndices ( line , rows , cols ) ; if ( indices != null ) { try { final String [ ] parts = line . split ( " \t " ) ; ret [ indices [ 0 ] ] [ indices [ 1 ] ] [ 0 ] = parts . length > 2 ? parts [ 2 ] : null ; ret [ indices [ 0 ] ] [ indices [ 1 ] ] [ 1 ] = line . substring ( line . lastIndexOf ( ' \t ' ) + 1 ) ; } catch ( final RuntimeException e ) { } } } return ret ; } finally { br . close ( ) ; } } finally { fileReader . close ( ) ; } } finally { stream . close ( ) ; } }
aborg0/hits | private static @ Nullable int [ ] getIndices ( final String line , final int rows , final int cols ) { if ( line == null ) { return null ; } final String [ ] parts = line . split ( " \t " ) ; if ( parts . length < 3 ) { return null ; } try { final String well = parts [ 1 ] ; final int wellIndex = getIndex ( well , rows , cols ) ; if ( wellIndex == - 1 ) { return null ; } return new int [ ] { Integer . parseInt ( parts [ 0 ] ) - 1 , wellIndex } ; } catch ( final RuntimeException e ) { return null ; } }
aborg0/hits | private static int getIndex ( final String well , final int rows , final int cols ) { final int row = Character . toLowerCase ( well . charAt ( 0 ) ) - ' a ' ; final int col = Integer . parseInt ( well . substring ( 1 ) ) - 1 ; final int wellIndex = row < 0 || row >= rows || col < 0 || col >= cols ? - 1 : row * cols + col ; return wellIndex ; }
chicagozer/rheosoft | @ BeforeClass public static void startService ( ) { Object implementor = new GreeterImpl ( ) ; String address = " http : // localhost : " + port1 + " / SoapContext / SoapPort " ; endpoint = Endpoint . publish ( address , implementor ) ; }
FHannes/intellij-community | private static void doTest ( Map < String , String > graph , String ... expectedPaths ) { doTest ( graph , 10 , expectedPaths ) ; }
FHannes/intellij-community | private static void doTest ( Map < String , String > graph , final int k , String ... expectedPaths ) { doTest ( graph , " s " , " t " , k , expectedPaths ) ; }
FHannes/intellij-community | private static void doTest ( Map < String , String > graph , final String start , final String finish , final int k , String ... expectedPaths ) { Graph < String > generator = initGraph ( graph ) ; List < List < String > > paths = getAlgorithmsInstance ( ) . findKShortestPaths ( generator , start , finish , k , new EmptyProgressIndicator ( ModalityState . NON_MODAL ) ) ; List < String > pathStrings = new ArrayList < > ( ) ; Set < Integer > sizes = new HashSet < > ( ) ; for ( List < String > path : paths ) { pathStrings . add ( StringUtil . join ( path , " " ) ) ; sizes . add ( path . size ( ) ) ; } if ( sizes . size ( ) != paths . size ( ) ) { UsefulTestCase . assertSameElements ( pathStrings , expectedPaths ) ; } else { UsefulTestCase . assertOrderedEquals ( pathStrings , expectedPaths ) ; } }
dextorer/BuildingForAndroidTV | public static String getCount ( ) { return Integer . toString ( sCount ) ; }
dextorer/BuildingForAndroidTV | public static void incrementCount ( ) { sCount ++ ; }
dextorer/BuildingForAndroidTV | public static final Parcelable . Creator CREATOR = new Parcelable . Creator ( ) { public Movie createFromParcel ( Parcel in ) { return new Movie ( in ) ; } public Movie [ ] newArray ( int size ) { return new Movie [ size ] ; } }
marlenech/PontChabanDelmas | public static boolean connectivity ( Context c ) { if ( c != null ) { ConnectivityManager connec = ( ConnectivityManager ) c . getSystemService ( Context . CONNECTIVITY_SERVICE ) ; try { android . net . NetworkInfo wifi = connec . getNetworkInfo ( ConnectivityManager . TYPE_WIFI ) ; android . net . NetworkInfo mobile = connec . getNetworkInfo ( ConnectivityManager . TYPE_MOBILE ) ; if ( wifi . isConnected ( ) || mobile . isConnected ( ) ) return true ; else if ( wifi . isConnected ( ) && mobile . isConnected ( ) ) return true ; else return false ; } catch ( NullPointerException e ) { Log . d ( " ConStatus " , " No ▁ Active ▁ Connection " ) ; return false ; } } else { Log . v ( " utils - - " , " null " ) ; return false ; } }
coolcrowd/ObjectService | public static void registerAllExtensions ( com . google . protobuf . ExtensionRegistry registry ) { }
coolcrowd/ObjectService | public static com . google . protobuf . Descriptors . FileDescriptor getDescriptor ( ) { return descriptor ; }
